language: d
name: HumanEval_87_get_row
results:
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    foreach(i : 0..lst.lenght-1)\
    \ {\n        foreach(j : 0..lst[i].lenght-1) {\n            if(lst[i][j] == x)\
    \ {\n                res = append(res, Tuple!(i, j));\n            }\n       \
    \ }\n    }\n    sort(res);\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_hy5cq3j.d(20): Error: no identifier for declarator `i`

    /tmp/tmp_hy5cq3j.d(20): Error: found `:` when expecting `;`

    /tmp/tmp_hy5cq3j.d(21): Error: no identifier for declarator `j`

    /tmp/tmp_hy5cq3j.d(21): Error: found `:` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_hy5cq3j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = null;\n    \n    foreach(row: lst, row_index:\
    \ 0) \n    {\n        foreach(column: row, column_index: 0) \n        {\n    \
    \        if(column_index == x) \n            {\n                result = Tuple!(long,\
    \ long)[](row_index, column_index);\n                break;\n            }\n \
    \       }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9tczzy77.d(21): Error: no identifier for declarator `row`

    /tmp/tmp9tczzy77.d(21): Error: found `:` when expecting `;`

    /tmp/tmp9tczzy77.d(21): Error: found `:` when expecting `)`

    /tmp/tmp9tczzy77.d(21): Error: found `)` when expecting `;` following statement

    /tmp/tmp9tczzy77.d(23): Error: no identifier for declarator `column`

    /tmp/tmp9tczzy77.d(23): Error: found `:` when expecting `;`

    /tmp/tmp9tczzy77.d(23): Error: found `:` when expecting `)`

    /tmp/tmp9tczzy77.d(23): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9tczzy77.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    \n    foreach(row: lst, row: row) \n\
    \    {\n        foreach(col: row, col: col) \n        {\n            if(col ==\
    \ x) \n            {\n                res = Tuple!(long, long)[Tuple!(0, row),\
    \ Tuple!(1, row)];\n                break;\n            }\n        }\n    }\n\
    \    \n    sort(res);\n    sort(res[1], res[1]);\n    \n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpw0_hsc4o.d(21): Error: no identifier for declarator `row`

    /tmp/tmpw0_hsc4o.d(21): Error: found `:` when expecting `;`

    /tmp/tmpw0_hsc4o.d(21): Error: found `:` when expecting `)`

    /tmp/tmpw0_hsc4o.d(21): Error: found `)` when expecting `;` following statement

    /tmp/tmpw0_hsc4o.d(23): Error: no identifier for declarator `col`

    /tmp/tmpw0_hsc4o.d(23): Error: found `:` when expecting `;`

    /tmp/tmpw0_hsc4o.d(23): Error: found `:` when expecting `)`

    /tmp/tmpw0_hsc4o.d(23): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpw0_hsc4o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = null;\n    foreach(row: lst, row: row) \n \
    \   {\n        foreach(col: row, col: col) \n        {\n            if(col ==\
    \ x) \n            {\n                result = Tuple!(long, long)[](row, col);\n\
    \                break;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwmo2m3n0.d(20): Error: no identifier for declarator `row`

    /tmp/tmpwmo2m3n0.d(20): Error: found `:` when expecting `;`

    /tmp/tmpwmo2m3n0.d(20): Error: found `:` when expecting `)`

    /tmp/tmpwmo2m3n0.d(20): Error: found `)` when expecting `;` following statement

    /tmp/tmpwmo2m3n0.d(22): Error: no identifier for declarator `col`

    /tmp/tmpwmo2m3n0.d(22): Error: found `:` when expecting `;`

    /tmp/tmpwmo2m3n0.d(22): Error: found `:` when expecting `)`

    /tmp/tmpwmo2m3n0.d(22): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwmo2m3n0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long[] res = new long[n];\n    for(int i = 0; i\
    \ < n; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            res[i]\
    \ = i;\n            break;\n        }\n    }\n    return Tuple!(long, long)[](res,\
    \ n - 1);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe7_qe_rr.d(29): Error: function expected before `()`, not `Tuple!(long,
    long)[]` of type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe7_qe_rr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.length; i++){\n\
    \        if(lst[i][0] == x){\n            rows++;\n        }\n        if(lst[i][1]\
    \ == x){\n            cols++;\n        }\n    }\n    Tuple!(long, long)[] res\
    \ = Tuple!(long, long)[(0, 0)];\n    for(long i = 0; i < lst.length; i++){\n \
    \       if(lst[i][0] == x){\n            res[rows] = Tuple!(long, long)[lst[i][1],\
    \ lst[i][0]];\n            rows++;\n        }\n        if(lst[i][1] == x){\n \
    \           res[rows] = Tuple!(long, long)[lst[i][0], lst[i][1]];\n          \
    \  cols--;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfp5yr9ip.d(29): Error: Using the result of a comma expression is
    not allowed

    /tmp/tmpfp5yr9ip.d(29): Error: need `this` for `__expand_field_0` of type `long`

    /tmp/tmpfp5yr9ip.d(32): Error: no `[]` operator overload for type `Tuple!(long,
    long)`

    /tmp/tmpfp5yr9ip.d(36): Error: no `[]` operator overload for type `Tuple!(long,
    long)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfp5yr9ip.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k, m, n;\n\
    \    long[][] coords = new long[n][2];\n    \n    for(i = 0; i < n; i++)\n   \
    \ {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n\
    \            {\n                coords[i][0] = 0;\n                coords[i][1]\
    \ = j;\n                break;\n            }\n        }\n    }\n    \n    for(i\
    \ = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n       \
    \     if(coords[i][0] == 0)\n            {\n                coords[i][0] = i;\n\
    \                coords[i][1] = j;\n                break;\n            }\n  \
    \      }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j\
    \ < m; j++)\n        {\n            if(coords[i][0] == i)\n            {\n   \
    \             coords[i][0] = i;\n                coords[i][1] = j;\n         \
    \       break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(coords[i][0]\
    \ == j)\n            {\n                coords[i][0] = i;\n                coords[i][1]\
    \ = j;\n                break;\n            }\n        }\n    }\n    \n    for(i\
    \ = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n       \
    \     if(coords[i][0] == j)\n            {\n                coords[i][0] = i;\n\
    \                coords[i][1] = j;\n                break;\n            }\n  \
    \      }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j\
    \ < m; j++)\n        {\n            if(coords[i][0] == j)\n            {\n   \
    \             coords[i][0] = i;\n                coords[i][1] = j;\n         \
    \       break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(coords[i][0]\
    \ == j)\n            {\n                coords[i][0] = i;\n                coords[i][1]\
    \ = j;\n                break;\n            }\n        }\n    }\n    \n    for(i\
    \ = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n       \
    \     if(coords[i][0] == j)\n            {\n                coords[i][0] = i;\n\
    \                coords[i][1] = j;\n                break;\n            }\n  \
    \      }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j\
    \ < m; j++)\n        {\n            if(coords[i][0] == j)\n            {\n   \
    \             coords[i][0] = i;\n                coords[i][1] = j;\n         \
    \       break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(coords[i][0]\
    \ == j)\n            {\n                coords[i][0] = i;\n                coords[i][1]\
    \ = j;\n                break;\n            }\n        }\n\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjqpd4__z.d(153): Error: found `unittest` instead of statement

    /tmp/tmpjqpd4__z.d(164): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjqpd4__z.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            res[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    Arrays.sort(res);\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzp9m6nd5.d(24): Error: variable `lst` cannot be read at compile
    time

    /tmp/tmpzp9m6nd5.d(24): Error: variable `lst` cannot be read at compile time

    /tmp/tmpzp9m6nd5.d(27): Error: undefined identifier `Arrays`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzp9m6nd5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    \n    foreach(i\
    \ : 0..lst.len())\n    {\n        foreach(j : 0..lst[i].len())\n        {\n  \
    \          if(lst[i][j] == x)\n            {\n                result.push(Tuple!(i,\
    \ j));\n            }\n        }\n    }\n    \n    result.sort(function(a, b)\
    \ -> a.first < b.first ? -1 : a.first > b.first ? 1 : 0);\n    result.sort(function(a,\
    \ b) -> a.second > b.second ? -1 : a.second < b.second ? 1 : 0);\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb1vygrqt.d(21): Error: no identifier for declarator `i`

    /tmp/tmpb1vygrqt.d(21): Error: found `:` when expecting `;`

    /tmp/tmpb1vygrqt.d(23): Error: no identifier for declarator `j`

    /tmp/tmpb1vygrqt.d(23): Error: found `:` when expecting `;`

    /tmp/tmpb1vygrqt.d(32): Error: missing `{ ... }` for function literal

    /tmp/tmpb1vygrqt.d(32): Error: expression expected, not `>`

    /tmp/tmpb1vygrqt.d(32): Error: found `a` when expecting `,`

    /tmp/tmpb1vygrqt.d(33): Error: missing `{ ... }` for function literal

    /tmp/tmpb1vygrqt.d(33): Error: expression expected, not `>`

    /tmp/tmpb1vygrqt.d(33): Error: found `a` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb1vygrqt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i = 0;\n    long\
    \ j = 0;\n    long k = 0;\n    long l = 0;\n    long m1 = m;\n    long n1 = n;\n\
    \    long m2 = m;\n    long n2 = n;\n    long m3 = m;\n    long n3 = n;\n    long\
    \ m4 = m;\n    long n4 = n;\n    long m5 = m;\n    long n5 = n;\n    long m6 =\
    \ m;\n    long n6 = n;\n    long m7 = m;\n    long n7 = n;\n    long m8 = m;\n\
    \    long n8 = n;\n    long m9 = m;\n    long n9 = n;\n    long m10 = m;\n   \
    \ long n10 = n;\n    long m11 = m;\n    long n11 = n;\n    long m12 = m;\n   \
    \ long n12 = n;\n    long m13 = m;\n    long n13 = n;\n    long m14 = m;\n   \
    \ long n14 = n;\n    long m15 = m;\n    long n15 = n;\n    long m16 = m;\n   \
    \ long n16 = n;\n    long m17 = m;\n    long n17 = n;\n    long m18 = m;\n   \
    \ long n18 = n;\n    long m19 = m;\n    long n19 = n;\n    long m20 = m;\n   \
    \ long n20 = n;\n    long m21 = m;\n    long n21 = n;\n    long m22 = m;\n   \
    \ long n22 = n;\n    long m23 = m;\n    long n23 = n;\n    long m24 = m;\n   \
    \ long n24 = n;\n    long m25 = m;\n    long n25 = n;\n    long m26 = m;\n   \
    \ long n26 = n;\n    long m27 = m;\n    long n27 = n;\n    long m28 = m;\n   \
    \ long n28 = n;\n    long m29 = m;\n    long n29 = n;\n    long m30 = m;\n   \
    \ long n30 = n;\n    long m31 = m;\n    long n31 = n;\n    long m32 = m;\n   \
    \ long n32 = n;\n    long m33 = m;\n    long n33 = n;\n    long m34 = m;\n   \
    \ long n34 = n;\n    long m35 = m;\n    long n35 = n;\n    long m36 = m;\n   \
    \ long n36 = n;\n    \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpknmqfrj2.d(98): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpknmqfrj2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    \n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n\
    \        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n      \
    \  }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1]\
    \ > x)\n        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1] - 1);\n\
    \        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n    \
    \    if(lst[i][1] < x)\n        {\n            result[i] = new Tuple!(lst[i][0],\
    \ lst[i][1] + 1);\n        }\n    }\n    \n    for(int i = 0; i < lst.length;\
    \ i++)\n    {\n        if(lst[i][1] > x && lst[i][1] < lst[i][0])\n        {\n\
    \            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n\
    \    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1] <\
    \ x && lst[i][1] > lst[i][0])\n        {\n            result[i] = new Tuple!(lst[i][0],\
    \ lst[i][1]);\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n\
    \    {\n        if(lst[i][1] > x && lst[i][1] < lst[i][0])\n        {\n      \
    \      result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1] < x && lst[i][1]\
    \ > lst[i][0])\n        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n\
    \        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n    \
    \    if(lst[i][1] > x && lst[i][1] < lst[i][0])\n        {\n            result[i]\
    \ = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n    for(int i =\
    \ 0; i < lst.length; i++)\n    {\n        if(lst[i][1] < x && lst[i][1] > lst[i][0])\n\
    \        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n      \
    \  }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1]\
    \ > x && lst[i][1] < lst[i][0])\n        {\n            result[i] = new Tuple!(lst[i][0],\
    \ lst[i][1]);\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n\
    \    {\n        if(lst[i][1] < x && lst[i][1] > lst[i][0])\n        {\n      \
    \      result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1] > x && lst[i][1]\
    \ < lst[i][0])\n        {\n            result[i] = new Tuple\nunittest\n{\n  \
    \  alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L],\
    \ [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L),\
    \ tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_qw_i73u.d(114): Error: found `unittest` when expecting `;` following
    statement

    /tmp/tmp_qw_i73u.d(125): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp_qw_i73u.d(125): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp_qw_i73u.d(125): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_qw_i73u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k, l, m,\
    \ n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k,\
    \ l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i,\
    \ j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n,\
    \ m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l,\
    \ m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j,\
    \ k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m,\
    \ i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m,\
    \ n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k,\
    \ l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i,\
    \ j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n,\
    \ m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l,\
    \ m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j,\
    \ k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m,\
    \ i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m,\
    \ n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k,\
    \ l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i,\
    \ j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n,\
    \ m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l,\
    \ m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, \nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppwde7bkg.d(22): Error: no identifier for declarator `long`

    /tmp/tmppwde7bkg.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppwde7bkg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] =\
    \ new long[n][m];\n    long row = 0;\n    long col = 0;\n    \n    for(long i\
    \ = 0; i < n; i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n  \
    \          if(lst[i][j] == x)\n            {\n                result[row][col]\
    \ = i;\n                result[row][col + 1] = j;\n                row++;\n  \
    \              col++;\n            }\n        }\n    }\n    \n    for(long i =\
    \ 0; i < n; i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n    \
    \        if(lst[i][j] > x)\n            {\n                result[row][col] =\
    \ i;\n                result[row][col + 1] = j;\n                row++;\n    \
    \            col++;\n            }\n        }\n    }\n    \n    for(long i = 0;\
    \ i < n; i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n       \
    \     if(lst[i][j] < x)\n            {\n                result[row][col] = i;\n\
    \                result[row][col + 1] = j;\n                row++;\n         \
    \       col++;\n            }\n        }\n    }\n    \n    for(long i = 0; i <\
    \ n; i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n           \
    \ if(lst[i][j] == x)\n            {\n                result[row][col] = i;\n \
    \               result[row][col + 1] = j;\n                row++;\n          \
    \      col++;\n            }\n        }\n    }\n    \n    for(long i = 0; i <\
    \ n; i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n           \
    \ if(lst[i][j] > x)\n            {\n                result[row][col] = i;\n  \
    \              result[row][col + 1] = j;\n                row++;\n           \
    \     col++;\n            }\n        }\n    }\n    \n    for(long i = 0; i < n;\
    \ i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ < x)\n            {\n                result[row][col] = i;\n               \
    \ result[row][col + 1] = j;\n                row++;\n                col++;\n\
    \            }\n        }\n    }\n    \n    for(long i = 0; i < n; i++)\n    {\n\
    \        for(long j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n\
    \            {\n                result[row][col] = i;\n                result[row][col\
    \ + 1] = j;\n                row++;\n                col++;\n            }\n \
    \       }\n    }\n    \n    for(long i = 0; i < n; i++)\n    {\n        for(long\
    \ j = 0; j < m; j++)\n        {\n            if(lst[i][j] > x)\n            {\n\
    \                result[row][col] = i;\n                result[row][col + 1] =\
    \ j;\n                row++;\n                col++;\n            }\n        }\n\
    \    }\n    \n    \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa44plfxs.d(21): Deprecation: instead of C-style syntax, use D-style
    syntax `long[][] result`

    /tmp/tmpa44plfxs.d(138): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa44plfxs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] ans;\n    \n    foreach(row: lst, i: 0)\n    {\n   \
    \     foreach(col: row, j: 0)\n        {\n            if(col == x)\n         \
    \   {\n                ans = Tuple!(long, long)[](Tuple!(i + 1, j + 1), Tuple!(i\
    \ + 1, j));\n            }\n        }\n    }\n    \n    foreach(row: lst, i: 0)\n\
    \    {\n        foreach(col: row, j: 0)\n        {\n            if(col != x)\n\
    \            {\n                ans = Tuple!(long, long)[](Tuple!(i + 1, j + 1),\
    \ Tuple!(i + 1, j));\n            }\n        }\n    }\n    \n    return ans;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7g3pxtcj.d(21): Error: no identifier for declarator `row`

    /tmp/tmp7g3pxtcj.d(21): Error: found `:` when expecting `;`

    /tmp/tmp7g3pxtcj.d(21): Error: found `:` when expecting `)`

    /tmp/tmp7g3pxtcj.d(21): Error: found `)` when expecting `;` following statement

    /tmp/tmp7g3pxtcj.d(23): Error: no identifier for declarator `col`

    /tmp/tmp7g3pxtcj.d(23): Error: found `:` when expecting `;`

    /tmp/tmp7g3pxtcj.d(23): Error: found `:` when expecting `)`

    /tmp/tmp7g3pxtcj.d(23): Error: found `)` when expecting `;` following statement

    /tmp/tmp7g3pxtcj.d(32): Error: no identifier for declarator `row`

    /tmp/tmp7g3pxtcj.d(32): Error: found `:` when expecting `;`

    /tmp/tmp7g3pxtcj.d(32): Error: found `:` when expecting `)`

    /tmp/tmp7g3pxtcj.d(32): Error: found `)` when expecting `;` following statement

    /tmp/tmp7g3pxtcj.d(34): Error: no identifier for declarator `col`

    /tmp/tmp7g3pxtcj.d(34): Error: found `:` when expecting `;`

    /tmp/tmp7g3pxtcj.d(34): Error: found `:` when expecting `)`

    /tmp/tmp7g3pxtcj.d(34): Error: found `)`'
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n  \
    \  \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n     \
    \   {\n            if(lst[i][j] == x)\n            {\n                return Tuple!(long,\
    \ long)[Tuple!(i-1, j), Tuple!(i, j-1)];\n            }\n        }\n    }\n  \
    \  return Tuple!(long, long)[Tuple!(n, m)];\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_tpdldgr.d(29): Error: no `[]` operator overload for type `Tuple!(long,
    long)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501):
    Error: template instance `parseSpecs!(n, m)` cannot use local `n` as parameter
    to non-global template `parseSpecs(Specs...)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501):
    Error: template instance `parseSpecs!(n, m)` cannot use local `m` as parameter
    to non-global template `parseSpecs(Specs...)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(614):
    Error: CTFE failed because of previous errors in `injectNamedFields`

    /tmp/tmp_tpdldgr.d(33): Error: template instance `tmp_tpdldgr.get_row.Tuple!(n,
    m)` error instantiating

    Failed: ["dmd", "-unittest",'
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n \
    \       {\n            if(lst[i][j] == x)\n            {\n                res[i]\
    \ = j;\n                break;\n            }\n        }\n    }\n    return Tuple!(long,\
    \ long)[](res, n - 1);\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp7p6are4.d(33): Error: function expected before `()`, not `Tuple!(long,
    long)[]` of type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp7p6are4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n  \
    \  Tuple!(long, long)[] result = new Tuple!(long, long)[n];\n    \n    for(i =\
    \ 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n         \
    \   if(lst[i][j] == x)\n            {\n                result[i] = Tuple!(long,\
    \ long)[i, j];\n                break;\n            }\n        }\n    }\n    \n\
    \    for(i = 0; i < n; i++)\n    {\n        for(j = m-1; j >= 0; j--)\n      \
    \  {\n            if(lst[i][j] == x)\n            {\n                result[i]\
    \ = Tuple!(long, long)[i, j];\n                break;\n            }\n       \
    \ }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m;\
    \ j++)\n        {\n            if(lst[i][j] == x)\n            {\n           \
    \     result[i] = Tuple!(long, long)[i, j];\n                break;\n        \
    \    }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j\
    \ = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n\
    \                result[i] = Tuple!(long, long)[i, j];\n                break;\n\
    \            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n  \
    \      for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n   \
    \         {\n                result[i] = Tuple!(long, long)[i, j];\n         \
    \       break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] ==\
    \ x)\n            {\n                result[i] = Tuple!(long, long)[i, j];\n \
    \               break;\n            }\n        }\n    }\n    \n    for(i = 0;\
    \ i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                result[i] = Tuple!(long, long)[i, j];\n\
    \                break;\n            }\n        }\n    }\n    \n    for(i = 0;\
    \ i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                result[i] = Tuple!(long, long)[i, j];\n\
    \                break;\n            }\n        }\n    }\n    \n    for(i = 0;\
    \ i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                result[i] = Tuple!(long, long)[i, j];\n\
    \                break;\n            }\n        }\n    }\n    \n    for(i = 0;\
    \ i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                result[i] = Tuple!(long, long)[i, j];\n\
    \                break;\n            }\n        }\n    }\n    \n    for(i = 0;\
    \ i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy4ax7p7k.d(149): Error: found `unittest` when expecting `)`

    /tmp/tmpy4ax7p7k.d(160): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpy4ax7p7k.d(160): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpy4ax7p7k.d(160): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy4ax7p7k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] ans;\n    \n    foreach(row,lst)\n    {\n        foreach(col,row)\n\
    \        {\n            if(col == x)\n            {\n                ans = Tuple!(long,\
    \ long)[Tuple!(0, col), Tuple!(1, col)];\n                break;\n           \
    \ }\n        }\n    }\n    \n    foreach(row,lst)\n    {\n        foreach(col,row)\n\
    \        {\n            if(col > x)\n            {\n                ans = Tuple!(long,\
    \ long)[Tuple!(0, col), Tuple!(1, col)];\n                break;\n           \
    \ }\n        }\n    }\n    \n    return ans;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfuzbt45x.d(21): Error: no identifier for declarator `lst`

    /tmp/tmpfuzbt45x.d(21): Error: found `)` when expecting `;`

    /tmp/tmpfuzbt45x.d(23): Error: no identifier for declarator `row`

    /tmp/tmpfuzbt45x.d(23): Error: found `)` when expecting `;`

    /tmp/tmpfuzbt45x.d(31): Error: found `}` when expecting `)`

    /tmp/tmpfuzbt45x.d(33): Error: no identifier for declarator `lst`

    /tmp/tmpfuzbt45x.d(33): Error: found `)` when expecting `;`

    /tmp/tmpfuzbt45x.d(35): Error: no identifier for declarator `row`

    /tmp/tmpfuzbt45x.d(35): Error: found `)` when expecting `;`

    /tmp/tmpfuzbt45x.d(43): Error: found `}` when expecting `)`

    /tmp/tmpfuzbt45x.d(47): Error: found `unittest` when expecting `)`

    /tmp/tmpfuzbt45x.d(58): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpfuzbt45x.d(58): Error: found `End of File` when expecting `)`

    /tmp/tmpfuzbt45x.d(58): Error: found `End of File` instead of statement

    /tmp/tmpfuzbt45x.d(58): Error: found `End of File` when expecting `}` following
    compound sta'
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row,lst)\n    {\n        foreach(col,row)\n\
    \        {\n            if(col == x)\n            {\n                res = Tuple!(long,\
    \ long)[Tuple!(0, col), Tuple!(1, col)];\n                break;\n           \
    \ }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate =\
    \ get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4xst1tj3.d(20): Error: no identifier for declarator `lst`

    /tmp/tmp4xst1tj3.d(20): Error: found `)` when expecting `;`

    /tmp/tmp4xst1tj3.d(22): Error: no identifier for declarator `row`

    /tmp/tmp4xst1tj3.d(22): Error: found `)` when expecting `;`

    /tmp/tmp4xst1tj3.d(30): Error: found `}` when expecting `)`

    /tmp/tmp4xst1tj3.d(33): Error: found `unittest` when expecting `)`

    /tmp/tmp4xst1tj3.d(44): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4xst1tj3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[] res = new long[lst.length];\n    for(int i = 0; i < lst.length; i++)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            res[i] = lst[i][1];\n\
    \        }\n    }\n    return Tuple!(long, long)[](res);\n}\nunittest\n{\n   \
    \ alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L],\
    \ [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L),\
    \ tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptjlq8vs3.d(27): Error: function expected before `()`, not `Tuple!(long,
    long)[]` of type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptjlq8vs3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n  \
    \  Tuple!(long, long)[] res = new Tuple!(long, long)[n];\n    \n    for(i = 0;\
    \ i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                res[i] = Tuple!(i, j);\n             \
    \   break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] >\
    \ x)\n            {\n                res[i] = Tuple!(i, j);\n                break;\n\
    \            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501):
    Error: template instance `parseSpecs!(i, j)` cannot use local `i` as parameter
    to non-global template `parseSpecs(Specs...)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501):
    Error: template instance `parseSpecs!(i, j)` cannot use local `j` as parameter
    to non-global template `parseSpecs(Specs...)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(614):
    Error: CTFE failed because of previous errors in `injectNamedFields`

    /tmp/tmp8rch3q06.d(30): Error: template instance `tmp8rch3q06.get_row.Tuple!(i,
    j)` error instantiating

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8rch3q06.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    for(int i = 0;\
    \ i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n       \
    \     Tuple!(long, long)[] row = new Tuple!(long, long)[lst[i].length];\n    \
    \        for(int j = 0; j < lst[i].length; ++j)\n            {\n             \
    \   row[j] = (lst[i][0], lst[i][1]);\n            }\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ long)[res];\n            res = Tuple!(long, long)[res];\n            res = Tuple!(long,\
    \ \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphd09hvs3.d(78): Error: expression expected, not `unittest`

    /tmp/tmphd09hvs3.d(79): Error: found `{` when expecting `)` following template
    argument list

    /tmp/tmphd09hvs3.d(80): Error: found `alias` when expecting `;` following statement

    /tmp/tmphd09hvs3.d(89): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmphd09hvs3.d(89): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphd09hvs3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long rows = lst.length;\n    long cols = lst[0].length;\n    long[] res =\
    \ new long[rows*cols];\n    for(int i = 0; i < rows; i++)\n    {\n        for(int\
    \ j = 0; j < cols; j++)\n        {\n            if(lst[i][j] == x)\n         \
    \   {\n                res[i*cols + j] = i;\n                res[i*cols + j +\
    \ 1] = j;\n            }\n        }\n    }\n    Arrays.sort(res);\n    return\
    \ Tuple!(long, long)[](res, rows);\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp99_heczy.d(33): Error: undefined identifier `Arrays`

    /tmp/tmp99_heczy.d(34): Error: function expected before `()`, not `Tuple!(long,
    long)[]` of type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp99_heczy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.len();\n    long m = lst[0].len();\n    long[][] res = new long[n][m];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n \
    \       {\n            if(lst[i][j] == x)\n            {\n                res[i][j]\
    \ = 1;\n                break;\n            }\n        }\n    }\n    \n    Arrays.sort(res,\
    \ (a, b) -> {\n        if(a[0] > b[0])\n            return 1;\n        if(a[0]\
    \ < b[0])\n            return -1;\n        return 0;\n    });\n    \n    Arrays.sort(res,\
    \ (a, b) -> {\n        if(a[1] > b[1])\n            return 1;\n        if(a[1]\
    \ < b[1])\n            return -1;\n        return 0;\n    });\n    \n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7b95cc5n.d(34): Error: expression expected, not `>`

    /tmp/tmp7b95cc5n.d(34): Error: found `{` when expecting `,`

    /tmp/tmp7b95cc5n.d(35): Error: expression expected, not `if`

    /tmp/tmp7b95cc5n.d(36): Error: found `return` when expecting `,`

    /tmp/tmp7b95cc5n.d(36): Error: found `;` when expecting `,`

    /tmp/tmp7b95cc5n.d(37): Error: expression expected, not `if`

    /tmp/tmp7b95cc5n.d(38): Error: found `return` when expecting `,`

    /tmp/tmp7b95cc5n.d(38): Error: found `;` when expecting `,`

    /tmp/tmp7b95cc5n.d(39): Error: expression expected, not `return`

    /tmp/tmp7b95cc5n.d(39): Error: found `0` when expecting `,`

    /tmp/tmp7b95cc5n.d(39): Error: expression expected, not `;`

    /tmp/tmp7b95cc5n.d(40): Error: found `}` when expecting `,`

    /tmp/tmp7b95cc5n.d(42): Error: expression expected, not `>`

    /tmp/tmp7b95cc5n.d(42): Error: found `{` when expecting `,`

    /tmp/tmp7b95cc5n.d(43): Error: expression expected, not `if`

    /tmp/tmp7b95cc5n.d(44): Error: found `return` when expecting `,`

    /tmp/tmp7b95cc5n.d(44): Error: found `;` '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = null;\n    \n    foreach(row: lst, row: row)\
    \ \n    {\n        foreach(column: row, column: column) \n        {\n        \
    \    if(column == x) \n            {\n                result = Tuple!(long, long)[](row,\
    \ column);\n                break;\n            }\n        }\n    }\n    \n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp01jm0614.d(21): Error: no identifier for declarator `row`

    /tmp/tmp01jm0614.d(21): Error: found `:` when expecting `;`

    /tmp/tmp01jm0614.d(21): Error: found `:` when expecting `)`

    /tmp/tmp01jm0614.d(21): Error: found `)` when expecting `;` following statement

    /tmp/tmp01jm0614.d(23): Error: no identifier for declarator `column`

    /tmp/tmp01jm0614.d(23): Error: found `:` when expecting `;`

    /tmp/tmp01jm0614.d(23): Error: found `:` when expecting `)`

    /tmp/tmp01jm0614.d(23): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp01jm0614.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j;\n    Tuple!(long,\
    \ long)[] res = null;\n    \n    for (i = 0; i < n; i++)\n    {\n        for (j\
    \ = 0; j < m; j++)\n        {\n            if (lst[i][j] == x)\n            {\n\
    \                res = new Tuple!(long, long)[](i, j);\n                break;\n\
    \            }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7r4gd6yt.d(30): Error: too many arguments for array

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7r4gd6yt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] ret = new Tuple!(long, long)[lst.length];\n    \n  \
    \  for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n  \
    \      {\n            ret[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n\
    \    \n    Arrays.sort(ret);\n    \n    return ret;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb_wblo27.d(25): Error: variable `lst` cannot be read at compile
    time

    /tmp/tmpb_wblo27.d(25): Error: variable `lst` cannot be read at compile time

    /tmp/tmpb_wblo27.d(29): Error: undefined identifier `Arrays`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb_wblo27.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row_index: 0) \n\
    \    {\n        foreach(col: row, col_index: 0) \n        {\n            if(col\
    \ == x) \n            {\n                res = Tuple!(long, long)[](row_index,\
    \ col_index);\n                break;\n            }\n        }\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp83xzmj8v.d(20): Error: no identifier for declarator `row`

    /tmp/tmp83xzmj8v.d(20): Error: found `:` when expecting `;`

    /tmp/tmp83xzmj8v.d(20): Error: found `:` when expecting `)`

    /tmp/tmp83xzmj8v.d(20): Error: found `)` when expecting `;` following statement

    /tmp/tmp83xzmj8v.d(22): Error: no identifier for declarator `col`

    /tmp/tmp83xzmj8v.d(22): Error: found `:` when expecting `;`

    /tmp/tmp83xzmj8v.d(22): Error: found `:` when expecting `)`

    /tmp/tmp83xzmj8v.d(22): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp83xzmj8v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row,lst)\n    {\n        foreach(col,row)\n\
    \        {\n            if(col == x)\n            {\n                res = Tuple!(long,\
    \ long)[](row,col);\n                break;\n            }\n        }\n      \
    \  if(res != null)\n            break;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpodyznd6l.d(20): Error: no identifier for declarator `lst`

    /tmp/tmpodyznd6l.d(20): Error: found `)` when expecting `;`

    /tmp/tmpodyznd6l.d(22): Error: no identifier for declarator `row`

    /tmp/tmpodyznd6l.d(22): Error: found `)` when expecting `;`

    /tmp/tmpodyznd6l.d(30): Error: found `if` when expecting `)`

    /tmp/tmpodyznd6l.d(31): Error: found `break` when expecting `;` following statement

    /tmp/tmpodyznd6l.d(31): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpodyznd6l.d(33): Error: found `return` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpodyznd6l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    for(long i = 0;\
    \ i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n       \
    \     Tuple!(long, long)[] row = new Tuple!(long, long)[lst[i].length];\n    \
    \        for(long j = 0; j < lst[i].length; ++j)\n            {\n            \
    \    row[j] = (i, lst[i][j]);\n            }\n            sort(row, true);\n \
    \           sort(row, false);\n            for(long j = 0; j < row.length; ++j)\n\
    \            {\n                res[res.length] = row[j];\n            }\n   \
    \     }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptl32udx5.d(27): Error: Using the result of a comma expression is
    not allowed

    /tmp/tmptl32udx5.d(27): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign`
    cannot deduce function from argument types `!()(long)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(long,
    long).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this),
    R, "="))`

    /tmp/tmptl32udx5.d(29): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    /tmp/tmptl32udx5.d(30): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptl32udx5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; i++){\n        if(lst[i][0] == x){\n            result[i]\
    \ = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    \n    for(int i = 0;\
    \ i < lst.length; i++){\n        if(lst[i][1] < x){\n            for(int j = i;\
    \ j < lst.length; j++){\n                if(lst[j][1] > x){\n                \
    \    swap(lst[i], lst[j]);\n                }\n            }\n        }\n    }\n\
    \    \n    for(int i = 0; i < lst.length; i++){\n        if(lst[i][1] < x){\n\
    \            for(int j = i; j < lst.length; j++){\n                if(lst[j][1]\
    \ > x){\n                    swap(lst[i], lst[j]);\n                }\n      \
    \      }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++){\n \
    \       for(int j = 0; j < lst[i].length; j++){\n            if(lst[i][j] > x){\n\
    \                swap(lst[i][j], lst[i][0]);\n            }\n        }\n    }\n\
    \    \n    for(int i = 0; i < lst.length; i++){\n        for(int j = 0; j < lst[i].length;\
    \ j++){\n            if(lst[i][j] > x){\n                swap(lst[i][j], lst[i][0]);\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++){\n\
    \        for(int j = 0; j < lst[i].length; j++){\n            if(lst[i][j] > x){\n\
    \                swap(lst[i][j], lst[i][0]);\n            }\n        }\n    }\n\
    \    \n    for(int i = 0; i < lst.length; i++){\n        for(int j = 0; j < lst[i].length;\
    \ j++){\n            if(lst[i][j] > x){\n                swap(lst[i][j], lst[i][0]);\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++){\n\
    \        for(int j = 0; j < lst[i].length; j++){\n            if(lst[i][j] > x){\n\
    \                swap(lst[i][j], lst[i][0]);\n            }\n        }\n    }\n\
    \    \n    for(int i = 0; i < lst.length; i++){\n        for(int j = 0; j < lst[i].length;\
    \ j++){\n            if(lst[i][j] > x){\n                swap(lst[i][j], lst[i][0]);\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++){\n\
    \        for(int j = 0; j < lst[i].length; j++){\n            if(lst[i][j] > x){\n\
    \                swap(lst[i][j], lst[i][0]);\n            }\n        }\n    }\n\
    \    \n    for(int i = 0; i < lst.length; i++){\n        for(int j = 0; j < lst[i].length;\
    \ j++){\n            if(lst[i][j] > x){\n                swap(lst[i][j], lst[i][0]);\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++){\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm1qxw0rx.d(111): Error: found `unittest` instead of statement

    /tmp/tmpm1qxw0rx.d(122): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm1qxw0rx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] =\
    \ new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j =\
    \ 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n \
    \               result[i][j] = 1;\n            }\n        }\n    }\n    \n   \
    \ for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n    \
    \    {\n            if(result[i][j] == 1)\n            {\n                long\
    \ temp = i;\n                i = j;\n                j = temp;\n            }\n\
    \        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int\
    \ j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n         \
    \   {\n                long temp = i;\n                i = j;\n              \
    \  j = temp;\n            }\n        }\n    }\n    \n    for(int i = 0; i < n;\
    \ i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n            if(result[i][j]\
    \ == 1)\n            {\n                long temp = i;\n                i = j;\n\
    \                j = temp;\n            }\n        }\n    }\n    \n    for(int\
    \ i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n \
    \           if(result[i][j] == 1)\n            {\n                long temp =\
    \ i;\n                i = j;\n                j = temp;\n            }\n     \
    \   }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j =\
    \ 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n\
    \                long temp = i;\n                i = j;\n                j = temp;\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n\
    \        for(int j = 0; j < m; j++)\n        {\n            if(result[i][j] ==\
    \ 1)\n            {\n                long temp = i;\n                i = j;\n\
    \                j = temp;\n            }\n        }\n    }\n    \n    for(int\
    \ i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n \
    \           if(result[i][j] == 1)\n            {\n                long temp =\
    \ i;\n                i = j;\n                j = temp;\n            }\n     \
    \   }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j =\
    \ 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n\
    \                long temp = i;\n                i = j;\n                j = temp;\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n\
    \        for(int j = 0; j < m; j++)\n        {\n            if(result[i][j] ==\
    \ 1)\n            {\n                long temp = i;\n                i = j;\n\
    \                j = temp;\n            }\n        }\n    }\n    \n    for(int\
    \ i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa_dse2ot.d(21): Deprecation: instead of C-style syntax, use D-style
    syntax `long[][] result`

    /tmp/tmpa_dse2ot.d(154): Error: found `unittest` instead of statement

    /tmp/tmpa_dse2ot.d(165): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa_dse2ot.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    foreach(i : 0..lst.len)\
    \ \n    {\n        foreach(j : 0..lst[i].len) \n        {\n            if(lst[i][j]\
    \ == x) \n            {\n                res = append(res, Tuple!(i, j));\n  \
    \          }\n        }\n    }\n    sort(res);\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu2py5z9p.d(20): Error: no identifier for declarator `i`

    /tmp/tmpu2py5z9p.d(20): Error: found `:` when expecting `;`

    /tmp/tmpu2py5z9p.d(22): Error: no identifier for declarator `j`

    /tmp/tmpu2py5z9p.d(22): Error: found `:` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu2py5z9p.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(i : 0..lst.len())\n    {\n\
    \        if(lst[i][0] == x)\n        {\n            res = lst[i];\n          \
    \  break;\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2vgaoxvg.d(20): Error: no identifier for declarator `i`

    /tmp/tmp2vgaoxvg.d(20): Error: found `:` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2vgaoxvg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row,lst)\n    {\n        foreach(col,row)\n\
    \        {\n            if(col == x)\n            {\n                res = Tuple!(long,\
    \ long)[Tuple!(0, col), Tuple!(1, col)];\n            }\n        }\n    }\n  \
    \  return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg7sgbuvt.d(20): Error: no identifier for declarator `lst`

    /tmp/tmpg7sgbuvt.d(20): Error: found `)` when expecting `;`

    /tmp/tmpg7sgbuvt.d(22): Error: no identifier for declarator `row`

    /tmp/tmpg7sgbuvt.d(22): Error: found `)` when expecting `;`

    /tmp/tmpg7sgbuvt.d(29): Error: found `}` when expecting `)`

    /tmp/tmpg7sgbuvt.d(32): Error: found `unittest` when expecting `)`

    /tmp/tmpg7sgbuvt.d(43): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg7sgbuvt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = null;\n    foreach(row: lst, row_index: 0)\
    \ \n    {\n        foreach(column: row, column_index: 0) \n        {\n       \
    \     if(column_index == x) \n            {\n                result = Tuple!(long,\
    \ long)[Tuple!((row_index, column_index)), Tuple!((row_index, column_index + 1))];\n\
    \            }\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6xv8xj89.d(20): Error: no identifier for declarator `row`

    /tmp/tmp6xv8xj89.d(20): Error: found `:` when expecting `;`

    /tmp/tmp6xv8xj89.d(20): Error: found `:` when expecting `)`

    /tmp/tmp6xv8xj89.d(20): Error: found `)` when expecting `;` following statement

    /tmp/tmp6xv8xj89.d(22): Error: no identifier for declarator `column`

    /tmp/tmp6xv8xj89.d(22): Error: found `:` when expecting `;`

    /tmp/tmp6xv8xj89.d(22): Error: found `:` when expecting `)`

    /tmp/tmp6xv8xj89.d(22): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6xv8xj89.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[] res = new long[lst[0].length];\n    for(int i = 0; i < lst.length;\
    \ ++i)\n    {\n        for(int j = 0; j < lst[i].length; ++j)\n        {\n   \
    \         if(lst[i][j] == x)\n            {\n                res[i] = j;\n   \
    \             break;\n            }\n        }\n    }\n    \n    Arrays.sort(res);\n\
    \    Arrays.sort(res, (a, b) => b - a);\n    \n    Tuple!(long, long)[] res =\
    \ new Tuple!(long, long)[lst.length];\n    for(int i = 0; i < lst.length; ++i)\n\
    \    {\n        res[i] = new Tuple!(long, long)(i, res[i]);\n    }\n    \n   \
    \ return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppdsfq67y.d(32): Error: undefined identifier `Arrays`

    /tmp/tmppdsfq67y.d(33): Error: undefined identifier `Arrays`

    /tmp/tmppdsfq67y.d(35): Error: declaration `tmppdsfq67y.get_row.res` is already
    defined

    /tmp/tmppdsfq67y.d(38): Error: cannot implicitly convert expression `new Tuple!(long,
    long)(cast(long)i, res[cast(ulong)i])` of type `Tuple!(long, long)*` to `long`

    /tmp/tmppdsfq67y.d(41): Error: cannot implicitly convert expression `res` of type
    `long[]` to `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppdsfq67y.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] =\
    \ new long[n][m];\n    long i, j;\n    \n    for(i = 0; i < n; i++)\n    {\n \
    \       for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n  \
    \          {\n                result[i][j] = 1;\n                break;\n    \
    \        }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n      \
    \  for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == 1)\n       \
    \     {\n                for(k = j; k < m; k++)\n                {\n         \
    \           lst[i][k] = lst[i][k - 1];\n                }\n                \n\
    \                for(k = j; k < m; k++)\n                {\n                 \
    \   lst[i][k] = lst[i][k + 1];\n                }\n                \n        \
    \        for(k = j; k < m; k++)\n                {\n                    lst[i][k]\
    \ = lst[i][k];\n                }\n                \n                for(k = j;\
    \ k < m; k++)\n                {\n                    lst[i][k] = lst[i][k];\n\
    \                }\n                \n                for(k = j; k < m; k++)\n\
    \                {\n                    lst[i][k] = lst[i][k];\n             \
    \   }\n                \n                for(k = j; k < m; k++)\n            \
    \    {\n                    lst[i][k] = lst[i][k];\n                }\n      \
    \          \n                for(k = j; k < m; k++)\n                {\n     \
    \               lst[i][k] = lst[i][k];\n                }\n                \n\
    \                for(k = j; k < m; k++)\n                {\n                 \
    \   lst[i][k] = lst[i][k];\n                }\n                \n            \
    \    for(k = j; k < m; k++)\n                {\n                    lst[i][k]\
    \ = lst[i][k];\n                }\n                \n                for(k = j;\
    \ k < m; k++)\n                {\n                    lst[i][k] = lst[i][k];\n\
    \                }\n                \n                for(k = j; k < m; k++)\n\
    \                {\n                    lst[i][k] = lst[i][k];\n             \
    \   }\n                \n                for(k = j; k < m; k++)\n            \
    \    {\n                    lst[i][k] = lst[i][k];\n                }\n      \
    \          \n                for(k = j; k < m; k++)\n                {\n     \
    \               lst[i][k] = lst[i][k];\n                }\n                \n\
    \                for(k = j; k < m; k++)\n                {\n                 \
    \   lst[i][k] = lst[i][k];\n                }\n                \n            \
    \    for(k = j; k < m; k++)\n                {\n                    lst[i][k]\
    \ = lst[i][k];\n                }\n                \n                for(k = j;\
    \ k < \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz_5j5o8q.d(21): Deprecation: instead of C-style syntax, use D-style
    syntax `long[][] result`

    /tmp/tmpz_5j5o8q.d(118): Error: expression expected, not `unittest`

    /tmp/tmpz_5j5o8q.d(119): Error: found `{` when expecting `;` following `for` condition

    /tmp/tmpz_5j5o8q.d(120): Error: expression expected, not `alias`

    /tmp/tmpz_5j5o8q.d(120): Error: found `candidate` when expecting `)`

    /tmp/tmpz_5j5o8q.d(120): Error: found `=` instead of statement

    /tmp/tmpz_5j5o8q.d(129): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpz_5j5o8q.d(129): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpz_5j5o8q.d(129): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz_5j5o8q.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    \n    foreach(row:\
    \ lst, row: row) \n    {\n        foreach(col: row, col: col) \n        {\n  \
    \          if(col == x) \n            {\n                foreach(coord: row, coord:\
    \ coord) \n                {\n                    result.push(Tuple!(coord, row));\n\
    \                }\n                break;\n            }\n        }\n    }\n\
    \    \n    foreach(coord: result, coord: coord) \n    {\n        foreach(row:\
    \ coord, row: row) \n        {\n            foreach(col: row, col: col) \n   \
    \         {\n                if(col > x) \n                {\n               \
    \     result.push(Tuple!(col, row));\n                }\n            }\n     \
    \   }\n    }\n    \n    foreach(coord: result, coord: coord) \n    {\n       \
    \ foreach(row: coord, row: row) \n        {\n            foreach(col: row, col:\
    \ col) \n            {\n                if(col < x) \n                {\n    \
    \                result.push(Tuple!(col, row));\n                }\n         \
    \   }\n        }\n    }\n    \n    foreach(coord: result, coord: coord) \n   \
    \ {\n        foreach(row: coord, row: row) \n        {\n            foreach(col:\
    \ row, col: col) \n            {\n                if(col == x) \n            \
    \    {\n                    result.push(Tuple!(col, row));\n                }\n\
    \            }\n        }\n    }\n    \n    foreach(coord: result, coord: coord)\
    \ \n    {\n        foreach(row: coord, row: row) \n        {\n            foreach(col:\
    \ row, col: col) \n            {\n                if(col > x) \n             \
    \   {\n                    result.push(Tuple!(col, row));\n                }\n\
    \            }\n        }\n    }\n    \n    foreach(coord: result, coord: coord)\
    \ \n    {\n        foreach(row: coord, row: row) \n        {\n            foreach(col:\
    \ row, col: col) \n            {\n                if(col < x) \n             \
    \   {\n                    result.push(Tuple!(col, row));\n                }\n\
    \            }\n        }\n    }\n    \n    foreach(coord: result, coord: coord)\
    \ \n    {\n        foreach(row: coord, row: row) \n        {\n            foreach(col:\
    \ row, col: col) \n            {\n                if(col == x) \n            \
    \    {\n                    result.push(Tuple!(col, row));\n                }\n\
    \            }\n        }\n    }\n    \n    foreach(coord: result, coord: coord)\
    \ \n    {\n        foreach(row: coord, row: row) \n        {\n            foreach(col:\
    \ row, col: col) \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgltp4run.d(21): Error: no identifier for declarator `row`

    /tmp/tmpgltp4run.d(21): Error: found `:` when expecting `;`

    /tmp/tmpgltp4run.d(21): Error: found `:` when expecting `)`

    /tmp/tmpgltp4run.d(21): Error: found `)` when expecting `;` following statement

    /tmp/tmpgltp4run.d(23): Error: no identifier for declarator `col`

    /tmp/tmpgltp4run.d(23): Error: found `:` when expecting `;`

    /tmp/tmpgltp4run.d(23): Error: found `:` when expecting `)`

    /tmp/tmpgltp4run.d(23): Error: found `)` when expecting `;` following statement

    /tmp/tmpgltp4run.d(27): Error: no identifier for declarator `coord`

    /tmp/tmpgltp4run.d(27): Error: found `:` when expecting `;`

    /tmp/tmpgltp4run.d(27): Error: found `:` when expecting `)`

    /tmp/tmpgltp4run.d(27): Error: found `)` when expecting `;` following statement

    /tmp/tmpgltp4run.d(36): Error: no identifier for declarator `coord`

    /tmp/tmpgltp4run.d(36): Error: found `:` when expecting `;`

    /tmp/tmpgltp4run.d(36): Error: found `:` when expecting `)`

    /tmp/tmpgltp4run.d(36): Error: found'
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n  \
    \  long[][] result = new long[n][m];\n    \n    for (i = 0; i < n; i++)\n    {\n\
    \        for (j = 0; j < m; j++)\n        {\n            if (lst[i][j] == x)\n\
    \            {\n                result[i][j] = 1;\n                break;\n  \
    \          }\n        }\n    }\n    \n    Arrays.sort(result, (a, b) => b[0] -\
    \ a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result,\
    \ (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n \
    \   \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result,\
    \ (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n\
    \    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result,\
    \ (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n \
    \   \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result,\
    \ (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n\
    \    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result,\
    \ (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n \
    \   \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result,\
    \ (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n\
    \    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result,\
    \ (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n \
    \   \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result,\
    \ (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n\
    \    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result,\
    \ (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n \
    \   \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result,\
    \ (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n\
    \    Arrays.sort(result, (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result,\
    \ (a, b) => b[0] - a[0]);\n    Arrays.sort(result, (a, b) => b[1] - a[1]);\n \
    \   \n    Arrays.sort(result, (a, b) => b[0] - a[0]);\n    Arrays.sort(result,\
    \ (a, b) => b[1] - a[1]);\n    \n    Arrays.sort(result, (a, b) => b\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpuldxoir2.d(91): Error: found `unittest` when expecting `,`

    /tmp/tmpuldxoir2.d(102): Error: found `void` when expecting `,`

    /tmp/tmpuldxoir2.d(102): Error: found `{` when expecting `,`

    /tmp/tmpuldxoir2.d(102): Error: expression expected, not `}`

    /tmp/tmpuldxoir2.d(102): Error: found `End of File` when expecting `,`

    /tmp/tmpuldxoir2.d(102): Error: found `End of File` when expecting `)`

    /tmp/tmpuldxoir2.d(102): Error: found `End of File` when expecting `;` following
    statement

    /tmp/tmpuldxoir2.d(102): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuldxoir2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = null;\n    foreach(row: lst, row: row) \n \
    \   {\n        foreach(column: row, column: column) \n        {\n            if(column\
    \ == x) \n            {\n                result = Tuple!(long, long)[](row, column);\n\
    \                break;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkbc6cxuz.d(20): Error: no identifier for declarator `row`

    /tmp/tmpkbc6cxuz.d(20): Error: found `:` when expecting `;`

    /tmp/tmpkbc6cxuz.d(20): Error: found `:` when expecting `)`

    /tmp/tmpkbc6cxuz.d(20): Error: found `)` when expecting `;` following statement

    /tmp/tmpkbc6cxuz.d(22): Error: no identifier for declarator `column`

    /tmp/tmpkbc6cxuz.d(22): Error: found `:` when expecting `;`

    /tmp/tmpkbc6cxuz.d(22): Error: found `:` when expecting `)`

    /tmp/tmpkbc6cxuz.d(22): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkbc6cxuz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(i : 0..lst.len())\n    {\n\
    \        foreach(j : 0..lst[i].len())\n        {\n            if(lst[i][j] ==\
    \ x)\n            {\n                res = Tuple!(long, long)[i, j];\n       \
    \         break;\n            }\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq2jq9cut.d(20): Error: no identifier for declarator `i`

    /tmp/tmpq2jq9cut.d(20): Error: found `:` when expecting `;`

    /tmp/tmpq2jq9cut.d(22): Error: no identifier for declarator `j`

    /tmp/tmpq2jq9cut.d(22): Error: found `:` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq2jq9cut.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k, l, m,\
    \ n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k,\
    \ l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i,\
    \ j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n,\
    \ m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l,\
    \ m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j,\
    \ k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m,\
    \ i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m,\
    \ n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k,\
    \ l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i,\
    \ j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n,\
    \ m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l,\
    \ m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j,\
    \ k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m,\
    \ i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m,\
    \ n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k,\
    \ l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i,\
    \ j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n,\
    \ m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l,\
    \ m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, n, m, i, j, k, l, m, \nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppwde7bkg.d(22): Error: no identifier for declarator `long`

    /tmp/tmppwde7bkg.d(22): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppwde7bkg.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row_index: 0) \n\
    \    {\n        foreach(col: row, col_index: 0) \n        {\n            if(col\
    \ == x) \n            {\n                res = Tuple!(long, long)[](row_index,\
    \ col_index);\n                break;\n            }\n        }\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp83xzmj8v.d(20): Error: no identifier for declarator `row`

    /tmp/tmp83xzmj8v.d(20): Error: found `:` when expecting `;`

    /tmp/tmp83xzmj8v.d(20): Error: found `:` when expecting `)`

    /tmp/tmp83xzmj8v.d(20): Error: found `)` when expecting `;` following statement

    /tmp/tmp83xzmj8v.d(22): Error: no identifier for declarator `col`

    /tmp/tmp83xzmj8v.d(22): Error: found `:` when expecting `;`

    /tmp/tmp83xzmj8v.d(22): Error: found `:` when expecting `)`

    /tmp/tmp83xzmj8v.d(22): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp83xzmj8v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            res[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n  \
    \  Arrays.sort(res);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6zvo7mx9.d(24): Error: variable `lst` cannot be read at compile
    time

    /tmp/tmp6zvo7mx9.d(24): Error: variable `lst` cannot be read at compile time

    /tmp/tmp6zvo7mx9.d(27): Error: undefined identifier `Arrays`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6zvo7mx9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            res[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n  \
    \  \n    Arrays.sort(res, (a, b) -> {\n        if(a.first > b.first)\n       \
    \     return 1;\n        if(a.first < b.first)\n            return -1;\n     \
    \   return 0;\n    });\n    \n    Arrays.sort(res, (a, b) -> {\n        if(a.second\
    \ > b.second)\n            return 1;\n        if(a.second < b.second)\n      \
    \      return -1;\n        return 0;\n    });\n    \n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr8nbgw3u.d(28): Error: expression expected, not `>`

    /tmp/tmpr8nbgw3u.d(28): Error: found `{` when expecting `,`

    /tmp/tmpr8nbgw3u.d(29): Error: expression expected, not `if`

    /tmp/tmpr8nbgw3u.d(30): Error: found `return` when expecting `,`

    /tmp/tmpr8nbgw3u.d(30): Error: found `;` when expecting `,`

    /tmp/tmpr8nbgw3u.d(31): Error: expression expected, not `if`

    /tmp/tmpr8nbgw3u.d(32): Error: found `return` when expecting `,`

    /tmp/tmpr8nbgw3u.d(32): Error: found `;` when expecting `,`

    /tmp/tmpr8nbgw3u.d(33): Error: expression expected, not `return`

    /tmp/tmpr8nbgw3u.d(33): Error: found `0` when expecting `,`

    /tmp/tmpr8nbgw3u.d(33): Error: expression expected, not `;`

    /tmp/tmpr8nbgw3u.d(34): Error: found `}` when expecting `,`

    /tmp/tmpr8nbgw3u.d(36): Error: expression expected, not `>`

    /tmp/tmpr8nbgw3u.d(36): Error: found `{` when expecting `,`

    /tmp/tmpr8nbgw3u.d(37): Error: expression expected, not `if`

    /tmp/tmpr8nbgw3u.d(38): Error: found `return` when expecting `,`

    /tmp/tmpr8nbgw3u.d(38): Error: found `;` '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = null;\n    foreach(row: lst, row_index: long\
    \ in\n        enumerate(row))\n    {\n        foreach(col: row, col_index: long\
    \ in\n            enumerate(col))\n        {\n            if(col_index == x)\n\
    \            {\n                result = Tuple!(long, long)[Tuple!(0, row_index)];\n\
    \                break;\n            }\n        }\n    }\n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6yyyoapf.d(20): Error: no identifier for declarator `row`

    /tmp/tmp6yyyoapf.d(20): Error: found `:` when expecting `;`

    /tmp/tmp6yyyoapf.d(20): Error: found `:` when expecting `)`

    /tmp/tmp6yyyoapf.d(20): Error: no identifier for declarator `long`

    /tmp/tmp6yyyoapf.d(20): Error: found `in` instead of statement

    /tmp/tmp6yyyoapf.d(31): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6yyyoapf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n  \
    \  Tuple!(long, long)[] res = new Tuple!(long, long)[n];\n    for(i = 0; i < n;\
    \ i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                res[i] = Tuple!(long, long)[i, j];\n \
    \               break;\n            }\n        }\n    }\n    sort(res);\n    for(i\
    \ = 0; i < n; i++)\n    {\n        res[i] = res[i].swap;\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp940r8cz3.d(29): Error: no `[]` operator overload for type `Tuple!(long,
    long)`

    /tmp/tmp940r8cz3.d(34): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    /tmp/tmp940r8cz3.d(37): Error: no property `swap` for type `Tuple!(long, long)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp940r8cz3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[][] res = new long[lst.length][lst[0].length];\n    for(int i = 0; i\
    \ < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i].length; ++j)\n\
    \        {\n            if(lst[i][j] == x)\n            {\n                res[i][j]\
    \ = 1;\n            }\n        }\n    }\n    \n    Arrays.sort(res, (a, b) =>\
    \ a[0] - b[0]);\n    Arrays.sort(res, (a, b) => a[1] - b[1]);\n    \n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8ml0pg6o.d(19): Error: variable `lst` cannot be read at compile
    time

    /tmp/tmp8ml0pg6o.d(31): Error: undefined identifier `Arrays`

    /tmp/tmp8ml0pg6o.d(32): Error: undefined identifier `Arrays`

    /tmp/tmp8ml0pg6o.d(34): Error: cannot implicitly convert expression `res` of type
    `long[][]` to `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8ml0pg6o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    \n    for(long\
    \ i = 0; i < lst.Length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            Tuple!(long, long)[] row = new Tuple!(long, long)[i];\n         \
    \   \n            for(long j = 0; j < lst[i].Length; j++)\n            {\n   \
    \             if(lst[i][j] > x)\n                {\n                    row.Add(lst[i][j],\
    \ j);\n                }\n            }\n            \n            row.Sort();\n\
    \            \n            for(long j = 0; j < row.Length; j++)\n            {\n\
    \                result.Add(row[j], i);\n            }\n        }\n    }\n   \
    \ \n    result.Sort();\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpem9gpbx2.d(21): Error: no property `Length` for type `long[][]`

    /tmp/tmpem9gpbx2.d(27): Error: no property `Length` for type `long[]`

    /tmp/tmpem9gpbx2.d(31): Error: no property `Add` for type `Tuple!(long, long)[]`

    /tmp/tmpem9gpbx2.d(35): Error: no property `Sort` for type `Tuple!(long, long)[]`

    /tmp/tmpem9gpbx2.d(37): Error: no property `Length` for type `Tuple!(long, long)[]`

    /tmp/tmpem9gpbx2.d(39): Error: no property `Add` for type `Tuple!(long, long)[]`

    /tmp/tmpem9gpbx2.d(44): Error: no property `Sort` for type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpem9gpbx2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[] res = new long[lst.length];\n    for(int i = 0; i < lst.length; ++i)\n\
    \    {\n        for(int j = 0; j < lst[i].length; ++j)\n        {\n          \
    \  if(lst[i][j] == x)\n            {\n                res[i] = j;\n          \
    \      break;\n            }\n        }\n    }\n    return Tuple!(long, long)[](res,\
    \ lst.length);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr39b5vlh.d(31): Error: function expected before `()`, not `Tuple!(long,
    long)[]` of type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr39b5vlh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n \
    \       {\n            if(lst[i][j] == x)\n            {\n                res[i]\
    \ = j;\n                break;\n            }\n        }\n    }\n    return Tuple!(long,\
    \ long)[](res, n - 1);\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp7p6are4.d(33): Error: function expected before `()`, not `Tuple!(long,
    long)[]` of type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp7p6are4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long[] res = new long[n];\n    for(int i = 0; i\
    \ < n; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            res[i]\
    \ = lst[i][1];\n        }\n    }\n    return Tuple!(long, long)[](res);\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_7dty2p3.d(28): Error: function expected before `()`, not `Tuple!(long,
    long)[]` of type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_7dty2p3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long rows = 0;\n    long cols = 0;\n    \n    foreach(long y, lst)\n    {\n\
    \        foreach(long x, y)\n        {\n            if(x != x)\n            {\n\
    \                cols++;\n            }\n            else\n            {\n   \
    \             rows++;\n            }\n        }\n    }\n    \n    Tuple!(long,\
    \ long)[] result = new Tuple!(long, long)[rows];\n    \n    foreach(long y, lst)\n\
    \    {\n        foreach(long x, y)\n        {\n            if(x != x)\n      \
    \      {\n                result[rows] = new Tuple!(long, long)(x, y);\n     \
    \       }\n        }\n    }\n    \n    foreach(long y, lst)\n    {\n        foreach(long\
    \ x, y)\n        {\n            if(x != x)\n            {\n                result[rows]\
    \ = new Tuple!(long, long)(x, y);\n            }\n        }\n    }\n    \n   \
    \ return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5get54nd.d(22): Error: no identifier for declarator `lst`

    /tmp/tmp5get54nd.d(22): Error: found `)` when expecting `;`

    /tmp/tmp5get54nd.d(24): Error: no identifier for declarator `y`

    /tmp/tmp5get54nd.d(24): Error: found `)` when expecting `;`

    /tmp/tmp5get54nd.d(35): Error: found `}` when expecting `)`

    /tmp/tmp5get54nd.d(39): Error: no identifier for declarator `lst`

    /tmp/tmp5get54nd.d(39): Error: found `)` when expecting `;`

    /tmp/tmp5get54nd.d(41): Error: no identifier for declarator `y`

    /tmp/tmp5get54nd.d(41): Error: found `)` when expecting `;`

    /tmp/tmp5get54nd.d(48): Error: found `}` when expecting `)`

    /tmp/tmp5get54nd.d(50): Error: no identifier for declarator `lst`

    /tmp/tmp5get54nd.d(50): Error: found `)` when expecting `;`

    /tmp/tmp5get54nd.d(52): Error: no identifier for declarator `y`

    /tmp/tmp5get54nd.d(52): Error: found `)` when expecting `;`

    /tmp/tmp5get54nd.d(59): Error: found `}` when expecting `)`

    /tmp/tmp5get54nd.d(63): Error: found `unittest` when expecting `)`

    /tmp/tmp5get54nd.d(74): Err'
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j;\n    long\
    \ row = 0;\n    long col = 0;\n    \n    for(i = 0; i < n; i++)\n    {\n     \
    \   for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n      \
    \      {\n                return Tuple!(long, long)[](row, col);\n           \
    \ }\n        }\n    }\n    return Tuple!(long, long)[](row, col);\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqo49fp9_.d(31): Error: function expected before `()`, not `Tuple!(long,
    long)[]` of type `Tuple!(long, long)[]`

    /tmp/tmpqo49fp9_.d(35): Error: function expected before `()`, not `Tuple!(long,
    long)[]` of type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqo49fp9_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] =\
    \ new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j =\
    \ 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n \
    \               result[i][j] = 1;\n            }\n        }\n    }\n    \n   \
    \ for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n    \
    \    {\n            if(result[i][j] == 1)\n            {\n                long\
    \ temp[][] = new long[m][2];\n                for(int k = 0; k < m; k++)\n   \
    \             {\n                    temp[k][0] = (int)i;\n                  \
    \  temp[k][1] = (int)j;\n                }\n                Arrays.sort(temp,\
    \ (x, y) -> {\n                    return y[0] - x[0];\n                });\n\
    \                \n                Tuple!(long, long)[] res = new Tuple!(long,\
    \ long)[temp.length];\n                for(int k = 0; k < temp.length; k++)\n\
    \                {\n                    res[k] = new Tuple!(long, long)[temp[k].length];\n\
    \                    res[k][0] = (long)temp[k][0];\n                    res[k][1]\
    \ = (long)temp[k][1];\n                }\n                return res;\n      \
    \      }\n        }\n    }\n    return null;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprq2zleo6.d(21): Deprecation: instead of C-style syntax, use D-style
    syntax `long[][] result`

    /tmp/tmprq2zleo6.d(39): Deprecation: instead of C-style syntax, use D-style syntax
    `long[][] temp`

    /tmp/tmprq2zleo6.d(42): Error: C style cast illegal, use `cast(int)i`

    /tmp/tmprq2zleo6.d(43): Error: C style cast illegal, use `cast(int)j`

    /tmp/tmprq2zleo6.d(45): Error: expression expected, not `>`

    /tmp/tmprq2zleo6.d(45): Error: found `{` when expecting `,`

    /tmp/tmprq2zleo6.d(46): Error: expression expected, not `return`

    /tmp/tmprq2zleo6.d(46): Error: found `y` when expecting `,`

    /tmp/tmprq2zleo6.d(46): Error: found `;` when expecting `,`

    /tmp/tmprq2zleo6.d(47): Error: expression expected, not `}`

    /tmp/tmprq2zleo6.d(53): Error: C style cast illegal, use `cast(long)temp[k][0]`

    /tmp/tmprq2zleo6.d(54): Error: C style cast illegal, use `cast(long)temp[k][1]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprq2zleo6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[][] res = new\
    \ long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j\
    \ < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n      \
    \          res[i][j] = 1;\n            }\n        }\n    }\n    Arrays.sort(res);\n\
    \    Arrays.sort(res, (a, b) -> b[0] - a[0]);\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprw5vp7ay.d(33): Error: expression expected, not `>`

    /tmp/tmprw5vp7ay.d(33): Error: found `b` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprw5vp7ay.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long[] res = new long[n];\n    for(int i = 0; i\
    \ < n; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            res[i]\
    \ = lst[i][1];\n        }\n    }\n    return Tuple!(long[], long[])[](res);\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgk5ild6u.d(28): Error: function expected before `()`, not `Tuple!(long[],
    long[])[]` of type `Tuple!(long[], long[])[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgk5ild6u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[] row = new long[lst[0].Length];\n    for(int i = 0; i < lst[0].Length;\
    \ i++)\n    {\n        row[i] = lst[0][i];\n    }\n    \n    for(int i = 0; i\
    \ < lst[0].Length; i++)\n    {\n        if(row[i] == x)\n        {\n         \
    \   Tuple!(long, long)[] res = new Tuple!(long, long)[lst[0].Length];\n      \
    \      for(int j = 0; j < lst[0].Length; j++)\n            {\n               \
    \ res[j] = (i, j);\n            }\n            return res;\n        }\n    }\n\
    \    return null;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_d51wbdr.d(19): Error: no property `Length` for type `long[]`

    /tmp/tmp_d51wbdr.d(20): Error: no property `Length` for type `long[]`

    /tmp/tmp_d51wbdr.d(25): Error: no property `Length` for type `long[]`

    /tmp/tmp_d51wbdr.d(29): Error: no property `Length` for type `long[]`

    /tmp/tmp_d51wbdr.d(30): Error: no property `Length` for type `long[]`

    /tmp/tmp_d51wbdr.d(32): Error: Using the result of a comma expression is not allowed

    /tmp/tmp_d51wbdr.d(32): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign`
    cannot deduce function from argument types `!()(int)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(long,
    long).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this),
    R, "="))`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_d51wbdr.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    \n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n\
    \        {\n            result[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n\
    \    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1]\
    \ > x)\n        {\n            for(int j = lst[i][1]; j > x; j--)\n          \
    \  {\n                result[i] = Tuple!(lst[i][0], j);\n            }\n     \
    \   }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1]\
    \ < x)\n        {\n            for(int j = lst[i][1]; j < x; j++)\n          \
    \  {\n                result[i] = Tuple!(lst[i][0], j);\n            }\n     \
    \   }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1]\
    \ > x)\n        {\n            for(int j = lst[i][1]; j > x; j--)\n          \
    \  {\n                result[i] = Tuple!(lst[i][0], j);\n            }\n     \
    \   }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1]\
    \ < x)\n        {\n            for(int j = lst[i][1]; j < x; j++)\n          \
    \  {\n                result[i] = Tuple!(lst[i][0], j);\n            }\n     \
    \   }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1]\
    \ > x)\n        {\n            for(int j = lst[i][1]; j > x; j--)\n          \
    \  {\n                result[i] = Tuple!(lst[i][0], j);\n            }\n     \
    \   }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1]\
    \ < x)\n        {\n            for(int j = lst[i][1]; j < x; j++)\n          \
    \  {\n                result[i] = Tuple!(lst[i][0], j);\n            }\n     \
    \   }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1]\
    \ > x)\n        {\n            for(int j = lst[i][1]; j > x; j--)\n          \
    \  {\n                result[i] = Tuple!(lst[i][0], j);\n            }\n     \
    \   }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1]\
    \ < x)\n        {\n            for(int j = lst[i][1]; j < x; j++)\n          \
    \  {\n                result[i] = Tuple!(lst[i][0], j);\n            }\n     \
    \   }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1]\
    \ > x)\n        {\n            for(int j = lst[i][1]; j > x; j--)\n          \
    \  {\n                result[i] = Tuple!(lst[i][0], j);\n            }\n     \
    \   }\n    }\n    \n    for(int \nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjy54nyq5.d(129): Error: no identifier for declarator `int`

    /tmp/tmpjy54nyq5.d(129): Error: expression expected, not `unittest`

    /tmp/tmpjy54nyq5.d(130): Error: found `{` when expecting `;` following `for` condition

    /tmp/tmpjy54nyq5.d(131): Error: expression expected, not `alias`

    /tmp/tmpjy54nyq5.d(131): Error: found `candidate` when expecting `)`

    /tmp/tmpjy54nyq5.d(131): Error: found `=` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjy54nyq5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0; j < lst[i].length;\
    \ ++j)\n        {\n            if(lst[i][j] == x)\n            {\n           \
    \     res[i] = Tuple!(i, j);\n            }\n        }\n    }\n    \n    sort(res);\n\
    \    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501):
    Error: template instance `parseSpecs!(i, j)` cannot use local `i` as parameter
    to non-global template `parseSpecs(Specs...)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501):
    Error: template instance `parseSpecs!(i, j)` cannot use local `j` as parameter
    to non-global template `parseSpecs(Specs...)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(614):
    Error: CTFE failed because of previous errors in `injectNamedFields`

    /tmp/tmpf4lzgs77.d(26): Error: template instance `tmpf4lzgs77.get_row.Tuple!(i,
    j)` error instantiating

    /tmp/tmpf4lzgs77.d(31): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittes'
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] =\
    \ new long[n][m];\n    long i, j, k;\n    for(i = 0; i < n; i++)\n    {\n    \
    \    for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n     \
    \       {\n                result[i][j] = 1;\n                break;\n       \
    \     }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j =\
    \ 0; j < m; j++)\n        {\n            if(lst[i][j] == 1)\n            {\n \
    \               k = j;\n                break;\n            }\n        }\n   \
    \     for(j = k - 1; j >= 0; j--)\n        {\n            result[i][j] = result[i][j\
    \ + 1];\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j =\
    \ 0; j < m; j++)\n        {\n            result[i][j] = result[i][j] - 1;\n  \
    \      }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m;\
    \ j++)\n        {\n            result[i][j] = result[i][j] + 1;\n        }\n \
    \   }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n   \
    \     {\n            if(result[i][j] == 0)\n            {\n                result[i][j]\
    \ = 1;\n                break;\n            }\n        }\n    }\n    for(i = 0;\
    \ i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j]\
    \ == 1)\n            {\n                k = j;\n                break;\n     \
    \       }\n        }\n        for(j = k - 1; j >= 0; j--)\n        {\n       \
    \     result[i][j] = result[i][j + 1];\n        }\n    }\n    for(i = 0; i < n;\
    \ i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            result[i][j]\
    \ = result[i][j] - 1;\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n \
    \       for(j = 0; j < m; j++)\n        {\n            result[i][j] = result[i][j]\
    \ + 1;\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0;\
    \ j < m; j++)\n        {\n            if(result[i][j] == 0)\n            {\n \
    \               result[i][j] = 1;\n                break;\n            }\n   \
    \     }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n\
    \        {\n            if(result[i][j] == 1)\n            {\n               \
    \ k = j;\n                break;\n            }\n        }\n        for(j = k\
    \ - 1; j >= 0; j--)\n        {\n            result[i][j] = result[i][j + 1];\n\
    \        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m;\
    \ j++)\n        {\n            result[i][j] = result[i][j] - 1;\n        }\n \
    \   }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n   \
    \     {\n            result[i][j] = result[i][j] + 1;\n        }\n    }\n    for(i\
    \ = 0; i < n; i++)\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_nreqgx2.d(21): Deprecation: instead of C-style syntax, use D-style
    syntax `long[][] result`

    /tmp/tmp_nreqgx2.d(144): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_nreqgx2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = null;\n    \n    foreach(row: lst, row_index:\
    \ 0) \n    {\n        foreach(column: row, column_index: 0) \n        {\n    \
    \        if(column_index == x) \n            {\n                result = Tuple!(long,\
    \ long)[](row_index, column_index);\n            }\n        }\n    }\n    \n \
    \   return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg1ymobvx.d(21): Error: no identifier for declarator `row`

    /tmp/tmpg1ymobvx.d(21): Error: found `:` when expecting `;`

    /tmp/tmpg1ymobvx.d(21): Error: found `:` when expecting `)`

    /tmp/tmpg1ymobvx.d(21): Error: found `)` when expecting `;` following statement

    /tmp/tmpg1ymobvx.d(23): Error: no identifier for declarator `column`

    /tmp/tmpg1ymobvx.d(23): Error: found `:` when expecting `;`

    /tmp/tmpg1ymobvx.d(23): Error: found `:` when expecting `)`

    /tmp/tmpg1ymobvx.d(23): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg1ymobvx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] =\
    \ new long[n][m];\n    long i, j, k;\n    \n    for(i = 0; i < n; i++)\n    {\n\
    \        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n \
    \           {\n                result[i][j] = 1;\n                break;\n   \
    \         }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n     \
    \   for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n   \
    \         {\n                k = j;\n                break;\n            }\n \
    \       }\n        \n        if(k == m)\n        {\n            k = j;\n     \
    \   }\n        \n        for(j = k; j < m; j++)\n        {\n            result[i][j]\
    \ = -1;\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j\
    \ = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n           \
    \ {\n                k = j;\n                break;\n            }\n        }\n\
    \        \n        if(k == m)\n        {\n            k = j;\n        }\n    \
    \    \n        for(j = k; j < m; j++)\n        {\n            result[i][j] = -1;\n\
    \        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0;\
    \ j < m; j++)\n        {\n            if(result[i][j] == -1)\n            {\n\
    \                k = j;\n                break;\n            }\n        }\n  \
    \      \n        if(k == m)\n        {\n            k = j;\n        }\n      \
    \  \n        for(j = k; j < m; j++)\n        {\n            result[i][j] = -1;\n\
    \        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0;\
    \ j < m; j++)\n        {\n            if(result[i][j] == -1)\n            {\n\
    \                k = j;\n                break;\n            }\n        }\n  \
    \      \n        if(k == m)\n        {\n            k = j;\n        }\n      \
    \  \n        for(j = k; j < m; j++)\n        {\n            result[i][j] = -1;\n\
    \        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0;\
    \ j < m; j++)\n        {\n            if(result[i][j] == -1)\n            {\n\
    \                k = j;\n                break;\n            }\n        }\n  \
    \      \n        if(k == m)\n        {\n            k = j;\n        }\n      \
    \  \n        for(j = k; j < m; j++)\n        {\n            result[i][j] = -1;\n\
    \        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0;\
    \ j < m; j++)\n        {\n            if(result[i][j] == -1)\n            {\n\
    \                k = j;\n                break;\n            }\n        }\n  \
    \      \n        if(k == m)\n        {\n            k = j;\n        }\n\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpcmkajzos.d(21): Deprecation: instead of C-style syntax, use D-style
    syntax `long[][] result`

    /tmp/tmpcmkajzos.d(162): Error: found `unittest` instead of statement

    /tmp/tmpcmkajzos.d(173): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcmkajzos.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    foreach(row,lst)\n\
    \    {\n        foreach(col,row)\n        {\n            if(col == x)\n      \
    \      {\n                res[res.length] = Tuple!(row,col);\n            }\n\
    \        }\n    }\n    sort(res,fun(x1,x2)->x1.1 > x2.1);\n    sort(res,fun(x1,x2)->x1.2\
    \ > x2.2);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3666a2g7.d(20): Error: no identifier for declarator `lst`

    /tmp/tmp3666a2g7.d(20): Error: found `)` when expecting `;`

    /tmp/tmp3666a2g7.d(22): Error: no identifier for declarator `row`

    /tmp/tmp3666a2g7.d(22): Error: found `)` when expecting `;`

    /tmp/tmp3666a2g7.d(29): Error: found `}` when expecting `)`

    /tmp/tmp3666a2g7.d(30): Error: expression expected, not `>`

    /tmp/tmp3666a2g7.d(30): Error: found `x1` when expecting `,`

    /tmp/tmp3666a2g7.d(30): Error: found `0.1` when expecting `,`

    /tmp/tmp3666a2g7.d(31): Error: expression expected, not `>`

    /tmp/tmp3666a2g7.d(31): Error: found `x1` when expecting `,`

    /tmp/tmp3666a2g7.d(31): Error: found `0.2` when expecting `,`

    /tmp/tmp3666a2g7.d(34): Error: found `unittest` when expecting `)`

    /tmp/tmp3666a2g7.d(45): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3666a2g7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.Length;\n    long m = lst[0].Length;\n    long[] res = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n \
    \       {\n            if(lst[i][j] == x)\n            {\n                res[i]\
    \ = j;\n                break;\n            }\n        }\n    }\n    return Tuple!(long,\
    \ long)[](res, n - 1);\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqsihp6jy.d(19): Error: no property `Length` for type `long[][]`

    /tmp/tmpqsihp6jy.d(20): Error: no property `Length` for type `long[]`

    /tmp/tmpqsihp6jy.d(33): Error: function expected before `()`, not `Tuple!(long,
    long)[]` of type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqsihp6jy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long ans = 0;\n  \
    \  long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m1\
    \ = m;\n    long m2 = m;\n    long m3 = m;\n    long m4 = m;\n    long m5 = m;\n\
    \    long m6 = m;\n    long m7 = m;\n    long m8 = m;\n    long m9 = m;\n    long\
    \ m10 = m;\n    long m11 = m;\n    long m12 = m;\n    long m13 = m;\n    long\
    \ m14 = m;\n    long m15 = m;\n    long m16 = m;\n    long m17 = m;\n    long\
    \ m18 = m;\n    long m19 = m;\n    long m20 = m;\n    long m21 = m;\n    long\
    \ m22 = m;\n    long m23 = m;\n    long m24 = m;\n    long m25 = m;\n    long\
    \ m26 = m;\n    long m27 = m;\n    long m28 = m;\n    long m29 = m;\n    long\
    \ m30 = m;\n    long m31 = m;\n    long m32 = m;\n    long m33 = m;\n    long\
    \ m34 = m;\n    long m35 = m;\n    long m36 = m;\n    long m37 = m;\n    long\
    \ m38 = m;\n    long m39 = m;\n    long m40 = m;\n    long m41 = m;\n    long\
    \ m42 = m;\n    long m43 = m;\n    long m44 = m;\n    long m45 = m;\n    long\
    \ m46 = m;\n    long m47 = m;\n    long m48 = m;\n    long m49 = m;\n    long\
    \ m50 = m;\n    long m51 = m;\n    long m52 = m;\n    long m53 = m;\n    long\
    \ m54 = m;\n    long m55 = m;\n    long m56 = m;\n    long m57 = m;\n    long\
    \ m58 = m;\n    long m59 = m;\n    long m60 = m;\n    long m61 = m;\n    long\
    \ m62 = m;\n    long m63 = m;\n    long m64 = m;\n    long m65 = m;\n    long\
    \ m66 = m;\n    long m67 = m;\n    long m68 = m;\n    long m69 = m;\n    long\
    \ m70\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpneu64gfq.d(96): Error: semicolon expected, not `unittest`

    /tmp/tmpneu64gfq.d(96): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpneu64gfq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            res[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    sort(res);\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdm1rjjrs.d(24): Error: variable `lst` cannot be read at compile
    time

    /tmp/tmpdm1rjjrs.d(24): Error: variable `lst` cannot be read at compile time

    /tmp/tmpdm1rjjrs.d(27): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdm1rjjrs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[][] res = new\
    \ long[n][m];\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j\
    \ = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n\
    \                res[i][j] = 1;\n            }\n        }\n    }\n    \n    for(int\
    \ i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n \
    \           if(res[i][j] == 1)\n            {\n                res[i][j] = j;\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n\
    \        for(int j = 0; j < m; j++)\n        {\n            if(res[i][j] == j)\n\
    \            {\n                res[i][j] = i;\n            }\n        }\n   \
    \ }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m;\
    \ j++)\n        {\n            if(res[i][j] == i)\n            {\n           \
    \     res[i][j] = j;\n            }\n        }\n    }\n    \n    for(int i = 0;\
    \ i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n        \
    \    if(res[i][j] == j)\n            {\n                res[i][j] = i;\n     \
    \       }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n   \
    \     for(int j = 0; j < m; j++)\n        {\n            if(res[i][j] == i)\n\
    \            {\n                res[i][j] = j;\n            }\n        }\n   \
    \ }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m;\
    \ j++)\n        {\n            if(res[i][j] == j)\n            {\n           \
    \     res[i][j] = i;\n            }\n        }\n    }\n    \n    for(int i = 0;\
    \ i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n        \
    \    if(res[i][j] == i)\n            {\n                res[i][j] = j;\n     \
    \       }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n   \
    \     for(int j = 0; j < m; j++)\n        {\n            if(res[i][j] == j)\n\
    \            {\n                res[i][j] = i;\n            }\n        }\n   \
    \ }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m;\
    \ j++)\n        {\n            if(res[i][j] == i)\n            {\n           \
    \     res[i][j] = j;\n            }\n        }\n    }\n    \n    for(int i = 0;\
    \ i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n        \
    \    if(res[i][j] == j)\n            {\n                res[i][j] = i;\n     \
    \       }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n   \
    \     for(int j = 0; j < m; j++)\n        {\n            if(res[i][j] == i)\n\
    \            {\n                res[i][j] = j;\n            }\n        }\n   \
    \ }\n    \n    for(int i = 0; i < n; i++)\n    {\n        \nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpc1hf0b9j.d(158): Error: found `unittest` instead of statement

    /tmp/tmpc1hf0b9j.d(169): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc1hf0b9j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    \n    for(int\
    \ i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            for(int j = 0; j < lst[i].length; ++j)\n            {\n         \
    \       result.push((lst[i][0], lst[i][j]));\n            }\n        }\n    }\n\
    \    \n    result.sort(function(a, b){return a[0] - b[0]});\n    result.sort(function(a,\
    \ b){return b[1] - a[1]});\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxet9k9v1.d(32): Error: found `}` when expecting `;` following `return`
    statement

    /tmp/tmpxet9k9v1.d(32): Error: found `)` instead of statement

    /tmp/tmpxet9k9v1.d(33): Error: found `}` when expecting `;` following `return`
    statement

    /tmp/tmpxet9k9v1.d(33): Error: found `)` instead of statement

    /tmp/tmpxet9k9v1.d(37): Error: found `unittest` when expecting `,`

    /tmp/tmpxet9k9v1.d(48): Error: found `void` when expecting `,`

    /tmp/tmpxet9k9v1.d(48): Error: found `{` when expecting `,`

    /tmp/tmpxet9k9v1.d(48): Error: expression expected, not `}`

    /tmp/tmpxet9k9v1.d(48): Error: found `End of File` when expecting `,`

    /tmp/tmpxet9k9v1.d(48): Error: found `End of File` when expecting `)`

    /tmp/tmpxet9k9v1.d(48): Error: found `End of File` when expecting `;` following
    statement

    /tmp/tmpxet9k9v1.d(48): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpxet9k9v1.d(48): Error: found `End of File` when expecting `,`

    /tmp/tmpxet9k9v1.d(48): Error: found `End of File` when expecting `)`

    /tm'
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[m];\n\
    \    for(int i = 0; i < m; i++)\n    {\n        res[i] = 0;\n    }\n    for(int\
    \ i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n \
    \           if(lst[i][j] == x)\n            {\n                res[j]++;\n   \
    \         }\n        }\n    }\n    for(int i = 0; i < m; i++)\n    {\n       \
    \ res[i] = res[i] / n;\n    }\n    return Tuple!(long, long)[](res, m);\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphx9eav0l.d(40): Error: function expected before `()`, not `Tuple!(long,
    long)[]` of type `Tuple!(long, long)[]`

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = null;\n    \n    foreach(row: lst, row_index:\
    \ 0) \n    {\n        foreach(column: row, column_index: 0) \n        {\n    \
    \        if(column_index == x) \n            {\n                result = Tuple!(long,\
    \ long)[](row_index, column_index);\n                break;\n            }\n \
    \       }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9tczzy77.d(21): Error: no identifier for declarator `row`

    /tmp/tmp9tczzy77.d(21): Error: found `:` when expecting `;`

    /tmp/tmp9tczzy77.d(21): Error: found `:` when expecting `)`

    /tmp/tmp9tczzy77.d(21): Error: found `)` when expecting `;` following statement

    /tmp/tmp9tczzy77.d(23): Error: no identifier for declarator `column`

    /tmp/tmp9tczzy77.d(23): Error: found `:` when expecting `;`

    /tmp/tmp9tczzy77.d(23): Error: found `:` when expecting `)`

    /tmp/tmp9tczzy77.d(23): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9tczzy77.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j;\n    long\
    \ min = 0;\n    long max = 0;\n    long sum = 0;\n    long count = 0;\n    long[][]\
    \ res = new long[n][m];\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0;\
    \ j < m; j++)\n        {\n            sum += lst[i][j];\n            if(sum ==\
    \ x)\n            {\n                res[i][j] = 1;\n                count++;\n\
    \            }\n            else if(sum > x)\n            {\n                min\
    \ = j;\n                break;\n            }\n            else\n            {\n\
    \                max = j;\n                break;\n            }\n        }\n\
    \    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n  \
    \      {\n            if(res[i][j] == 1)\n            {\n                res[i][j]\
    \ = count;\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n\
    \        for(j = 0; j < m; j++)\n        {\n            if(res[i][j] > max)\n\
    \            {\n                max = res[i][j];\n            }\n            if(res[i][j]\
    \ < min)\n            {\n                min = res[i][j];\n            }\n   \
    \     }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n\
    \        {\n            if(res[i][j] > max)\n            {\n                max\
    \ = res[i][j];\n            }\n            if(res[i][j] < min)\n            {\n\
    \                min = res[i][j];\n            }\n        }\n    }\n    for(i\
    \ = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n       \
    \     if(res[i][j] > max)\n            {\n                max = res[i][j];\n \
    \           }\n            if(res[i][j] < min)\n            {\n              \
    \  min = res[i][j];\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(res[i][j] >\
    \ max)\n            {\n                max = res[i][j];\n            }\n     \
    \       if(res[i][j] < min)\n            {\n                min = res[i][j];\n\
    \            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j\
    \ = 0; j < m; j++)\n        {\n            if(res[i][j] > max)\n            {\n\
    \                max = res[i][j];\n            }\n            if(res[i][j] < min)\n\
    \            {\n                min = res[i][j];\n            }\n        }\n \
    \   }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n   \
    \     {\n            if(res[i][j] > max)\n            {\n                max =\
    \ res[i][j];\n            }\n            if(res[i][j] < min)\n            {\n\
    \                min = res[i][j];\n            }\n        }\n    }\n    for(i\
    \ = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n       \
    \     if(res[i][j] > max)\n            {\n                max = res[i][j\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmppxhr02m4.d(150): Error: found `unittest` when expecting `,`

    /tmp/tmppxhr02m4.d(161): Error: found `void` when expecting `,`

    /tmp/tmppxhr02m4.d(161): Error: found `{` when expecting `,`

    /tmp/tmppxhr02m4.d(161): Error: expression expected, not `}`

    /tmp/tmppxhr02m4.d(161): Error: found `End of File` when expecting `,`

    /tmp/tmppxhr02m4.d(161): Error: found `End of File` when expecting `]`

    /tmp/tmppxhr02m4.d(161): Error: found `End of File` when expecting `;` following
    statement

    /tmp/tmppxhr02m4.d(161): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmppxhr02m4.d(161): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmppxhr02m4.d(161): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmppxhr02m4.d(161): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppxhr02m4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n  \
    \  Tuple!(long, long)[] result = new Tuple!(long, long)[n];\n    \n    for(i =\
    \ 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n         \
    \   if(lst[i][j] == x)\n            {\n                result[i] = Tuple!(long,\
    \ long)[i, j];\n                break;\n            }\n        }\n    }\n    \n\
    \    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n\
    \            if(lst[i][j] > x)\n            {\n                k = j;\n      \
    \          for(; k < m; k++)\n                {\n                    if(lst[i][k]\
    \ > x)\n                    {\n                        break;\n              \
    \      }\n                }\n                \n                result[i] = Tuple!(long,\
    \ long)[i, k];\n                break;\n            }\n        }\n    }\n    \n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi7l6w5ru.d(30): Error: no `[]` operator overload for type `Tuple!(long,
    long)`

    /tmp/tmpi7l6w5ru.d(51): Error: no `[]` operator overload for type `Tuple!(long,
    long)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi7l6w5ru.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[] res = new long[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            res[i] = lst[i][1];\n\
    \        }\n    }\n    return Tuple!(long, long)[res];\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg_0oggst.d(19): Error: no property `Length` for type `long[][]`

    /tmp/tmpg_0oggst.d(20): Error: no property `Length` for type `long[][]`

    /tmp/tmpg_0oggst.d(27): Error: cannot implicitly convert expression `res` of type
    `long[]` to `ulong`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg_0oggst.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] ret = new Tuple!(long, long)[0];\n    for(long i = 0;\
    \ i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n       \
    \     ret.push(new Tuple!(lst[i][0], lst[i][1]));\n        }\n    }\n    \n  \
    \  sort(ret, (x, y) => y._1 - x._1);\n    sort(ret, (x, y) => y._2 - x._2);\n\
    \    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1jsd6l74.d(24): Error: no property `push` for type `Tuple!(long,
    long)[]`

    /tmp/tmp1jsd6l74.d(28): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    /tmp/tmp1jsd6l74.d(29): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1jsd6l74.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    \n    for(int\
    \ i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            result.add(new Tuple!(lst[i][1], i));\n        }\n    }\n    \n \
    \   result.sort(function(a, b) {\n        return a.1 < b.1;\n    });\n    \n \
    \   result.sort(function(a, b) {\n        return b.1 < a.1;\n    });\n    \n \
    \   return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgxw7j0m6.d(30): Error: found `0.1` when expecting `;` following
    `return` statement

    /tmp/tmpgxw7j0m6.d(30): Error: found `<` instead of statement

    /tmp/tmpgxw7j0m6.d(34): Error: found `0.1` when expecting `;` following `return`
    statement

    /tmp/tmpgxw7j0m6.d(34): Error: found `<` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgxw7j0m6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[][] res = new long[lst.length][lst[0].length];\n    for(int i = 0; i\
    \ < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n\
    \        {\n            if(lst[i][j] == x)\n            {\n                res[i][j]\
    \ = 1;\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length;\
    \ i++)\n    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n   \
    \         if(res[i][j] == 0)\n            {\n                res[i][j] = -1;\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n\
    \    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n          \
    \  if(res[i][j] == -1)\n            {\n                res[i][j] = -1;\n     \
    \       }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n \
    \   {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n           \
    \ if(res[i][j] == -1)\n            {\n                res[i][j] = -1;\n      \
    \      }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n  \
    \  {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n            if(res[i][j]\
    \ == -1)\n            {\n                res[i][j] = -1;\n            }\n    \
    \    }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int\
    \ j = 0; j < lst[i].length; j++)\n        {\n            if(res[i][j] == -1)\n\
    \            {\n                res[i][j] = -1;\n            }\n        }\n  \
    \  }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j\
    \ = 0; j < lst[i].length; j++)\n        {\n            if(res[i][j] == -1)\n \
    \           {\n                res[i][j] = -1;\n            }\n        }\n   \
    \ }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j =\
    \ 0; j < lst[i].length; j++)\n        {\n            if(res[i][j] == -1)\n   \
    \         {\n                res[i][j] = -1;\n            }\n        }\n    }\n\
    \    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0;\
    \ j < lst[i].length; j++)\n        {\n            if(res[i][j] == -1)\n      \
    \      {\n                res[i][j] = -1;\n            }\n        }\n    }\n \
    \   \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j\
    \ < lst[i].length; j++)\n        {\n            if(res[i][j] == -1)\n        \
    \    {\n                res[i][j] = -1;\n            }\n        }\n    }\n   \
    \ \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j <\
    \ lst[i].length; j++)\n        {\n            if(res[i][j] == -1)\n          \
    \  {\n                res[i][j] = -1;\n            }\n        }\n    }\n    \n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i].length;\
    \ j++)\n        {\n            if(res[i][j] == -1)\n            {\n          \
    \      res[i][j] = \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpksxjtfg_.d(148): Error: expression expected, not `unittest`

    /tmp/tmpksxjtfg_.d(149): Error: found `{` when expecting `;` following statement

    /tmp/tmpksxjtfg_.d(159): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpksxjtfg_.d(159): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpksxjtfg_.d(159): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpksxjtfg_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[(n\
    \ + 1) * (m + 1)];\n    long i = 0, j = 0, k = 0;\n    \n    for(i = 0; i < n;\
    \ i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                res[k] = Tuple!(i, j);\n             \
    \   k++;\n            }\n        }\n    }\n    \n    Arrays.sort(res);\n    \n\
    \    Arrays.sort(res, (a, b) => Tuple!(b[0], a[0]));\n    \n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501):
    Error: template instance `parseSpecs!(i, j)` cannot use local `i` as parameter
    to non-global template `parseSpecs(Specs...)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501):
    Error: template instance `parseSpecs!(i, j)` cannot use local `j` as parameter
    to non-global template `parseSpecs(Specs...)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(614):
    Error: CTFE failed because of previous errors in `injectNamedFields`

    /tmp/tmptnq_qt46.d(30): Error: template instance `tmptnq_qt46.get_row.Tuple!(i,
    j)` error instantiating

    /tmp/tmptnq_qt46.d(36): Error: undefined identifier `Arrays`

    /tmp/tmptnq_qt46.d(38): Error: undefined identifier `A'
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            result[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n   \
    \ \n    Arrays.sort(result, (a, b) => (a.0 < b.0) ? 1 : ((b.0 < a.0) ? -1 : 0));\n\
    \    Arrays.sort(result, (a, b) => (a.1 < b.1) ? 1 : ((b.1 < a.1) ? -1 : 0));\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3tb5a9kh.d(28): Error: found `0.00000` when expecting `)`

    /tmp/tmp3tb5a9kh.d(28): Error: found `0.00000` when expecting `,`

    /tmp/tmp3tb5a9kh.d(28): Error: found `0.00000` when expecting `)`

    /tmp/tmp3tb5a9kh.d(28): Error: found `0.00000` when expecting `)`

    /tmp/tmp3tb5a9kh.d(28): Error: found `)` when expecting `;` following statement

    /tmp/tmp3tb5a9kh.d(28): Error: found `?` instead of statement

    /tmp/tmp3tb5a9kh.d(29): Error: found `0.1` when expecting `)`

    /tmp/tmp3tb5a9kh.d(29): Error: found `0.1` when expecting `,`

    /tmp/tmp3tb5a9kh.d(29): Error: found `0.1` when expecting `)`

    /tmp/tmp3tb5a9kh.d(29): Error: found `0.1` when expecting `)`

    /tmp/tmp3tb5a9kh.d(29): Error: found `)` when expecting `;` following statement

    /tmp/tmp3tb5a9kh.d(29): Error: found `?` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3tb5a9kh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    \n    foreach(i\
    \ : 0..lst.len())\n    {\n        if(lst[i][0] == x)\n        {\n            result\
    \ = append(result, Tuple!(long, long)[lst[i][1], lst[i][2]]);\n        }\n   \
    \ }\n    \n    sort(result);\n    sort(result, 1, 2);\n    \n    return result;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu65pit7m.d(21): Error: no identifier for declarator `i`

    /tmp/tmpu65pit7m.d(21): Error: found `:` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu65pit7m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row,lst)\n    {\n        foreach(col,row)\n\
    \        {\n            if(col == x)\n            {\n                res = Tuple!(long,\
    \ long)[](row,col);\n                break;\n            }\n        }\n      \
    \  if(res != null)\n            break;\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpodyznd6l.d(20): Error: no identifier for declarator `lst`

    /tmp/tmpodyznd6l.d(20): Error: found `)` when expecting `;`

    /tmp/tmpodyznd6l.d(22): Error: no identifier for declarator `row`

    /tmp/tmpodyznd6l.d(22): Error: found `)` when expecting `;`

    /tmp/tmpodyznd6l.d(30): Error: found `if` when expecting `)`

    /tmp/tmpodyznd6l.d(31): Error: found `break` when expecting `;` following statement

    /tmp/tmpodyznd6l.d(31): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpodyznd6l.d(33): Error: found `return` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpodyznd6l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] =\
    \ new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j =\
    \ 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n \
    \               result[i][j] = 1;\n            }\n        }\n    }\n    \n   \
    \ for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n    \
    \    {\n            if(result[i][j] == 1)\n            {\n                long\
    \ temp[][] = new long[m][2];\n                for(int k = 0; k < m; k++)\n   \
    \             {\n                    temp[k][0] = (int)i;\n                  \
    \  temp[k][1] = (int)j;\n                }\n                \n               \
    \ Arrays.sort(temp, (a, b) -> {\n                    if(a[0] > b[0])\n       \
    \             {\n                        return 1;\n                    }\n  \
    \                  if(a[0] == b[0])\n                    {\n                 \
    \       if(a[1] > b[1])\n                        {\n                         \
    \   return 1;\n                        }\n                        if(a[1] == b[1])\n\
    \                        {\n                            return 0;\n          \
    \              }\n                    }\n                    return -1;\n    \
    \            });\n                \n                for(int k = 0; k < m; k++)\n\
    \                {\n                    result[i][k] = temp[k][0];\n         \
    \           result[j][k] = temp[k][1];\n                }\n            }\n   \
    \     }\n    }\n    \n    Arrays.sort(result, (a, b) -> {\n        if(a[0] > b[0])\n\
    \        {\n            return 1;\n        }\n        if(a[0] == b[0])\n     \
    \   {\n            if(a[1] > b[1])\n            {\n                return 1;\n\
    \            }\n            if(a[1] == b[1])\n            {\n                return\
    \ 0;\n            }\n        }\n        return -1;\n    });\n    \n    for(int\
    \ i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n \
    \           if(result[i][j] == 1)\n            {\n                return Tuple!((long)i,\
    \ (long)j);\n            }\n        }\n    }\n    return Tuple!();\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf_vhaowb.d(21): Deprecation: instead of C-style syntax, use D-style
    syntax `long[][] result`

    /tmp/tmpf_vhaowb.d(39): Deprecation: instead of C-style syntax, use D-style syntax
    `long[][] temp`

    /tmp/tmpf_vhaowb.d(42): Error: C style cast illegal, use `cast(int)i`

    /tmp/tmpf_vhaowb.d(43): Error: C style cast illegal, use `cast(int)j`

    /tmp/tmpf_vhaowb.d(46): Error: expression expected, not `>`

    /tmp/tmpf_vhaowb.d(46): Error: found `{` when expecting `,`

    /tmp/tmpf_vhaowb.d(47): Error: expression expected, not `if`

    /tmp/tmpf_vhaowb.d(48): Error: found `{` when expecting `,`

    /tmp/tmpf_vhaowb.d(49): Error: expression expected, not `return`

    /tmp/tmpf_vhaowb.d(49): Error: found `1` when expecting `,`

    /tmp/tmpf_vhaowb.d(49): Error: expression expected, not `;`

    /tmp/tmpf_vhaowb.d(50): Error: found `}` when expecting `,`

    /tmp/tmpf_vhaowb.d(51): Error: expression expected, not `if`

    /tmp/tmpf_vhaowb.d(52): Error: found `{` when expecting `,`

    /tmp/tmpf_vhaowb.d(53): Error: expression expected, not `if`

    /tmp/tmpf_vhaowb'
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n \
    \       {\n            if(lst[i][j] == x)\n            {\n                res[i]\
    \ = j;\n                break;\n            }\n        }\n    }\n    return Tuple!(long,\
    \ long)[](res, n - 1);\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp7p6are4.d(33): Error: function expected before `()`, not `Tuple!(long,
    long)[]` of type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp7p6are4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] ans;\n    \n    for(int i = 0; i < lst.length; ++i)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            ans = lst[i];\n   \
    \         break;\n        }\n    }\n    \n    return ans;\n}\nunittest\n{\n  \
    \  alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L],\
    \ [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L),\
    \ tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3kjyhacv.d(25): Error: cannot implicitly convert expression `lst[cast(ulong)i]`
    of type `long[]` to `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3kjyhacv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] =\
    \ new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j =\
    \ 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n \
    \               result[i][j] = 1;\n            }\n        }\n    }\n    Arrays.sort(result);\n\
    \    Arrays.sort(result, (a, b) -> b[0] - a[0]);\n    Arrays.sort(result, (a,\
    \ b) -> b[1] - a[1]);\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5n8gu1kh.d(21): Deprecation: instead of C-style syntax, use D-style
    syntax `long[][] result`

    /tmp/tmp5n8gu1kh.d(33): Error: expression expected, not `>`

    /tmp/tmp5n8gu1kh.d(33): Error: found `b` when expecting `,`

    /tmp/tmp5n8gu1kh.d(34): Error: expression expected, not `>`

    /tmp/tmp5n8gu1kh.d(34): Error: found `b` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5n8gu1kh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.length; ++i)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            rows = i;\n       \
    \     break;\n        }\n    }\n    for(long i = 0; i < lst.length; ++i)\n   \
    \ {\n        if(lst[i][cols] == x)\n        {\n            cols = i;\n       \
    \     break;\n        }\n    }\n    Tuple!(long, long)[] res = new Tuple!(long,\
    \ long)[rows];\n    for(long i = 0; i < rows; ++i)\n    {\n        res[i] = new\
    \ Tuple!(long, long)[cols];\n        for(long j = 0; j < cols; ++j)\n        {\n\
    \            res[i][j] = new Tuple!(long, long)();\n        }\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqfjxdn16.d(40): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign`
    cannot deduce function from argument types `!()(Tuple!(long, long)[])`, candidates
    are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(long,
    long).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this),
    R, "="))`

    /tmp/tmpqfjxdn16.d(43): Error: variable `j` cannot be read at compile time

    /tmp/tmpqfjxdn16.d(43): Error: cannot implicitly convert expression `new Tuple!(long,
    long)(0L, 0L)` of type `Tuple!(long, long)*` to `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqfjxdn16.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long ans = 0;\n  \
    \  \n    for(long i = 0; i < n; i++)\n    {\n        for(long j = 0; j < m; j++)\n\
    \        {\n            if(lst[i][j] == x)\n            {\n                ans\
    \ += 1;\n                break;\n            }\n        }\n    }\n    \n    Tuple!(long,\
    \ long)[] ans = new Tuple!(long, long)[ans];\n    \n    for(long i = 0; i < n;\
    \ i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                ans[ans].0 = i;\n                ans[ans].1\
    \ = j;\n                break;\n            }\n        }\n    }\n    \n    return\
    \ ans;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp58_76ry.d(43): Error: found `0.00000` when expecting `;` following
    statement

    /tmp/tmpp58_76ry.d(43): Error: found `=` instead of statement

    /tmp/tmpp58_76ry.d(44): Error: found `0.1` when expecting `;` following statement

    /tmp/tmpp58_76ry.d(44): Error: found `=` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp58_76ry.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.len();\n    long m = lst[0].len();\n    long result[][] = new\
    \ long[n][m];\n    long i, j, k;\n    \n    for(i = 0; i < n; i++)\n    {\n  \
    \      for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n   \
    \         {\n                result[i][j] = 1;\n                break;\n     \
    \       }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n       \
    \ for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n     \
    \       {\n                k = j;\n                while(k >= 0 && lst[i][k] ==\
    \ x)\n                {\n                    result[i][k] = 2;\n             \
    \       k--;\n                }\n                k = j;\n                while(k\
    \ >= 0 && lst[i][k] == x)\n                {\n                    result[i][k]\
    \ = 1;\n                    k--;\n                }\n                break;\n\
    \            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n  \
    \      for(j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n\
    \            {\n                k = j;\n                while(k >= 0 && lst[i][k]\
    \ == x)\n                {\n                    result[i][k] = 2;\n          \
    \          k--;\n                }\n                break;\n            }\n  \
    \      }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j\
    \ < m; j++)\n        {\n            if(result[i][j] == 2)\n            {\n   \
    \             k = j;\n                while(k >= 0 && lst[i][k] == x)\n      \
    \          {\n                    result[i][k] = 1;\n                    k--;\n\
    \                }\n                break;\n            }\n        }\n    }\n\
    \    \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n   \
    \     {\n            if(result[i][j] == 2)\n            {\n                k =\
    \ j;\n                while(k >= 0 && lst[i][k] == x)\n                {\n   \
    \                 result[i][k] = 1;\n                    k--;\n              \
    \  }\n                break;\n            }\n        }\n    }\n    \n    for(i\
    \ = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n       \
    \     if(result[i][j] == 2)\n            {\n                k = j;\n         \
    \       while(k >= 0 && lst[i][k] == x)\n                {\n                 \
    \   result[i][k] = 1;\n                    k--;\n                }\n         \
    \       break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j]\
    \ == 2)\n            {\n                k = j;\n                while(k >= 0 &&\
    \ lst[i][k] == x)\n                {\n                    result[i][k] = 1;\n\
    \                    k--;\n                }\n                break;\n       \
    \     }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n    {\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5r59f5fi.d(21): Deprecation: instead of C-style syntax, use D-style
    syntax `long[][] result`

    /tmp/tmp5r59f5fi.d(146): Error: found `unittest` instead of statement

    /tmp/tmp5r59f5fi.d(157): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5r59f5fi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] ans;\n    \n    for(int i = 0; i < lst.length; ++i)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            ans = Tuple!(long,\
    \ long)[Tuple!(i + 1, lst[i][1])];\n            break;\n        }\n    }\n   \
    \ \n    return ans;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpysk3pm85.d(25): Error: variable `i` cannot be read at compile time

    /tmp/tmpysk3pm85.d(25): Error: variable `lst` cannot be read at compile time

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpysk3pm85.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n  \
    \  Tuple!(long, long)[] res = null;\n    \n    for(i = 0; i < n; i++) {\n    \
    \    for(j = 0; j < m; j++) {\n            if(lst[i][j] == x) {\n            \
    \    res = new Tuple!(long, long)[new Tuple!(i, j)]; \n                break;\n\
    \            }\n        }\n    }\n    \n    if(res == null) {\n        throw new\
    \ Exception(\"Invalid coordinate\");\n    }\n    \n    for(i = 0; i < n; i++)\
    \ {\n        for(j = 0; j < m; j++) {\n            if(lst[i][j] > x) {\n     \
    \           k = j;\n                break;\n            }\n        }\n       \
    \ \n        if(k > m) {\n            k = m;\n        }\n        \n        for(;\
    \ k < m; k++) {\n            res[new Tuple!(i, k)] = new Tuple!(i, k);\n     \
    \   }\n    }\n    \n    for(i = 0; i < n; i++) {\n        for(j = 0; j < m; j++)\
    \ {\n            if(lst[i][j] < x) {\n                k = j;\n               \
    \ break;\n            }\n        }\n        \n        if(k > m) {\n          \
    \  k = m;\n        }\n        \n        for(; k < m; k++) {\n            res[new\
    \ Tuple!(i, k)] = new Tuple!(i, k);\n        }\n    }\n    \n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501):
    Error: template instance `parseSpecs!(i, j)` cannot use local `i` as parameter
    to non-global template `parseSpecs(Specs...)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501):
    Error: template instance `parseSpecs!(i, j)` cannot use local `j` as parameter
    to non-global template `parseSpecs(Specs...)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(614):
    Error: CTFE failed because of previous errors in `injectNamedFields`

    /tmp/tmpgjasaxhx.d(27): Error: template instance `tmpgjasaxhx.get_row.Tuple!(i,
    j)` error instantiating

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/lin'
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[(n\
    \ + 1) * (m + 1)];\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int\
    \ j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n\
    \                res[(i * m) + j] = (i * m) + j;\n            }\n        }\n \
    \   }\n    \n    Arrays.sort(res);\n    \n    for(int i = 0; i < n; i++)\n   \
    \ {\n        for(int j = 0; j < m; j++)\n        {\n            if(res[(i * m)\
    \ + j] != (i * m) + j)\n            {\n                res[(i * m) + j] = (i *\
    \ m) + j;\n            }\n        }\n    }\n    \n    Arrays.sort(res, (a, b)\
    \ -> b - a);\n    \n    Tuple!(long, long)[] res = new Tuple!(long, long)[(n +\
    \ 1) * (m + 1)];\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int\
    \ j = 0; j < m; j++)\n        {\n            if(res[(i * m) + j] != (i * m) +\
    \ j)\n            {\n                res[(i * m) + j] = (i * m) + j;\n       \
    \     }\n        }\n    }\n    \n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphw00exw3.d(47): Error: expression expected, not `>`

    /tmp/tmphw00exw3.d(47): Error: found `b` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphw00exw3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row: row) \n    {\n\
    \        foreach(col: row, col: col) \n        {\n            if(col == x) \n\
    \            {\n                res = Tuple!(long, long)[](row, col);\n      \
    \          break;\n            }\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_u6di9uz.d(20): Error: no identifier for declarator `row`

    /tmp/tmp_u6di9uz.d(20): Error: found `:` when expecting `;`

    /tmp/tmp_u6di9uz.d(20): Error: found `:` when expecting `)`

    /tmp/tmp_u6di9uz.d(20): Error: found `)` when expecting `;` following statement

    /tmp/tmp_u6di9uz.d(22): Error: no identifier for declarator `col`

    /tmp/tmp_u6di9uz.d(22): Error: found `:` when expecting `;`

    /tmp/tmp_u6di9uz.d(22): Error: found `:` when expecting `)`

    /tmp/tmp_u6di9uz.d(22): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_u6di9uz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row_index: 0) \n\
    \    {\n        foreach(col: row, col_index: 0) \n        {\n            if(col\
    \ == x) \n            {\n                res = Tuple!(long, long)[](row_index,\
    \ col_index);\n            }\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1tj2t4h0.d(20): Error: no identifier for declarator `row`

    /tmp/tmp1tj2t4h0.d(20): Error: found `:` when expecting `;`

    /tmp/tmp1tj2t4h0.d(20): Error: found `:` when expecting `)`

    /tmp/tmp1tj2t4h0.d(20): Error: found `)` when expecting `;` following statement

    /tmp/tmp1tj2t4h0.d(22): Error: no identifier for declarator `col`

    /tmp/tmp1tj2t4h0.d(22): Error: found `:` when expecting `;`

    /tmp/tmp1tj2t4h0.d(22): Error: found `:` when expecting `)`

    /tmp/tmp1tj2t4h0.d(22): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1tj2t4h0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[] res = new long[lst.length];\n    for(int i = 0; i < lst.length; i++)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            res[i] = lst[i][1];\n\
    \        }\n    }\n    return Tuple!(long, long)[](res, lst.length);\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu2blg68w.d(27): Error: function expected before `()`, not `Tuple!(long,
    long)[]` of type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu2blg68w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n \
    \       {\n            if(lst[i][j] == x)\n            {\n                res[i]\
    \ = j;\n                break;\n            }\n        }\n    }\n    return Tuple!(long,\
    \ long)[](res, n - 1);\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp7p6are4.d(33): Error: function expected before `()`, not `Tuple!(long,
    long)[]` of type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp7p6are4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n \
    \       {\n            if(lst[i][j] == x)\n            {\n                res[i]\
    \ = j;\n                break;\n            }\n        }\n    }\n    return Tuple!<long,\
    \ long>[res];\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl68f3vwh.d(33): Error: template argument expected following `!`

    /tmp/tmpl68f3vwh.d(33): Error: found `,` when expecting `.` following long

    /tmp/tmpl68f3vwh.d(33): Error: found `long` when expecting identifier following
    `long`.

    /tmp/tmpl68f3vwh.d(33): Error: found `>` when expecting `;` following `return`
    statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl68f3vwh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[] res = new long[lst.length];\n    for(int i = 0; i < lst.length; i++)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            res[i] = lst[i][1];\n\
    \        }\n    }\n    return Tuple!(long, long)[res];\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpysy2v30e.d(27): Error: cannot implicitly convert expression `res`
    of type `long[]` to `ulong`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpysy2v30e.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = null;\n    \n    foreach(row: lst, row_index:\
    \ 0) \n    {\n        foreach(column: row, column_index: 0) \n        {\n    \
    \        if(column_index == x) \n            {\n                result = Tuple!(long,\
    \ long)[Tuple!((row_index, column_index), Tuple!((row_index, column_index))];\n\
    \            }\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n \
    \   alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L],\
    \ [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L),\
    \ tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpizcb6x2_.d(21): Error: no identifier for declarator `row`

    /tmp/tmpizcb6x2_.d(21): Error: found `:` when expecting `;`

    /tmp/tmpizcb6x2_.d(21): Error: found `:` when expecting `)`

    /tmp/tmpizcb6x2_.d(21): Error: found `)` when expecting `;` following statement

    /tmp/tmpizcb6x2_.d(23): Error: no identifier for declarator `column`

    /tmp/tmpizcb6x2_.d(23): Error: found `:` when expecting `;`

    /tmp/tmpizcb6x2_.d(23): Error: found `:` when expecting `)`

    /tmp/tmpizcb6x2_.d(23): Error: found `)` when expecting `;` following statement

    /tmp/tmpizcb6x2_.d(27): Error: found `]` when expecting `)` following template
    argument list

    /tmp/tmpizcb6x2_.d(27): Error: found `;` when expecting `,`

    /tmp/tmpizcb6x2_.d(28): Error: expression expected, not `}`

    /tmp/tmpizcb6x2_.d(29): Error: found `}` when expecting `,`

    /tmp/tmpizcb6x2_.d(30): Error: expression expected, not `}`

    /tmp/tmpizcb6x2_.d(32): Error: found `return` when expecting `,`

    /tmp/tmpizcb6x2_.d(32): Error: found `;` when expecting `,`

    /tmp/tmpizcb6x2_.d(33): Error: '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[][] res = new\
    \ long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j\
    \ < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n      \
    \          res[i][j] = 1;\n            }\n            else\n            {\n  \
    \              res[i][j] = 0;\n            }\n        }\n    }\n    return Tuple!(long,\
    \ long)[](sort(res), sort(res));\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpsgeian2r.d(21): Error: variable `n` cannot be read at compile time

    /tmp/tmpsgeian2r.d(36): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    /tmp/tmpsgeian2r.d(36): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsgeian2r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row,lst)\n    {\n        foreach(col,row)\n\
    \        {\n            if(col == x)\n            {\n                res = Tuple!(long,\
    \ long)[](row,col);\n                break;\n            }\n        }\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_88sn8_3.d(20): Error: no identifier for declarator `lst`

    /tmp/tmp_88sn8_3.d(20): Error: found `)` when expecting `;`

    /tmp/tmp_88sn8_3.d(22): Error: no identifier for declarator `row`

    /tmp/tmp_88sn8_3.d(22): Error: found `)` when expecting `;`

    /tmp/tmp_88sn8_3.d(30): Error: found `}` when expecting `)`

    /tmp/tmp_88sn8_3.d(33): Error: found `unittest` when expecting `)`

    /tmp/tmp_88sn8_3.d(44): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_88sn8_3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; i++){\n        if(lst[i][0] == x){\n            res[i]\
    \ = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    sort(res);\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpo1f42cnd.d(22): Error: variable `lst` cannot be read at compile
    time

    /tmp/tmpo1f42cnd.d(22): Error: variable `lst` cannot be read at compile time

    /tmp/tmpo1f42cnd.d(25): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpo1f42cnd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n\
    \    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        for(int j = 0;\
    \ j < lst[i][1]; ++j)\n        {\n            if(lst[i][0] == j)\n           \
    \ {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n         \
    \   }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n\
    \        for(int j = 0; j < lst[i][1]; ++j)\n        {\n            if(lst[i][0]\
    \ == j)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n\
    \    {\n        for(int j = 0; j < lst[i][1]; ++j)\n        {\n            if(lst[i][0]\
    \ == j)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n\
    \    {\n        for(int j = 0; j < lst[i][1]; ++j)\n        {\n            if(lst[i][0]\
    \ == j)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n\
    \    {\n        for(int j = 0; j < lst[i][1]; ++j)\n        {\n            if(lst[i][0]\
    \ == j)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n\
    \    {\n        for(int j = 0; j < lst[i][1]; ++j)\n        {\n            if(lst[i][0]\
    \ == j)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n\
    \    {\n        for(int j = 0; j < lst[i][1]; ++j)\n        {\n            if(lst[i][0]\
    \ == j)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n\
    \    {\n        for(int j = 0; j < lst[i][1]; ++j)\n        {\n            if(lst[i][0]\
    \ == j)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n\
    \    {\n        for(int j = 0; j < lst[i][1]; ++j)\n        {\n            if(lst[i][0]\
    \ == j)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n\
    \    {\n        for(int j = 0; j < lst[i][1]\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpra3dkffo.d(130): Error: found `unittest` when expecting `;` following
    `for` condition

    /tmp/tmpra3dkffo.d(141): Error: found `void` when expecting `)`

    /tmp/tmpra3dkffo.d(141): Error: found `{` when expecting `;` following statement

    /tmp/tmpra3dkffo.d(141): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpra3dkffo.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.Length;\n    long m = lst[0].Length;\n    long[] res = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n \
    \       {\n            if(lst[i][j] == x)\n            {\n                res[i]\
    \ = j;\n                break;\n            }\n        }\n    }\n    return Tuple!(long,\
    \ long)[](res, n - 1);\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqsihp6jy.d(19): Error: no property `Length` for type `long[][]`

    /tmp/tmpqsihp6jy.d(20): Error: no property `Length` for type `long[]`

    /tmp/tmpqsihp6jy.d(33): Error: function expected before `()`, not `Tuple!(long,
    long)[]` of type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqsihp6jy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row: row) \n    {\n\
    \        foreach(col: row, col: col) \n        {\n            if(col == x) \n\
    \            {\n                res = Tuple!(long, long)[](row, col);\n      \
    \          break;\n            }\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_u6di9uz.d(20): Error: no identifier for declarator `row`

    /tmp/tmp_u6di9uz.d(20): Error: found `:` when expecting `;`

    /tmp/tmp_u6di9uz.d(20): Error: found `:` when expecting `)`

    /tmp/tmp_u6di9uz.d(20): Error: found `)` when expecting `;` following statement

    /tmp/tmp_u6di9uz.d(22): Error: no identifier for declarator `col`

    /tmp/tmp_u6di9uz.d(22): Error: found `:` when expecting `;`

    /tmp/tmp_u6di9uz.d(22): Error: found `:` when expecting `)`

    /tmp/tmp_u6di9uz.d(22): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_u6di9uz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.len();\n    long m = lst[0].len();\n    long result[][] = new\
    \ long[n][m];\n    long row = 0;\n    long col = 0;\n    for(long i = 0; i < n;\
    \ i++)\n    {\n        for(long j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                result[row][col] = i;\n              \
    \  result[row][col + 1] = j;\n                row++;\n                col = 0;\n\
    \            }\n            else\n            {\n                col++;\n    \
    \        }\n        }\n    }\n    Arrays.sort(result);\n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi3mssd_o.d(21): Deprecation: instead of C-style syntax, use D-style
    syntax `long[][] result`

    /tmp/tmpi3mssd_o.d(19): Error: no property `len` for type `long[][]`

    /tmp/tmpi3mssd_o.d(20): Error: no property `len` for type `long[]`

    /tmp/tmpi3mssd_o.d(21): Error: variable `n` cannot be read at compile time

    /tmp/tmpi3mssd_o.d(41): Error: undefined identifier `Arrays`

    /tmp/tmpi3mssd_o.d(42): Error: cannot implicitly convert expression `result` of
    type `long[][]` to `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi3mssd_o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            res[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n  \
    \  sort(res);\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpyxltz6oy.d(24): Error: variable `lst` cannot be read at compile
    time

    /tmp/tmpyxltz6oy.d(24): Error: variable `lst` cannot be read at compile time

    /tmp/tmpyxltz6oy.d(27): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyxltz6oy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long[] res = new long[n];\n    for(int i = 0; i\
    \ < n; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            res[i]\
    \ = lst[i][1];\n        }\n    }\n    return Tuple!(long, long)[](res);\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_7dty2p3.d(28): Error: function expected before `()`, not `Tuple!(long,
    long)[]` of type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_7dty2p3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.Length; i++)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            rows++;\n        }\n\
    \        else\n        {\n            cols++;\n        }\n    }\n    Tuple!(long,\
    \ long)[] res = new Tuple!(long, long)[rows];\n    for(long i = 0; i < rows; i++)\n\
    \    {\n        res[i] = new Tuple!(long, long)[cols];\n        for(long j = 0;\
    \ j < cols; j++)\n        {\n            res[i][j] = new Tuple!(long, long)[i,\
    \ j];\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_tm1axbb.d(38): Error: found `,` when expecting `]`

    /tmp/tmp_tm1axbb.d(38): Error: found `j` when expecting `;` following statement

    /tmp/tmp_tm1axbb.d(38): Error: found `]` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_tm1axbb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] =\
    \ new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j =\
    \ 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n \
    \               result[i][j] = 1;\n            }\n        }\n    }\n    Arrays.sort(result);\n\
    \    Arrays.sort(result, (a, b) -> b[0] - a[0]);\n    Arrays.sort(result, (a,\
    \ b) -> b[1] - a[1]);\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5n8gu1kh.d(21): Deprecation: instead of C-style syntax, use D-style
    syntax `long[][] result`

    /tmp/tmp5n8gu1kh.d(33): Error: expression expected, not `>`

    /tmp/tmp5n8gu1kh.d(33): Error: found `b` when expecting `,`

    /tmp/tmp5n8gu1kh.d(34): Error: expression expected, not `>`

    /tmp/tmp5n8gu1kh.d(34): Error: found `b` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5n8gu1kh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    foreach(i : 0..lst.length-1)\n\
    \    {\n        foreach(j : 0..lst[i].length-1)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                res = append(res, Tuple!(i, j));\n   \
    \         }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg1r06zhb.d(20): Error: no identifier for declarator `i`

    /tmp/tmpg1r06zhb.d(20): Error: found `:` when expecting `;`

    /tmp/tmpg1r06zhb.d(22): Error: no identifier for declarator `j`

    /tmp/tmpg1r06zhb.d(22): Error: found `:` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg1r06zhb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] =\
    \ new long[n][m];\n    long i, j, k;\n    for(i = 0; i < n; i++)\n    {\n    \
    \    for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n     \
    \       {\n                result[i][j] = 1;\n                break;\n       \
    \     }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j =\
    \ 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n\
    \                k = j;\n                break;\n            }\n        }\n  \
    \      for(j = k; j < m; j++)\n        {\n            if(result[i][j] == 1)\n\
    \            {\n                result[i][j] = 2;\n                break;\n  \
    \          }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j\
    \ = 0; j < m; j++)\n        {\n            if(result[i][j] == 2)\n           \
    \ {\n                result[i][j] = 0;\n                break;\n            }\n\
    \        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m;\
    \ j++)\n        {\n            if(result[i][j] == 0)\n            {\n        \
    \        result[i][j] = 1;\n                break;\n            }\n        }\n\
    \    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n  \
    \      {\n            if(result[i][j] == 1)\n            {\n                result[i][j]\
    \ = 2;\n                break;\n            }\n        }\n    }\n    for(i = 0;\
    \ i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j]\
    \ == 2)\n            {\n                result[i][j] = 0;\n                break;\n\
    \            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j\
    \ = 0; j < m; j++)\n        {\n            if(result[i][j] == 0)\n           \
    \ {\n                result[i][j] = 1;\n                break;\n            }\n\
    \        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m;\
    \ j++)\n        {\n            if(result[i][j] == 1)\n            {\n        \
    \        result[i][j] = 2;\n                break;\n            }\n        }\n\
    \    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n  \
    \      {\n            if(result[i][j] == 2)\n            {\n                result[i][j]\
    \ = 0;\n                break;\n            }\n        }\n    }\n    for(i = 0;\
    \ i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j]\
    \ == 0)\n            {\n                result[i][j] = 1;\n                break;\n\
    \            }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j\
    \ = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n           \
    \ {\n                result[i][j] = 2;\n                break;\n            }\n\
    \        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m;\
    \ j++)\n        {\n            if(result[i][j] == 2)\n            {\n        \
    \        result[i][j] = 0;\n                break;\n            }\n\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1ep3hnfv.d(21): Deprecation: instead of C-style syntax, use D-style
    syntax `long[][] result`

    /tmp/tmp1ep3hnfv.d(162): Error: found `unittest` instead of statement

    /tmp/tmp1ep3hnfv.d(173): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp1ep3hnfv.d(173): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1ep3hnfv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = null;\n    \n    foreach(row: lst, row: row)\
    \ \n    {\n        foreach(column: row, column: column) \n        {\n        \
    \    if(column == x) \n            {\n                result = Tuple!(long, long)[](row,\
    \ column);\n                break;\n            }\n        }\n    }\n    \n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp01jm0614.d(21): Error: no identifier for declarator `row`

    /tmp/tmp01jm0614.d(21): Error: found `:` when expecting `;`

    /tmp/tmp01jm0614.d(21): Error: found `:` when expecting `)`

    /tmp/tmp01jm0614.d(21): Error: found `)` when expecting `;` following statement

    /tmp/tmp01jm0614.d(23): Error: no identifier for declarator `column`

    /tmp/tmp01jm0614.d(23): Error: found `:` when expecting `;`

    /tmp/tmp01jm0614.d(23): Error: found `:` when expecting `)`

    /tmp/tmp01jm0614.d(23): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp01jm0614.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i = 0;\n    long\
    \ j = 0;\n    long k = 0;\n    long l = 0;\n    long m1 = m;\n    long n1 = n;\n\
    \    long m2 = m;\n    long n2 = n;\n    long m3 = m;\n    long n3 = n;\n    long\
    \ m4 = m;\n    long n4 = n;\n    long m5 = m;\n    long n5 = n;\n    long m6 =\
    \ m;\n    long n6 = n;\n    long m7 = m;\n    long n7 = n;\n    long m8 = m;\n\
    \    long n8 = n;\n    long m9 = m;\n    long n9 = n;\n    long m10 = m;\n   \
    \ long n10 = n;\n    long m11 = m;\n    long n11 = n;\n    long m12 = m;\n   \
    \ long n12 = n;\n    long m13 = m;\n    long n13 = n;\n    long m14 = m;\n   \
    \ long n14 = n;\n    long m15 = m;\n    long n15 = n;\n    long m16 = m;\n   \
    \ long n16 = n;\n    long m17 = m;\n    long n17 = n;\n    long m18 = m;\n   \
    \ long n18 = n;\n    long m19 = m;\n    long n19 = n;\n    long m20 = m;\n   \
    \ long n20 = n;\n    long m21 = m;\n    long n21 = n;\n    long m22 = m;\n   \
    \ long n22 = n;\n    long m23 = m;\n    long n23 = n;\n    long m24 = m;\n   \
    \ long n24 = n;\n    long m25 = m;\n    long n25 = n;\n    long m26 = m;\n   \
    \ long n26 = n;\n    long m27 = m;\n    long n27 = n;\n    long m28 = m;\n   \
    \ long n28 = n;\n    long m29 = m;\n    long n29 = n;\n    long m30 = m;\n   \
    \ long n30 = n;\n    long m31 = m;\n    long n31 = n;\n    long m32 = m;\n   \
    \ long n32 = n;\n    long m33 = m;\n    long n33 = n;\n    long m34 = m;\n   \
    \ long n34 = n;\n    long m35 = m;\n    long n35 = n;\n    long m36 = m;\n   \
    \ long n36 = n;\n    \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpknmqfrj2.d(98): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpknmqfrj2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.lenght;\n    long m = lst[0].lenght;\n    long[] res = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n \
    \       {\n            if(lst[i][j] == x)\n            {\n                res[i]\
    \ = j;\n                break;\n            }\n        }\n    }\n    return Tuple!(long,\
    \ long)[](res);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8bxbk9or.d(19): Error: no property `lenght` for type `long[][]`

    /tmp/tmp8bxbk9or.d(20): Error: no property `lenght` for type `long[]`

    /tmp/tmp8bxbk9or.d(33): Error: function expected before `()`, not `Tuple!(long,
    long)[]` of type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8bxbk9or.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.len();\n    long m = lst[0].len();\n    long i = 0;\n    long\
    \ j = 0;\n    long k = 0;\n    long l = 0;\n    long m1 = 0;\n    long m2 = 0;\n\
    \    long m3 = 0;\n    long m4 = 0;\n    long m5 = 0;\n    long m6 = 0;\n    long\
    \ m7 = 0;\n    long m8 = 0;\n    long m9 = 0;\n    long m10 = 0;\n    long m11\
    \ = 0;\n    long m12 = 0;\n    long m13 = 0;\n    long m14 = 0;\n    long m15\
    \ = 0;\n    long m16 = 0;\n    long m17 = 0;\n    long m18 = 0;\n    long m19\
    \ = 0;\n    long m20 = 0;\n    long m21 = 0;\n    long m22 = 0;\n    long m23\
    \ = 0;\n    long m24 = 0;\n    long m25 = 0;\n    long m26 = 0;\n    long m27\
    \ = 0;\n    long m28 = 0;\n    long m29 = 0;\n    long m30 = 0;\n    long m31\
    \ = 0;\n    long m32 = 0;\n    long m33 = 0;\n    long m34 = 0;\n    long m35\
    \ = 0;\n    long m36 = 0;\n    long m37 = 0;\n    long m38 = 0;\n    long m39\
    \ = 0;\n    long m40 = 0;\n    long m41 = 0;\n    long m42 = 0;\n    long m43\
    \ = 0;\n    long m44 = 0;\n    long m45 = 0;\n    long m46 = 0;\n    long m47\
    \ = 0;\n    long m48 = 0;\n    long m49 = 0;\n    long m50 = 0;\n    long m51\
    \ = 0;\n    long m52 = 0;\n    long m53 = 0;\n    long m54 = 0;\n    long m55\
    \ = 0;\n    long m56 = 0;\n    long m57 = 0;\n    long m58 = 0;\n    long m59\
    \ = 0;\n    long m60 = 0;\n    long m61 = 0;\n    long m62 = 0;\n    long m63\
    \ = 0;\n    long m64 = 0;\n    long m65 = 0;\n    long m66 = 0;\n    long m67\
    \ = 0;\n    long m68 = 0;\n    long m69 = 0;\n    long m70 = 0;\n    long m71\
    \ = 0;\n    long m72 = 0;\n    long m73 = 0;\n    long m74 = 0;\n    long m75\
    \ = 0;\n    long m76 = 0;\n    long m77 = 0;\n    long m78 = 0;\n    long m79\
    \ = 0;\n    long m80 = 0;\n\nunittest\n{\n    alias candidate = get_row;\n\n \
    \   assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr5wvgi4i.d(106): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr5wvgi4i.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.len();\n    long m = lst[0].len();\n    long result[][] = new\
    \ long[n][m];\n    long i, j, k;\n    for(i = 0; i < n; i++)\n    {\n        for(j\
    \ = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n\
    \                result[i][j] = 1;\n                break;\n            }\n  \
    \      }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m;\
    \ j++)\n        {\n            if(result[i][j] == 1)\n            {\n        \
    \        k = j;\n                while(k >= 0 && lst[i][k] == x)\n           \
    \     {\n                    result[i][k] = 2;\n                    k--;\n   \
    \             }\n                k = j;\n                while(k >= 0 && lst[i][k]\
    \ == x)\n                {\n                    result[i][k] = 1;\n          \
    \          k--;\n                }\n                break;\n            }\n  \
    \      }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m;\
    \ j++)\n        {\n            if(result[i][j] == 1)\n            {\n        \
    \        k = j;\n                while(k >= 0 && lst[i][k] == x)\n           \
    \     {\n                    result[i][k] = 2;\n                    k--;\n   \
    \             }\n                break;\n            }\n        }\n    }\n   \
    \ for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n \
    \           if(result[i][j] == 2)\n            {\n                k = j;\n   \
    \             while(k >= 0 && lst[i][k] == x)\n                {\n           \
    \         result[i][k] = 1;\n                    k--;\n                }\n   \
    \             break;\n            }\n        }\n    }\n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j]\
    \ == 2)\n            {\n                k = j;\n                while(k >= 0 &&\
    \ lst[i][k] == x)\n                {\n                    result[i][k] = 1;\n\
    \                    k--;\n                }\n                break;\n       \
    \     }\n        }\n    }\n    for(i = 0; i < n; i++)\n    {\n        for(j =\
    \ 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n            {\n\
    \                k = j;\n                while(k >= 0 && lst[i][k] == x)\n   \
    \             {\n                    result[i][k] = 2;\n                    k--;\n\
    \                }\n                break;\n            }\n        }\n    }\n\
    \    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n\
    \            if(result[i][j] == 2)\n            {\n                k = j;\n  \
    \              while(k >= 0 && lst[i][k] == x)\n                {\n          \
    \          result[i][k] = 1;\n                    k--;\n                }\n  \
    \              break;\n            }\n        }\n    }\n    for(i = 0; i < n;\
    \ i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(result[i][j]\
    \ == 1)\n\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpx49r583s.d(21): Deprecation: instead of C-style syntax, use D-style
    syntax `long[][] result`

    /tmp/tmpx49r583s.d(142): Error: found `unittest` instead of statement

    /tmp/tmpx49r583s.d(153): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpx49r583s.d(153): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpx49r583s.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    for(long i = 0;\
    \ i < lst.Length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n       \
    \     Tuple!(long, long)[] row = new Tuple!(long, long)[i];\n            for(long\
    \ j = 0; j < lst[i].Length; j++)\n            {\n                if(lst[i][j]\
    \ > x)\n                {\n                    row.Add(lst[i][j], j);\n      \
    \          }\n            }\n            res.Add(row);\n        }\n    }\n   \
    \ return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2p1rnaqz.d(20): Error: no property `Length` for type `long[][]`

    /tmp/tmp2p1rnaqz.d(25): Error: no property `Length` for type `long[]`

    /tmp/tmp2p1rnaqz.d(29): Error: no property `Add` for type `Tuple!(long, long)[]`

    /tmp/tmp2p1rnaqz.d(32): Error: no property `Add` for type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2p1rnaqz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    for(int i = 0;\
    \ i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n       \
    \     Tuple!(long, long)[] row = new Tuple!(long, long)[lst[i].length];\n    \
    \        for(int j = 0; j < lst[i].length; j++)\n            {\n             \
    \   row[j] = (lst[i][0], lst[i][1]);\n            }\n            sort(row);\n\
    \            sort(res);\n            res = new Tuple!(long, long)[res.length +\
    \ 1];\n            res[res.length - 1] = row;\n        }\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg32ngcvw.d(27): Error: Using the result of a comma expression is
    not allowed

    /tmp/tmpg32ngcvw.d(27): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign`
    cannot deduce function from argument types `!()(long)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(long,
    long).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this),
    R, "="))`

    /tmp/tmpg32ngcvw.d(29): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    /tmp/tmpg32ngcvw.d(30): Error: undefined identifier `sort`, did you mean function
    `sqrt`?

    /tmp/tmpg32ngcvw.d(32): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign`
    cannot deduce function from argument types `!()(Tuple!(long, long)[])`, candidates
    are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/ph'
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[][] result = new long[lst.length][];\n    for(int i = 0; i < lst.length;\
    \ ++i)\n    {\n        if(lst[i][x] != 0)\n        {\n            result[i] =\
    \ new long[] {lst[i][x], i};\n        }\n    }\n    Arrays.sort(result);\n   \
    \ Arrays.sort(result, (a, b) => b[0] - a[0]);\n    return result;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpj6rj8kuk.d(24): Error: found `{` when expecting `;` following statement

    /tmp/tmpj6rj8kuk.d(24): Error: found `}` when expecting `;` following statement

    /tmp/tmpj6rj8kuk.d(24): Deprecation: use `{ }` for an empty statement, not `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpj6rj8kuk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[] result = new\
    \ long[n];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j <\
    \ m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n        \
    \        result[i] = j;\n                break;\n            }\n        }\n  \
    \  }\n    Arrays.sort(result);\n    Arrays.sort(result, (a, b) -> b - a);\n  \
    \  return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp4uwqrofy.d(34): Error: expression expected, not `>`

    /tmp/tmp4uwqrofy.d(34): Error: found `b` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4uwqrofy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    foreach(i : 0..lst.Length-1)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            foreach(j : 0..lst[i][1]-1)\n\
    \            {\n                res.Add(Tuple!(i, j));\n            }\n      \
    \  }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_cjsf8qv.d(20): Error: no identifier for declarator `i`

    /tmp/tmp_cjsf8qv.d(20): Error: found `:` when expecting `;`

    /tmp/tmp_cjsf8qv.d(24): Error: no identifier for declarator `j`

    /tmp/tmp_cjsf8qv.d(24): Error: found `:` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_cjsf8qv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.lenght;\n    long m = lst[0].lenght;\n    long result[][] =\
    \ new long[n][m];\n    long j = 0;\n    for(long i = 0; i < n; i++)\n    {\n \
    \       for(long k = 0; k < m; k++)\n        {\n            if(lst[i][j] == x)\n\
    \            {\n                result[i][j] = k;\n                break;\n  \
    \          }\n        }\n    }\n    \n    Arrays.sort(result, (a, b) => (a[0]\
    \ - b[0]) * (a[1] - b[1]));\n    Arrays.sort(result, (a, b) => (b[0] - a[0]) *\
    \ (b[1] - a[1]));\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0qsmqb73.d(21): Deprecation: instead of C-style syntax, use D-style
    syntax `long[][] result`

    /tmp/tmp0qsmqb73.d(19): Error: no property `lenght` for type `long[][]`

    /tmp/tmp0qsmqb73.d(20): Error: no property `lenght` for type `long[]`

    /tmp/tmp0qsmqb73.d(21): Error: variable `n` cannot be read at compile time

    /tmp/tmp0qsmqb73.d(35): Error: undefined identifier `Arrays`

    /tmp/tmp0qsmqb73.d(36): Error: undefined identifier `Arrays`

    /tmp/tmp0qsmqb73.d(38): Error: cannot implicitly convert expression `result` of
    type `long[][]` to `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0qsmqb73.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row: row) \n    {\n\
    \        foreach(col: row, col: col) \n        {\n            if(col == x) \n\
    \            {\n                res = Tuple!(long, long)[Tuple!(0, row), Tuple!(1,\
    \ row)];\n            }\n        }\n    }\n    return res;\n}\nunittest\n{\n \
    \   alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L],\
    \ [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L),\
    \ tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8xyrbo4x.d(20): Error: no identifier for declarator `row`

    /tmp/tmp8xyrbo4x.d(20): Error: found `:` when expecting `;`

    /tmp/tmp8xyrbo4x.d(20): Error: found `:` when expecting `)`

    /tmp/tmp8xyrbo4x.d(20): Error: found `)` when expecting `;` following statement

    /tmp/tmp8xyrbo4x.d(22): Error: no identifier for declarator `col`

    /tmp/tmp8xyrbo4x.d(22): Error: found `:` when expecting `;`

    /tmp/tmp8xyrbo4x.d(22): Error: found `:` when expecting `)`

    /tmp/tmp8xyrbo4x.d(22): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8xyrbo4x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    \n    foreach(i\
    \ : 0..lst.len) \n    {\n        foreach(j : 0..lst[i].len) \n        {\n    \
    \        if(lst[i][j] == x) \n            {\n                result.add(Tuple!(i,\
    \ j));\n            }\n        }\n    }\n    \n    result.sort(byRow);\n    result.sort(byCol);\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpvuojf2g5.d(21): Error: no identifier for declarator `i`

    /tmp/tmpvuojf2g5.d(21): Error: found `:` when expecting `;`

    /tmp/tmpvuojf2g5.d(23): Error: no identifier for declarator `j`

    /tmp/tmpvuojf2g5.d(23): Error: found `:` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvuojf2g5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] =\
    \ new long[n][m];\n    \n    for(long i = 0; i < n; i++)\n    {\n        for(long\
    \ j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n\
    \                result[i][j] = 1;\n            }\n        }\n    }\n    \n  \
    \  for(long i = 0; i < n; i++)\n    {\n        for(long j = 0; j < m; j++)\n \
    \       {\n            if(lst[i][j] == 1)\n            {\n                long\
    \ temp[][] = new long[m][2];\n                for(long k = 0; k < m; k++)\n  \
    \              {\n                    temp[k][0] = (int)i;\n                 \
    \   temp[k][1] = (int)j;\n                }\n                \n              \
    \  sort(temp, (a, b) => b[0] - a[0]);\n                \n                for(long\
    \ k = 0; k < m; k++)\n                {\n                    if(temp[k][0] > i)\n\
    \                    {\n                        swap(temp[k], temp[k - 1]);\n\
    \                    }\n                    if(temp[k][1] > j)\n             \
    \       {\n                        swap(temp[k], temp[k - 1]);\n             \
    \       }\n                }\n                \n                for(long k = 0;\
    \ k < m; k++)\n                {\n                    if(temp[k][0] > i)\n   \
    \                 {\n                        swap(temp[k], temp[k - 1]);\n   \
    \                 }\n                    if(temp[k][1] > j)\n                \
    \    {\n                        swap(temp[k], temp[k - 1]);\n                \
    \    }\n                }\n                \n                for(long k = 0; k\
    \ < m; k++)\n                {\n                    if(temp[k][0] > i)\n     \
    \               {\n                        swap(temp[k], temp[k - 1]);\n     \
    \               }\n                    if(temp[k][1] > j)\n                  \
    \  {\n                        swap(temp[k], temp[k - 1]);\n                  \
    \  }\n                }\n                \n                for(long k = 0; k <\
    \ m; k++)\n                {\n                    if(temp[k][0] > i)\n       \
    \             {\n                        swap(temp[k], temp[k - 1]);\n       \
    \             }\n                    if(temp[k][1] > j)\n                    {\n\
    \                        swap(temp[k], temp[k - 1]);\n                    }\n\
    \                }\n                \n                for(long k = 0; k < m; k++)\n\
    \                {\n                    if(temp[k][0] > i)\n                 \
    \   {\n                        swap(temp[k], temp[k - 1]);\n                 \
    \   }\n                    if(temp[k][1] > j)\n                    {\n       \
    \                 swap(temp[k], temp[k - 1]);\n                    }\n       \
    \         }\n                \n                for(long k = 0; k < m; k++)\n \
    \               {\n                    if(temp[k][0] > i)\n                  \
    \  {\n                        swap(temp[k], temp[k - 1]);\n                  \
    \  }\n                    if(temp[k][1] > j)\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpidw0mx_6.d(21): Deprecation: instead of C-style syntax, use D-style
    syntax `long[][] result`

    /tmp/tmpidw0mx_6.d(40): Deprecation: instead of C-style syntax, use D-style syntax
    `long[][] temp`

    /tmp/tmpidw0mx_6.d(43): Error: C style cast illegal, use `cast(int)i`

    /tmp/tmpidw0mx_6.d(44): Error: C style cast illegal, use `cast(int)j`

    /tmp/tmpidw0mx_6.d(116): Error: found `unittest` instead of statement

    /tmp/tmpidw0mx_6.d(127): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpidw0mx_6.d(127): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpidw0mx_6.d(127): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpidw0mx_6.d(127): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpidw0mx_6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[n];\n\
    \    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n \
    \       {\n            if(lst[i][j] == x)\n            {\n                res[i]\
    \ = j;\n                break;\n            }\n        }\n    }\n    return Tuple!(long,\
    \ long)[res];\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzjelr_oq.d(33): Error: cannot implicitly convert expression `res`
    of type `long[]` to `ulong`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzjelr_oq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long rows = 0;\n    long cols = 0;\n    \n    foreach(long y, lst)\n    {\n\
    \        if(y == x)\n        {\n            return Tuple!(long, long[])[](rows,\
    \ cols);\n        }\n        \n        foreach(long x, lst)\n        {\n     \
    \       if(y == x)\n            {\n                cols++;\n            }\n  \
    \      }\n        rows++;\n        cols = 0;\n    }\n    \n    return Tuple!(long,\
    \ long[])[](rows, cols);\n}\nunittest\n{\n    alias candidate = get_row;\n\n \
    \   assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbf7fkqej.d(22): Error: no identifier for declarator `lst`

    /tmp/tmpbf7fkqej.d(22): Error: found `)` when expecting `;`

    /tmp/tmpbf7fkqej.d(29): Error: no identifier for declarator `lst`

    /tmp/tmpbf7fkqej.d(29): Error: found `)` when expecting `;`

    /tmp/tmpbf7fkqej.d(36): Error: found `rows` when expecting `)`

    /tmp/tmpbf7fkqej.d(36): Error: expression expected, not `;`

    /tmp/tmpbf7fkqej.d(37): Error: found `cols` when expecting `;` following statement

    /tmp/tmpbf7fkqej.d(37): Error: found `=` instead of statement

    /tmp/tmpbf7fkqej.d(40): Error: found `return` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbf7fkqej.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.length; ++i)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            rows = i;\n       \
    \     break;\n        }\n    }\n    for(long i = 0; i < lst.length; ++i)\n   \
    \ {\n        if(lst[i][1] == x)\n        {\n            cols = i;\n          \
    \  break;\n        }\n    }\n    Tuple!(long, long)[] result = new Tuple!(long,\
    \ long)[rows];\n    for(long i = 0; i < rows; ++i)\n    {\n        result[i] =\
    \ new Tuple!(long, long)[cols];\n        for(long j = 0; j < cols; ++j)\n    \
    \    {\n            result[i][j] = new Tuple!(long, long)(i, j);\n        }\n\
    \    }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpiu9undrz.d(40): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign`
    cannot deduce function from argument types `!()(Tuple!(long, long)[])`, candidates
    are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(long,
    long).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this),
    R, "="))`

    /tmp/tmpiu9undrz.d(43): Error: variable `j` cannot be read at compile time

    /tmp/tmpiu9undrz.d(43): Error: cannot implicitly convert expression `new Tuple!(long,
    long)(i, j)` of type `Tuple!(long, long)*` to `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpiu9undrz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    \n    foreach(row:\
    \ lst, row: row) \n    {\n        foreach(column: row, column: column) \n    \
    \    {\n            if(column == x) \n            {\n                result.push((row,\
    \ column));\n            }\n        }\n    }\n    \n    result.sort(function(a,\
    \ b) -> a.first > b.first);\n    result.sort(function(a, b) -> a.second > b.second);\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv_johnz8.d(21): Error: no identifier for declarator `row`

    /tmp/tmpv_johnz8.d(21): Error: found `:` when expecting `;`

    /tmp/tmpv_johnz8.d(21): Error: found `:` when expecting `)`

    /tmp/tmpv_johnz8.d(21): Error: found `)` when expecting `;` following statement

    /tmp/tmpv_johnz8.d(23): Error: no identifier for declarator `column`

    /tmp/tmpv_johnz8.d(23): Error: found `:` when expecting `;`

    /tmp/tmpv_johnz8.d(23): Error: found `:` when expecting `)`

    /tmp/tmpv_johnz8.d(23): Error: found `)` when expecting `;` following statement

    /tmp/tmpv_johnz8.d(32): Error: missing `{ ... }` for function literal

    /tmp/tmpv_johnz8.d(32): Error: expression expected, not `>`

    /tmp/tmpv_johnz8.d(32): Error: found `a` when expecting `,`

    /tmp/tmpv_johnz8.d(33): Error: missing `{ ... }` for function literal

    /tmp/tmpv_johnz8.d(33): Error: expression expected, not `>`

    /tmp/tmpv_johnz8.d(33): Error: found `a` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv_johnz8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n  \
    \  Tuple!(long, long)[] res = new Tuple!(long, long)[n];\n    \n    for(i = 0;\
    \ i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                res[i] = new Tuple!(i, j);\n         \
    \       break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = m-1; j >= 0; j--)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                res[i] = new Tuple!(i, j);\n         \
    \       break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] ==\
    \ x)\n            {\n                res[i] = new Tuple!(i, j);\n            \
    \    break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] ==\
    \ x)\n            {\n                res[i] = new Tuple!(i, j);\n            \
    \    break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] ==\
    \ x)\n            {\n                res[i] = new Tuple!(i, j);\n            \
    \    break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] ==\
    \ x)\n            {\n                res[i] = new Tuple!(i, j);\n            \
    \    break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] ==\
    \ x)\n            {\n                res[i] = new Tuple!(i, j);\n            \
    \    break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] ==\
    \ x)\n            {\n                res[i] = new Tuple!(i, j);\n            \
    \    break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] ==\
    \ x)\n            {\n                res[i] = new Tuple!(i, j);\n            \
    \    break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] ==\
    \ x)\n            {\n                res[i] = new Tuple!(i, j);\n            \
    \    break;\n            }\n        }\n    }\n    \n    for(i = 0; i < n; i++)\n\
    \    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j] ==\
    \ x)\n            {\n                res[i] = new \nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe1unr_of.d(151): Error: basic type expected, not `unittest`

    /tmp/tmpe1unr_of.d(151): Error: found `unittest` when expecting `;` following
    statement

    /tmp/tmpe1unr_of.d(162): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpe1unr_of.d(162): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpe1unr_of.d(162): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpe1unr_of.d(162): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe1unr_of.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long rows = 0;\n    long cols = 0;\n    foreach(long y, lst)\n    {\n   \
    \     foreach(long x, y)\n        {\n            if(x != x)\n            {\n \
    \               cols++;\n            }\n            else\n            {\n    \
    \            rows++;\n            }\n        }\n    }\n    Tuple!(long, long)[]\
    \ res = new Tuple!(long, long)[rows];\n    foreach(long y, lst)\n    {\n     \
    \   foreach(long x, y)\n        {\n            if(x != x)\n            {\n   \
    \             res[rows] = new Tuple!(long, long)(x, y);\n                rows++;\n\
    \            }\n            else\n            {\n                res[rows] = new\
    \ Tuple!(long, long)(x, y);\n                cols--;\n            }\n        }\n\
    \    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n  \
    \  assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1yx_9eo_.d(21): Error: no identifier for declarator `lst`

    /tmp/tmp1yx_9eo_.d(21): Error: found `)` when expecting `;`

    /tmp/tmp1yx_9eo_.d(23): Error: no identifier for declarator `y`

    /tmp/tmp1yx_9eo_.d(23): Error: found `)` when expecting `;`

    /tmp/tmp1yx_9eo_.d(34): Error: found `}` when expecting `)`

    /tmp/tmp1yx_9eo_.d(36): Error: no identifier for declarator `lst`

    /tmp/tmp1yx_9eo_.d(36): Error: found `)` when expecting `;`

    /tmp/tmp1yx_9eo_.d(38): Error: no identifier for declarator `y`

    /tmp/tmp1yx_9eo_.d(38): Error: found `)` when expecting `;`

    /tmp/tmp1yx_9eo_.d(51): Error: found `}` when expecting `)`

    /tmp/tmp1yx_9eo_.d(54): Error: found `unittest` when expecting `)`

    /tmp/tmp1yx_9eo_.d(65): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp1yx_9eo_.d(65): Error: found `End of File` when expecting `)`

    /tmp/tmp1yx_9eo_.d(65): Error: found `End of File` instead of statement

    /tmp/tmp1yx_9eo_.d(65): Error: found `End of File` when expecting `}` following
    compound stateme'
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n\
    \    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0;\
    \ j < lst[i].length; j++)\n        {\n            if(lst[i][j] > lst[i][0])\n\
    \            {\n                Tuple!(long, long)[] temp = new Tuple!(long, long)[lst[i].length];\n\
    \                for(int k = 0; k < lst[i].length; k++)\n                {\n \
    \                   temp[k] = new Tuple!(lst[i][j], k);\n                }\n \
    \               Arrays.sort(temp, (x, y) => y._1 > x._1);\n                for(int\
    \ k = 0; k < temp.length; k++)\n                {\n                    result[i]\
    \ = result[i].__append(temp[k]);\n                }\n            }\n        }\n\
    \    }\n    \n    Arrays.sort(result, (x, y) => y._1 > x._1);\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt66vs_zw.d(24): Error: variable `lst` cannot be read at compile
    time

    /tmp/tmpt66vs_zw.d(24): Error: variable `lst` cannot be read at compile time

    /tmp/tmpt66vs_zw.d(37): Error: variable `lst` cannot be read at compile time

    /tmp/tmpt66vs_zw.d(39): Error: undefined identifier `Arrays`

    /tmp/tmpt66vs_zw.d(42): Error: no property `__append` for type `Tuple!(long, long)`

    /tmp/tmpt66vs_zw.d(48): Error: undefined identifier `Arrays`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt66vs_zw.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i = 0;\n    long\
    \ j = 0;\n    long k = 0;\n    long l = 0;\n    long m1 = m;\n    long n1 = n;\n\
    \    long x1;\n    long x2;\n    long y1;\n    long y2;\n    long z = 0;\n   \
    \ long z1 = 0;\n    long z2 = 0;\n    long z3 = 0;\n    long z4 = 0;\n    long\
    \ z5 = 0;\n    long z6 = 0;\n    long z7 = 0;\n    long z8 = 0;\n    long z9 =\
    \ 0;\n    long z10 = 0;\n    long z11 = 0;\n    long z12 = 0;\n    long z13 =\
    \ 0;\n    long z14 = 0;\n    long z15 = 0;\n    long z16 = 0;\n    long z17 =\
    \ 0;\n    long z18 = 0;\n    long z19 = 0;\n    long z20 = 0;\n    long z21 =\
    \ 0;\n    long z22 = 0;\n    long z23 = 0;\n    long z24 = 0;\n    long z25 =\
    \ 0;\n    long z26 = 0;\n    long z27 = 0;\n    long z28 = 0;\n    long z29 =\
    \ 0;\n    long z30 = 0;\n    long z31 = 0;\n    long z32 = 0;\n    long z33 =\
    \ 0;\n    long z34 = 0;\n    long z35 = 0;\n    long z36 = 0;\n    long z37 =\
    \ 0;\n    long z38 = 0;\n    long z39 = 0;\n    long z40 = 0;\n    long z41 =\
    \ 0;\n    long z42 = 0;\n    long z43 = 0;\n    long z44 = 0;\n    long z45 =\
    \ 0;\n    long z46 = 0;\n    long z47 = 0;\n    long z48 = 0;\n    long z49 =\
    \ 0;\n    long z50 = 0;\n    long z51 = 0;\n    long z52 = 0;\n    long z53 =\
    \ 0;\n    long z54 = 0;\n    long z55 = 0;\n    long z56 = 0;\n    long z57 =\
    \ 0;\n    long z58 = 0;\n    long z59 = 0;\n    long z60 = 0;\n    long z61 =\
    \ 0;\n    long z62 = 0;\n    long z63 = 0;\n    long z64 = 0;\n    long z65 =\
    \ 0;\n    long z66 = 0;\n    long z67 = 0;\n    long z68 = 0;\n    long z69 =\
    \ 0;\n    long z70 = 0;\n    long z71 = 0;\n    long z72 = 0;\n    long z73 =\
    \ 0;\n    long z74 = 0;\n    long \nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp49qvwai9.d(107): Error: no identifier for declarator `long`

    /tmp/tmp49qvwai9.d(107): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp49qvwai9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] ans;\n    \n    foreach(i : 0..lst.len())\n    {\n \
    \       foreach(j : 0..lst[i].len())\n        {\n            if(lst[i][j] == x)\n\
    \            {\n                ans = Tuple!(long, long)[](Tuple!(i + 1, j + 1),\
    \ Tuple!(i + 1, j));\n            }\n        }\n    }\n    \n    foreach(i : 0..lst.len())\n\
    \    {\n        foreach(j : 0..lst[i].len())\n        {\n            if(lst[i][j]\
    \ > x)\n            {\n                ans = Tuple!(long, long)[](Tuple!(i + 1,\
    \ j + 1), Tuple!(i + 1, j));\n            }\n        }\n    }\n    \n    return\
    \ ans;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] ret = new Tuple!(long, long)[0];\n    foreach(row,lst)\n\
    \    {\n        foreach(col,row)\n        {\n            if(col == x)\n      \
    \      {\n                ret = new Tuple!(long, long)[ret.length + 1];\n    \
    \            ret[ret.length] = Tuple!(row, col);\n            }\n        }\n \
    \   }\n    \n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprdv2dusx.d(20): Error: no identifier for declarator `lst`

    /tmp/tmprdv2dusx.d(20): Error: found `)` when expecting `;`

    /tmp/tmprdv2dusx.d(22): Error: no identifier for declarator `row`

    /tmp/tmprdv2dusx.d(22): Error: found `)` when expecting `;`

    /tmp/tmprdv2dusx.d(30): Error: found `}` when expecting `)`

    /tmp/tmprdv2dusx.d(34): Error: found `unittest` when expecting `)`

    /tmp/tmprdv2dusx.d(45): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprdv2dusx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n\
    \    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0;\
    \ j < lst[i].length; j++)\n        {\n            if(lst[i][j] > x)\n        \
    \    {\n                for(int k = j; k < lst[i].length; k++)\n             \
    \   {\n                    lst[i][k] = lst[i][k - 1];\n                }\n   \
    \             lst[i][0] = x;\n                break;\n            }\n        }\n\
    \    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int\
    \ j = 0; j < lst[i].length; j++)\n        {\n            if(lst[i][j] < x)\n \
    \           {\n                for(int k = j; k < lst[i].length; k++)\n      \
    \          {\n                    lst[i][k] = lst[i][k + 1];\n               \
    \ }\n                lst[i][1] = x;\n                break;\n            }\n \
    \       }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n     \
    \   for(int j = 0; j < lst[i].length; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n\
    \            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n\
    \    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n          \
    \  if(lst[i][j] > x)\n            {\n                for(int k = j; k < lst[i].length;\
    \ k++)\n                {\n                    lst[i][k] = lst[i][k - 1];\n  \
    \              }\n                lst[i][0] = x;\n                break;\n   \
    \         }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n\
    \    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n          \
    \  if(lst[i][j] < x)\n            {\n                for(int k = j; k < lst[i].length;\
    \ k++)\n                {\n                    lst[i][k] = lst[i][k + 1];\n  \
    \              }\n                lst[i][1] = x;\n                break;\n   \
    \         }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n\
    \    {\n        for(int j = 0; j < lst[i].length; j++)\n        {\n          \
    \  if(lst[i][j] == x)\n            {\n                result[i] = new Tuple!(lst[i][0],\
    \ lst[i][1]);\n            }\n        }\n    }\n    \n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxqpg1lto.d(24): Error: variable `lst` cannot be read at compile
    time

    /tmp/tmpxqpg1lto.d(24): Error: variable `lst` cannot be read at compile time

    /tmp/tmpxqpg1lto.d(66): Error: variable `lst` cannot be read at compile time

    /tmp/tmpxqpg1lto.d(66): Error: variable `lst` cannot be read at compile time

    /tmp/tmpxqpg1lto.d(109): Error: variable `lst` cannot be read at compile time

    /tmp/tmpxqpg1lto.d(109): Error: variable `lst` cannot be read at compile time

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxqpg1lto.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.length; ++i)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            rows = i;\n       \
    \     break;\n        }\n    }\n    for(long i = 0; i < lst.length; ++i)\n   \
    \ {\n        if(lst[i][1] == x)\n        {\n            cols = i;\n          \
    \  break;\n        }\n    }\n    Tuple!(long, long)[] res = new Tuple!(long, long)[rows];\n\
    \    for(long i = 0; i < rows; ++i)\n    {\n        res[i] = new Tuple!(long,\
    \ long)[cols];\n        for(long j = 0; j < cols; ++j)\n        {\n          \
    \  res[i][j] = new Tuple!(long, long)();\n        }\n    }\n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9sdgp209.d(40): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign`
    cannot deduce function from argument types `!()(Tuple!(long, long)[])`, candidates
    are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(long,
    long).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this),
    R, "="))`

    /tmp/tmp9sdgp209.d(43): Error: variable `j` cannot be read at compile time

    /tmp/tmp9sdgp209.d(43): Error: cannot implicitly convert expression `new Tuple!(long,
    long)(0L, 0L)` of type `Tuple!(long, long)*` to `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9sdgp209.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            result[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n   \
    \ Arrays.sort(result, (x, y) => y._1 - x._1);\n    Arrays.sort(result, (x, y)\
    \ => y._2 - x._2);\n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1zsoesss.d(24): Error: variable `lst` cannot be read at compile
    time

    /tmp/tmp1zsoesss.d(24): Error: variable `lst` cannot be read at compile time

    /tmp/tmp1zsoesss.d(27): Error: undefined identifier `Arrays`

    /tmp/tmp1zsoesss.d(28): Error: undefined identifier `Arrays`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1zsoesss.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] ret = new Tuple!(long, long)[0];\n    foreach(row: lst,\
    \ i: 0) {\n        foreach(col: row, j: 0) {\n            if(col == x) {\n   \
    \             ret.add((i, j));\n            }\n        }\n    }\n    sort(ret);\n\
    \    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgf3e9_fm.d(20): Error: no identifier for declarator `row`

    /tmp/tmpgf3e9_fm.d(20): Error: found `:` when expecting `;`

    /tmp/tmpgf3e9_fm.d(20): Error: found `:` when expecting `)`

    /tmp/tmpgf3e9_fm.d(20): Error: found `)` when expecting `;` following statement

    /tmp/tmpgf3e9_fm.d(21): Error: no identifier for declarator `col`

    /tmp/tmpgf3e9_fm.d(21): Error: found `:` when expecting `;`

    /tmp/tmpgf3e9_fm.d(21): Error: found `:` when expecting `)`

    /tmp/tmpgf3e9_fm.d(21): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgf3e9_fm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.len();\n    long m = lst[0].len();\n    long result[][] = new\
    \ long[n][m];\n    long i, j, k;\n    for(i = 0; i < n; i++)\n    {\n        for(j\
    \ = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n\
    \                for(k = 0; k < m; k++)\n                {\n                 \
    \   result[i][k] = j;\n                }\n            }\n        }\n    }\n  \
    \  \n    Arrays.sort(result, (a, b) => (a[0] > b[0]) ? 1 : ((b[0] > a[0]) ? -1\
    \ : 0));\n    Arrays.sort(result, (a, b) => (a[1] > b[1]) ? 1 : ((b[1] > a[1])\
    \ ? -1 : 0));\n    \n    return result;\n}\nunittest\n{\n    alias candidate =\
    \ get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf4lku6fq.d(21): Deprecation: instead of C-style syntax, use D-style
    syntax `long[][] result`

    /tmp/tmpf4lku6fq.d(19): Error: no property `len` for type `long[][]`

    /tmp/tmpf4lku6fq.d(20): Error: no property `len` for type `long[]`

    /tmp/tmpf4lku6fq.d(21): Error: variable `n` cannot be read at compile time

    /tmp/tmpf4lku6fq.d(37): Error: undefined identifier `Arrays`

    /tmp/tmpf4lku6fq.d(38): Error: undefined identifier `Arrays`

    /tmp/tmpf4lku6fq.d(40): Error: cannot implicitly convert expression `result` of
    type `long[][]` to `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf4lku6fq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[] res = new long[lst[0].Length];\n    for(int i = 0; i < lst[0].Length;\
    \ i++)\n    {\n        res[i] = lst[0][i];\n    }\n    for(int i = 1; i < lst.Length;\
    \ i++)\n    {\n        for(int j = 0; j < lst[i].Length; j++)\n        {\n   \
    \         if(res[j] == x)\n            {\n                Tuple!(long, long)[]\
    \ ret = new Tuple!(long, long)[lst[i].Length];\n                for(int k = 0;\
    \ k < lst[i].Length; k++)\n                {\n                    ret[k] = Tuple!(long,\
    \ long)[i, k];\n                }\n                return ret;\n            }\n\
    \        }\n    }\n    return null;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpea99ak_n.d(19): Error: no property `Length` for type `long[]`

    /tmp/tmpea99ak_n.d(20): Error: no property `Length` for type `long[]`

    /tmp/tmpea99ak_n.d(24): Error: no property `Length` for type `long[][]`

    /tmp/tmpea99ak_n.d(26): Error: no property `Length` for type `long[]`

    /tmp/tmpea99ak_n.d(30): Error: no property `Length` for type `long[]`

    /tmp/tmpea99ak_n.d(31): Error: no property `Length` for type `long[]`

    /tmp/tmpea99ak_n.d(33): Error: no `[]` operator overload for type `Tuple!(long,
    long)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpea99ak_n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[][] res = new\
    \ long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j\
    \ < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n      \
    \          res[i][j] = 1;\n                break;\n            }\n        }\n\
    \    }\n    Arrays.sort(res);\n    Arrays.sort(res, (a, b) -> {\n        if(a[0]\
    \ == b[0])\n            return a[1] - b[1];\n        return a[0] - b[0];\n   \
    \ });\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp20x2pk8h.d(34): Error: expression expected, not `>`

    /tmp/tmp20x2pk8h.d(34): Error: found `{` when expecting `,`

    /tmp/tmp20x2pk8h.d(35): Error: expression expected, not `if`

    /tmp/tmp20x2pk8h.d(36): Error: found `return` when expecting `,`

    /tmp/tmp20x2pk8h.d(36): Error: found `;` when expecting `,`

    /tmp/tmp20x2pk8h.d(37): Error: expression expected, not `return`

    /tmp/tmp20x2pk8h.d(37): Error: found `a` when expecting `,`

    /tmp/tmp20x2pk8h.d(37): Error: found `;` when expecting `,`

    /tmp/tmp20x2pk8h.d(38): Error: expression expected, not `}`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp20x2pk8h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i = 0;\n    long\
    \ j = 0;\n    long k = 0;\n    long l = 0;\n    long m1 = m;\n    long n1 = n;\n\
    \    long m2 = m;\n    long n2 = n;\n    long m3 = m;\n    long n3 = n;\n    long\
    \ m4 = m;\n    long n4 = n;\n    long m5 = m;\n    long n5 = n;\n    long m6 =\
    \ m;\n    long n6 = n;\n    long m7 = m;\n    long n7 = n;\n    long m8 = m;\n\
    \    long n8 = n;\n    long m9 = m;\n    long n9 = n;\n    long m10 = m;\n   \
    \ long n10 = n;\n    long m11 = m;\n    long n11 = n;\n    long m12 = m;\n   \
    \ long n12 = n;\n    long m13 = m;\n    long n13 = n;\n    long m14 = m;\n   \
    \ long n14 = n;\n    long m15 = m;\n    long n15 = n;\n    long m16 = m;\n   \
    \ long n16 = n;\n    long m17 = m;\n    long n17 = n;\n    long m18 = m;\n   \
    \ long n18 = n;\n    long m19 = m;\n    long n19 = n;\n    long m20 = m;\n   \
    \ long n20 = n;\n    long m21 = m;\n    long n21 = n;\n    long m22 = m;\n   \
    \ long n22 = n;\n    long m23 = m;\n    long n23 = n;\n    long m24 = m;\n   \
    \ long n24 = n;\n    long m25 = m;\n    long n25 = n;\n    long m26 = m;\n   \
    \ long n26 = n;\n    long m27 = m;\n    long n27 = n;\n    long m28 = m;\n   \
    \ long n28 = n;\n    long m29 = m;\n    long n29 = n;\n    long m30 = m;\n   \
    \ long n30 = n;\n    long m31 = m;\n    long n31 = n;\n    long m32 = m;\n   \
    \ long n32 = n;\n    long m33 = m;\n    long n33 = n;\n    long m34 = m;\n   \
    \ long n34 = n;\n    long m35 = m;\n    long n35 = n;\n    long m36 = m;\n   \
    \ long n36 = n;\n    \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpknmqfrj2.d(98): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpknmqfrj2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    foreach(row: lst,\
    \ i: 0) \n    {\n        foreach(col: row, j: 0) \n        {\n            if(col\
    \ == x) \n            {\n                res[res.length] = Tuple!(i, j);\n   \
    \         }\n        }\n    }\n    sort(res);\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpxcnij5ig.d(20): Error: no identifier for declarator `row`

    /tmp/tmpxcnij5ig.d(20): Error: found `:` when expecting `;`

    /tmp/tmpxcnij5ig.d(20): Error: found `:` when expecting `)`

    /tmp/tmpxcnij5ig.d(20): Error: found `)` when expecting `;` following statement

    /tmp/tmpxcnij5ig.d(22): Error: no identifier for declarator `col`

    /tmp/tmpxcnij5ig.d(22): Error: found `:` when expecting `;`

    /tmp/tmpxcnij5ig.d(22): Error: found `:` when expecting `)`

    /tmp/tmpxcnij5ig.d(22): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxcnij5ig.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row,lst)\n    {\n        foreach(col,row)\n\
    \        {\n            if(col == x)\n            {\n                res = Tuple!(long,\
    \ long)[](row,col);\n                break;\n            }\n        }\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_88sn8_3.d(20): Error: no identifier for declarator `lst`

    /tmp/tmp_88sn8_3.d(20): Error: found `)` when expecting `;`

    /tmp/tmp_88sn8_3.d(22): Error: no identifier for declarator `row`

    /tmp/tmp_88sn8_3.d(22): Error: found `)` when expecting `;`

    /tmp/tmp_88sn8_3.d(30): Error: found `}` when expecting `)`

    /tmp/tmp_88sn8_3.d(33): Error: found `unittest` when expecting `)`

    /tmp/tmp_88sn8_3.d(44): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_88sn8_3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    \n\
    \    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n\
    \        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n      \
    \  }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        if(lst[i][1]\
    \ > x)\n        {\n            result[i] = new Tuple!(lst[i][0], lst[i][1] - 1);\n\
    \        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n    \
    \    if(lst[i][1] < x)\n        {\n            result[i] = new Tuple!(lst[i][0],\
    \ lst[i][1] + 1);\n        }\n    }\n    \n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpgt98d77h.d(25): Error: variable `lst` cannot be read at compile
    time

    /tmp/tmpgt98d77h.d(25): Error: variable `lst` cannot be read at compile time

    /tmp/tmpgt98d77h.d(33): Error: variable `lst` cannot be read at compile time

    /tmp/tmpgt98d77h.d(33): Error: variable `lst` cannot be read at compile time

    /tmp/tmpgt98d77h.d(41): Error: variable `lst` cannot be read at compile time

    /tmp/tmpgt98d77h.d(41): Error: variable `lst` cannot be read at compile time

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgt98d77h.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    \n    foreach(row:\
    \ lst, row_index: 0) \n    {\n        foreach(column: row, column_index: 0) \n\
    \        {\n            if(column_index == x) \n            {\n              \
    \  foreach(coor: row, coor_index: 0) \n                {\n                   \
    \ if(coor_index == row_index) \n                    {\n                      \
    \  result.push(Tuple!(long, long)((row_index, column_index)));\n             \
    \       }\n                }\n            }\n        }\n    }\n    \n    sort(result,\
    \ (a, b) => a.1 < b.1);\n    sort(result, (a, b) => a.2 < b.2);\n    \n    return\
    \ result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwgjce671.d(21): Error: no identifier for declarator `row`

    /tmp/tmpwgjce671.d(21): Error: found `:` when expecting `;`

    /tmp/tmpwgjce671.d(21): Error: found `:` when expecting `)`

    /tmp/tmpwgjce671.d(21): Error: found `)` when expecting `;` following statement

    /tmp/tmpwgjce671.d(23): Error: no identifier for declarator `column`

    /tmp/tmpwgjce671.d(23): Error: found `:` when expecting `;`

    /tmp/tmpwgjce671.d(23): Error: found `:` when expecting `)`

    /tmp/tmpwgjce671.d(23): Error: found `)` when expecting `;` following statement

    /tmp/tmpwgjce671.d(27): Error: no identifier for declarator `coor`

    /tmp/tmpwgjce671.d(27): Error: found `:` when expecting `;`

    /tmp/tmpwgjce671.d(27): Error: found `:` when expecting `)`

    /tmp/tmpwgjce671.d(27): Error: found `)` when expecting `;` following statement

    /tmp/tmpwgjce671.d(38): Error: found `0.1` when expecting `,`

    /tmp/tmpwgjce671.d(38): Error: expression expected, not `<`

    /tmp/tmpwgjce671.d(38): Error: found `b` when expecting `,`

    /tmp/tmpwgjce671.d(39): Error: found `0.'
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.len();\n    long m = lst[0].len();\n    long[][] res = new long[n][m];\n\
    \    for(int i = 0; i < n; ++i)\n    {\n        for(int j = 0; j < m; ++j)\n \
    \       {\n            if(lst[i][j] == x)\n            {\n                res[i][j]\
    \ = 1;\n            }\n        }\n    }\n    Arrays.sort(res, (a, b) -> {\n  \
    \      if(a[0] == b[0])\n        {\n            return a[1] - b[1];\n        }\n\
    \        return a[0] - b[0];\n    });\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa88hs_5m.d(32): Error: expression expected, not `>`

    /tmp/tmpa88hs_5m.d(32): Error: found `{` when expecting `,`

    /tmp/tmpa88hs_5m.d(33): Error: expression expected, not `if`

    /tmp/tmpa88hs_5m.d(34): Error: found `{` when expecting `,`

    /tmp/tmpa88hs_5m.d(35): Error: expression expected, not `return`

    /tmp/tmpa88hs_5m.d(35): Error: found `a` when expecting `,`

    /tmp/tmpa88hs_5m.d(35): Error: found `;` when expecting `,`

    /tmp/tmpa88hs_5m.d(36): Error: expression expected, not `}`

    /tmp/tmpa88hs_5m.d(37): Error: found `return` when expecting `,`

    /tmp/tmpa88hs_5m.d(37): Error: found `;` when expecting `,`

    /tmp/tmpa88hs_5m.d(38): Error: expression expected, not `}`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa88hs_5m.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.length; ++i)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            rows = i;\n       \
    \     break;\n        }\n    }\n    for(long i = 0; i < lst.length; ++i)\n   \
    \ {\n        if(lst[i][1] == x)\n        {\n            cols = i;\n          \
    \  break;\n        }\n    }\n    Tuple!(long, long)[] ret = new Tuple!(long, long)[rows];\n\
    \    for(long i = 0; i < rows; ++i)\n    {\n        ret[i] = new Tuple!(long,\
    \ long)[cols];\n    }\n    for(long i = 0; i < rows; ++i)\n    {\n        for(long\
    \ j = 0; j < cols; ++j)\n        {\n            ret[i][j] = new Tuple!(long, long)();\n\
    \        }\n    }\n    for(long i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0]\
    \ == x)\n        {\n            for(long j = 0; j < cols; ++j)\n            {\n\
    \                ret[i][j] = new Tuple!(long, long)();\n            }\n      \
    \  }\n    }\n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3iny8diq.d(40): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign`
    cannot deduce function from argument types `!()(Tuple!(long, long)[])`, candidates
    are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(long,
    long).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this),
    R, "="))`

    /tmp/tmp3iny8diq.d(46): Error: variable `j` cannot be read at compile time

    /tmp/tmp3iny8diq.d(46): Error: cannot implicitly convert expression `new Tuple!(long,
    long)(0L, 0L)` of type `Tuple!(long, long)*` to `long`

    /tmp/tmp3iny8diq.d(55): Error: variable `j` cannot be read at compile time

    /tmp/tmp3iny8diq.d(55): Error: cannot implicitly convert expression `new Tuple!(long,
    long)(0L, 0L)` of type `Tuple!(long, long)*` to `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3iny8diq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] =\
    \ new long[n][m];\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int\
    \ j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n\
    \                result[i][j] = 1;\n                break;\n            }\n  \
    \      }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int\
    \ j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n         \
    \   {\n                for(int k = j + 1; k < m; k++)\n                {\n   \
    \                 if(lst[i][k] > lst[i][j])\n                    {\n         \
    \               result[i][j] = lst[i][k];\n                        break;\n  \
    \                  }\n                }\n                break;\n            }\n\
    \        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int\
    \ j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n         \
    \   {\n                for(int k = j + 1; k < m; k++)\n                {\n   \
    \                 if(lst[i][k] > lst[i][j])\n                    {\n         \
    \               result[i][j] = lst[i][k];\n                        break;\n  \
    \                  }\n                }\n                break;\n            }\n\
    \        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int\
    \ j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n         \
    \   {\n                for(int k = j + 1; k < m; k++)\n                {\n   \
    \                 if(lst[i][k] > lst[i][j])\n                    {\n         \
    \               result[i][j] = lst[i][k];\n                        break;\n  \
    \                  }\n                }\n                break;\n            }\n\
    \        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int\
    \ j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n         \
    \   {\n                for(int k = j + 1; k < m; k++)\n                {\n   \
    \                 if(lst[i][k] > lst[i][j])\n                    {\n         \
    \               result[i][j] = lst[i][k];\n                        break;\n  \
    \                  }\n                }\n                break;\n            }\n\
    \        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int\
    \ j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n         \
    \   {\n                for(int k = j + 1; k < m; k++)\n                {\n   \
    \                 if(lst[i][k] > lst[i][j])\n                    {\n         \
    \               result[i][j] = lst[i][k];\n                        break;\n  \
    \                  }\n                }\n                break;\n            }\n\
    \        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int\
    \ j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n         \
    \   {\n                for(int k = j + 1; k < m; k++)\n                {\n   \
    \                 if(lst[i][k] > lst[i][j])\n                    {\n         \
    \               result[i][j] = lst[i][k\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi8x4llsn.d(21): Deprecation: instead of C-style syntax, use D-style
    syntax `long[][] result`

    /tmp/tmpi8x4llsn.d(141): Error: found `unittest` when expecting `,`

    /tmp/tmpi8x4llsn.d(152): Error: found `void` when expecting `,`

    /tmp/tmpi8x4llsn.d(152): Error: found `{` when expecting `,`

    /tmp/tmpi8x4llsn.d(152): Error: expression expected, not `}`

    /tmp/tmpi8x4llsn.d(152): Error: found `End of File` when expecting `,`

    /tmp/tmpi8x4llsn.d(152): Error: found `End of File` when expecting `]`

    /tmp/tmpi8x4llsn.d(152): Error: found `End of File` when expecting `;` following
    statement

    /tmp/tmpi8x4llsn.d(152): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpi8x4llsn.d(152): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpi8x4llsn.d(152): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpi8x4llsn.d(152): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpi8x4llsn.d(152): Error: foun'
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[(m\
    \ * n) + 1];\n    long i = 0, j = 0;\n    for(i = 0; i < n; i++) {\n        for(j\
    \ = 0; j < m; j++) {\n            if(lst[i][j] == x) {\n                res[i\
    \ * m + j] = i;\n                res[i * m + j + 1] = j;\n            }\n    \
    \    }\n    }\n    sort(res, 0, res.length);\n    return res;\n}\nunittest\n{\n\
    \    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9liflart.d(31): Error: undefined identifier `sort`, did you mean
    function `sqrt`?

    /tmp/tmp9liflart.d(32): Error: cannot implicitly convert expression `res` of type
    `long[]` to `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9liflart.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n\
    \    Arrays.sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8qrabkf6.d(24): Error: variable `lst` cannot be read at compile
    time

    /tmp/tmp8qrabkf6.d(24): Error: variable `lst` cannot be read at compile time

    /tmp/tmp8qrabkf6.d(27): Error: undefined identifier `Arrays`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8qrabkf6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = null;\n    \n    foreach(row: lst, row_index:\
    \ 0) \n    {\n        foreach(column: row, column_index: 0) \n        {\n    \
    \        if(column_index == x) \n            {\n                result = Tuple!(long,\
    \ long)[Tuple!(row_index, column_index)];\n            }\n        }\n    }\n \
    \   \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n \
    \   assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmph7lij41n.d(21): Error: no identifier for declarator `row`

    /tmp/tmph7lij41n.d(21): Error: found `:` when expecting `;`

    /tmp/tmph7lij41n.d(21): Error: found `:` when expecting `)`

    /tmp/tmph7lij41n.d(21): Error: found `)` when expecting `;` following statement

    /tmp/tmph7lij41n.d(23): Error: no identifier for declarator `column`

    /tmp/tmph7lij41n.d(23): Error: found `:` when expecting `;`

    /tmp/tmph7lij41n.d(23): Error: found `:` when expecting `)`

    /tmp/tmph7lij41n.d(23): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph7lij41n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(i : 0..lst.len())\n    {\n\
    \        foreach(j : 0..lst[i].len())\n        {\n            if(lst[i][j] ==\
    \ x)\n            {\n                res = Tuple!(long, long)[](Tuple!(i + 1,\
    \ j), Tuple!(i + 1, j + 1));\n            }\n        }\n    }\n    \n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg43jno6d.d(20): Error: no identifier for declarator `i`

    /tmp/tmpg43jno6d.d(20): Error: found `:` when expecting `;`

    /tmp/tmpg43jno6d.d(22): Error: no identifier for declarator `j`

    /tmp/tmpg43jno6d.d(22): Error: found `:` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg43jno6d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    for(long i = 0;\
    \ i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n       \
    \     Tuple!(long, long)[] row = new Tuple!(long, long)[i];\n            for(long\
    \ j = 0; j < lst[i][1]; ++j)\n            {\n                row.push(new Tuple!(long,\
    \ long)[lst[i][j]]);\n            }\n            res.push(row);\n        }\n \
    \   }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpypd73_66.d(27): Error: no property `push` for type `Tuple!(long,
    long)[]`

    /tmp/tmpypd73_66.d(29): Error: no property `push` for type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpypd73_66.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row_index: 0) \n\
    \    {\n        foreach(col: row, col_index: 0) \n        {\n            if(col\
    \ == x) \n            {\n                res = Tuple!(long, long)[](row_index,\
    \ col_index);\n            }\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1tj2t4h0.d(20): Error: no identifier for declarator `row`

    /tmp/tmp1tj2t4h0.d(20): Error: found `:` when expecting `;`

    /tmp/tmp1tj2t4h0.d(20): Error: found `:` when expecting `)`

    /tmp/tmp1tj2t4h0.d(20): Error: found `)` when expecting `;` following statement

    /tmp/tmp1tj2t4h0.d(22): Error: no identifier for declarator `col`

    /tmp/tmp1tj2t4h0.d(22): Error: found `:` when expecting `;`

    /tmp/tmp1tj2t4h0.d(22): Error: found `:` when expecting `)`

    /tmp/tmp1tj2t4h0.d(22): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1tj2t4h0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            result[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n   \
    \ Arrays.sort(result);\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp24aowfi4.d(24): Error: variable `lst` cannot be read at compile
    time

    /tmp/tmp24aowfi4.d(24): Error: variable `lst` cannot be read at compile time

    /tmp/tmp24aowfi4.d(27): Error: undefined identifier `Arrays`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp24aowfi4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    \n    for(int\
    \ i = 0; i < lst.length; i++) \n    {\n        if(lst[i][0] == x) \n        {\n\
    \            Tuple!(long, long)[] row = new Tuple!(long, long)[lst[i].length];\n\
    \            for(int j = 0; j < lst[i].length; j++) \n            {\n        \
    \        row[j] = (lst[i][j], j);\n            }\n            \n            Arrays.sort(row);\n\
    \            \n            for(int j = 0; j < row.length; j++) \n            {\n\
    \                res[res.length] = row[j];\n            }\n        }\n    }\n\
    \    \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n   \
    \ assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L,\
    \ 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp60sak343.d(28): Error: Using the result of a comma expression is
    not allowed

    /tmp/tmp60sak343.d(28): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign`
    cannot deduce function from argument types `!()(int)`, candidates are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(long,
    long).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this),
    R, "="))`

    /tmp/tmp60sak343.d(31): Error: undefined identifier `Arrays`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp60sak343.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[] result = new long[lst.Length];\n    for(int i = 0; i < lst.Length;\
    \ i++)\n    {\n        result[i] = lst[i][0];\n    }\n    Array.Sort(result);\n\
    \    Array.Sort(result, (x, y) => { return y - x; });\n    Array.Sort(result,\
    \ (x, y) => { return x - y; });\n    for(int i = 0; i < lst.Length; i++)\n   \
    \ {\n        if(result[i] == x)\n        {\n            return Tuple!(long[],\
    \ long[])[](Tuple!(long[], long[])[](Tuple!(0, i), Tuple!(0, i + 1)), Tuple!(0,\
    \ i + 1));\n        }\n    }\n    return Tuple!(long[], long[])[](Tuple!(0, 0),\
    \ Tuple!(0, 0));\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz6_p_xhp.d(19): Error: no property `Length` for type `long[][]`

    /tmp/tmpz6_p_xhp.d(20): Error: no property `Length` for type `long[][]`

    /tmp/tmpz6_p_xhp.d(24): Error: undefined identifier `Array`

    /tmp/tmpz6_p_xhp.d(25): Error: undefined identifier `Array`

    /tmp/tmpz6_p_xhp.d(26): Error: undefined identifier `Array`

    /tmp/tmpz6_p_xhp.d(27): Error: no property `Length` for type `long[][]`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(501):
    Error: template instance `parseSpecs!(0, i)` cannot use local `i` as parameter
    to non-global template `parseSpecs(Specs...)`

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(614):
    Error: CTFE failed because of previous errors in `injectNamedFields`

    /tmp/tmpz6_p_xhp.d(31): Error: template instance `tmpz6_p_xhp.get_row.Tuple!(0,
    i)` error instantiating

    /tmp/t'
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n\
    \    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][1] >\
    \ x)\n        {\n            for(int j = i; j < lst.length; ++j)\n           \
    \ {\n                if(lst[j][1] > x)\n                {\n                  \
    \  result[i] = new Tuple!(lst[i][0], lst[j][1]);\n                    break;\n\
    \                }\n            }\n        }\n    }\n    \n    for(int i = 0;\
    \ i < lst.length; ++i)\n    {\n        if(lst[i][1] < x)\n        {\n        \
    \    for(int j = i; j < lst.length; ++j)\n            {\n                if(lst[j][1]\
    \ < x)\n                {\n                    result[i] = new Tuple!(lst[i][0],\
    \ lst[j][1]);\n                    break;\n                }\n            }\n\
    \        }\n    }\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n    \
    \    if(lst[i][1] > x)\n        {\n            for(int j = i; j < lst.length;\
    \ ++j)\n            {\n                if(lst[j][1] > x)\n                {\n\
    \                    result[i] = new Tuple!(lst[i][0], lst[j][1]);\n         \
    \           break;\n                }\n            }\n        }\n    }\n    \n\
    \    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][1] < x)\n \
    \       {\n            for(int j = i; j < lst.length; ++j)\n            {\n  \
    \              if(lst[j][1] < x)\n                {\n                    result[i]\
    \ = new Tuple!(lst[i][0], lst[j][1]);\n                    break;\n          \
    \      }\n            }\n        }\n    }\n    \n    for(int i = 0; i < lst.length;\
    \ ++i)\n    {\n        if(lst[i][1] > x)\n        {\n            for(int j = i;\
    \ j < lst.length; ++j)\n            {\n                if(lst[j][1] > x)\n   \
    \             {\n                    result[i] = new Tuple!(lst[i][0], lst[j][1]);\n\
    \                    break;\n                }\n            }\n        }\n   \
    \ }\n    \n    for(int i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][1]\
    \ < x)\n        {\n            for(int j = i; j < lst.length; ++j)\n         \
    \   {\n                if(lst[j][1] < x)\n                {\n                \
    \    result[i] = new Tuple!(lst[i][0], lst[j][1]);\n                    break;\n\
    \                }\n            }\n        }\n    }\n    \n    for(int i = 0;\
    \ i < lst.length; ++i)\n    {\n        if(lst[i][1] > x)\n        {\n        \
    \    for(int j = i; j < lst.length; ++j)\n            {\n                if(lst[j][1]\
    \ > x)\n                {\n                    result[i] = new Tuple!(lst[i][0],\
    \ lst[j][1]);\n                    break;\n                }\n            }\n\
    \        }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3fi5tcli.d(131): Error: found `unittest` instead of statement

    /tmp/tmp3fi5tcli.d(142): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3fi5tcli.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] =\
    \ new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j =\
    \ 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n \
    \               result[i][j] = 1;\n            }\n        }\n    }\n    \n   \
    \ for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n    \
    \    {\n            if(result[i][j] == 1)\n            {\n                long\
    \ temp[][] = new long[m][2];\n                for(int k = 0; k < m; k++)\n   \
    \             {\n                    temp[k][0] = (long)i;\n                 \
    \   temp[k][1] = (long)j;\n                }\n                sort(temp, false);\n\
    \                for(int k = 0; k < m; k++)\n                {\n             \
    \       result[i][k] = temp[k][0] * m + temp[k][1];\n                }\n     \
    \       }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n   \
    \     for(int j = 0; j < m; j++)\n        {\n            if(result[i][j] == 1)\n\
    \            {\n                long temp[][] = new long[m][2];\n            \
    \    for(int k = 0; k < m; k++)\n                {\n                    temp[k][0]\
    \ = (long)i;\n                    temp[k][1] = (long)j;\n                }\n \
    \               sort(temp, true);\n                for(int k = 0; k < m; k++)\n\
    \                {\n                    result[i][j] = temp[k][0] * m + temp[k][1];\n\
    \                }\n            }\n        }\n    }\n    \n    for(int i = 0;\
    \ i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n        {\n        \
    \    if(result[i][j] == 1)\n            {\n                long temp[][] = new\
    \ long[m][2];\n                for(int k = 0; k < m; k++)\n                {\n\
    \                    temp[k][0] = (long)i;\n                    temp[k][1] = (long)j;\n\
    \                }\n                sort(temp, true);\n                for(int\
    \ k = 0; k < m; k++)\n                {\n                    result[i][j] = temp[k][0]\
    \ * m + temp[k][1];\n                }\n            }\n        }\n    }\n    \n\
    \    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < m; j++)\n \
    \       {\n            if(result[i][j] == 1)\n            {\n                long\
    \ temp[][] = new long[m][2];\n                for(int k = 0; k < m; k++)\n   \
    \             {\n                    temp[k][0] = (long)i;\n                 \
    \   temp[k][1] = (long)j;\n                }\n                sort(temp, true);\n\
    \                for(int k = 0; k < m; k++)\n                {\n             \
    \       result[i][j] = temp[k][0] * m + temp[k][1];\n                }\n     \
    \       }\n        }\n    }\n    \n    for(int i = 0; i < n; i++)\n    {\n   \
    \     for(int j = 0; j < m; j++)\n        {\n\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdhq0kxwb.d(21): Deprecation: instead of C-style syntax, use D-style
    syntax `long[][] result`

    /tmp/tmpdhq0kxwb.d(39): Deprecation: instead of C-style syntax, use D-style syntax
    `long[][] temp`

    /tmp/tmpdhq0kxwb.d(42): Error: C style cast illegal, use `cast(long)i`

    /tmp/tmpdhq0kxwb.d(43): Error: C style cast illegal, use `cast(long)j`

    /tmp/tmpdhq0kxwb.d(60): Deprecation: instead of C-style syntax, use D-style syntax
    `long[][] temp`

    /tmp/tmpdhq0kxwb.d(63): Error: C style cast illegal, use `cast(long)i`

    /tmp/tmpdhq0kxwb.d(64): Error: C style cast illegal, use `cast(long)j`

    /tmp/tmpdhq0kxwb.d(81): Deprecation: instead of C-style syntax, use D-style syntax
    `long[][] temp`

    /tmp/tmpdhq0kxwb.d(84): Error: C style cast illegal, use `cast(long)i`

    /tmp/tmpdhq0kxwb.d(85): Error: C style cast illegal, use `cast(long)j`

    /tmp/tmpdhq0kxwb.d(102): Deprecation: instead of C-style syntax, use D-style syntax
    `long[][] temp`

    /tmp/tmpdhq0kxwb.d(105): Error: C style cast illegal, use `cast(long)i`

    /tmp/tmpdhq0kxwb.d(106): Err'
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    \n    for(int\
    \ i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            for(int j = 0; j < lst[i].length; ++j)\n            {\n         \
    \       if(lst[i][j] == x)\n                {\n                    result.add(new\
    \ Tuple!(i, j));\n                }\n            }\n        }\n    }\n    \n \
    \   result.sort(function(a, b){return b._1 - a._1});\n    result.sort(function(a,\
    \ b){return a._2 - b._2});\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9de27ydd.d(35): Error: found `}` when expecting `;` following `return`
    statement

    /tmp/tmp9de27ydd.d(35): Error: found `)` instead of statement

    /tmp/tmp9de27ydd.d(36): Error: found `}` when expecting `;` following `return`
    statement

    /tmp/tmp9de27ydd.d(36): Error: found `)` instead of statement

    /tmp/tmp9de27ydd.d(40): Error: found `unittest` when expecting `,`

    /tmp/tmp9de27ydd.d(51): Error: found `void` when expecting `,`

    /tmp/tmp9de27ydd.d(51): Error: found `{` when expecting `,`

    /tmp/tmp9de27ydd.d(51): Error: expression expected, not `}`

    /tmp/tmp9de27ydd.d(51): Error: found `End of File` when expecting `,`

    /tmp/tmp9de27ydd.d(51): Error: found `End of File` when expecting `)`

    /tmp/tmp9de27ydd.d(51): Error: found `End of File` when expecting `;` following
    statement

    /tmp/tmp9de27ydd.d(51): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp9de27ydd.d(51): Error: found `End of File` when expecting `,`

    /tmp/tmp9de27ydd.d(51): Error: found `End of File` when expecting `)`

    /tm'
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[][] res = new\
    \ long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j\
    \ < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n      \
    \          res[i][j] = 1;\n            }\n        }\n    }\n    return Tuple!(long,\
    \ long)[](res, m);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjxw1jtjj.d(21): Error: variable `n` cannot be read at compile time

    /tmp/tmpjxw1jtjj.d(32): Error: function expected before `()`, not `Tuple!(long,
    long)[]` of type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjxw1jtjj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long[] res = new long[n];\n    for(int i = 0; i\
    \ < n; i++)\n    {\n        if(lst[i][0] == x)\n        {\n            res[i]\
    \ = i;\n            break;\n        }\n    }\n    return Tuple!(long, long)[res];\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpkiamusgm.d(29): Error: cannot implicitly convert expression `res`
    of type `long[]` to `ulong`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpkiamusgm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.lenght;\n    long m = lst[0].lenght;\n    long i, j, k;\n  \
    \  Tuple!(long, long)[] res = new Tuple!(long, long)[n];\n    for(i = 0; i < n;\
    \ i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                res[i] = Tuple!(long, long)[i, j];\n \
    \               break;\n            }\n        }\n    }\n    for(i = 0; i < n;\
    \ i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ > x)\n            {\n                res[i] = Tuple!(long, long)[i, j];\n  \
    \              break;\n            }\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpv2525zfy.d(19): Error: no property `lenght` for type `long[][]`

    /tmp/tmpv2525zfy.d(20): Error: no property `lenght` for type `long[]`

    /tmp/tmpv2525zfy.d(29): Error: no `[]` operator overload for type `Tuple!(long,
    long)`

    /tmp/tmpv2525zfy.d(40): Error: no `[]` operator overload for type `Tuple!(long,
    long)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpv2525zfy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] ans;\n    \n    foreach(i : 0..lst.len())\n    {\n \
    \       foreach(j : 0..lst[i].len())\n        {\n            if(lst[i][j] == x)\n\
    \            {\n                ans = Tuple!(long, long)[i, j];\n            \
    \    break;\n            }\n        }\n    }\n    \n    return ans;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp02v615r5.d(21): Error: no identifier for declarator `i`

    /tmp/tmp02v615r5.d(21): Error: found `:` when expecting `;`

    /tmp/tmp02v615r5.d(23): Error: no identifier for declarator `j`

    /tmp/tmp02v615r5.d(23): Error: found `:` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp02v615r5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.len();\n    long m = lst[0].len();\n    long result[][] = new\
    \ long[n][m];\n    long i, j;\n    \n    for (i = 0; i < n; i++)\n    {\n    \
    \    for (j = 0; j < m; j++)\n        {\n            if (lst[i][j] == x)\n   \
    \         {\n                result[i][j] = 1;\n                break;\n     \
    \       }\n        }\n    }\n    \n    Tuple!(long, long)[] res = new Tuple!(long,\
    \ long)[result.len()];\n    \n    for (i = 0; i < result.len(); i++)\n    {\n\
    \        res[i] = new Tuple!(long, long)[result[i].len()];\n        for (j = 0;\
    \ j < result[i].len(); j++)\n        {\n            res[i][j] = new Tuple!(long,\
    \ long)(0, 0);\n        }\n    }\n    \n    for (i = 0; i < n; i++)\n    {\n \
    \       for (j = 0; j < m; j++)\n        {\n            if (result[i][j] == 1)\n\
    \            {\n                res[i][j] = new Tuple!(long, long)(i, j);\n  \
    \          }\n        }\n    }\n    \n    sort!(res, (a, b) => (a.1, b.1), (a,\
    \ b) => (a.2, b.2), (a, b) => (a.3, b.3));\n    \n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpwxq10u4v.d(21): Deprecation: instead of C-style syntax, use D-style
    syntax `long[][] result`

    /tmp/tmpwxq10u4v.d(58): Error: found `0.1` when expecting `)`

    /tmp/tmpwxq10u4v.d(58): Error: found `0.1` when expecting `)` following template
    argument list

    /tmp/tmpwxq10u4v.d(58): Error: found `)` when expecting `;` following statement

    /tmp/tmpwxq10u4v.d(58): Error: found `,` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwxq10u4v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row_index: 0) \n\
    \    {\n        foreach(col: row, col_index: 0) \n        {\n            if(col\
    \ == x) \n            {\n                res = Tuple!(long, long)[](row_index,\
    \ col_index);\n                break;\n            }\n        }\n        if(res\
    \ != null) break;\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpap6ooctk.d(20): Error: no identifier for declarator `row`

    /tmp/tmpap6ooctk.d(20): Error: found `:` when expecting `;`

    /tmp/tmpap6ooctk.d(20): Error: found `:` when expecting `)`

    /tmp/tmpap6ooctk.d(20): Error: found `)` when expecting `;` following statement

    /tmp/tmpap6ooctk.d(22): Error: no identifier for declarator `col`

    /tmp/tmpap6ooctk.d(22): Error: found `:` when expecting `;`

    /tmp/tmpap6ooctk.d(22): Error: found `:` when expecting `)`

    /tmp/tmpap6ooctk.d(22): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpap6ooctk.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[] res = new long[lst[0].length];\n    for(int i = 0; i < lst.length;\
    \ i++) \n    {\n        for(int j = 0; j < lst[i].length; j++) \n        {\n \
    \           if(lst[i][j] == x) \n            {\n                res[i] = j;\n\
    \                break;\n            }\n        }\n    }\n    return Tuple!(long,\
    \ long)[](res, res);\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpz3qfg5o3.d(31): Error: function expected before `()`, not `Tuple!(long,
    long)[]` of type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz3qfg5o3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            result[i] = new Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n\
    \    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int j = 0;\
    \ j < lst[i][1]; j++)\n        {\n            if(lst[i][0] == j)\n           \
    \ {\n                result[i] = new Tuple!(lst[i][0], lst[i][1]);\n         \
    \   }\n        }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n\
    \        for(int j = 0; j < lst[i][1]; j++)\n        {\n            for(int k\
    \ = 0; k < lst[i][1]; k++)\n            {\n                if(lst[i][0] == k)\n\
    \                {\n                    result[i] = new Tuple!(lst[i][0], lst[i][1]);\n\
    \                }\n            }\n        }\n    }\n    \n    for(int i = 0;\
    \ i < lst.length; i++)\n    {\n        for(int j = 0; j < lst[i][1]; j++)\n  \
    \      {\n            for(int k = 0; k < lst[i][1]; k++)\n            {\n    \
    \            for(int l = 0; l < lst[i][1]; l++)\n                {\n         \
    \           if(lst[i][0] == l)\n                    {\n                      \
    \  result[i] = new Tuple!(lst[i][0], lst[i][1]);\n                    }\n    \
    \            }\n            }\n        }\n    }\n    \n    for(int i = 0; i <\
    \ lst.length; i++)\n    {\n        for(int j = 0; j < lst[i][1]; j++)\n      \
    \  {\n            for(int k = 0; k < lst[i][1]; k++)\n            {\n        \
    \        for(int l = 0; l < lst[i][1]; l++)\n                {\n             \
    \       for(int m = 0; m < lst[i][1]; m++)\n                    {\n          \
    \              if(lst[i][0] == m)\n                        {\n               \
    \             result[i] = new Tuple!(lst[i][0], lst[i][1]);\n                \
    \        }\n                    }\n                }\n            }\n        }\n\
    \    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int\
    \ j = 0; j < lst[i][1]; j++)\n        {\n            for(int k = 0; k < lst[i][1];\
    \ k++)\n            {\n                for(int l = 0; l < lst[i][1]; l++)\n  \
    \              {\n                    for(int m = 0; m < lst[i][1]; m++)\n   \
    \                 {\n                        for(int n = 0; n < lst[i][1]; n++)\n\
    \                        {\n                            if(lst[i][0] == n)\n \
    \                           {\n                                result[i] = new\
    \ Tuple!(lst[i][0], lst[i][1]);\n                            }\n             \
    \           }\n                    }\n                }\n            }\n     \
    \   }\n    }\n    \n    for(int i = 0; i < lst.length; i++)\n    {\n        for(int\
    \ j = 0; j < lst[i][1]; j++)\n        {\n            for(int k = 0; k < lst[i][1];\
    \ k++)\n            {\n                for(int l = 0; l < lst[i][1]; l\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg9uhwjm4.d(120): Error: found `unittest` when expecting `)`

    /tmp/tmpg9uhwjm4.d(131): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpg9uhwjm4.d(131): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpg9uhwjm4.d(131): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpg9uhwjm4.d(131): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg9uhwjm4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[] res = new long[(n\
    \ + 1) * (m + 1)];\n    \n    for(int i = 0; i < n; i++)\n    {\n        for(int\
    \ j = 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n\
    \                res[(i * m) + j] = i;\n                res[(i * m) + j + 1] =\
    \ j;\n            }\n        }\n    }\n    \n    Arrays.sort(res);\n    \n   \
    \ Tuple!(long, long)[] res = new Tuple!(long, long)[(res.length / 2) * (res.length\
    \ / 2)];\n    \n    for(int i = 0; i < res.length / 2; i++)\n    {\n        for(int\
    \ j = 0; j < res.length / 2; j++)\n        {\n            res[(i * res.length\
    \ / 2) + j] = new Tuple!(long, long)((res[i + j * res.length / 2]), res[i + j\
    \ * res.length / 2 + 1]);\n        }\n    }\n    \n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp5dpomze_.d(35): Error: undefined identifier `Arrays`

    /tmp/tmp5dpomze_.d(37): Error: declaration `tmp5dpomze_.get_row.res` is already
    defined

    /tmp/tmp5dpomze_.d(43): Error: cannot implicitly convert expression `new Tuple!(long,
    long)(res[cast(ulong)i + cast(ulong)j * res.length / 2LU], res[cast(ulong)i +
    cast(ulong)j * res.length / 2LU + 1LU])` of type `Tuple!(long, long)*` to `long`

    /tmp/tmp5dpomze_.d(47): Error: cannot implicitly convert expression `res` of type
    `long[]` to `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5dpomze_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = new Tuple!(long, long)[0];\n    foreach(row: lst,\
    \ i: 0) \n    {\n        foreach(col: row, j: 0) \n        {\n            if(col\
    \ == x) \n            {\n                Tuple!(long, long)[] rowRes = new Tuple!(long,\
    \ long)[row.Length];\n                foreach(colRes: row, k: 0) \n          \
    \      {\n                    rowRes[k] = Tuple!(long, long)[i, k];\n        \
    \        }\n                res = append(res, rowRes);\n            }\n      \
    \  }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpl_evnzr9.d(20): Error: no identifier for declarator `row`

    /tmp/tmpl_evnzr9.d(20): Error: found `:` when expecting `;`

    /tmp/tmpl_evnzr9.d(20): Error: found `:` when expecting `)`

    /tmp/tmpl_evnzr9.d(20): Error: found `)` when expecting `;` following statement

    /tmp/tmpl_evnzr9.d(22): Error: no identifier for declarator `col`

    /tmp/tmpl_evnzr9.d(22): Error: found `:` when expecting `;`

    /tmp/tmpl_evnzr9.d(22): Error: found `:` when expecting `)`

    /tmp/tmpl_evnzr9.d(22): Error: found `)` when expecting `;` following statement

    /tmp/tmpl_evnzr9.d(27): Error: no identifier for declarator `colRes`

    /tmp/tmpl_evnzr9.d(27): Error: found `:` when expecting `;`

    /tmp/tmpl_evnzr9.d(27): Error: found `:` when expecting `)`

    /tmp/tmpl_evnzr9.d(27): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpl_evnzr9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row_index: 0) \n\
    \    {\n        foreach(col: row, col_index: 0) \n        {\n            if(col\
    \ == x) \n            {\n                res = Tuple!(long, long)[](row_index,\
    \ col_index);\n            }\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1tj2t4h0.d(20): Error: no identifier for declarator `row`

    /tmp/tmp1tj2t4h0.d(20): Error: found `:` when expecting `;`

    /tmp/tmp1tj2t4h0.d(20): Error: found `:` when expecting `)`

    /tmp/tmp1tj2t4h0.d(20): Error: found `)` when expecting `;` following statement

    /tmp/tmp1tj2t4h0.d(22): Error: no identifier for declarator `col`

    /tmp/tmp1tj2t4h0.d(22): Error: found `:` when expecting `;`

    /tmp/tmp1tj2t4h0.d(22): Error: found `:` when expecting `)`

    /tmp/tmp1tj2t4h0.d(22): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1tj2t4h0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[][] res = new\
    \ long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j\
    \ < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n      \
    \          res[i][j] = 1;\n            }\n        }\n    }\n    Arrays.sort(res);\n\
    \    Arrays.sort(res, (a, b) -> b[0] - a[0]);\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprw5vp7ay.d(33): Error: expression expected, not `>`

    /tmp/tmprw5vp7ay.d(33): Error: found `b` when expecting `,`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprw5vp7ay.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n  \
    \  Tuple!(long, long)[] res = new Tuple!(long, long)[n];\n    \n    for(i = 0;\
    \ i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                res[i] = Tuple!(long, long)[i, j];\n \
    \               break;\n            }\n        }\n    }\n    \n    for(i = 0;\
    \ i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ > x)\n            {\n                res[i] = Tuple!(long, long)[i, j];\n  \
    \              break;\n            }\n        }\n    }\n    \n    for(i = 0; i\
    \ < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ < x)\n            {\n                res[i] = Tuple!(long, long)[i, j];\n  \
    \              break;\n            }\n        }\n    }\n    \n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpfbxiahxe.d(30): Error: no `[]` operator overload for type `Tuple!(long,
    long)`

    /tmp/tmpfbxiahxe.d(42): Error: no `[]` operator overload for type `Tuple!(long,
    long)`

    /tmp/tmpfbxiahxe.d(54): Error: no `[]` operator overload for type `Tuple!(long,
    long)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpfbxiahxe.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; i++){\n        if(lst[i][0] == x){\n            result[i]\
    \ = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    Arrays.sort(result);\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9hcd_co0.d(22): Error: variable `lst` cannot be read at compile
    time

    /tmp/tmp9hcd_co0.d(22): Error: variable `lst` cannot be read at compile time

    /tmp/tmp9hcd_co0.d(25): Error: undefined identifier `Arrays`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9hcd_co0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row,lst)\n    {\n        foreach(col,row)\n\
    \        {\n            if(col == x)\n            {\n                res = Tuple!(long,\
    \ long)[Tuple!(0, col), Tuple!(1, col)];\n                break;\n           \
    \ }\n        }\n        if(res != null)\n            break;\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2j6nu0_0.d(20): Error: no identifier for declarator `lst`

    /tmp/tmp2j6nu0_0.d(20): Error: found `)` when expecting `;`

    /tmp/tmp2j6nu0_0.d(22): Error: no identifier for declarator `row`

    /tmp/tmp2j6nu0_0.d(22): Error: found `)` when expecting `;`

    /tmp/tmp2j6nu0_0.d(30): Error: found `if` when expecting `)`

    /tmp/tmp2j6nu0_0.d(31): Error: found `break` when expecting `;` following statement

    /tmp/tmp2j6nu0_0.d(31): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmp2j6nu0_0.d(33): Error: found `return` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2j6nu0_0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            result[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n   \
    \ \n    Arrays.sort(result, (a, b) => a.first > b.first);\n    Arrays.sort(result,\
    \ (a, b) => a.second > b.second);\n    \n    return result;\n}\nunittest\n{\n\
    \    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpryfj50v9.d(24): Error: variable `lst` cannot be read at compile
    time

    /tmp/tmpryfj50v9.d(24): Error: variable `lst` cannot be read at compile time

    /tmp/tmpryfj50v9.d(28): Error: undefined identifier `Arrays`

    /tmp/tmpryfj50v9.d(29): Error: undefined identifier `Arrays`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpryfj50v9.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] ans;\n    \n    for(int i = 0; i < lst.length; ++i)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            ans = Tuple!(long,\
    \ long)[Tuple!(i + 1, lst[i][1])];\n            break;\n        }\n    }\n   \
    \ \n    return ans;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpysk3pm85.d(25): Error: variable `i` cannot be read at compile time

    /tmp/tmpysk3pm85.d(25): Error: variable `lst` cannot be read at compile time

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpysk3pm85.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long[][] res = new\
    \ long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j\
    \ < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n      \
    \          res[i][j] = 1;\n            }\n        }\n    }\n    \n    Arrays.sort(res);\n\
    \    Arrays.sort(res, (a, b) => b[0] - a[0]);\n    \n    for(int i = 0; i < n;\
    \ i++)\n    {\n        Arrays.sort(res[i], (a, b) => b[1] - a[1]);\n    }\n  \
    \  \n    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1oywx7d5.d(21): Error: variable `n` cannot be read at compile time

    /tmp/tmp1oywx7d5.d(33): Error: undefined identifier `Arrays`

    /tmp/tmp1oywx7d5.d(34): Error: undefined identifier `Arrays`

    /tmp/tmp1oywx7d5.d(38): Error: undefined identifier `Arrays`

    /tmp/tmp1oywx7d5.d(41): Error: cannot implicitly convert expression `res` of type
    `long[][]` to `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1oywx7d5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] ret = new Tuple!(long, long)[0];\n    \n    foreach(row:\
    \ lst, row_index: 0) \n    {\n        foreach(col: row, col_index: 0) \n     \
    \   {\n            if(col == x) \n            {\n                ret[ret.length]\
    \ = Tuple!(row_index, col_index);\n            }\n        }\n    }\n    \n   \
    \ sort(ret, (x, y) => Tuple!(x._1, y._1));\n    sort(ret, (x, y) => Tuple!(y._1,\
    \ x._1));\n    \n    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2_7k55md.d(21): Error: no identifier for declarator `row`

    /tmp/tmp2_7k55md.d(21): Error: found `:` when expecting `;`

    /tmp/tmp2_7k55md.d(21): Error: found `:` when expecting `)`

    /tmp/tmp2_7k55md.d(21): Error: found `)` when expecting `;` following statement

    /tmp/tmp2_7k55md.d(23): Error: no identifier for declarator `col`

    /tmp/tmp2_7k55md.d(23): Error: found `:` when expecting `;`

    /tmp/tmp2_7k55md.d(23): Error: found `:` when expecting `)`

    /tmp/tmp2_7k55md.d(23): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2_7k55md.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    for(int i =\
    \ 0; i < lst.Length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n    \
    \        Tuple!(long, long)[] row = new Tuple!(long, long)[i];\n            for(int\
    \ j = 0; j < lst[i].Length; j++)\n            {\n                if(lst[i][j]\
    \ > x)\n                {\n                    Tuple!(long, long)[] col = new\
    \ Tuple!(long, long)[j];\n                    row.Add(col);\n                }\n\
    \            }\n            result.Add(row);\n        }\n    }\n    result.Sort();\n\
    \    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi9_g5tux.d(20): Error: no property `Length` for type `long[][]`

    /tmp/tmpi9_g5tux.d(25): Error: no property `Length` for type `long[]`

    /tmp/tmpi9_g5tux.d(30): Error: no property `Add` for type `Tuple!(long, long)[]`

    /tmp/tmpi9_g5tux.d(33): Error: no property `Add` for type `Tuple!(long, long)[]`

    /tmp/tmpi9_g5tux.d(36): Error: no property `Sort` for type `Tuple!(long, long)[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi9_g5tux.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] ans;\n    \n    foreach(i : 0..lst.len())\n    {\n \
    \       if(lst[i][0] == x)\n        {\n            ans = Tuple!(long, long)[Tuple!(i\
    \ + 1, lst[i][1])];\n            break;\n        }\n    }\n    \n    return ans;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmperh48nu_.d(21): Error: no identifier for declarator `i`

    /tmp/tmperh48nu_.d(21): Error: found `:` when expecting `;`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmperh48nu_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[];\n    \n    for(int\
    \ i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            result.push((lst[i][1], lst[i][2]));\n        }\n    }\n    \n  \
    \  result.sort(function(a, b){return a[0] - b[0]});\n    result.sort(function(a,\
    \ b){return a[1] - b[1]});\n    \n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp95_fzljo.d(29): Error: found `}` when expecting `;` following `return`
    statement

    /tmp/tmp95_fzljo.d(29): Error: found `)` instead of statement

    /tmp/tmp95_fzljo.d(30): Error: found `}` when expecting `;` following `return`
    statement

    /tmp/tmp95_fzljo.d(30): Error: found `)` instead of statement

    /tmp/tmp95_fzljo.d(34): Error: found `unittest` when expecting `,`

    /tmp/tmp95_fzljo.d(45): Error: found `void` when expecting `,`

    /tmp/tmp95_fzljo.d(45): Error: found `{` when expecting `,`

    /tmp/tmp95_fzljo.d(45): Error: expression expected, not `}`

    /tmp/tmp95_fzljo.d(45): Error: found `End of File` when expecting `,`

    /tmp/tmp95_fzljo.d(45): Error: found `End of File` when expecting `)`

    /tmp/tmp95_fzljo.d(45): Error: found `End of File` when expecting `;` following
    statement

    /tmp/tmp95_fzljo.d(45): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmp95_fzljo.d(45): Error: found `End of File` when expecting `,`

    /tmp/tmp95_fzljo.d(45): Error: found `End of File` when expecting `)`

    /tm'
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n  \
    \  \n    for(i = 0; i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n     \
    \   {\n            if(lst[i][j] == x)\n            {\n                Tuple!(long,\
    \ long)[] res = new Tuple!(long, long)[(n*m)];\n                for(k = 0; k <\
    \ n*m; k++)\n                {\n                    res[k] = new Tuple!(long,\
    \ long)(i, j);\n                }\n                return res;\n            }\n\
    \        }\n    }\n    return null;\n}\nunittest\n{\n    alias candidate = get_row;\n\
    \n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpn04yc8ta.d(32): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign`
    cannot deduce function from argument types `!()(Tuple!(long, long)*)`, candidates
    are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(long,
    long).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this),
    R, "="))`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpn04yc8ta.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.length; ++i)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            rows = i;\n       \
    \     break;\n        }\n    }\n    for(long i = 0; i < lst.length; ++i)\n   \
    \ {\n        if(lst[i][cols] == x)\n        {\n            cols = i;\n       \
    \     break;\n        }\n    }\n    Tuple!(long, long)[] res = new Tuple!(long,\
    \ long)[rows];\n    for(long i = 0; i < rows; ++i)\n    {\n        res[i] = new\
    \ Tuple!(long, long)[cols];\n        for(long j = 0; j < cols; ++j)\n        {\n\
    \            res[i][j] = new Tuple!(long, long)();\n        }\n    }\n    return\
    \ res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqfjxdn16.d(40): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign`
    cannot deduce function from argument types `!()(Tuple!(long, long)[])`, candidates
    are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(long,
    long).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this),
    R, "="))`

    /tmp/tmpqfjxdn16.d(43): Error: variable `j` cannot be read at compile time

    /tmp/tmpqfjxdn16.d(43): Error: cannot implicitly convert expression `new Tuple!(long,
    long)(0L, 0L)` of type `Tuple!(long, long)*` to `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqfjxdn16.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.Length; i++)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            rows++;\n        }\n\
    \        else\n        {\n            cols++;\n        }\n    }\n    Tuple!(long,\
    \ long)[] res = new Tuple!(long, long)[rows];\n    long row = 0;\n    long col\
    \ = 0;\n    for(long i = 0; i < lst.Length; i++)\n    {\n        if(lst[i][0]\
    \ == x)\n        {\n            res[row][0] = row;\n            res[row][1] =\
    \ col;\n            row++;\n        }\n        else\n        {\n            res[row][0]\
    \ = row;\n            res[row][1] = col;\n            col++;\n        }\n    }\n\
    \    return res;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphsgijfvx.d(21): Error: no property `Length` for type `long[][]`

    /tmp/tmphsgijfvx.d(35): Error: no property `Length` for type `long[][]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphsgijfvx.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long[] res = new long[lst.Length];\n    for(int i = 0; i < lst.Length; i++)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            res[i] = lst[i][1];\n\
    \        }\n    }\n    return Tuple!(long, long)[](res, lst.Length);\n}\nunittest\n\
    {\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L,\
    \ 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpdykdk0ud.d(19): Error: no property `Length` for type `long[][]`

    /tmp/tmpdykdk0ud.d(20): Error: no property `Length` for type `long[][]`

    /tmp/tmpdykdk0ud.d(27): Error: no property `Length` for type `long[][]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdykdk0ud.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.length; i++){\n\
    \        if(lst[i][0] == x){\n            rows++;\n        }\n        if(lst[i][1]\
    \ == x){\n            cols++;\n        }\n    }\n    Tuple!(long, long)[] res\
    \ = new Tuple!(long, long)[rows];\n    for(int i = 0; i < rows; i++){\n      \
    \  res[i] = new Tuple!(long, long)[cols];\n        for(int j = 0; j < cols; j++){\n\
    \            res[i][j] = new Tuple!(long, long)();\n        }\n    }\n    for(int\
    \ i = 0; i < lst.length; i++){\n        if(lst[i][0] == x){\n            res[lst[i][0]][lst[i][1]]\
    \ = new Tuple!(long, long)();\n            res[lst[i][0]][lst[i][1]][0] = i;\n\
    \            res[lst[i][0]][lst[i][1]][1] = lst[i][1];\n        }\n        if(lst[i][1]\
    \ == x){\n            res[lst[i][0]][lst[i][1]][2] = i;\n            res[lst[i][0]][lst[i][1]][3]\
    \ = lst[i][0];\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1daexifz.d(31): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign`
    cannot deduce function from argument types `!()(Tuple!(long, long)[])`, candidates
    are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(long,
    long).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this),
    R, "="))`

    /tmp/tmp1daexifz.d(33): Error: variable `j` cannot be read at compile time

    /tmp/tmp1daexifz.d(33): Error: cannot implicitly convert expression `new Tuple!(long,
    long)(0L, 0L)` of type `Tuple!(long, long)*` to `long`

    /tmp/tmp1daexifz.d(38): Error: variable `lst` cannot be read at compile time

    /tmp/tmp1daexifz.d(38): Error: cannot implicitly convert expression `new Tuple!(long,
    long)(0L, 0L)` of type `Tuple!(long, long)*` to `long`

    /tmp/tmp1daexifz.d(39): Error: variable `lst` cannot be read at compile time

    /tmp/tmp1daexifz.d(39): Error: only one index allow'
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] res = null;\n    foreach(row: lst, row: row) \n    {\n\
    \        foreach(col: row, col: col) \n        {\n            if(col == x) \n\
    \            {\n                res = Tuple!(long, long)[](row, col);\n      \
    \      }\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0imd3hx0.d(20): Error: no identifier for declarator `row`

    /tmp/tmp0imd3hx0.d(20): Error: found `:` when expecting `;`

    /tmp/tmp0imd3hx0.d(20): Error: found `:` when expecting `)`

    /tmp/tmp0imd3hx0.d(20): Error: found `)` when expecting `;` following statement

    /tmp/tmp0imd3hx0.d(22): Error: no identifier for declarator `col`

    /tmp/tmp0imd3hx0.d(22): Error: found `:` when expecting `;`

    /tmp/tmp0imd3hx0.d(22): Error: found `:` when expecting `)`

    /tmp/tmp0imd3hx0.d(22): Error: found `)` when expecting `;` following statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0imd3hx0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] ret = new Tuple!(long, long)[lst.length];\n    for(int\
    \ i = 0; i < lst.length; i++)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            ret[i] = Tuple!(lst[i][0], lst[i][1]);\n        }\n    }\n    Arrays.sort(ret);\n\
    \    return ret;\n}\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp3ts8jun5.d(24): Error: variable `lst` cannot be read at compile
    time

    /tmp/tmp3ts8jun5.d(24): Error: variable `lst` cannot be read at compile time

    /tmp/tmp3ts8jun5.d(27): Error: undefined identifier `Arrays`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3ts8jun5.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i, j, k;\n  \
    \  Tuple!(long, long)[] res = new Tuple!(long, long)[n];\n    \n    for(i = 0;\
    \ i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ == x)\n            {\n                res[i] = Tuple!(long, long)[i, j];\n \
    \               break;\n            }\n        }\n    }\n    \n    for(i = 0;\
    \ i < n; i++)\n    {\n        for(j = 0; j < m; j++)\n        {\n            if(lst[i][j]\
    \ > x)\n            {\n                res[i] = Tuple!(long, long)[i, j];\n  \
    \              break;\n            }\n        }\n    }\n    \n    return res;\n\
    }\nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L, 2L,\
    \ 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) ==\
    \ [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpp3unw6iz.d(30): Error: no `[]` operator overload for type `Tuple!(long,
    long)`

    /tmp/tmpp3unw6iz.d(42): Error: no `[]` operator overload for type `Tuple!(long,
    long)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp3unw6iz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long result[][] =\
    \ new long[n][m];\n    for(int i = 0; i < n; i++)\n    {\n        for(int j =\
    \ 0; j < m; j++)\n        {\n            if(lst[i][j] == x)\n            {\n \
    \               result[i][j] = 1;\n            }\n        }\n    }\n    Arrays.sort(result,\
    \ (a, b) -> {\n        return a[0] - b[0];\n    });\n    Arrays.sort(result, (a,\
    \ b) -> {\n        return b[1] - a[1];\n    });\n    \n    Tuple!(long, long)[]\
    \ res = new Tuple!(long, long)[result.length];\n    for(int i = 0; i < result.length;\
    \ i++)\n    {\n        res[i] = new Tuple!(long, long)[result[i].length];\n  \
    \      for(int j = 0; j < result[i].length; j++)\n        {\n            res[i][j]\
    \ = new Tuple!(long, long)();\n            res[i][j].first = 0;\n            res[i][j].second\
    \ = result[i][j];\n        }\n    }\n    return res;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzqneh_k7.d(21): Deprecation: instead of C-style syntax, use D-style
    syntax `long[][] result`

    /tmp/tmpzqneh_k7.d(32): Error: expression expected, not `>`

    /tmp/tmpzqneh_k7.d(32): Error: found `{` when expecting `,`

    /tmp/tmpzqneh_k7.d(33): Error: expression expected, not `return`

    /tmp/tmpzqneh_k7.d(33): Error: found `a` when expecting `,`

    /tmp/tmpzqneh_k7.d(33): Error: found `;` when expecting `,`

    /tmp/tmpzqneh_k7.d(34): Error: expression expected, not `}`

    /tmp/tmpzqneh_k7.d(35): Error: expression expected, not `>`

    /tmp/tmpzqneh_k7.d(35): Error: found `{` when expecting `,`

    /tmp/tmpzqneh_k7.d(36): Error: expression expected, not `return`

    /tmp/tmpzqneh_k7.d(36): Error: found `b` when expecting `,`

    /tmp/tmpzqneh_k7.d(36): Error: found `;` when expecting `,`

    /tmp/tmpzqneh_k7.d(37): Error: expression expected, not `}`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzqneh_k7.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long n = lst.length;\n    long m = lst[0].length;\n    long i = 0;\n    long\
    \ j = 0;\n    long k = 0;\n    long l = 0;\n    long m1 = m;\n    long n1 = n;\n\
    \    long m2 = m;\n    long n2 = n;\n    long m3 = m;\n    long n3 = n;\n    long\
    \ m4 = m;\n    long n4 = n;\n    long m5 = m;\n    long n5 = n;\n    long m6 =\
    \ m;\n    long n6 = n;\n    long m7 = m;\n    long n7 = n;\n    long m8 = m;\n\
    \    long n8 = n;\n    long m9 = m;\n    long n9 = n;\n    long m10 = m;\n   \
    \ long n10 = n;\n    long m11 = m;\n    long n11 = n;\n    long m12 = m;\n   \
    \ long n12 = n;\n    long m13 = m;\n    long n13 = n;\n    long m14 = m;\n   \
    \ long n14 = n;\n    long m15 = m;\n    long n15 = n;\n    long m16 = m;\n   \
    \ long n16 = n;\n    long m17 = m;\n    long n17 = n;\n    long m18 = m;\n   \
    \ long n18 = n;\n    long m19 = m;\n    long n19 = n;\n    long m20 = m;\n   \
    \ long n20 = n;\n    long m21 = m;\n    long n21 = n;\n    long m22 = m;\n   \
    \ long n22 = n;\n    long m23 = m;\n    long n23 = n;\n    long m24 = m;\n   \
    \ long n24 = n;\n    long m25 = m;\n    long n25 = n;\n    long m26 = m;\n   \
    \ long n26 = n;\n    long m27 = m;\n    long n27 = n;\n    long m28 = m;\n   \
    \ long n28 = n;\n    long m29 = m;\n    long n29 = n;\n    long m30 = m;\n   \
    \ long n30 = n;\n    long m31 = m;\n    long n31 = n;\n    long m32 = m;\n   \
    \ long n32 = n;\n    long m33 = m;\n    long n33 = n;\n    long m34 = m;\n   \
    \ long n34 = n;\n    long m35 = m;\n    long n35 = n;\n    long m36 = m;\n   \
    \ long n36 = n;\n    \nunittest\n{\n    alias candidate = get_row;\n\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L)\
    \ == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L,\
    \ 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L),\
    \ tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L,\
    \ 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L) == []);\n\
    \    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[], [1L], [1L,\
    \ 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpknmqfrj2.d(98): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpknmqfrj2.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164641
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = null;\n    foreach(row,lst)\n    {\n      \
    \  foreach(column,row)\n        {\n            if(column == x)\n            {\n\
    \                result = Tuple!(long, long)[](row,column);\n                break;\n\
    \            }\n        }\n        if(result != null)\n            break;\n  \
    \  }\n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n \
    \   assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpunssq57v.d(20): Error: no identifier for declarator `lst`

    /tmp/tmpunssq57v.d(20): Error: found `)` when expecting `;`

    /tmp/tmpunssq57v.d(22): Error: no identifier for declarator `row`

    /tmp/tmpunssq57v.d(22): Error: found `)` when expecting `;`

    /tmp/tmpunssq57v.d(30): Error: found `if` when expecting `)`

    /tmp/tmpunssq57v.d(31): Error: found `break` when expecting `;` following statement

    /tmp/tmpunssq57v.d(31): Deprecation: use `{ }` for an empty statement, not `;`

    /tmp/tmpunssq57v.d(33): Error: found `return` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpunssq57v.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    \n    foreach(row:\
    \ lst, row_index: 0) \n    {\n        foreach(column: row, column_index: 0) \n\
    \        {\n            if(column_index == x) \n            {\n              \
    \  foreach(tuple: result, tuple_index: 0) \n                {\n              \
    \      tuple.item1 = row_index;\n                    tuple.item2 = column_index;\n\
    \                }\n            }\n        }\n    }\n    \n    foreach(tuple:\
    \ result, tuple_index: 0) \n    {\n        tuple.item1 = tuple.item1 * -1;\n \
    \       tuple.item2 = tuple.item2 * -1;\n    }\n    \n    foreach(tuple: result,\
    \ tuple_index: 0) \n    {\n        tuple.item1 = tuple.item1 + 1;\n        tuple.item2\
    \ = tuple.item2 + 1;\n    }\n    \n    foreach(tuple: result, tuple_index: 0)\
    \ \n    {\n        tuple.item1 = tuple.item1 + 1;\n        tuple.item2 = tuple.item2\
    \ + 1;\n    }\n    \n    foreach(tuple: result, tuple_index: 0) \n    {\n    \
    \    tuple.item1 = tuple.item1 + 1;\n        tuple.item2 = tuple.item2 + 1;\n\
    \    }\n    \n    foreach(tuple: result, tuple_index: 0) \n    {\n        tuple.item1\
    \ = tuple.item1 + 1;\n        tuple.item2 = tuple.item2 + 1;\n    }\n    \n  \
    \  foreach(tuple: result, tuple_index: 0) \n    {\n        tuple.item1 = tuple.item1\
    \ + 1;\n        tuple.item2 = tuple.item2 + 1;\n    }\n    \n    foreach(tuple:\
    \ result, tuple_index: 0) \n    {\n        tuple.item1 = tuple.item1 + 1;\n  \
    \      tuple.item2 = tuple.item2 + 1;\n    }\n    \n    foreach(tuple: result,\
    \ tuple_index: 0) \n    {\n        tuple.item1 = tuple.item1 + 1;\n        tuple.item2\
    \ = tuple.item2 + 1;\n    }\n    \n    foreach(tuple: result, tuple_index: 0)\
    \ \n    {\n        tuple.item1 = tuple.item1 + 1;\n        tuple.item2 = tuple.item2\
    \ + 1;\n    }\n    \n    foreach(tuple: result, tuple_index: 0) \n    {\n    \
    \    tuple.item1 = tuple.item1 + 1;\n        tuple.item2 = tuple.item2 + 1;\n\
    \    }\n    \n    foreach(tuple: result, tuple_index: 0) \n    {\n        tuple.item1\
    \ = tuple.item1 + 1;\n        tuple.item2 = tuple.item2 + 1;\n    }\n    \n  \
    \  foreach(tuple: result, tuple_index: 0) \n    {\n        tuple.item1 = tuple.item1\
    \ + 1;\n        tuple.item2 = tuple.item2 + 1;\n    }\n    \n\nunittest\n{\n \
    \   alias candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L],\
    \ [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L),\
    \ tuple(1L, 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp20rnkyvd.d(21): Error: no identifier for declarator `row`

    /tmp/tmp20rnkyvd.d(21): Error: found `:` when expecting `;`

    /tmp/tmp20rnkyvd.d(21): Error: found `:` when expecting `)`

    /tmp/tmp20rnkyvd.d(21): Error: found `)` when expecting `;` following statement

    /tmp/tmp20rnkyvd.d(23): Error: no identifier for declarator `column`

    /tmp/tmp20rnkyvd.d(23): Error: found `:` when expecting `;`

    /tmp/tmp20rnkyvd.d(23): Error: found `:` when expecting `)`

    /tmp/tmp20rnkyvd.d(23): Error: found `)` when expecting `;` following statement

    /tmp/tmp20rnkyvd.d(27): Error: no identifier for declarator `tuple`

    /tmp/tmp20rnkyvd.d(27): Error: found `:` when expecting `;`

    /tmp/tmp20rnkyvd.d(27): Error: found `:` when expecting `)`

    /tmp/tmp20rnkyvd.d(27): Error: found `)` when expecting `;` following statement

    /tmp/tmp20rnkyvd.d(36): Error: no identifier for declarator `tuple`

    /tmp/tmp20rnkyvd.d(36): Error: found `:` when expecting `;`

    /tmp/tmp20rnkyvd.d(36): Error: found `:` when expecting `)`

    /tmp/tmp20rnkyvd.d(36): Error: fo'
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    long rows = 0;\n    long cols = 0;\n    for(long i = 0; i < lst.Length; i++)\n\
    \    {\n        if(lst[i][0] == x)\n        {\n            rows++;\n        }\n\
    \        else\n        {\n            cols++;\n        }\n    }\n    Tuple!(long,\
    \ long)[] result = new Tuple!(long, long)[rows];\n    for(long i = 0; i < rows;\
    \ i++)\n    {\n        result[i] = new Tuple!(long, long)[cols];\n        for(long\
    \ j = 0; j < cols; j++)\n        {\n            result[i][j] = new Tuple!(long,\
    \ long)(i, j);\n        }\n    }\n    return result;\n}\nunittest\n{\n    alias\
    \ candidate = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 4L), tuple(1L, 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L)\
    \ == [tuple(0L, 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L),\
    \ tuple(5L, 1L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L,\
    \ 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L,\
    \ 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L),\
    \ tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L,\
    \ 0L)]);\n    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L)\
    \ == []);\n    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n\
    }\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpakycpuup.d(21): Error: no property `Length` for type `long[][]`

    /tmp/tmpakycpuup.d(35): Error: template `std.typecons.Tuple!(long, long).Tuple.opAssign`
    cannot deduce function from argument types `!()(Tuple!(long, long)[])`, candidates
    are:

    /home/a.guha/repos/spack/opt/spack/linux-centos7-haswell/gcc-9.2.0/dmd-2.081.1-jzbhflp3vff4u2dqrltybjq3in2pa22f/linux/bin64/../../src/phobos/std/typecons.d(898):        `std.typecons.Tuple!(long,
    long).Tuple.opAssign(R)(auto ref R rhs) if (areCompatibleTuples!(typeof(this),
    R, "="))`

    /tmp/tmpakycpuup.d(38): Error: variable `j` cannot be read at compile time

    /tmp/tmpakycpuup.d(38): Error: cannot implicitly convert expression `new Tuple!(long,
    long)(i, j)` of type `Tuple!(long, long)*` to `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpakycpuup.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = null;\n    \n    foreach(row: lst, row_index:\
    \ long in  0 .. row.length - 1)\n    {\n        foreach(column: row[0..row.length\
    \ - 1], column_index: long in  0 .. row.length - 1 - row_index)\n        {\n \
    \           if(column_index == x)\n            {\n                result = Tuple!(long,\
    \ long)[](row_index, column_index);\n                break;\n            }\n \
    \       }\n    }\n    \n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_row;\n\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L,\
    \ 0L), tuple(2L, 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L,\
    \ 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L,\
    \ 1L), tuple(1L, 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 1L, 3L, 4L, 5L, 6L], [1L, 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 1L, 6L], [1L, 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L,\
    \ 0L), tuple(2L, 1L), tuple(2L, 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L),\
    \ tuple(4L, 0L), tuple(5L, 4L), tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n\
    \    assert(candidate([], 1L) == []);\n    assert(candidate([[1L]], 2L) == []);\n\
    \    assert(candidate([[], [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpted72a5c.d(21): Error: no identifier for declarator `row`

    /tmp/tmpted72a5c.d(21): Error: found `:` when expecting `;`

    /tmp/tmpted72a5c.d(21): Error: found `:` when expecting `)`

    /tmp/tmpted72a5c.d(21): Error: no identifier for declarator `long`

    /tmp/tmpted72a5c.d(21): Error: found `in` instead of statement

    /tmp/tmpted72a5c.d(30): Error: unrecognized declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpted72a5c.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
- exit_code: 1
  program: "import std.math;\nimport std.typecons;\n/*\n\n    You are given a 2 dimensional\
    \ data, as a nested lists,\n    which is similar to matrix, however, unlike matrices,\n\
    \    each row may contain a different number of columns.\n    Given lst, and integer\
    \ x, find integers x in the list,\n    and return list of tuples, [(x1, y1), (x2,\
    \ y2) ...] such that\n    each tuple is a coordinate - (row, columns), starting\
    \ with 0.\n    Sort coordinates initially by rows in ascending order.\n    Also,\
    \ sort coordinates of the row by columns in descending order.\n    \n    Examples:\n\
    \                \n*/\nTuple!(long, long)[] get_row(long[][] lst, long x) \n{\n\
    \    Tuple!(long, long)[] result = new Tuple!(long, long)[0];\n    \n    for(long\
    \ i = 0; i < lst.length; ++i)\n    {\n        if(lst[i][0] == x)\n        {\n\
    \            for(long j = 0; j < lst[i].length; ++j)\n            {\n        \
    \        result.add((i, j));\n            }\n        }\n    }\n    \n    result.sort(function(a,\
    \ b){return a.0 < b.0;});\n    result.sort(function(a, b){return b.1 < a.1;});\n\
    \    \n    return result;\n}\nunittest\n{\n    alias candidate = get_row;\n\n\
    \    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 4L), tuple(1L, 0L), tuple(2L,\
    \ 5L), tuple(2L, 0L)]);\n    assert(candidate([[1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L]], 2L) == [tuple(0L, 1L), tuple(1L,\
    \ 1L), tuple(2L, 1L), tuple(3L, 1L), tuple(4L, 1L), tuple(5L, 1L)]);\n    assert(candidate([[1L,\
    \ 2L, 3L, 4L, 5L, 6L], [1L, 2L, 3L, 4L, 5L, 6L], [1L, 1L, 3L, 4L, 5L, 6L], [1L,\
    \ 2L, 1L, 4L, 5L, 6L], [1L, 2L, 3L, 1L, 5L, 6L], [1L, 2L, 3L, 4L, 1L, 6L], [1L,\
    \ 2L, 3L, 4L, 5L, 1L]], 1L) == [tuple(0L, 0L), tuple(1L, 0L), tuple(2L, 1L), tuple(2L,\
    \ 0L), tuple(3L, 2L), tuple(3L, 0L), tuple(4L, 3L), tuple(4L, 0L), tuple(5L, 4L),\
    \ tuple(5L, 0L), tuple(6L, 5L), tuple(6L, 0L)]);\n    assert(candidate([], 1L)\
    \ == []);\n    assert(candidate([[1L]], 2L) == []);\n    assert(candidate([[],\
    \ [1L], [1L, 2L, 3L]], 3L) == [tuple(2L, 2L)]);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm6e1ue7x.d(32): Error: found `0.00000` when expecting `;` following
    `return` statement

    /tmp/tmpm6e1ue7x.d(32): Error: found `<` instead of statement

    /tmp/tmpm6e1ue7x.d(33): Error: found `0.1` when expecting `;` following `return`
    statement

    /tmp/tmpm6e1ue7x.d(33): Error: found `<` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm6e1ue7x.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660164642
