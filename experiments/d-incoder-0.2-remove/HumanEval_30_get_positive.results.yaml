language: d
name: HumanEval_30_get_positive
results:
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tr[i] = l[i];\n\
    \t}\n\treturn r;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpa8f1jz77.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpa8f1jz77.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpa8f1jz77.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmplap82hkq.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmplap82hkq.__unittest_L16_C1() [0x427fb5]

    ??:? void tmplap82hkq.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmph7ib4irf.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmph7ib4irf.__unittest_L13_C1() [0x427fb9]

    ??:? void tmph7ib4irf.__modtest() [0x428258]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] < 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are\
    \ even numbers.\n            \n*/\nlong[] get_even(long[] l) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i]\
    \ % 2 == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only\
    \ numbers in the list that are odd numbers.\n            \n*/\nlong[] get_odd(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++)\n\t{\n\t\tif(l[i] % 2 != 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 3.\n            \n\
    */\nlong[] get_divisible_by_3(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] % 3 == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 5.\n            \n*/\nlong[] get_divisible_by_5(long[] l) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t{\n\t\tif(l[i] % 5 == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n\
    /*\nReturn only numbers in the list that are divisible by 7.\n            \n*/\n\
    long[] get_divisible_by_7(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] % 7 == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l)\
    \ \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t{\n\t\tif(l[i] % 11 == 0)\n\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi_frbkcs.d(111): Error: found `unittest` instead of statement

    /tmp/tmpi_frbkcs.d(120): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi_frbkcs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmjukmpu9.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpmjukmpu9.__unittest_L13_C1() [0x427fb9]

    ??:? void tmpmjukmpu9.__modtest() [0x428258]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = {0};\n\tfor(int\
    \ i = 0; i < l.length; ++i)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tr[r.length] = l[i];\n\
    \t}\n\treturn r;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpoy08exbd.d(8): Error: a struct is not a valid initializer for a
    `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpoy08exbd.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmjukmpu9.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpmjukmpu9.__unittest_L13_C1() [0x427fb9]

    ??:? void tmpmjukmpu9.__modtest() [0x428258]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only negative\
    \ numbers in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\
    \    long[] result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n\
    \    {\n        if(l[i] < 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn only numbers in the list that are even numbers.\n   \
    \         \n*/\nlong[] get_even(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] % 2 == 0)\n   \
    \         result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only numbers\
    \ in the list that are odd numbers.\n            \n*/\nlong[] get_odd(long[] l)\
    \ \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        if(l[i] % 2 != 0)\n            result[i] = l[i];\n    }\n\
    \    return result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n\
    \        if(l[i] % 3 == 0)\n            result[i] = l[i];\n    }\n    return result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 5.\n            \n\
    */\nlong[] get_divisible_by_5(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] % 5 == 0)\n   \
    \         result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 7.\n            \n*/\nlong[] get_divisible_by_7(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        if(l[i] % 7 == 0)\n            result[i] = l[i];\n    }\n\
    \    return result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n\
    \        if(l[i] % 11 == 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn \nunittest\n{\n    alias candidate = get_positive;\n\n\
    \    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp8j5391ff.d(114): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8j5391ff.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t\tr[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ r;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[]\
    \ get_negative(long[] l) \n{\n\tlong[] r = new long[l.length];\n\tfor(int i =\
    \ 0; i < l.length; i++) \n\t\tr[i] = l[i] < 0 ? l[i] : 0;\n\treturn r;\n}\n/*\n\
    Return only zeros in the list.\n            \n*/\nlong[] get_zero(long[] l) \n\
    {\n\tlong[] r = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t\t\
    r[i] = l[i] == 0 ? 0 : l[i];\n\treturn r;\n}\n/*\nReturn only numbers in the list\
    \ that are divisible by n.\n            \n*/\nlong[] get_divisible_by(long[] l,\
    \ long n) \n{\n\tlong[] r = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t\tr[i] = l[i] % n == 0 ? l[i] : 0;\n\treturn r;\n}\n/*\nReturn only\
    \ numbers in the list that are not divisible by n.\n            \n*/\nlong[] get_not_divisible_by(long[]\
    \ l, long n) \n{\n\tlong[] r = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t\tr[i] = l[i] % n != 0 ? l[i] : 0;\n\treturn r;\n}\n/*\nReturn only\
    \ numbers in the list that are less than n.\n            \n*/\nlong[] get_less_than(long[]\
    \ l, long n) \n{\n\tlong[] r = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t\tr[i] = l[i] < n ? l[i] : 0;\n\treturn r;\n}\n/*\nReturn only numbers\
    \ in the list that are greater than n.\n            \n*/\nlong[] get_greater_than(long[]\
    \ l, long n) \n{\n\tlong[] r = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t\tr[i] = l[i] > n ? l[i] : 0;\n\treturn r;\n}\n/*\nReturn only numbers\
    \ in the list that are less than or equal to n.\n            \n*/\nlong[] get_less_than_or_equal_to(long[]\
    \ l, long n) \n{\n\tlong[] r = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t\tr[i] = l[i] <= n ? l[i] : 0;\n\treturn r;\n}\n/*\nReturn only numbers\
    \ in the list that are greater than or equal to n.\n            \n*/\nlong[] get_greater_than_or_equal_\n\
    unittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzjohw1xy.d(95): Error: semicolon expected, not `unittest`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzjohw1xy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9an9q3ul.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmp9an9q3ul.__unittest_L16_C1() [0x427fb5]

    ??:? void tmp9an9q3ul.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n      \
    \  {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpz1ua0iv5.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpz1ua0iv5.__unittest_L18_C1() [0x427fb5]

    ??:? void tmpz1ua0iv5.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprwf__2q4.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmprwf__2q4.__unittest_L18_C1() [0x427fb5]

    ??:? void tmprwf__2q4.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n      \
    \  {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\n/*\nReturn\
    \ only negative numbers in the list.\n            \n*/\nlong[] get_negative(long[]\
    \ l) \n{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++) \n    {\n        if(l[i] < 0) \n        {\n            res[i] = l[i];\n\
    \        }\n    }\n    return res;\n}\n/*\nReturn only zeros in the list.\n  \
    \          \n*/\nlong[] get_zero(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] == 0) \n     \
    \   {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\n/*\n\
    Return only numbers in the list that are not zero.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l) \n{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++) \n    {\n        if(l[i] != 0) \n        {\n            res[i] = l[i];\n\
    \        }\n    }\n    return res;\n}\n/*\nReturn only numbers in the list that\
    \ are not negative.\n            \n*/\nlong[] get_not_negative(long[] l) \n{\n\
    \    long[] res = new long[l.length];\n    for(int i = 0; i < l.length; i++) \n\
    \    {\n        if(l[i] < 0) \n        {\n            res[i] = l[i];\n       \
    \ }\n    }\n    return res;\n}\n/*\nReturn only numbers in the list that are not\
    \ positive.\n            \n*/\nlong[] get_not_positive(long[] l) \n{\n    long[]\
    \ res = new long[l.length];\n    for(int i = 0; i < l.length; i++) \n    {\n \
    \       if(l[i] > 0) \n        {\n            res[i] = l[i];\n        }\n    }\n\
    \    return res;\n}\n/*\nReturn only numbers in the list that are not even.\n\
    \            \n*/\nlong[] get_not_even(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] % 2 == 0) \n \
    \       {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\n\
    /*\nReturn only numbers in the list that are not odd.\n            \n*/\nlong[]\
    \ get_not_odd(long[] l) \n{\n    long[] res = new long[l.length];\n    for(int\
    \ i = 0; i < l.length; i++\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzwnq3tlb.d(122): Error: found `unittest` when expecting `)`

    /tmp/tmpzwnq3tlb.d(131): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzwnq3tlb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpgjf6jfze.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpgjf6jfze.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpgjf6jfze.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpd4ihdaf7.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpd4ihdaf7.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpd4ihdaf7.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1o023viu.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284cd]

    ??:? void tmp1o023viu.__unittest_L13_C1() [0x427fad]

    ??:? void tmp1o023viu.__modtest() [0x42824c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5ab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b43e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b78]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430655]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]

    ??:? runModuleUnitTests [0x42c381]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpi1i10oez.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpi1i10oez.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpi1i10oez.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpuf4c2o00.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284cd]

    ??:? void tmpuf4c2o00.__unittest_L13_C1() [0x427fad]

    ??:? void tmpuf4c2o00.__modtest() [0x42824c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5ab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b43e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b78]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430655]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]

    ??:? runModuleUnitTests [0x42c381]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpuf4c2o00.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284cd]

    ??:? void tmpuf4c2o00.__unittest_L13_C1() [0x427fad]

    ??:? void tmpuf4c2o00.__modtest() [0x42824c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5ab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b43e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b78]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430655]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]

    ??:? runModuleUnitTests [0x42c381]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[]\
    \ get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i\
    \ = 0; i < l.length; i++)\n\t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn res;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t\tres[i] = l[i] == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only ones\
    \ in the list.\n            \n*/\nlong[] get_one(long[] l) \n{\n\tlong[] res =\
    \ new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i]\
    \ == 1 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ divisible by n.\n            \n*/\nlong[] get_divisible_by(long[] l, long n)\
    \ \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] % n == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by n.\n            \n*/\nlong[] get_divisible_by_array(long[]\
    \ l, long[] n) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i <\
    \ l.length; i++)\n\t\tres[i] = l[i] % n[i] == 0 ? 1 : 0;\n\treturn res;\n}\n/*\n\
    Return only numbers in the list that are divisible by n.\n            \n*/\nlong[]\
    \ get_divisible_by_array(long[] l, long[] n, int len) \n{\n\tlong[] res = new\
    \ long[len];\n\tfor (int i = 0; i < len; i++)\n\t\tres[i] = l[i] % n[i] == 0 ?\
    \ 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by n.\n            \n*/\nlong[] get_divisible_by_array(long[] l, long[] n, int\
    \ len, int offset) \n{\n\tlong[] res = new long[len];\n\tfor (int i = offset;\
    \ i < len; i++)\n\t\tres[i] = l[i] % n[i] == 0 ? 1 : 0;\n\treturn res;\n}\n/*\n\
    Return only numbers in the list that are divisible by n.\n            \n*/\nlong[]\
    \ get_divisible_by_array(long[] l, long[] n, int len, int offset, int step) \n\
    unittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpr9v49y4j.d(95): Error: semicolon expected following function declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr9v49y4j.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tresult[i] = std.math.max(l[i], 0);\n\
    \treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpg38hqf8u.d(10): Error: undefined identifier `max` in module `std.math`,
    did you mean function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg38hqf8u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\t\
    result[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers\
    \ in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\
    \tif (l[i] < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\
    \treturn result;\n}\n/*\nReturn only numbers in the list that are divisible by\
    \ 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i]\
    \ % 3 == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n\
    /*\nReturn only numbers in the list that are divisible by 5.\n            \n*/\n\
    long[] get_divisible_by_5(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] % 5 == 0) \n\t\t{\n\t\
    \t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 7.\n            \n*/\nlong[] get_divisible_by_7(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % 7 == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\
    \t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\
    \tif (l[i] % 11 == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 13.\n           \
    \ \n*/\nlong[] get_divisible_by_13(long[] \nunittest\n{\n    alias candidate =\
    \ get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n\
    \    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L,\
    \ 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) == []);\n\
    \    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbpem8eaf.d(119): Error: found `unittest` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbpem8eaf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[]\
    \ get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i\
    \ = 0; i < l.length; ++i)\n\t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn res;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\
    \t\tres[i] = l[i] == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only ones in the\
    \ list.\n            \n*/\nlong[] get_one(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] == 1 ? 1 : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only numbers in the list that are divisible by n.\n    \
    \        \n*/\nlong[] get_divisible_by(long[] l, long n) \n{\n\tlong[] res = new\
    \ long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] % n\
    \ == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ divisible by n and are in the range [a, b].\n            \n*/\nlong[] get_divisible_by_range(long[]\
    \ l, long a, long b, long n) \n{\n\tlong[] res = new long[l.length];\n\tfor(int\
    \ i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] % n == 0 && (l[i] >= a && l[i]\
    \ <= b) ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ divisible by n and are in the range [a, b] and are in the range [c, d].\n  \
    \          \n*/\nlong[] get_divisible_by_range_2(long[] l, long a, long b, long\
    \ c, long d, long n) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0;\
    \ i < l.length; ++i)\n\t\tres[i] = l[i] % n == 0 && (l[i] >= a && l[i] <= b) &&\
    \ (l[i] >= c && l[i] <= d) ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by n and are in the range [a, b] and are in the\
    \ range [c, d] and are in the range [e, f].\n            \n*/\nlong[] \nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm8rq71my.d(84): Error: no identifier for declarator `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm8rq71my.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpgjf6jfze.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpgjf6jfze.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpgjf6jfze.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in\
    \ the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i]\
    \ < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\n\
    Return only zeros in the list.\n            \n*/\nlong[] get_zero(long[] l) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n/*\nReturn only numbers in the list that are not zero.\n       \
    \     \n*/\nlong[] get_not_zero(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] != 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list\
    \ that are not negative.\n            \n*/\nlong[] get_not_negative(long[] l)\
    \ \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n/*\nReturn only numbers in the list that are not positive.\n   \
    \         \n*/\nlong[] get_not_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list\
    \ that are not even.\n            \n*/\nlong[] get_not_even(long[] l) \n{\n\t\
    long[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t\
    {\n\t\tif(l[i] % 2 == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n/*\nReturn only numbers in the list that are not odd.\n        \
    \    \n*/\nlong[] get_not_odd(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpt1qvqum8.d(122): Error: found `unittest` when expecting `)`

    /tmp/tmpt1qvqum8.d(131): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt1qvqum8.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9an9q3ul.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmp9an9q3ul.__unittest_L16_C1() [0x427fb5]

    ??:? void tmp9an9q3ul.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[]\
    \ get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i\
    \ = 0; i < l.length; i++)\n\t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn res;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] == 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by n.\n            \n*/\nlong[] get_divisible_by(long[]\
    \ l, long n) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++)\n\t\tres[i] = l[i] % n == 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only\
    \ numbers in the list that are divisible by n and are less than n.\n         \
    \   \n*/\nlong[] get_less_than(long[] l, long n) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] % n != 0 ? l[i] : 0;\n\t\
    return res;\n}\n/*\nReturn only numbers in the list that are divisible by n and\
    \ are greater than n.\n            \n*/\nlong[] get_greater_than(long[] l, long\
    \ n) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] % n != 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by n and are less than or equal to n.\n     \
    \       \n*/\nlong[] get_less_than_or_equal_to(long[] l, long n) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\tres[i] =\
    \ l[i] % n != 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the\
    \ list that are divisible by n and are greater than or equal to n.\n         \
    \   \n*/\nlong[] get_greater_than_or_equal_to(long[] l, long n) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\tres[i] =\
    \ l[i] % n != 0 ? l[i] : 0;\n\treturn res;\nunittest\n{\n    alias candidate =\
    \ get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n\
    \    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L,\
    \ 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) == []);\n\
    \    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9iasuwea.d(89): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9iasuwea.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpl23apj5m.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpl23apj5m.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpl23apj5m.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9an9q3ul.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmp9an9q3ul.__unittest_L16_C1() [0x427fb5]

    ??:? void tmp9an9q3ul.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg1py0sz3.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpg1py0sz3.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpg1py0sz3.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tresult[i] = std.math.getPositive(l[i]);\n\
    \treturn result;\n}\n/*\nReturn only negative numbers in the list.\n         \
    \   \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tresult[i] = std.math.getNegative(l[i]);\n\
    \treturn result;\n}\n/*\nReturn only zeros in the list.\n            \n*/\nlong[]\
    \ get_zero(long[] l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i\
    \ = 0; i < l.length; ++i)\n\t\tresult[i] = std.math.getZero(l[i]);\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are greater than or equal to zero.\n\
    \            \n*/\nlong[] get_greater_or_equal(long[] l) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; ++i)\n\t\tresult[i] =\
    \ std.math.getGreaterOrEqual(l[i]);\n\treturn result;\n}\n/*\nReturn only numbers\
    \ in the list that are less than or equal to zero.\n            \n*/\nlong[] get_less_or_equal(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ ++i)\n\t\tresult[i] = std.math.getLessOrEqual(l[i]);\n\treturn result;\n}\n\
    /*\nReturn only numbers in the list that are greater than zero.\n            \n\
    */\nlong[] get_greater(long[] l) \n{\n\tlong[] result = new long[l.length];\n\t\
    for (int i = 0; i < l.length; ++i)\n\t\tresult[i] = std.math.getGreater(l[i]);\n\
    \treturn result;\n}\n/*\nReturn only numbers in the list that are less than zero.\n\
    \            \n*/\nlong[] get_less(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tresult[i] = std.math.getLess(l[i]);\n\
    \treturn result;\n}\n/*\nReturn only numbers in the list that are equal to zero.\n\
    \            \n*/\nlong[] get_equal(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tresult[i] = std.math.getEqual(l[i]);\n\
    \treturn result;\n}\n/*\nReturn only numbers in the list that are less than or\
    \ equal to zero.\n            \n*/\nlong[] get_less_or_equal_zero(long[] l) \n\
    {\n\tlong[] result = \nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp_8hycdkm.d(97): Error: expression expected, not `unittest`

    /tmp/tmp_8hycdkm.d(98): Error: semicolon expected, not `{`

    /tmp/tmp_8hycdkm.d(106): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_8hycdkm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tr[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ r;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpurbgg1_h.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284cd]

    ??:? void tmpurbgg1_h.__unittest_L13_C1() [0x427fad]

    ??:? void tmpurbgg1_h.__modtest() [0x42824c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5ab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b43e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b78]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430655]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]

    ??:? runModuleUnitTests [0x42c381]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmjukmpu9.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpmjukmpu9.__unittest_L13_C1() [0x427fb9]

    ??:? void tmpmjukmpu9.__modtest() [0x428258]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] < 0) \n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only zeros in the list.\n    \
    \        \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by given number.\n            \n*/\nlong[] get_divisible_by(long[]\
    \ l, long d) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i <\
    \ l.length; i++) \n\t{\n\t\tif (l[i] % d == 0) \n\t\t\tresult[i] = l[i];\n\t}\n\
    \treturn result;\n}\n/*\nReturn only numbers in the list that are not divisible\
    \ by given number.\n            \n*/\nlong[] get_not_divisible_by(long[] l, long\
    \ d) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % d != 0) \n\t\t\tresult[i] = l[i];\n\t}\n\treturn\
    \ result;\n}\n/*\nReturn only numbers in the list that are less than given number.\n\
    \            \n*/\nlong[] get_less_than(long[] l, long d) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i]\
    \ < d) \n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers\
    \ in the list that are less than or equal given number.\n            \n*/\nlong[]\
    \ get_less_than_or_equal_to(long[] l, long d) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] <= d) \n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are greater than given number.\n            \n*/\nlong[] get_greater_than(long[]\
    \ l, long d) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i <\
    \ l.length; i++) \n\t{\n\t\tif (\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpby_7up2w.d(110): Error: expression expected, not `unittest`

    /tmp/tmpby_7up2w.d(111): Error: found `{` when expecting `)`

    /tmp/tmpby_7up2w.d(119): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpby_7up2w.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmplap82hkq.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmplap82hkq.__unittest_L16_C1() [0x427fb5]

    ??:? void tmplap82hkq.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpi1i10oez.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpi1i10oez.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpi1i10oez.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tr[i] = l[i];\n\
    \t}\n\treturn r;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmph3yhee2k.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmph3yhee2k.__unittest_L16_C1() [0x427fb5]

    ??:? void tmph3yhee2k.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tr[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ r;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp4mtqnge1.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284cd]

    ??:? void tmp4mtqnge1.__unittest_L13_C1() [0x427fad]

    ??:? void tmp4mtqnge1.__modtest() [0x42824c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5ab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b43e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b78]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430655]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]

    ??:? runModuleUnitTests [0x42c381]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] < 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n\tlong[] res\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i]\
    \ % 3 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 5.\n            \n*/\nlong[] get_divisible_by_5(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % 5 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 7.\n            \n\
    */\nlong[] get_divisible_by_7(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] % 7 == 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ divisible by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l) \n\
    {\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\
    \t{\n\t\tif (l[i] % 11 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\n\
    Return only numbers in the list that are divisible by 13.\n            \n*/\n\
    long[] get_divisible_by_13(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] % 13 == 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ divisible by 17.\n            \n*/\nlong[] get_divisible_by_17(long[] l) \n\
    {\n\tlong[] res = new long[l.length];\n\t\nunittest\n{\n    alias candidate =\
    \ get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n\
    \    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L,\
    \ 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) == []);\n\
    \    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb1fgnbzz.d(108): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb1fgnbzz.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[]\
    \ get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i\
    \ = 0; i < l.length; i++)\n\t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn res;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] == 0 ? 0 : l[i];\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not zero.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] != 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not negative.\n            \n*/\nlong[] get_not_negative(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers in\
    \ the list that are not positive.\n            \n*/\nlong[] get_not_positive(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers in\
    \ the list that are not in the list.\n            \n*/\nlong[] get_not_in(long[]\
    \ l, long[] l2) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i <\
    \ l.length; i++)\n\t\tres[i] = l[i] != l2 ? l[i] : 0;\n\treturn res;\n}\n/*\n\
    Return only numbers in the list that are not in the list.\n            \n*/\n\
    long[] get_not_in_2(long[] l, long[] l2) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] != l2 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only numbers in the list that are not in the list.\n   \
    \         \n*/\nlong[] get_not_in_3(long[] l, long[] l2) \n{\n\tlong[] res = new\
    \ long[l.length];\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprumo32zq.d(97): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprumo32zq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg1py0sz3.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpg1py0sz3.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpg1py0sz3.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n      \
    \  {\n            result[i] = l[i];\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpoate52pu.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpoate52pu.__unittest_L18_C1() [0x427fb5]

    ??:? void tmpoate52pu.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate =\
    \ get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n\
    \    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L,\
    \ 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) == []);\n\
    \    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_k4mfmiv.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmp_k4mfmiv.__unittest_L18_C1() [0x427fb5]

    ??:? void tmp_k4mfmiv.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpi1i10oez.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpi1i10oez.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpi1i10oez.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n      \
    \  {\n            result[i] = l[i];\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpoate52pu.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpoate52pu.__unittest_L18_C1() [0x427fb5]

    ??:? void tmpoate52pu.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpuf4c2o00.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284cd]

    ??:? void tmpuf4c2o00.__unittest_L13_C1() [0x427fad]

    ??:? void tmpuf4c2o00.__modtest() [0x42824c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5ab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b43e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b78]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430655]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]

    ??:? runModuleUnitTests [0x42c381]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9an9q3ul.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmp9an9q3ul.__unittest_L16_C1() [0x427fb5]

    ??:? void tmp9an9q3ul.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmjukmpu9.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpmjukmpu9.__unittest_L13_C1() [0x427fb9]

    ??:? void tmpmjukmpu9.__modtest() [0x428258]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpuf4c2o00.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284cd]

    ??:? void tmpuf4c2o00.__unittest_L13_C1() [0x427fad]

    ??:? void tmpuf4c2o00.__modtest() [0x42824c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5ab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b43e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b78]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430655]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]

    ??:? runModuleUnitTests [0x42c381]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n      \
    \  {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\n/*\nReturn\
    \ only negative numbers in the list.\n            \n*/\nlong[] get_negative(long[]\
    \ l) \n{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++) \n    {\n        if(l[i] < 0) \n        {\n            res[i] = l[i];\n\
    \        }\n    }\n    return res;\n}\n/*\nReturn only zeros in the list.\n  \
    \          \n*/\nlong[] get_zero(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] == 0) \n     \
    \   {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\n/*\n\
    Return only numbers in the list that are not zero.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l) \n{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++) \n    {\n        if(l[i] != 0) \n        {\n            res[i] = l[i];\n\
    \        }\n    }\n    return res;\n}\n/*\nReturn only numbers in the list that\
    \ are not negative.\n            \n*/\nlong[] get_not_negative(long[] l) \n{\n\
    \    long[] res = new long[l.length];\n    for(int i = 0; i < l.length; i++) \n\
    \    {\n        if(l[i] < 0) \n        {\n            res[i] = l[i];\n       \
    \ }\n    }\n    return res;\n}\n/*\nReturn only numbers in the list that are not\
    \ positive.\n            \n*/\nlong[] get_not_positive(long[] l) \n{\n    long[]\
    \ res = new long[l.length];\n    for(int i = 0; i < l.length; i++) \n    {\n \
    \       if(l[i] > 0) \n        {\n            res[i] = l[i];\n        }\n    }\n\
    \    return res;\n}\n/*\nReturn only numbers in the list that are not even.\n\
    \            \n*/\nlong[] get_not_even(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] % 2 == 0) \n \
    \       {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\n\
    /*\nReturn only numbers in the list that are not odd.\n            \n*/\nlong[]\
    \ get_not_odd(long[] l) \n{\n    long[] res = new long[l.length];\n    for(int\
    \ i = 0; i < l.length; i++\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpzwnq3tlb.d(122): Error: found `unittest` when expecting `)`

    /tmp/tmpzwnq3tlb.d(131): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzwnq3tlb.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpi1i10oez.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpi1i10oez.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpi1i10oez.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] < 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only zeros in the list.\n    \
    \        \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are not zero.\n            \n*/\nlong[] get_not_zero(long[] l) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\t\
    if (l[i] != 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn\
    \ only numbers in the list that are not negative.\n            \n*/\nlong[] get_not_negative(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t{\n\t\tif (l[i] < 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are not positive.\n            \n\
    */\nlong[] get_not_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are not even.\n            \n*/\nlong[] get_not_even(long[] l) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\t\
    if (l[i] % 2 == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn\
    \ only numbers in the list that are not odd.\n            \n*/\nlong[] get_not_odd(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t{\n\t\tif (l[i] % 2 != 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are not \nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpqr4y3kq4.d(114): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpqr4y3kq4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmph7ib4irf.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmph7ib4irf.__unittest_L13_C1() [0x427fb9]

    ??:? void tmph7ib4irf.__modtest() [0x428258]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9an9q3ul.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmp9an9q3ul.__unittest_L16_C1() [0x427fb5]

    ??:? void tmp9an9q3ul.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmph7ib4irf.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmph7ib4irf.__unittest_L13_C1() [0x427fb9]

    ??:? void tmph7ib4irf.__modtest() [0x428258]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\t\
    result[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmw2wt9tq.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpmw2wt9tq.__unittest_L18_C1() [0x427fb5]

    ??:? void tmpmw2wt9tq.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[]\
    \ get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i\
    \ = 0; i < l.length; ++i)\n\t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn res;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\
    \t\tres[i] = l[i] == 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not zero.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\
    \t\tres[i] = l[i] != 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are less than the number in the second argument.\n        \
    \    \n*/\nlong[] get_less_than(long[] l, long r) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] < r ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only numbers in the list that are greater than the number\
    \ in the second argument.\n            \n*/\nlong[] get_greater_than(long[] l,\
    \ long r) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ ++i)\n\t\tres[i] = l[i] > r ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are less than or equal to the number in the second argument.\n\
    \            \n*/\nlong[] get_less_than_or_equal_to(long[] l, long r) \n{\n\t\
    long[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\t\tres[i]\
    \ = l[i] <= r ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list\
    \ that are greater than or equal to the number in the second argument.\n     \
    \       \n*/\nlong[] get_greater_than_or_equal_to(long[] l, long r) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] =\
    \ l[i] >= r ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list\
    \ that are equal to the \nunittest\n{\n    alias candidate = get_positive;\n\n\
    \    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpb_rg9agf.d(90): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb_rg9agf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpgjf6jfze.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpgjf6jfze.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpgjf6jfze.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmjukmpu9.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpmjukmpu9.__unittest_L13_C1() [0x427fb9]

    ??:? void tmpmjukmpu9.__modtest() [0x428258]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\t\
    result[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmw2wt9tq.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpmw2wt9tq.__unittest_L18_C1() [0x427fb5]

    ??:? void tmpmw2wt9tq.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] < 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only zeros in the list.\n         \
    \   \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\t\
    for (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by n.\n            \n*/\nlong[] get_divisible_by(long[] l, long n) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\t\
    if (l[i] % n == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only\
    \ numbers in the list that are divisible by n and are less than n.\n         \
    \   \n*/\nlong[] get_less_than(long[] l, long n) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] % n != 0 && l[i] < n)\
    \ \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the\
    \ list that are divisible by n and are greater than n.\n            \n*/\nlong[]\
    \ get_greater_than(long[] l, long n) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] % n != 0 && l[i] > n)\
    \ \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the\
    \ list that are divisible by n and are less than or equal to n.\n            \n\
    */\nlong[] get_less_than_or_equal_to(long[] l, long n) \n{\n\tlong[] res = new\
    \ long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] %\
    \ n != 0 && l[i] <= n) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn\
    \ only numbers in the list that are divisible by n and are greater than or equal\
    \ to n.\n\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp53tt3cyh.d(100): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp53tt3cyh.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] < 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\
    \t{\n\t\tif (l[i] % 3 == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 5.\n            \n\
    */\nlong[] get_divisible_by_5(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] % 5 == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 7.\n            \n*/\nlong[] get_divisible_by_7(long[] l) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\
    \t{\n\t\tif (l[i] % 7 == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 11.\n           \
    \ \n*/\nlong[] get_divisible_by_11(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] % 11 == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 13.\n            \n*/\nlong[] get_divisible_by_13(long[] l)\
    \ \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t{\n\t\tif (l[i] % 13 == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 17.\n           \
    \ \n*/\nlong[] get_divisible_by_17(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpu01aizsl.d(109): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu01aizsl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in\
    \ the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i]\
    \ < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\n\
    Return only zeros in the list.\n            \n*/\nlong[] get_zero(long[] l) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n/*\nReturn only numbers in the list that are not zeros or negative.\n\
    \            \n*/\nlong[] get_not_zero(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] != 0 && l[i] < 0) \n\t\t\
    {\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers\
    \ in the list that are not negative.\n            \n*/\nlong[] get_not_negative(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif(l[i] != 0 && l[i] > 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\
    \t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are\
    \ even.\n            \n*/\nlong[] get_even(long[] l) \n{\n\tlong[] result = new\
    \ long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 2\
    \ == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\n\
    Return only numbers in the list that are odd.\n            \n*/\nlong[] get_odd(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif(l[i] % 2 != 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t\
    }\n\treturn result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n\tlong[] result\
    \ = new \nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpha_mzgrv.d(121): Error: basic type expected, not `unittest`

    /tmp/tmpha_mzgrv.d(121): Error: semicolon expected, not `unittest`

    /tmp/tmpha_mzgrv.d(121): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpha_mzgrv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tr[i] = l[i];\n\
    \t}\n\treturn r;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbd5sl78b.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpbd5sl78b.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpbd5sl78b.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate =\
    \ get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n\
    \    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L,\
    \ 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) == []);\n\
    \    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_k4mfmiv.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmp_k4mfmiv.__unittest_L18_C1() [0x427fb5]

    ??:? void tmp_k4mfmiv.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpk5ht99np.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpk5ht99np.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpk5ht99np.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmjukmpu9.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpmjukmpu9.__unittest_L13_C1() [0x427fb9]

    ??:? void tmpmjukmpu9.__modtest() [0x428258]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[]\
    \ get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i\
    \ = 0; i < l.length; i++)\n\t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn res;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t\tres[i] = l[i] == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only ones\
    \ in the list.\n            \n*/\nlong[] get_one(long[] l) \n{\n\tlong[] res =\
    \ new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i]\
    \ == 1 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only twos in the list.\n       \
    \     \n*/\nlong[] get_two(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] == 2 ? 1 : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only threes in the list.\n            \n*/\nlong[] get_three(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t\tres[i] = l[i] == 3 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only fours\
    \ in the list.\n            \n*/\nlong[] get_four(long[] l) \n{\n\tlong[] res\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i]\
    \ == 4 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only fives in the list.\n      \
    \      \n*/\nlong[] get_five(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] == 5 ? 1 : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only sixes in the list.\n            \n*/\nlong[] get_six(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t\tres[i] = l[i] == 6 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only sevens\
    \ in the list.\n            \n*/\nlong[] get_seven(long[] l) \n{\n\tlong[] res\
    \ = new long[\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0366kprc.d(108): Error: expression expected, not `unittest`

    /tmp/tmp0366kprc.d(109): Error: found `{` when expecting `]`

    /tmp/tmp0366kprc.d(110): Error: semicolon expected, not `alias`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0366kprc.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n      \
    \  {\n            result[i] = l[i];\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpoate52pu.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpoate52pu.__unittest_L18_C1() [0x427fb5]

    ??:? void tmpoate52pu.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only negative\
    \ numbers in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\
    \    long[] result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n\
    \    {\n        if(l[i] < 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        if(l[i] == 0)\n            result[i] = l[i];\n    }\n \
    \   return result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n\
    \        if(l[i] % 3 == 0)\n            result[i] = l[i];\n    }\n    return result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 5.\n            \n\
    */\nlong[] get_divisible_by_5(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] % 5 == 0)\n   \
    \         result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 7.\n            \n*/\nlong[] get_divisible_by_7(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        if(l[i] % 7 == 0)\n            result[i] = l[i];\n    }\n\
    \    return result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n\
    \        if(l[i] % 11 == 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn only numbers in the list that are divisible by 13.\n\
    \            \n*/\nlong[] get_divisible_by_13(long[] l) \n{\n    long[] result\
    \ = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n      \
    \  if(l[i] % 13 == 0)\n            result[i] = l[i];\n    }\n    return result;\n\
    }\n/*\nReturn only \nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpto4kf2sj.d(114): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpto4kf2sj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = {0};\n\tfor (int\
    \ i = 0; i < l.length; ++i)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tr[r.length] = l[i];\n\
    \t}\n\treturn r;\n}\n/*\nReturn only negative numbers in the list.\n         \
    \   \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] r = {0};\n\tfor (int i =\
    \ 0; i < l.length; ++i)\n\t{\n\t\tif (l[i] < 0)\n\t\t\tr[r.length] = l[i];\n\t\
    }\n\treturn r;\n}\n/*\nReturn only zeros in the list.\n            \n*/\nlong[]\
    \ get_zero(long[] l) \n{\n\tlong[] r = {0};\n\tfor (int i = 0; i < l.length; ++i)\n\
    \t{\n\t\tif (l[i] == 0)\n\t\t\tr[r.length] = l[i];\n\t}\n\treturn r;\n}\n/*\n\
    Return only numbers in the list that are not zero.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l) \n{\n\tlong[] r = {0};\n\tfor (int i = 0; i < l.length; ++i)\n\t{\n\t\tif\
    \ (l[i] != 0)\n\t\t\tr[r.length] = l[i];\n\t}\n\treturn r;\n}\n/*\nReturn only\
    \ numbers in the list that are not negative.\n            \n*/\nlong[] get_not_negative(long[]\
    \ l) \n{\n\tlong[] r = {0};\n\tfor (int i = 0; i < l.length; ++i)\n\t{\n\t\tif\
    \ (l[i] < 0)\n\t\t\tr[r.length] = l[i];\n\t}\n\treturn r;\n}\n/*\nReturn only\
    \ numbers in the list that are not positive.\n            \n*/\nlong[] get_not_positive(long[]\
    \ l) \n{\n\tlong[] r = {0};\n\tfor (int i = 0; i < l.length; ++i)\n\t{\n\t\tif\
    \ (l[i] > 0)\n\t\t\tr[r.length] = l[i];\n\t}\n\treturn r;\n}\n/*\nReturn only\
    \ numbers in the list that are not the given value.\n            \n*/\nlong[]\
    \ get_not_equal_to(long[] l, long value) \n{\n\tlong[] r = {0};\n\tfor (int i\
    \ = 0; i < l.length; ++i)\n\t{\n\t\tif (l[i] != value)\n\t\t\tr[r.length] = l[i];\n\
    \t}\n\treturn r;\n}\n/*\nReturn only numbers in the list that are not the given\
    \ value.\n            \n*/\nlong[] get_not_equal_to(long[] l, double value) \n\
    {\n\tlong[] r = {0};\n\tfor (int i = 0; i < l.length; ++i)\n\t{\n\t\tif (l[i]\
    \ != value)\n\t\t\tr[r.length] = l[i];\n\t}\n\treturn r;\n}\n/*\nReturn only number\n\
    unittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpe7ui322l.d(114): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe7ui322l.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only negative\
    \ numbers in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\
    \    long[] result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n\
    \    {\n        if(l[i] < 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        if(l[i] == 0)\n            result[i] = l[i];\n    }\n \
    \   return result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n\
    \        if(l[i] % 3 == 0)\n            result[i] = l[i];\n    }\n    return result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 5.\n            \n\
    */\nlong[] get_divisible_by_5(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] % 5 == 0)\n   \
    \         result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 7.\n            \n*/\nlong[] get_divisible_by_7(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        if(l[i] % 7 == 0)\n            result[i] = l[i];\n    }\n\
    \    return result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n\
    \        if(l[i] % 11 == 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn only numbers in the list that are divisible by 13.\n\
    \            \n*/\nlong[] get_divisible_by_13(long[] l) \n{\n    long[] result\
    \ = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n      \
    \  if(l[i] % 13 == 0)\n            result[i] = l[i];\n    }\n    return result;\n\
    }\n/*\nReturn only \nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpto4kf2sj.d(114): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpto4kf2sj.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t\tr[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ r;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpj_th1icx.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpj_th1icx.__unittest_L13_C1() [0x427fb9]

    ??:? void tmpj_th1icx.__modtest() [0x428258]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpuf4c2o00.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284cd]

    ??:? void tmpuf4c2o00.__unittest_L13_C1() [0x427fad]

    ??:? void tmpuf4c2o00.__modtest() [0x42824c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5ab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b43e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b78]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430655]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]

    ??:? runModuleUnitTests [0x42c381]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\t\
    result[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers\
    \ in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\
    \tif (l[i] < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\
    \treturn result;\n}\n/*\nReturn only numbers in the list that are divisible by\
    \ n.\n            \n*/\nlong[] get_divisible_by(long[] l, long n) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\
    \tif (l[i] % n == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are not divisible by n.\n        \
    \    \n*/\nlong[] get_not_divisible_by(long[] l, long n) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i]\
    \ % n != 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n\
    /*\nReturn only numbers in the list that are less than n.\n            \n*/\n\
    long[] get_less_than(long[] l, long n) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] < n) \n\t\t{\n\t\t\t\
    result[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in\
    \ the list that are greater than n.\n            \n*/\nlong[] get_greater_than(long[]\
    \ l, long n) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i <\
    \ l.length; i++) \n\t{\n\t\tif (l[i] > n) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\
    \t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are less\
    \ than or equal to n.\n            \n*/\nlong[] get_less_than_or_equal_to(long\n\
    unittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7q5wl7mi.d(119): Error: found `unittest` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7q5wl7mi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9an9q3ul.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmp9an9q3ul.__unittest_L16_C1() [0x427fb5]

    ??:? void tmp9an9q3ul.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvdsv8u_6.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpvdsv8u_6.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpvdsv8u_6.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpi1i10oez.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpi1i10oez.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpi1i10oez.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpgjf6jfze.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpgjf6jfze.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpgjf6jfze.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprdjqi7ck.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmprdjqi7ck.__unittest_L18_C1() [0x427fb5]

    ??:? void tmprdjqi7ck.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\t\
    result[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmw2wt9tq.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpmw2wt9tq.__unittest_L18_C1() [0x427fb5]

    ??:? void tmpmw2wt9tq.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprdjqi7ck.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmprdjqi7ck.__unittest_L18_C1() [0x427fb5]

    ??:? void tmprdjqi7ck.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpuf4c2o00.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284cd]

    ??:? void tmpuf4c2o00.__unittest_L13_C1() [0x427fad]

    ??:? void tmpuf4c2o00.__modtest() [0x42824c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5ab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b43e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b78]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430655]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]

    ??:? runModuleUnitTests [0x42c381]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] < 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are\
    \ even.\n            \n*/\nlong[] get_even(long[] l) \n{\n\tlong[] result = new\
    \ long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] % 2 ==\
    \ 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers\
    \ in the list that are odd.\n            \n*/\nlong[] get_odd(long[] l) \n{\n\t\
    long[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t{\n\
    \t\tif(l[i] % 2 != 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\n\
    Return only numbers in the list that are divisible by 3.\n            \n*/\nlong[]\
    \ get_divisible_by_3(long[] l) \n{\n\tlong[] result = new long[l.length];\n\t\
    for(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] % 3 == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 5.\n            \n*/\nlong[] get_divisible_by_5(long[] l) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t{\n\t\tif(l[i] % 5 == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n\
    /*\nReturn only numbers in the list that are divisible by 7.\n            \n*/\n\
    long[] get_divisible_by_7(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] % 7 == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l)\
    \ \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t{\n\t\tif(l[i] % 11 == 0)\n\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmptzkknl46.d(111): Error: found `unittest` instead of statement

    /tmp/tmptzkknl46.d(120): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptzkknl46.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}\n/*\nReturn\
    \ only negative numbers in the list.\n            \n*/\nlong[] get_negative(long[]\
    \ l) \n{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ ++i)\n    {\n        if(l[i] < 0)\n        {\n            res[i] = l[i];\n \
    \       }\n    }\n    return res;\n}\n/*\nReturn only zeros in the list.\n   \
    \         \n*/\nlong[] get_zero(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] == 0)\n       \
    \ {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\n/*\nReturn\
    \ only numbers in the list that are not zero.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l) \n{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ ++i)\n    {\n        if(l[i] != 0)\n        {\n            res[i] = l[i];\n\
    \        }\n    }\n    return res;\n}\n/*\nReturn only numbers in the list that\
    \ are not negative.\n            \n*/\nlong[] get_not_negative(long[] l) \n{\n\
    \    long[] res = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n\
    \    {\n        if(l[i] < 0)\n        {\n            res[i] = l[i];\n        }\n\
    \    }\n    return res;\n}\n/*\nReturn only numbers in the list that are not positive.\n\
    \            \n*/\nlong[] get_not_positive(long[] l) \n{\n    long[] res = new\
    \ long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i]\
    \ > 0)\n        {\n            res[i] = l[i];\n        }\n    }\n    return res;\n\
    }\n/*\nReturn only numbers in the list that are not even.\n            \n*/\n\
    long[] get_not_even(long[] l) \n{\n    long[] res = new long[l.length];\n    for(int\
    \ i = 0; i < l.length; ++i)\n    {\n        if(l[i] % 2 == 0)\n        {\n   \
    \         res[i] = l[i];\n        }\n    }\n    return res;\n}\n/*\nReturn only\
    \ numbers in the list that are not odd.\n            \n*/\nlong[] get_not_odd(long[]\
    \ l) \n{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpej4je_6d.d(122): Error: identifier expected following `.`, not
    `unittest`

    /tmp/tmpej4je_6d.d(123): Error: found `{` when expecting `;` following `for` condition

    /tmp/tmpej4je_6d.d(124): Error: expression expected, not `alias`

    /tmp/tmpej4je_6d.d(124): Error: found `candidate` when expecting `)`

    /tmp/tmpej4je_6d.d(124): Error: found `=` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpej4je_6d.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnthygly7.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpnthygly7.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpnthygly7.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in\
    \ the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i]\
    \ < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\n\
    Return only zeros in the list.\n            \n*/\nlong[] get_zero(long[] l) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n/*\nReturn only numbers in the list that are not zero, negative\
    \ or positive.\n            \n*/\nlong[] get_not_zero(long[] l) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\t\
    if(l[i] != 0 && l[i] != -1 && l[i] != 1) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t\
    }\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are not\
    \ zero, negative or positive.\n            \n*/\nlong[] get_not_negative(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif(l[i] != 0 && l[i] != -1 && l[i] != 1) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list\
    \ that are not zero, negative or positive.\n            \n*/\nlong[] get_not_positive(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif(l[i] != 0 && l[i] != -1 && l[i] != 1) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list\
    \ that are not zero, negative or positive.\n            \n*/\nlong[] get_not_negative_and_not_zero(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif(l[i] != 0 && l[i] != -1 && l[i] != 1) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmphdfqyj_4.d(110): Error: found `unittest` instead of statement

    /tmp/tmphdfqyj_4.d(119): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmphdfqyj_4.d(119): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmphdfqyj_4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg1py0sz3.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpg1py0sz3.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpg1py0sz3.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg1py0sz3.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpg1py0sz3.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpg1py0sz3.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}\n/*\nReturn\
    \ only negative numbers in the list.\n            \n*/\nlong[] get_negative(long[]\
    \ l) \n{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ ++i)\n    {\n        if(l[i] < 0)\n        {\n            res[i] = l[i];\n \
    \       }\n    }\n    return res;\n}\n/*\nReturn only zeros in the list.\n   \
    \         \n*/\nlong[] get_zero(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] == 0)\n       \
    \ {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\n/*\nReturn\
    \ only numbers in the list that are not zero.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l) \n{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ ++i)\n    {\n        if(l[i] != 0)\n        {\n            res[i] = l[i];\n\
    \        }\n    }\n    return res;\n}\n/*\nReturn only numbers in the list that\
    \ are not negative.\n            \n*/\nlong[] get_not_negative(long[] l) \n{\n\
    \    long[] res = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n\
    \    {\n        if(l[i] < 0)\n        {\n            res[i] = l[i];\n        }\n\
    \    }\n    return res;\n}\n/*\nReturn only numbers in the list that are not positive.\n\
    \            \n*/\nlong[] get_not_positive(long[] l) \n{\n    long[] res = new\
    \ long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i]\
    \ > 0)\n        {\n            res[i] = l[i];\n        }\n    }\n    return res;\n\
    }\n/*\nReturn only numbers in the list that are not the given value.\n       \
    \     \n*/\nlong[] get_not_equal_to(long[] l, long value) \n{\n    long[] res\
    \ = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n      \
    \  if(l[i] != value)\n        {\n            res[i] = l[i];\n        }\n    }\n\
    \    return res;\n}\n/*\nReturn only numbers in the list that are not the given\
    \ value.\n            \n*/\nlong[] get_not_equal_to(long[] l, double value) \n\
    {\n    long[] res = new long[l.length\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpat1f2ng0.d(121): Error: found `unittest` when expecting `]`

    /tmp/tmpat1f2ng0.d(122): Error: semicolon expected, not `{`

    /tmp/tmpat1f2ng0.d(130): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpat1f2ng0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpuf4c2o00.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284cd]

    ??:? void tmpuf4c2o00.__unittest_L13_C1() [0x427fad]

    ??:? void tmpuf4c2o00.__modtest() [0x42824c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5ab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b43e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b78]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430655]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]

    ??:? runModuleUnitTests [0x42c381]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only negative\
    \ numbers in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\
    \    long[] result = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n\
    \    {\n        if(l[i] < 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ ++i)\n    {\n        if(l[i] == 0)\n            result[i] = l[i];\n    }\n \
    \   return result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n\
    \        if(l[i] % 3 == 0)\n            result[i] = l[i];\n    }\n    return result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 5.\n            \n\
    */\nlong[] get_divisible_by_5(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] % 5 == 0)\n   \
    \         result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 7.\n            \n*/\nlong[] get_divisible_by_7(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ ++i)\n    {\n        if(l[i] % 7 == 0)\n            result[i] = l[i];\n    }\n\
    \    return result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n\
    \        if(l[i] % 11 == 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn only numbers in the list that are divisible by 13.\n\
    \            \n*/\nlong[] get_divisible_by_13(long[] l) \n{\n    long[] result\
    \ = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n      \
    \  if(l[i] % 13 == 0)\n            result[i] = l[i];\n    }\n\nunittest\n{\n \
    \   alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L,\
    \ 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L,\
    \ 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplyrk9c7t.d(113): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplyrk9c7t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpgjf6jfze.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpgjf6jfze.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpgjf6jfze.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmjukmpu9.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpmjukmpu9.__unittest_L13_C1() [0x427fb9]

    ??:? void tmpmjukmpu9.__modtest() [0x428258]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    int i = 0;\n    for(; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n \
    \       {\n            result[i] = l[i];\n        }\n    }\n    return result;\n\
    }\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[] get_negative(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    int i = 0;\n    for(; i\
    \ < l.length; ++i)\n    {\n        if(l[i] < 0)\n        {\n            result[i]\
    \ = l[i];\n        }\n    }\n    return result;\n}\n/*\nReturn only zeros in the\
    \ list.\n            \n*/\nlong[] get_zero(long[] l) \n{\n    long[] result =\
    \ new long[l.length];\n    int i = 0;\n    for(; i < l.length; ++i)\n    {\n \
    \       if(l[i] == 0)\n        {\n            result[i] = l[i];\n        }\n \
    \   }\n    return result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    int i = 0;\n    for(; i < l.length; ++i)\n\
    \    {\n        if(l[i] % 3 == 0)\n        {\n            result[i] = l[i];\n\
    \        }\n    }\n    return result;\n}\n/*\nReturn only numbers in the list\
    \ that are divisible by 5.\n            \n*/\nlong[] get_divisible_by_5(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    int i = 0;\n    for(; i\
    \ < l.length; ++i)\n    {\n        if(l[i] % 5 == 0)\n        {\n            result[i]\
    \ = l[i];\n        }\n    }\n    return result;\n}\n/*\nReturn only numbers in\
    \ the list that are divisible by 7.\n            \n*/\nlong[] get_divisible_by_7(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    int i = 0;\n    for(; i\
    \ < l.length; ++i)\n    {\n        if(l[i] % 7 == 0)\n        {\n            result[i]\
    \ = l[i];\n        }\n    }\n    return result;\n}\n/*\nReturn only numbers in\
    \ the list that are divisible by 11.\n            \n*/\nlong[] get_divisible_by_11(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    int i = 0;\n    for(; i\
    \ < l.length; ++i)\n    {\n        if(l[i] % 11 == 0)\n        {\n           \
    \ result[i] = l[i];\n        }\n    }\n    return result;\n}\n/*\nReturn only\
    \ numbers in the list that are divisible by 13.\n            \n*/\nlong\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7lfby_b6.d(126): Error: no identifier for declarator `long`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7lfby_b6.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only negative numbers in the list.\n       \
    \     \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] < 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only zeros in the list.\n            \n*/\n\
    long[] get_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i\
    \ = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] == 0) \n\t\t\tres[i] = l[i];\n\t\
    }\n\treturn res;\n}\n/*\nReturn only numbers in the list that are not zero.\n\
    \            \n*/\nlong[] get_not_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] != 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are not\
    \ negative.\n            \n*/\nlong[] get_not_negative(long[] l) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i]\
    \ < 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not positive.\n            \n*/\nlong[] get_not_positive(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\n\
    Return only numbers in the list that are not even.\n            \n*/\nlong[] get_not_even(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] % 2 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n\
    /*\nReturn only numbers in the list that are not odd.\n            \n*/\nlong[]\
    \ get_not_odd(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i =\
    \ 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 2 != 0) \n\t\t\tres[i] = l[i];\n\t\
    }\n\treturn res;\n}\n/*\nReturn \nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9c3t1o8f.d(114): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9c3t1o8f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpuf4c2o00.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284cd]

    ??:? void tmpuf4c2o00.__unittest_L13_C1() [0x427fad]

    ??:? void tmpuf4c2o00.__modtest() [0x42824c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5ab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b43e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b78]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430655]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]

    ??:? runModuleUnitTests [0x42c381]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmjukmpu9.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpmjukmpu9.__unittest_L13_C1() [0x427fb9]

    ??:? void tmpmjukmpu9.__modtest() [0x428258]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmph7ib4irf.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmph7ib4irf.__unittest_L13_C1() [0x427fb9]

    ??:? void tmph7ib4irf.__modtest() [0x428258]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n      \
    \  {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpz1ua0iv5.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpz1ua0iv5.__unittest_L18_C1() [0x427fb5]

    ??:? void tmpz1ua0iv5.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpgjf6jfze.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpgjf6jfze.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpgjf6jfze.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n      \
    \  {\n            result[i] = l[i];\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpoate52pu.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpoate52pu.__unittest_L18_C1() [0x427fb5]

    ??:? void tmpoate52pu.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpgjf6jfze.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpgjf6jfze.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpgjf6jfze.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmplap82hkq.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmplap82hkq.__unittest_L16_C1() [0x427fb5]

    ??:? void tmplap82hkq.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprdjqi7ck.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmprdjqi7ck.__unittest_L18_C1() [0x427fb5]

    ??:? void tmprdjqi7ck.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] < 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only zeros in the list.\n         \
    \   \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\t\
    for (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list.\n       \
    \     \n*/\nlong[] get_number(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] != 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list.\n     \
    \       \n*/\nlong[] get_number_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list.\n       \
    \     \n*/\nlong[] get_number_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] < 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list.\n       \
    \     \n*/\nlong[] get_number_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list.\n     \
    \       \n*/\nlong[] get_number_number(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] != 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list.\n     \
    \       \n*/\nlong[] get_number_number_positive(long[] l) \n{\n\tlong[] \nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpekzubjdl.d(121): Error: no identifier for declarator `long[]`

    /tmp/tmpekzubjdl.d(121): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpekzubjdl.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpk5ht99np.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpk5ht99np.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpk5ht99np.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] < 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are\
    \ even numbers.\n            \n*/\nlong[] get_even(long[] l) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i]\
    \ % 2 == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only\
    \ numbers in the list that are odd numbers.\n            \n*/\nlong[] get_odd(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++)\n\t{\n\t\tif(l[i] % 2 != 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 3.\n            \n\
    */\nlong[] get_divisible_by_3(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] % 3 == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 5.\n            \n*/\nlong[] get_divisible_by_5(long[] l) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t{\n\t\tif(l[i] % 5 == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n\
    /*\nReturn only numbers in the list that are divisible by 7.\n            \n*/\n\
    long[] get_divisible_by_7(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] % 7 == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l)\
    \ \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t{\n\t\tif(l[i] % 11 == 0)\n\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpi_frbkcs.d(111): Error: found `unittest` instead of statement

    /tmp/tmpi_frbkcs.d(120): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi_frbkcs.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\t\
    result[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmw2wt9tq.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpmw2wt9tq.__unittest_L18_C1() [0x427fb5]

    ??:? void tmpmw2wt9tq.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[]\
    \ get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i\
    \ = 0; i < l.length; ++i)\n\t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn res;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ ++i)\n\t\tres[i] = l[i] == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only ones\
    \ in the list.\n            \n*/\nlong[] get_one(long[] l) \n{\n\tlong[] res =\
    \ new long[l.length];\n\tfor (int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i]\
    \ == 1 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only twos in the list.\n       \
    \     \n*/\nlong[] get_two(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] == 2 ? 1 : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only threes in the list.\n            \n*/\nlong[] get_three(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ ++i)\n\t\tres[i] = l[i] == 3 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only fours\
    \ in the list.\n            \n*/\nlong[] get_four(long[] l) \n{\n\tlong[] res\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i]\
    \ == 4 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only fives in the list.\n      \
    \      \n*/\nlong[] get_five(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] == 5 ? 1 : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only sixes in the list.\n            \n*/\nlong[] get_six(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ ++i)\n\t\tres[i] = l[i] == 6 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only sevens\
    \ in the list.\n            \n*/\nlong[] get_seven(long[] l) \n\nunittest\n{\n\
    \    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L,\
    \ 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L,\
    \ 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp2j131o2b.d(107): Error: semicolon expected following function declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2j131o2b.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmph7ib4irf.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmph7ib4irf.__unittest_L13_C1() [0x427fb9]

    ??:? void tmph7ib4irf.__modtest() [0x428258]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n      \
    \  {\n            result[i] = l[i];\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpoate52pu.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpoate52pu.__unittest_L18_C1() [0x427fb5]

    ??:? void tmpoate52pu.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n      \
    \  {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpz1ua0iv5.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpz1ua0iv5.__unittest_L18_C1() [0x427fb5]

    ??:? void tmpz1ua0iv5.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnhdo8v0t.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpnhdo8v0t.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpnhdo8v0t.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only negative numbers in the list.\n       \
    \     \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] < 0)\n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only zeros in the list.\n            \n*/\n\
    long[] get_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int\
    \ i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] == 0)\n\t\t\tres[i] = l[i];\n\t\
    }\n\treturn res;\n}\n/*\nReturn only numbers in the list that are not zero, negative\
    \ or positive.\n            \n*/\nlong[] get_not_zero(long[] l) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif\
    \ (l[i] != 0)\n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not zero, negative or positive.\n            \n*/\nlong[]\
    \ get_not_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int\
    \ i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] != 0)\n\t\t\tres[i] = l[i];\n\t\
    }\n\treturn res;\n}\n/*\nReturn only numbers in the list that are not zero, negative\
    \ or positive.\n            \n*/\nlong[] get_not_positive(long[] l) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif\
    \ (l[i] != 0)\n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not zero, negative or positive.\n            \n*/\nlong[]\
    \ get_not_zero_and_not_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] != 0 && l[i] != 0)\n\t\
    \t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list\
    \ that are not zero, negative or positive.\n            \n*/\nlong[] get_not_zero_and_not_positive(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t{\n\t\tif (\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp7ocagid0.d(110): Error: expression expected, not `unittest`

    /tmp/tmp7ocagid0.d(111): Error: found `{` when expecting `)`

    /tmp/tmp7ocagid0.d(119): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7ocagid0.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmph7ib4irf.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmph7ib4irf.__unittest_L13_C1() [0x427fb9]

    ??:? void tmph7ib4irf.__modtest() [0x428258]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tr[i] = l[i];\n\
    \t}\n\treturn r;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1spdoucx.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmp1spdoucx.__unittest_L16_C1() [0x427fb5]

    ??:? void tmp1spdoucx.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = {0};\n\tfor (int\
    \ i = 0; i < l.length; ++i)\n\t\tif (l[i] > 0)\n\t\t\tr[r.length] = l[i];\n\t\
    return r;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpym4cyh3u.d(8): Error: a struct is not a valid initializer for a
    `long[]`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpym4cyh3u.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmplap82hkq.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmplap82hkq.__unittest_L16_C1() [0x427fb5]

    ??:? void tmplap82hkq.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    int i = 0;\n    for (; i < l.length; ++i)\n    {\n        if (l[i] > 0)\n\
    \            result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only\
    \ negative numbers in the list.\n            \n*/\nlong[] get_negative(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    int i = 0;\n    for (;\
    \ i < l.length; ++i)\n    {\n        if (l[i] < 0)\n            result[i] = l[i];\n\
    \    }\n    return result;\n}\n/*\nReturn only zeros in the list.\n          \
    \  \n*/\nlong[] get_zero(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    int i = 0;\n    for (; i < l.length; ++i)\n    {\n        if (l[i] == 0)\n\
    \            result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only\
    \ numbers in the list that are not zero.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    int i = 0;\n    for (;\
    \ i < l.length; ++i)\n    {\n        if (l[i] != 0)\n            result[i] = l[i];\n\
    \    }\n    return result;\n}\n/*\nReturn only numbers in the list that are not\
    \ negative.\n            \n*/\nlong[] get_not_negative(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    int i = 0;\n    for (; i < l.length; ++i)\n\
    \    {\n        if (l[i] < 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn only numbers in the list that are not positive.\n   \
    \         \n*/\nlong[] get_not_positive(long[] l) \n{\n    long[] result = new\
    \ long[l.length];\n    int i = 0;\n    for (; i < l.length; ++i)\n    {\n    \
    \    if (l[i] > 0)\n            result[i] = l[i];\n    }\n    return result;\n\
    }\n/*\nReturn only numbers in the list that are not in the list.\n           \
    \ \n*/\nlong[] get_not_in(long[] l, long[] l2) \n{\n    long[] result = new long[l.length];\n\
    \    int i = 0;\n    for (; i < l.length; ++i)\n    {\n        if (l[i] != l2[i])\n\
    \            result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only\
    \ numbers in the list that are not in the list 2.\n            \n*/\nlong[] get_not_in_2(long[]\
    \ l, long[] l2) \n{\n    long[] result = new long[l.length];\n    int i = 0;\n\
    \    for (; i < l.length; ++i)\n    {\n        if (l[i] != l2[i])\n          \
    \  result[i] = l[i];\n    }\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp1dig581o.d(120): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1dig581o.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\t\
    result[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmw2wt9tq.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpmw2wt9tq.__unittest_L18_C1() [0x427fb5]

    ??:? void tmpmw2wt9tq.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprwf__2q4.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmprwf__2q4.__unittest_L18_C1() [0x427fb5]

    ??:? void tmprwf__2q4.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnhdo8v0t.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpnhdo8v0t.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpnhdo8v0t.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        \
    \    res[i] = l[i];\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp5bp4jq0_.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmp5bp4jq0_.__unittest_L16_C1() [0x427fb5]

    ??:? void tmp5bp4jq0_.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmjukmpu9.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpmjukmpu9.__unittest_L13_C1() [0x427fb9]

    ??:? void tmpmjukmpu9.__modtest() [0x428258]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] < 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only zeros in the list.\n    \
    \        \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by n.\n            \n*/\nlong[] get_divisible_by(long[] l, long\
    \ n) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t{\n\t\tif (l[i] % n == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by n and are less than\
    \ n.\n            \n*/\nlong[] get_less_than(long[] l, long n) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i]\
    \ % n != 0 && l[i] < n)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\n\
    Return only numbers in the list that are divisible by n and are greater than n.\n\
    \            \n*/\nlong[] get_greater_than(long[] l, long n) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i]\
    \ % n != 0 && l[i] > n)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\n\
    Return only numbers in the list that are divisible by n and are less than or equal\
    \ to n.\n            \n*/\nlong[] get_less_than_or_equal_to(long[] l, long n)\
    \ \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t{\n\t\tif (l[i] % n != 0 && l[i] <= n)\n\t\t\tresult[i] = l[i];\n\t\
    }\n\treturn result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by n and are greater than or equal to n.\n            \n*/\nlong[] get_greater_\n\
    unittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpir25rcqi.d(105): Error: semicolon expected, not `unittest`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpir25rcqi.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnthygly7.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpnthygly7.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpnthygly7.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\t\
    result[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers\
    \ in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\
    \tif (l[i] < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\
    \treturn result;\n}\n/*\nReturn only numbers in the list that are divisible by\
    \ given number.\n            \n*/\nlong[] get_divisible_by(long[] l, long d) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif (l[i] % d == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\
    \treturn result;\n}\n/*\nReturn only numbers in the list that are not divisible\
    \ by given number.\n            \n*/\nlong[] get_not_divisible_by(long[] l, long\
    \ d) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % d != 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\
    \t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are less than\
    \ given number.\n            \n*/\nlong[] get_less_than(long[] l, long d) \n{\n\
    \tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\
    \t{\n\t\tif (l[i] < d) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n/*\nReturn only numbers in the list that are greater than given\
    \ number.\n            \n*/\nlong[] get_greater_than(long[] l, long d) \n{\n\t\
    long[] result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t\
    {\n\t\tif (l[i] > d) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are less than or equal to given number.\n\
    \            \n*/\nlong[] get_less_than_or_equal_to(long[] \nunittest\n{\n   \
    \ alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L])\
    \ == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L,\
    \ 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy0w6z1ha.d(119): Error: found `unittest` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy0w6z1ha.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[]\
    \ get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i\
    \ = 0; i < l.length; i++)\n\t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn res;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t\tres[i] = l[i] == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only ones\
    \ in the list.\n            \n*/\nlong[] get_one(long[] l) \n{\n\tlong[] res =\
    \ new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i]\
    \ == 1 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ divisible by given number.\n            \n*/\nlong[] get_divisible_by(long[]\
    \ l, long d) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t\tres[i] = l[i] % d == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only\
    \ numbers in the list that are divisible by given number.\n            \n*/\n\
    long[] get_divisible_by_2(long[] l, long d) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] % d == 0 ? 1 : 0;\n\t\
    return res;\n}\n/*\nReturn only numbers in the list that are divisible by given\
    \ number.\n            \n*/\nlong[] get_divisible_by_3(long[] l, long d) \n{\n\
    \tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\t\
    res[i] = l[i] % d == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in\
    \ the list that are divisible by given number.\n            \n*/\nlong[] get_divisible_by_4(long[]\
    \ l, long d) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t\tres[i] = l[i] % d == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only\
    \ numbers in the list that are divisible by given number.\n            \n*/\n\
    long[] get_divisible_by_5(long[] l, long d) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < \nunittest\n{\n    alias candidate = get_positive;\n\n \
    \   assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpq2a5ohg4.d(98): Error: expression expected, not `unittest`

    /tmp/tmpq2a5ohg4.d(99): Error: found `{` when expecting `;` following `for` condition

    /tmp/tmpq2a5ohg4.d(100): Error: expression expected, not `alias`

    /tmp/tmpq2a5ohg4.d(100): Error: found `candidate` when expecting `)`

    /tmp/tmpq2a5ohg4.d(100): Error: found `=` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq2a5ohg4.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmjukmpu9.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpmjukmpu9.__unittest_L13_C1() [0x427fb9]

    ??:? void tmpmjukmpu9.__modtest() [0x428258]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    int i = 0;\n    for(; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n \
    \           result[i] = l[i];\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L])\
    \ == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L,\
    \ 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpc9vtobzi.d(21): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpc9vtobzi.__unittest_L17_C1() [0x427fb5]

    ??:? void tmpc9vtobzi.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpuf4c2o00.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284cd]

    ??:? void tmpuf4c2o00.__unittest_L13_C1() [0x427fad]

    ??:? void tmpuf4c2o00.__modtest() [0x42824c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5ab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b43e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b78]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430655]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]

    ??:? runModuleUnitTests [0x42c381]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpuf4c2o00.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284cd]

    ??:? void tmpuf4c2o00.__unittest_L13_C1() [0x427fad]

    ??:? void tmpuf4c2o00.__modtest() [0x42824c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5ab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b43e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b78]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430655]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]

    ??:? runModuleUnitTests [0x42c381]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmjukmpu9.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpmjukmpu9.__unittest_L13_C1() [0x427fb9]

    ??:? void tmpmjukmpu9.__modtest() [0x428258]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprwf__2q4.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmprwf__2q4.__unittest_L18_C1() [0x427fb5]

    ??:? void tmprwf__2q4.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp9an9q3ul.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmp9an9q3ul.__unittest_L16_C1() [0x427fb5]

    ??:? void tmp9an9q3ul.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpd4ihdaf7.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpd4ihdaf7.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpd4ihdaf7.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpi1i10oez.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpi1i10oez.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpi1i10oez.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\t\
    result[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers\
    \ in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\
    \tif (l[i] < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\
    \treturn result;\n}\n/*\nReturn only numbers in the list that are divisible by\
    \ 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i]\
    \ % 3 == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n\
    /*\nReturn only numbers in the list that are divisible by 5.\n            \n*/\n\
    long[] get_divisible_by_5(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] % 5 == 0) \n\t\t{\n\t\
    \t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 7.\n            \n*/\nlong[] get_divisible_by_7(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % 7 == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\
    \t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\
    \tif (l[i] % 11 == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 13.\n           \
    \ \n*/\nlong[] get_divisible_by_13(long[] \nunittest\n{\n    alias candidate =\
    \ get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n\
    \    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L,\
    \ 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) == []);\n\
    \    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpbpem8eaf.d(119): Error: found `unittest` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpbpem8eaf.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmph7ib4irf.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmph7ib4irf.__unittest_L13_C1() [0x427fb9]

    ??:? void tmph7ib4irf.__modtest() [0x428258]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\t\
    result[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmw2wt9tq.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpmw2wt9tq.__unittest_L18_C1() [0x427fb5]

    ??:? void tmpmw2wt9tq.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] < 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only zeros in the list.\n         \
    \   \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\t\
    for (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n\tlong[] res\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i]\
    \ % 3 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 5.\n            \n*/\nlong[] get_divisible_by_5(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % 5 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 7.\n            \n\
    */\nlong[] get_divisible_by_7(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] % 7 == 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ divisible by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l) \n\
    {\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\
    \t{\n\t\tif (l[i] % 11 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\n\
    Return only numbers in the list that are divisible by 13.\n            \n*/\n\
    long[] get_divisible_by_13(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l\nunittest\n{\n    alias\
    \ candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) ==\
    \ [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L,\
    \ 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpm9wfg0xy.d(110): Error: found `unittest` when expecting `)`

    /tmp/tmpm9wfg0xy.d(119): Error: found `End of File` when expecting `}` following
    compound statement

    /tmp/tmpm9wfg0xy.d(119): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpm9wfg0xy.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate =\
    \ get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n\
    \    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L,\
    \ 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) == []);\n\
    \    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_k4mfmiv.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmp_k4mfmiv.__unittest_L18_C1() [0x427fb5]

    ??:? void tmp_k4mfmiv.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tr[i] = l[i];\n\
    \t}\n\treturn r;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpbd5sl78b.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpbd5sl78b.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpbd5sl78b.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnhdo8v0t.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpnhdo8v0t.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpnhdo8v0t.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = std.math.rem(l[i], 1);\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplduat1a3.d(10): Error: undefined identifier `rem` in module `std.math`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplduat1a3.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tr[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n/*\nReturn only negative numbers in the\
    \ list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] r = new\
    \ long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] < 0)\
    \ \n\t\t{\n\t\t\tr[i] = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n/*\nReturn only zeros\
    \ in the list.\n            \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] r =\
    \ new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i]\
    \ == 0) \n\t\t{\n\t\t\tr[i] = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n/*\nReturn only\
    \ numbers in the list that are divisible by 3.\n            \n*/\nlong[] get_divisible_by_3(long[]\
    \ l) \n{\n\tlong[] r = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] % 3 == 0) \n\t\t{\n\t\t\tr[i] = l[i];\n\t\t}\n\t}\n\treturn\
    \ r;\n}\n/*\nReturn only numbers in the list that are divisible by 5.\n      \
    \      \n*/\nlong[] get_divisible_by_5(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 5 == 0) \n\t\t{\n\t\t\
    \tr[i] = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n/*\nReturn only numbers in the list\
    \ that are divisible by 7.\n            \n*/\nlong[] get_divisible_by_7(long[]\
    \ l) \n{\n\tlong[] r = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] % 7 == 0) \n\t\t{\n\t\t\tr[i] = l[i];\n\t\t}\n\t}\n\treturn\
    \ r;\n}\n/*\nReturn only numbers in the list that are divisible by 11.\n     \
    \       \n*/\nlong[] get_divisible_by_11(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 11 == 0) \n\t\t{\n\t\t\
    \tr[i] = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n/*\nReturn only numbers in the list\
    \ that are divisible by 13.\n            \n*/\nlong[] get_divisible_by_13(long[]\
    \ \nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpupsizibq.d(119): Error: found `unittest` when expecting `)`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpupsizibq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprdjqi7ck.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmprdjqi7ck.__unittest_L18_C1() [0x427fb5]

    ??:? void tmprdjqi7ck.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[]\
    \ get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i\
    \ = 0; i < l.length; i++)\n\t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn res;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in\
    \ the list that are not zero.\n            \n*/\nlong[] get_not_zero(long[] l)\
    \ \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] != 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in\
    \ the list that are not negative.\n            \n*/\nlong[] get_not_negative(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] < 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the\
    \ list that are not positive.\n            \n*/\nlong[] get_not_positive(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] > 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the\
    \ list that are not odd.\n            \n*/\nlong[] get_odd(long[] l) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\tres[i] =\
    \ l[i] % 2 != 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list\
    \ that are not even.\n            \n*/\nlong[] get_even(long[] l) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\tres[i] =\
    \ l[i] % 2 == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list\
    \ that are not divisible by 2.\n            \n*/\nlong[] get_not_divisible_by_2(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] % 2 != 0 ? 1 : 0;\n\treturn \nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpill4tr1f.d(100): Error: expression expected, not `unittest`

    /tmp/tmpill4tr1f.d(101): Error: found `{` when expecting `;` following `return`
    statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpill4tr1f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmplap82hkq.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmplap82hkq.__unittest_L16_C1() [0x427fb5]

    ??:? void tmplap82hkq.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpuf4c2o00.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284cd]

    ??:? void tmpuf4c2o00.__unittest_L13_C1() [0x427fad]

    ??:? void tmpuf4c2o00.__modtest() [0x42824c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5ab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b43e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b78]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430655]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]

    ??:? runModuleUnitTests [0x42c381]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnhdo8v0t.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpnhdo8v0t.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpnhdo8v0t.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpl23apj5m.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpl23apj5m.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpl23apj5m.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnthygly7.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpnthygly7.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpnthygly7.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n        if(l[i] > 0)\n            res[i]\
    \ = l[i];\n    return res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpm44dewpr.d(18): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpm44dewpr.__unittest_L14_C1() [0x427fb5]

    ??:? void tmpm44dewpr.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmjukmpu9.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpmjukmpu9.__unittest_L13_C1() [0x427fb9]

    ??:? void tmpmjukmpu9.__modtest() [0x428258]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n      \
    \  {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpz1ua0iv5.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpz1ua0iv5.__unittest_L18_C1() [0x427fb5]

    ??:? void tmpz1ua0iv5.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tresult[i] = l[i] > 0 ? l[i] : 0;\n\t\
    return result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmfwa3yw9.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284cd]

    ??:? void tmpmfwa3yw9.__unittest_L13_C1() [0x427fad]

    ??:? void tmpmfwa3yw9.__modtest() [0x42824c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5ab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b43e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b78]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430655]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]

    ??:? runModuleUnitTests [0x42c381]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprwf__2q4.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmprwf__2q4.__unittest_L18_C1() [0x427fb5]

    ??:? void tmprwf__2q4.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpk5ht99np.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpk5ht99np.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpk5ht99np.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        \
    \    res[i] = l[i];\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp5bp4jq0_.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmp5bp4jq0_.__unittest_L16_C1() [0x427fb5]

    ??:? void tmp5bp4jq0_.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpd4ihdaf7.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpd4ihdaf7.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpd4ihdaf7.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg1py0sz3.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpg1py0sz3.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpg1py0sz3.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpk5ht99np.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpk5ht99np.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpk5ht99np.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpvdsv8u_6.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpvdsv8u_6.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpvdsv8u_6.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpg1py0sz3.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpg1py0sz3.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpg1py0sz3.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnipcrcx9.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpnipcrcx9.__unittest_L13_C1() [0x427fb9]

    ??:? void tmpnipcrcx9.__modtest() [0x428258]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = {0};\n\tfor (int\
    \ i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\tr[r.length]\
    \ = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n/*\nReturn only negative numbers in the\
    \ list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] r = {0};\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] < 0) \n\t\t{\n\t\t\t\
    r[r.length] = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n/*\nReturn only zeros in the\
    \ list.\n            \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] r = {0};\n\t\
    for (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t{\n\t\t\tr[r.length]\
    \ = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n\
    {\n\tlong[] r = {0};\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i]\
    \ % 3 == 0) \n\t\t{\n\t\t\tr[r.length] = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n/*\n\
    Return only numbers in the list that are divisible by 5.\n            \n*/\nlong[]\
    \ get_divisible_by_5(long[] l) \n{\n\tlong[] r = {0};\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % 5 == 0) \n\t\t{\n\t\t\tr[r.length] = l[i];\n\t\t\
    }\n\t}\n\treturn r;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 7.\n            \n*/\nlong[] get_divisible_by_7(long[] l) \n{\n\tlong[] r\
    \ = {0};\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] % 7 == 0) \n\
    \t\t{\n\t\t\tr[r.length] = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n/*\nReturn only\
    \ numbers in the list that are divisible by 11.\n            \n*/\nlong[] get_divisible_by_11(long[]\
    \ l) \n{\n\tlong[] r = {0};\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\t\
    if (l[i] % 11 == 0) \n\t\t{\n\t\t\tr[r.length] = l[i];\n\t\t}\n\t}\n\treturn r;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 13.\n           \
    \ \n*/\nlong[] get_divisible_by_13(long[] l) \n{\n\tlong\nunittest\n{\n    alias\
    \ candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) ==\
    \ [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L,\
    \ 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpol5lzt7n.d(121): Error: no identifier for declarator `long`

    /tmp/tmpol5lzt7n.d(121): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpol5lzt7n.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate =\
    \ get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n\
    \    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L,\
    \ 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) == []);\n\
    \    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_k4mfmiv.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmp_k4mfmiv.__unittest_L18_C1() [0x427fb5]

    ??:? void tmp_k4mfmiv.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n      \
    \  {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpz1ua0iv5.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpz1ua0iv5.__unittest_L18_C1() [0x427fb5]

    ??:? void tmpz1ua0iv5.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tres[i] = std.math.max(l[i], 0);\n\t\
    return res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpa91y6s_k.d(10): Error: undefined identifier `max` in module `std.math`,
    did you mean function `fmax`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa91y6s_k.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpi1i10oez.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpi1i10oez.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpi1i10oez.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tr[i] = l[i];\n\
    \t}\n\treturn r;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmph3yhee2k.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmph3yhee2k.__unittest_L16_C1() [0x427fb5]

    ??:? void tmph3yhee2k.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpnthygly7.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpnthygly7.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpnthygly7.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tr[i] = l[i];\n\
    \t}\n\treturn r;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1spdoucx.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmp1spdoucx.__unittest_L16_C1() [0x427fb5]

    ??:? void tmp1spdoucx.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1o023viu.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284cd]

    ??:? void tmp1o023viu.__unittest_L13_C1() [0x427fad]

    ??:? void tmp1o023viu.__modtest() [0x42824c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5ab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b43e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b78]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430655]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]

    ??:? runModuleUnitTests [0x42c381]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprdjqi7ck.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmprdjqi7ck.__unittest_L18_C1() [0x427fb5]

    ??:? void tmprdjqi7ck.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only negative\
    \ numbers in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\
    \    long[] result = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n\
    \    {\n        if(l[i] < 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ ++i)\n    {\n        if(l[i] == 0)\n            result[i] = l[i];\n    }\n \
    \   return result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n\
    \        if(l[i] % 3 == 0)\n            result[i] = l[i];\n    }\n    return result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 5.\n            \n\
    */\nlong[] get_divisible_by_5(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] % 5 == 0)\n   \
    \         result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 7.\n            \n*/\nlong[] get_divisible_by_7(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ ++i)\n    {\n        if(l[i] % 7 == 0)\n            result[i] = l[i];\n    }\n\
    \    return result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n\
    \        if(l[i] % 11 == 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn only numbers in the list that are divisible by 13.\n\
    \            \n*/\nlong[] get_divisible_by_13(long[] l) \n{\n    long[] result\
    \ = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n      \
    \  if(l[i] % 13 == 0)\n            result[i] = l[i];\n    }\n\nunittest\n{\n \
    \   alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L,\
    \ 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L,\
    \ 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmplyrk9c7t.d(113): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplyrk9c7t.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmph7ib4irf.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmph7ib4irf.__unittest_L13_C1() [0x427fb9]

    ??:? void tmph7ib4irf.__modtest() [0x428258]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpi1i10oez.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpi1i10oez.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpi1i10oez.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprdjqi7ck.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmprdjqi7ck.__unittest_L18_C1() [0x427fb5]

    ??:? void tmprdjqi7ck.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in\
    \ the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i]\
    \ < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\n\
    Return only zeros in the list.\n            \n*/\nlong[] get_zero(long[] l) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n/*\nReturn only numbers in the list that are not zero.\n       \
    \     \n*/\nlong[] get_not_zero(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] != 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list\
    \ that are not negative.\n            \n*/\nlong[] get_not_negative(long[] l)\
    \ \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n/*\nReturn only numbers in the list that are not positive.\n   \
    \         \n*/\nlong[] get_not_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list\
    \ that are not odd.\n            \n*/\nlong[] get_odd(long[] l) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\t\
    if(l[i] % 2 != 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are not even.\n            \n*/\n\
    long[] get_even(long[] l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int\
    \ i = 0; i < l.length; i++) \nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpy2y6n4db.d(122): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpy2y6n4db.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tr[i] = std.math.min(l[i], 0L);\n\treturn\
    \ r;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmprwhpgm_f.d(10): Error: undefined identifier `min` in module `std.math`,
    did you mean function `sin`?

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprwhpgm_f.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[]\
    \ get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i\
    \ = 0; i < l.length; ++i)\n\t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn res;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\
    \t\tres[i] = l[i] == 0 ? 0 : l[i];\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by given number.\n            \n*/\nlong[] get_divisible_by(long[]\
    \ l, long d) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ ++i)\n\t\tres[i] = l[i] % d == 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only\
    \ numbers in the list that are divisible by given number.\n            \n*/\n\
    long[] get_divisible_by_array(long[] l, long[] d) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] % d[i] == 0 ? l[i] : 0;\n\
    \treturn res;\n}\n/*\nReturn only numbers in the list that are divisible by given\
    \ number.\n            \n*/\nlong[] get_divisible_by_array(long[] l, long[] d,\
    \ int len) \n{\n\tlong[] res = new long[len];\n\tfor(int i = 0; i < len; ++i)\n\
    \t\tres[i] = l[i] % d[i] == 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by given number.\n            \n*/\nlong[] get_divisible_by_array(long[]\
    \ l, long[] d, long[] m) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i\
    \ = 0; i < l.length; ++i)\n\t\tres[i] = l[i] % d[i] == 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only numbers in the list that are divisible by given number.\n\
    \            \n*/\nlong[] get_divisible_by_array(long[] l, long[] d, long[] m,\
    \ int len) \n{\n\tlong[] res = new long[len];\n\tfor(int i = 0; i < len; ++i)\n\
    \t\tres[i] = l[i] % d[i] == 0 ? l[i] : 0;\n\treturn res;\n\nunittest\n{\n    alias\
    \ candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) ==\
    \ [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L,\
    \ 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpklcn907r.d(90): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpklcn907r.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        \
    \    res[i] = l[i];\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp5bp4jq0_.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmp5bp4jq0_.__unittest_L16_C1() [0x427fb5]

    ??:? void tmp5bp4jq0_.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only negative numbers in the list.\n       \
    \     \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] < 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only zeros in the list.\n            \n*/\n\
    long[] get_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i\
    \ = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] == 0) \n\t\t\tres[i] = l[i];\n\t\
    }\n\treturn res;\n}\n/*\nReturn only numbers in the list that are not zero.\n\
    \            \n*/\nlong[] get_not_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] != 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are not\
    \ negative.\n            \n*/\nlong[] get_not_negative(long[] l) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i]\
    \ < 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not positive.\n            \n*/\nlong[] get_not_positive(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\n\
    Return only numbers in the list that are not odd.\n            \n*/\nlong[] get_odd(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] % 2 != 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n\
    /*\nReturn only numbers in the list that are not even.\n            \n*/\nlong[]\
    \ get_even(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0;\
    \ i < l.length; i++) \n\t{\n\t\tif(l[i] % 2 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\
    \treturn res;\n}\n/*\nReturn only number\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpf0mxsqcv.d(114): Error: unterminated /* */ comment

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf0mxsqcv.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpmjukmpu9.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpmjukmpu9.__unittest_L13_C1() [0x427fb9]

    ??:? void tmpmjukmpu9.__modtest() [0x428258]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\t\
    result[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers\
    \ in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\
    \tif (l[i] < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\
    \treturn result;\n}\n/*\nReturn only numbers in the list that are divisible by\
    \ given number.\n            \n*/\nlong[] get_divisible_by(long[] l, long d) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif (l[i] % d == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\
    \treturn result;\n}\n/*\nReturn only numbers in the list that are divisible by\
    \ given number.\n            \n*/\nlong[] get_divisible_by_2(long[] l, long d)\
    \ \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % d == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\
    \t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by given number.\n            \n*/\nlong[] get_divisible_by_3(long[] l, long\
    \ d) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % d == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\
    \t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by given number.\n            \n*/\nlong[] get_divisible_by_4(long[] l, long\
    \ d) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % d == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\
    \t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by given number.\n            \n*/\nlong[] get_di\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp9knoo4q_.d(119): Error: semicolon expected, not `unittest`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9knoo4q_.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only negative numbers in the list.\n       \
    \     \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] < 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n\tlong[] res\
    \ = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i]\
    \ % 3 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 5.\n            \n*/\nlong[] get_divisible_by_5(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] % 5 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n\
    /*\nReturn only numbers in the list that are divisible by 7.\n            \n*/\n\
    long[] get_divisible_by_7(long[] l) \n{\n\tlong[] res = new long[l.length];\n\t\
    for(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 7 == 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ divisible by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l) \n\
    {\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t\
    {\n\t\tif(l[i] % 11 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\n\
    Return only numbers in the list that are divisible by 15.\n            \n*/\n\
    long[] get_divisible_by_15(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 15 == 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ divisible by 17.\n            \n*/\nlong[] get_divisible_by_17(long[] l) \n\
    {\n\tlong[] res = new long[l.length];\n\t\nunittest\n{\n    alias candidate =\
    \ get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n\
    \    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L,\
    \ 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) == []);\n\
    \    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp6f20xdzm.d(108): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp6f20xdzm.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpgjf6jfze.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpgjf6jfze.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpgjf6jfze.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmprdjqi7ck.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmprdjqi7ck.__unittest_L18_C1() [0x427fb5]

    ??:? void tmprdjqi7ck.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tresult[i] = std.math.get_positive(l[i]);\n\
    \treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp22pgfqdt.d(10): Error: undefined identifier `get_positive` in module
    `std.math`

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp22pgfqdt.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[]\
    \ get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i\
    \ = 0; i < l.length; i++)\n\t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn res;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] == 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not zero in the list.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] != 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not zero in the list.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l, int len) \n{\n\tlong[] res = new long[len];\n\tfor(int i = 0; i < len; i++)\n\
    \t\tres[i] = l[i] != 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not zero in the list.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l, long[] len) \n{\n\tlong[] res = new long[len.length];\n\tfor(int i = 0; i\
    \ < len.length; i++)\n\t\tres[i] = l[i] != 0 ? l[i] : 0;\n\treturn res;\n}\n/*\n\
    Return only numbers in the list that are not zero in the list.\n            \n\
    */\nlong[] get_not_zero(long[] l, long[] len, int len2) \n{\n\tlong[] res = new\
    \ long[len2];\n\tfor(int i = 0; i < len2; i++)\n\t\tres[i] = l[i] != 0 ? l[i]\
    \ : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list that are not zero\
    \ in the list.\n            \n*/\nlong[] get_not_zero(long[] l, long[] len, long[]\
    \ len2) \n{\n\tlong[] res = new long[len2];\n\tfor(int i = 0; i < len2; i++)\n\
    \t\tres[i] = l[i] != 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not zero in the list.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l, long[] len, long[] len2, int len3) \nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmpjw6rk1ty.d(95): Error: semicolon expected following function declaration

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpjw6rk1ty.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpi1i10oez.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpi1i10oez.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpi1i10oez.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpl2u5s_od.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpl2u5s_od.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpl2u5s_od.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] < 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only zeros in the list.\n         \
    \   \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\t\
    for (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are not\
    \ zero in the list.\n            \n*/\nlong[] get_not_zero(long[] l) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\t\
    if (l[i] != 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only\
    \ numbers in the list that are not in the list in the list.\n            \n*/\n\
    long[] get_not_in(long[] l, long[] l2) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (!std.array.contains(l2, l[i]))\
    \ \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the\
    \ list that are not in the list in the list.\n            \n*/\nlong[] get_not_in_long(long[]\
    \ l, long[] l2) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i <\
    \ l.length; i++) \n\t{\n\t\tif (!std.array.contains(l2, l[i])) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ not in the list in the list.\n            \n*/\nlong[] get_not_in_double(long[]\
    \ l, long[] l2) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i <\
    \ l.length; i++) \n\t{\n\t\tif (!std.array.contains(l2, l[i])) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ not in the list in the list.\n            \n*/\nlong[] get_not_in_string(long[]\
    \ l, long[] l2) \n{\n\tlong[] res = new long\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp0ucrhhzq.d(107): Error: semicolon expected, not `unittest`

    /tmp/tmp0ucrhhzq.d(107): Error: found `unittest` instead of statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp0ucrhhzq.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only negative numbers in the list.\n       \
    \     \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] < 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are even.\n  \
    \          \n*/\nlong[] get_even(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 2 == 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ odd.\n            \n*/\nlong[] get_odd(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 2 != 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ divisible by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n\
    \tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\
    \t\tif(l[i] % 3 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn\
    \ only numbers in the list that are divisible by 5.\n            \n*/\nlong[]\
    \ get_divisible_by_5(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int\
    \ i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 5 == 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 7.\n            \n*/\nlong[] get_divisible_by_7(long[] l) \n{\n\tlong[] res\
    \ = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i]\
    \ % 7 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 11.\n            \n*/\nlong[] get_divisible_by_11(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: '/tmp/tmp279pikap.d(110): Error: expression expected, not `unittest`

    /tmp/tmp279pikap.d(111): Error: found `{` when expecting `)`

    /tmp/tmp279pikap.d(119): Error: found `End of File` when expecting `}` following
    compound statement

    Failed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp279pikap.d", "-I/tmp"]

    '
  stdout: ''
  timestamp: 1660163990
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmpi1i10oez.d(20): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmpi1i10oez.__unittest_L16_C1() [0x427fb5]

    ??:? void tmpi1i10oez.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate =\
    \ get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n\
    \    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L,\
    \ 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) == []);\n\
    \    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp_k4mfmiv.d(22): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284d5]

    ??:? void tmp_k4mfmiv.__unittest_L18_C1() [0x427fb5]

    ??:? void tmp_k4mfmiv.__modtest() [0x428254]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5b3]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b446]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306d1]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b80]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x43065d]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b41d]

    ??:? runModuleUnitTests [0x42c389]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428998]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: Exception
  stderr: 'core.exception.AssertError@/tmp/tmp1o023viu.d(17): unittest failure

    ----------------

    ??:? _d_unittestp [0x4284cd]

    ??:? void tmp1o023viu.__unittest_L13_C1() [0x427fad]

    ??:? void tmp1o023viu.__modtest() [0x42824c]

    ??:? int core.runtime.runModuleUnitTests().__foreachbody2(object.ModuleInfo*)
    [0x42c5ab]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)).__lambda2(immutable(object.ModuleInfo*))
    [0x42b43e]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*))).__foreachbody2(ref
    rt.sections_elf_shared.DSO) [0x4306c9]

    ??:? int rt.sections_elf_shared.DSO.opApply(scope int delegate(ref rt.sections_elf_shared.DSO))
    [0x430b78]

    ??:? int rt.minfo.moduleinfos_apply(scope int delegate(immutable(object.ModuleInfo*)))
    [0x430655]

    ??:? int object.ModuleInfo.opApply(scope int delegate(object.ModuleInfo*)) [0x42b415]

    ??:? runModuleUnitTests [0x42c381]

    ??:? void rt.dmain2._d_run_main(int, char**, extern (C) int function(char[][])*).runAll()
    [0x428990]

    ??:? void rt.dmain2._d_r'
  stdout: ''
  timestamp: 1660163989
