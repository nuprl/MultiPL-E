language: d
name: HumanEval_30_get_positive
results:
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tr[i] = l[i];\n\
    \t}\n\treturn r;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpntnup49u.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7nzo45xl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcvj95udf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] < 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are\
    \ even numbers.\n            \n*/\nlong[] get_even(long[] l) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i]\
    \ % 2 == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only\
    \ numbers in the list that are odd numbers.\n            \n*/\nlong[] get_odd(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++)\n\t{\n\t\tif(l[i] % 2 != 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 3.\n            \n\
    */\nlong[] get_divisible_by_3(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] % 3 == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 5.\n            \n*/\nlong[] get_divisible_by_5(long[] l) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t{\n\t\tif(l[i] % 5 == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n\
    /*\nReturn only numbers in the list that are divisible by 7.\n            \n*/\n\
    long[] get_divisible_by_7(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] % 7 == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l)\
    \ \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t{\n\t\tif(l[i] % 11 == 0)\n\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7rkhlc3x.d(111): Error: found \''unittest\'' instead of statement\n/tmp/tmp7rkhlc3x.d(120):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7rkhlc3x.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpni_beasv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = {0};\n\tfor(int\
    \ i = 0; i < l.length; ++i)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tr[r.length] = l[i];\n\
    \t}\n\treturn r;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnlplkt6p.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpni_beasv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only negative\
    \ numbers in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\
    \    long[] result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n\
    \    {\n        if(l[i] < 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn only numbers in the list that are even numbers.\n   \
    \         \n*/\nlong[] get_even(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] % 2 == 0)\n   \
    \         result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only numbers\
    \ in the list that are odd numbers.\n            \n*/\nlong[] get_odd(long[] l)\
    \ \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        if(l[i] % 2 != 0)\n            result[i] = l[i];\n    }\n\
    \    return result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n\
    \        if(l[i] % 3 == 0)\n            result[i] = l[i];\n    }\n    return result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 5.\n            \n\
    */\nlong[] get_divisible_by_5(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] % 5 == 0)\n   \
    \         result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 7.\n            \n*/\nlong[] get_divisible_by_7(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        if(l[i] % 7 == 0)\n            result[i] = l[i];\n    }\n\
    \    return result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n\
    \        if(l[i] % 11 == 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn \nunittest\n{\n    alias candidate = get_positive;\n\n\
    \    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp69vil71d.d(114): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp69vil71d.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t\tr[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ r;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[]\
    \ get_negative(long[] l) \n{\n\tlong[] r = new long[l.length];\n\tfor(int i =\
    \ 0; i < l.length; i++) \n\t\tr[i] = l[i] < 0 ? l[i] : 0;\n\treturn r;\n}\n/*\n\
    Return only zeros in the list.\n            \n*/\nlong[] get_zero(long[] l) \n\
    {\n\tlong[] r = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t\t\
    r[i] = l[i] == 0 ? 0 : l[i];\n\treturn r;\n}\n/*\nReturn only numbers in the list\
    \ that are divisible by n.\n            \n*/\nlong[] get_divisible_by(long[] l,\
    \ long n) \n{\n\tlong[] r = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t\tr[i] = l[i] % n == 0 ? l[i] : 0;\n\treturn r;\n}\n/*\nReturn only\
    \ numbers in the list that are not divisible by n.\n            \n*/\nlong[] get_not_divisible_by(long[]\
    \ l, long n) \n{\n\tlong[] r = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t\tr[i] = l[i] % n != 0 ? l[i] : 0;\n\treturn r;\n}\n/*\nReturn only\
    \ numbers in the list that are less than n.\n            \n*/\nlong[] get_less_than(long[]\
    \ l, long n) \n{\n\tlong[] r = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t\tr[i] = l[i] < n ? l[i] : 0;\n\treturn r;\n}\n/*\nReturn only numbers\
    \ in the list that are greater than n.\n            \n*/\nlong[] get_greater_than(long[]\
    \ l, long n) \n{\n\tlong[] r = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t\tr[i] = l[i] > n ? l[i] : 0;\n\treturn r;\n}\n/*\nReturn only numbers\
    \ in the list that are less than or equal to n.\n            \n*/\nlong[] get_less_than_or_equal_to(long[]\
    \ l, long n) \n{\n\tlong[] r = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t\tr[i] = l[i] <= n ? l[i] : 0;\n\treturn r;\n}\n/*\nReturn only numbers\
    \ in the list that are greater than or equal to n.\n            \n*/\nlong[] get_greater_than_or_equal_\n\
    unittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpuq3_13gn.d(95): Error: semicolon expected, not \''unittest\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpuq3_13gn.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptxnwkj8d.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n      \
    \  {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe3pn7ma7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq8hg88zo.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n      \
    \  {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\n/*\nReturn\
    \ only negative numbers in the list.\n            \n*/\nlong[] get_negative(long[]\
    \ l) \n{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++) \n    {\n        if(l[i] < 0) \n        {\n            res[i] = l[i];\n\
    \        }\n    }\n    return res;\n}\n/*\nReturn only zeros in the list.\n  \
    \          \n*/\nlong[] get_zero(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] == 0) \n     \
    \   {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\n/*\n\
    Return only numbers in the list that are not zero.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l) \n{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++) \n    {\n        if(l[i] != 0) \n        {\n            res[i] = l[i];\n\
    \        }\n    }\n    return res;\n}\n/*\nReturn only numbers in the list that\
    \ are not negative.\n            \n*/\nlong[] get_not_negative(long[] l) \n{\n\
    \    long[] res = new long[l.length];\n    for(int i = 0; i < l.length; i++) \n\
    \    {\n        if(l[i] < 0) \n        {\n            res[i] = l[i];\n       \
    \ }\n    }\n    return res;\n}\n/*\nReturn only numbers in the list that are not\
    \ positive.\n            \n*/\nlong[] get_not_positive(long[] l) \n{\n    long[]\
    \ res = new long[l.length];\n    for(int i = 0; i < l.length; i++) \n    {\n \
    \       if(l[i] > 0) \n        {\n            res[i] = l[i];\n        }\n    }\n\
    \    return res;\n}\n/*\nReturn only numbers in the list that are not even.\n\
    \            \n*/\nlong[] get_not_even(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] % 2 == 0) \n \
    \       {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\n\
    /*\nReturn only numbers in the list that are not odd.\n            \n*/\nlong[]\
    \ get_not_odd(long[] l) \n{\n    long[] res = new long[l.length];\n    for(int\
    \ i = 0; i < l.length; i++\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpp40r7ywt.d(122): Error: found \''unittest\'' when expecting
    \'')\''\n/tmp/tmpp40r7ywt.d(131): Error: found \''EOF\'' when expecting \''}\''
    following compound statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp40r7ywt.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpatumcycs.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu20xv4dg.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu63i7qni.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9q0konwr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq52490_i.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq52490_i.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[]\
    \ get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i\
    \ = 0; i < l.length; i++)\n\t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn res;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t\tres[i] = l[i] == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only ones\
    \ in the list.\n            \n*/\nlong[] get_one(long[] l) \n{\n\tlong[] res =\
    \ new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i]\
    \ == 1 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ divisible by n.\n            \n*/\nlong[] get_divisible_by(long[] l, long n)\
    \ \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] % n == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by n.\n            \n*/\nlong[] get_divisible_by_array(long[]\
    \ l, long[] n) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i <\
    \ l.length; i++)\n\t\tres[i] = l[i] % n[i] == 0 ? 1 : 0;\n\treturn res;\n}\n/*\n\
    Return only numbers in the list that are divisible by n.\n            \n*/\nlong[]\
    \ get_divisible_by_array(long[] l, long[] n, int len) \n{\n\tlong[] res = new\
    \ long[len];\n\tfor (int i = 0; i < len; i++)\n\t\tres[i] = l[i] % n[i] == 0 ?\
    \ 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by n.\n            \n*/\nlong[] get_divisible_by_array(long[] l, long[] n, int\
    \ len, int offset) \n{\n\tlong[] res = new long[len];\n\tfor (int i = offset;\
    \ i < len; i++)\n\t\tres[i] = l[i] % n[i] == 0 ? 1 : 0;\n\treturn res;\n}\n/*\n\
    Return only numbers in the list that are divisible by n.\n            \n*/\nlong[]\
    \ get_divisible_by_array(long[] l, long[] n, int len, int offset, int step) \n\
    unittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpi4bxzre2.d(95): Error: semicolon expected following function
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi4bxzre2.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tresult[i] = std.math.max(l[i], 0);\n\
    \treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp63kbfbmi.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\t\
    result[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers\
    \ in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\
    \tif (l[i] < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\
    \treturn result;\n}\n/*\nReturn only numbers in the list that are divisible by\
    \ 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i]\
    \ % 3 == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n\
    /*\nReturn only numbers in the list that are divisible by 5.\n            \n*/\n\
    long[] get_divisible_by_5(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] % 5 == 0) \n\t\t{\n\t\
    \t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 7.\n            \n*/\nlong[] get_divisible_by_7(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % 7 == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\
    \t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\
    \tif (l[i] % 11 == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 13.\n           \
    \ \n*/\nlong[] get_divisible_by_13(long[] \nunittest\n{\n    alias candidate =\
    \ get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n\
    \    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L,\
    \ 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) == []);\n\
    \    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc5rcvpgs.d(119): Error: found \''unittest\'' when expecting
    \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc5rcvpgs.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[]\
    \ get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i\
    \ = 0; i < l.length; ++i)\n\t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn res;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\
    \t\tres[i] = l[i] == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only ones in the\
    \ list.\n            \n*/\nlong[] get_one(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] == 1 ? 1 : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only numbers in the list that are divisible by n.\n    \
    \        \n*/\nlong[] get_divisible_by(long[] l, long n) \n{\n\tlong[] res = new\
    \ long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] % n\
    \ == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ divisible by n and are in the range [a, b].\n            \n*/\nlong[] get_divisible_by_range(long[]\
    \ l, long a, long b, long n) \n{\n\tlong[] res = new long[l.length];\n\tfor(int\
    \ i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] % n == 0 && (l[i] >= a && l[i]\
    \ <= b) ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ divisible by n and are in the range [a, b] and are in the range [c, d].\n  \
    \          \n*/\nlong[] get_divisible_by_range_2(long[] l, long a, long b, long\
    \ c, long d, long n) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0;\
    \ i < l.length; ++i)\n\t\tres[i] = l[i] % n == 0 && (l[i] >= a && l[i] <= b) &&\
    \ (l[i] >= c && l[i] <= d) ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by n and are in the range [a, b] and are in the\
    \ range [c, d] and are in the range [e, f].\n            \n*/\nlong[] \nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzoqvuj4n.d(84): Error: no identifier for declarator long[]\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzoqvuj4n.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpatumcycs.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in\
    \ the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i]\
    \ < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\n\
    Return only zeros in the list.\n            \n*/\nlong[] get_zero(long[] l) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n/*\nReturn only numbers in the list that are not zero.\n       \
    \     \n*/\nlong[] get_not_zero(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] != 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list\
    \ that are not negative.\n            \n*/\nlong[] get_not_negative(long[] l)\
    \ \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n/*\nReturn only numbers in the list that are not positive.\n   \
    \         \n*/\nlong[] get_not_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list\
    \ that are not even.\n            \n*/\nlong[] get_not_even(long[] l) \n{\n\t\
    long[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t\
    {\n\t\tif(l[i] % 2 == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n/*\nReturn only numbers in the list that are not odd.\n        \
    \    \n*/\nlong[] get_not_odd(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpohlf6ga6.d(122): Error: found \''unittest\'' when expecting
    \'')\''\n/tmp/tmpohlf6ga6.d(131): Error: found \''EOF\'' when expecting \''}\''
    following compound statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpohlf6ga6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptxnwkj8d.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[]\
    \ get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i\
    \ = 0; i < l.length; i++)\n\t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn res;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] == 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by n.\n            \n*/\nlong[] get_divisible_by(long[]\
    \ l, long n) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++)\n\t\tres[i] = l[i] % n == 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only\
    \ numbers in the list that are divisible by n and are less than n.\n         \
    \   \n*/\nlong[] get_less_than(long[] l, long n) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] % n != 0 ? l[i] : 0;\n\t\
    return res;\n}\n/*\nReturn only numbers in the list that are divisible by n and\
    \ are greater than n.\n            \n*/\nlong[] get_greater_than(long[] l, long\
    \ n) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] % n != 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by n and are less than or equal to n.\n     \
    \       \n*/\nlong[] get_less_than_or_equal_to(long[] l, long n) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\tres[i] =\
    \ l[i] % n != 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the\
    \ list that are divisible by n and are greater than or equal to n.\n         \
    \   \n*/\nlong[] get_greater_than_or_equal_to(long[] l, long n) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\tres[i] =\
    \ l[i] % n != 0 ? l[i] : 0;\n\treturn res;\nunittest\n{\n    alias candidate =\
    \ get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n\
    \    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L,\
    \ 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) == []);\n\
    \    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3bhlf7ar.d(89): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp3bhlf7ar.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp89jv1enh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptxnwkj8d.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsn9tnh8t.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tresult[i] = std.math.getPositive(l[i]);\n\
    \treturn result;\n}\n/*\nReturn only negative numbers in the list.\n         \
    \   \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tresult[i] = std.math.getNegative(l[i]);\n\
    \treturn result;\n}\n/*\nReturn only zeros in the list.\n            \n*/\nlong[]\
    \ get_zero(long[] l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i\
    \ = 0; i < l.length; ++i)\n\t\tresult[i] = std.math.getZero(l[i]);\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are greater than or equal to zero.\n\
    \            \n*/\nlong[] get_greater_or_equal(long[] l) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; ++i)\n\t\tresult[i] =\
    \ std.math.getGreaterOrEqual(l[i]);\n\treturn result;\n}\n/*\nReturn only numbers\
    \ in the list that are less than or equal to zero.\n            \n*/\nlong[] get_less_or_equal(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ ++i)\n\t\tresult[i] = std.math.getLessOrEqual(l[i]);\n\treturn result;\n}\n\
    /*\nReturn only numbers in the list that are greater than zero.\n            \n\
    */\nlong[] get_greater(long[] l) \n{\n\tlong[] result = new long[l.length];\n\t\
    for (int i = 0; i < l.length; ++i)\n\t\tresult[i] = std.math.getGreater(l[i]);\n\
    \treturn result;\n}\n/*\nReturn only numbers in the list that are less than zero.\n\
    \            \n*/\nlong[] get_less(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tresult[i] = std.math.getLess(l[i]);\n\
    \treturn result;\n}\n/*\nReturn only numbers in the list that are equal to zero.\n\
    \            \n*/\nlong[] get_equal(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tresult[i] = std.math.getEqual(l[i]);\n\
    \treturn result;\n}\n/*\nReturn only numbers in the list that are less than or\
    \ equal to zero.\n            \n*/\nlong[] get_less_or_equal_zero(long[] l) \n\
    {\n\tlong[] result = \nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7hzlun_a.d(97): Error: expression expected, not \''unittest\''\n/tmp/tmp7hzlun_a.d(98):
    Error: semicolon expected, not \''{\''\n/tmp/tmp7hzlun_a.d(106): Error: found
    \''EOF\'' when expecting \''}\'' following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp7hzlun_a.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tr[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ r;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptad4rpnq.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpni_beasv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] < 0) \n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only zeros in the list.\n    \
    \        \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by given number.\n            \n*/\nlong[] get_divisible_by(long[]\
    \ l, long d) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i <\
    \ l.length; i++) \n\t{\n\t\tif (l[i] % d == 0) \n\t\t\tresult[i] = l[i];\n\t}\n\
    \treturn result;\n}\n/*\nReturn only numbers in the list that are not divisible\
    \ by given number.\n            \n*/\nlong[] get_not_divisible_by(long[] l, long\
    \ d) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % d != 0) \n\t\t\tresult[i] = l[i];\n\t}\n\treturn\
    \ result;\n}\n/*\nReturn only numbers in the list that are less than given number.\n\
    \            \n*/\nlong[] get_less_than(long[] l, long d) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i]\
    \ < d) \n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers\
    \ in the list that are less than or equal given number.\n            \n*/\nlong[]\
    \ get_less_than_or_equal_to(long[] l, long d) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] <= d) \n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are greater than given number.\n            \n*/\nlong[] get_greater_than(long[]\
    \ l, long d) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i <\
    \ l.length; i++) \n\t{\n\t\tif (\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcw_7amq9.d(110): Error: expression expected, not \''unittest\''\n/tmp/tmpcw_7amq9.d(111):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpcw_7amq9.d(119): Error: found
    \''EOF\'' when expecting \''}\'' following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpcw_7amq9.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7nzo45xl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9q0konwr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tr[i] = l[i];\n\
    \t}\n\treturn r;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt0beo9ty.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tr[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ r;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpdx_idics.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] < 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n\tlong[] res\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i]\
    \ % 3 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 5.\n            \n*/\nlong[] get_divisible_by_5(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % 5 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 7.\n            \n\
    */\nlong[] get_divisible_by_7(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] % 7 == 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ divisible by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l) \n\
    {\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\
    \t{\n\t\tif (l[i] % 11 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\n\
    Return only numbers in the list that are divisible by 13.\n            \n*/\n\
    long[] get_divisible_by_13(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] % 13 == 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ divisible by 17.\n            \n*/\nlong[] get_divisible_by_17(long[] l) \n\
    {\n\tlong[] res = new long[l.length];\n\t\nunittest\n{\n    alias candidate =\
    \ get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n\
    \    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L,\
    \ 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) == []);\n\
    \    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmph1iplcqg.d(108): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmph1iplcqg.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[]\
    \ get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i\
    \ = 0; i < l.length; i++)\n\t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn res;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] == 0 ? 0 : l[i];\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not zero.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] != 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not negative.\n            \n*/\nlong[] get_not_negative(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers in\
    \ the list that are not positive.\n            \n*/\nlong[] get_not_positive(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers in\
    \ the list that are not in the list.\n            \n*/\nlong[] get_not_in(long[]\
    \ l, long[] l2) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i <\
    \ l.length; i++)\n\t\tres[i] = l[i] != l2 ? l[i] : 0;\n\treturn res;\n}\n/*\n\
    Return only numbers in the list that are not in the list.\n            \n*/\n\
    long[] get_not_in_2(long[] l, long[] l2) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] != l2 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only numbers in the list that are not in the list.\n   \
    \         \n*/\nlong[] get_not_in_3(long[] l, long[] l2) \n{\n\tlong[] res = new\
    \ long[l.length];\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpgz01f6_r.d(97): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgz01f6_r.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsn9tnh8t.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n      \
    \  {\n            result[i] = l[i];\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr170w7mz.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate =\
    \ get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n\
    \    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L,\
    \ 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) == []);\n\
    \    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd_nv73i6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9q0konwr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n      \
    \  {\n            result[i] = l[i];\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr170w7mz.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq52490_i.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptxnwkj8d.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpni_beasv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq52490_i.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n      \
    \  {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\n/*\nReturn\
    \ only negative numbers in the list.\n            \n*/\nlong[] get_negative(long[]\
    \ l) \n{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++) \n    {\n        if(l[i] < 0) \n        {\n            res[i] = l[i];\n\
    \        }\n    }\n    return res;\n}\n/*\nReturn only zeros in the list.\n  \
    \          \n*/\nlong[] get_zero(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] == 0) \n     \
    \   {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\n/*\n\
    Return only numbers in the list that are not zero.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l) \n{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++) \n    {\n        if(l[i] != 0) \n        {\n            res[i] = l[i];\n\
    \        }\n    }\n    return res;\n}\n/*\nReturn only numbers in the list that\
    \ are not negative.\n            \n*/\nlong[] get_not_negative(long[] l) \n{\n\
    \    long[] res = new long[l.length];\n    for(int i = 0; i < l.length; i++) \n\
    \    {\n        if(l[i] < 0) \n        {\n            res[i] = l[i];\n       \
    \ }\n    }\n    return res;\n}\n/*\nReturn only numbers in the list that are not\
    \ positive.\n            \n*/\nlong[] get_not_positive(long[] l) \n{\n    long[]\
    \ res = new long[l.length];\n    for(int i = 0; i < l.length; i++) \n    {\n \
    \       if(l[i] > 0) \n        {\n            res[i] = l[i];\n        }\n    }\n\
    \    return res;\n}\n/*\nReturn only numbers in the list that are not even.\n\
    \            \n*/\nlong[] get_not_even(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] % 2 == 0) \n \
    \       {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\n\
    /*\nReturn only numbers in the list that are not odd.\n            \n*/\nlong[]\
    \ get_not_odd(long[] l) \n{\n    long[] res = new long[l.length];\n    for(int\
    \ i = 0; i < l.length; i++\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpp40r7ywt.d(122): Error: found \''unittest\'' when expecting
    \'')\''\n/tmp/tmpp40r7ywt.d(131): Error: found \''EOF\'' when expecting \''}\''
    following compound statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp40r7ywt.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9q0konwr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] < 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only zeros in the list.\n    \
    \        \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are not zero.\n            \n*/\nlong[] get_not_zero(long[] l) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\t\
    if (l[i] != 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn\
    \ only numbers in the list that are not negative.\n            \n*/\nlong[] get_not_negative(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t{\n\t\tif (l[i] < 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are not positive.\n            \n\
    */\nlong[] get_not_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are not even.\n            \n*/\nlong[] get_not_even(long[] l) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\t\
    if (l[i] % 2 == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn\
    \ only numbers in the list that are not odd.\n            \n*/\nlong[] get_not_odd(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t{\n\t\tif (l[i] % 2 != 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are not \nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmprgr6v30z.d(114): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmprgr6v30z.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcvj95udf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptxnwkj8d.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcvj95udf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\t\
    result[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2147bww_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[]\
    \ get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i\
    \ = 0; i < l.length; ++i)\n\t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn res;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\
    \t\tres[i] = l[i] == 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not zero.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\
    \t\tres[i] = l[i] != 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are less than the number in the second argument.\n        \
    \    \n*/\nlong[] get_less_than(long[] l, long r) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] < r ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only numbers in the list that are greater than the number\
    \ in the second argument.\n            \n*/\nlong[] get_greater_than(long[] l,\
    \ long r) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ ++i)\n\t\tres[i] = l[i] > r ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are less than or equal to the number in the second argument.\n\
    \            \n*/\nlong[] get_less_than_or_equal_to(long[] l, long r) \n{\n\t\
    long[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\t\tres[i]\
    \ = l[i] <= r ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list\
    \ that are greater than or equal to the number in the second argument.\n     \
    \       \n*/\nlong[] get_greater_than_or_equal_to(long[] l, long r) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] =\
    \ l[i] >= r ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list\
    \ that are equal to the \nunittest\n{\n    alias candidate = get_positive;\n\n\
    \    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpi_hnx3g9.d(90): Error: unterminated /* */ comment\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpi_hnx3g9.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpatumcycs.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpni_beasv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\t\
    result[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2147bww_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] < 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only zeros in the list.\n         \
    \   \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\t\
    for (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by n.\n            \n*/\nlong[] get_divisible_by(long[] l, long n) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\t\
    if (l[i] % n == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only\
    \ numbers in the list that are divisible by n and are less than n.\n         \
    \   \n*/\nlong[] get_less_than(long[] l, long n) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] % n != 0 && l[i] < n)\
    \ \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the\
    \ list that are divisible by n and are greater than n.\n            \n*/\nlong[]\
    \ get_greater_than(long[] l, long n) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] % n != 0 && l[i] > n)\
    \ \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the\
    \ list that are divisible by n and are less than or equal to n.\n            \n\
    */\nlong[] get_less_than_or_equal_to(long[] l, long n) \n{\n\tlong[] res = new\
    \ long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] %\
    \ n != 0 && l[i] <= n) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn\
    \ only numbers in the list that are divisible by n and are greater than or equal\
    \ to n.\n\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpg49isthu.d(100): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpg49isthu.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] < 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\
    \t{\n\t\tif (l[i] % 3 == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 5.\n            \n\
    */\nlong[] get_divisible_by_5(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] % 5 == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 7.\n            \n*/\nlong[] get_divisible_by_7(long[] l) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\
    \t{\n\t\tif (l[i] % 7 == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 11.\n           \
    \ \n*/\nlong[] get_divisible_by_11(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] % 11 == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 13.\n            \n*/\nlong[] get_divisible_by_13(long[] l)\
    \ \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t{\n\t\tif (l[i] % 13 == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 17.\n           \
    \ \n*/\nlong[] get_divisible_by_17(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpyvsmaxes.d(109): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpyvsmaxes.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in\
    \ the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i]\
    \ < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\n\
    Return only zeros in the list.\n            \n*/\nlong[] get_zero(long[] l) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n/*\nReturn only numbers in the list that are not zeros or negative.\n\
    \            \n*/\nlong[] get_not_zero(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] != 0 && l[i] < 0) \n\t\t\
    {\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers\
    \ in the list that are not negative.\n            \n*/\nlong[] get_not_negative(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif(l[i] != 0 && l[i] > 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\
    \t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are\
    \ even.\n            \n*/\nlong[] get_even(long[] l) \n{\n\tlong[] result = new\
    \ long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 2\
    \ == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\n\
    Return only numbers in the list that are odd.\n            \n*/\nlong[] get_odd(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif(l[i] % 2 != 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t\
    }\n\treturn result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n\tlong[] result\
    \ = new \nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp465r4_nq.d(121): Error: basic type expected, not unittest\n/tmp/tmp465r4_nq.d(121):
    Error: semicolon expected, not \''unittest\''\n/tmp/tmp465r4_nq.d(121): Error:
    found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest", "-v",
    "-o-", "/tmp/tmp465r4_nq.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tr[i] = l[i];\n\
    \t}\n\treturn r;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa1dxhz29.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate =\
    \ get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n\
    \    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L,\
    \ 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) == []);\n\
    \    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd_nv73i6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcrotcdxh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpni_beasv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[]\
    \ get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i\
    \ = 0; i < l.length; i++)\n\t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn res;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t\tres[i] = l[i] == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only ones\
    \ in the list.\n            \n*/\nlong[] get_one(long[] l) \n{\n\tlong[] res =\
    \ new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i]\
    \ == 1 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only twos in the list.\n       \
    \     \n*/\nlong[] get_two(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] == 2 ? 1 : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only threes in the list.\n            \n*/\nlong[] get_three(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t\tres[i] = l[i] == 3 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only fours\
    \ in the list.\n            \n*/\nlong[] get_four(long[] l) \n{\n\tlong[] res\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i]\
    \ == 4 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only fives in the list.\n      \
    \      \n*/\nlong[] get_five(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] == 5 ? 1 : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only sixes in the list.\n            \n*/\nlong[] get_six(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t\tres[i] = l[i] == 6 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only sevens\
    \ in the list.\n            \n*/\nlong[] get_seven(long[] l) \n{\n\tlong[] res\
    \ = new long[\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpz932mrot.d(108): Error: expression expected, not \''unittest\''\n/tmp/tmpz932mrot.d(109):
    Error: found \''{\'' when expecting \'']\''\n/tmp/tmpz932mrot.d(110): Error: semicolon
    expected, not \''alias\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpz932mrot.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n      \
    \  {\n            result[i] = l[i];\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr170w7mz.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only negative\
    \ numbers in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\
    \    long[] result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n\
    \    {\n        if(l[i] < 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        if(l[i] == 0)\n            result[i] = l[i];\n    }\n \
    \   return result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n\
    \        if(l[i] % 3 == 0)\n            result[i] = l[i];\n    }\n    return result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 5.\n            \n\
    */\nlong[] get_divisible_by_5(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] % 5 == 0)\n   \
    \         result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 7.\n            \n*/\nlong[] get_divisible_by_7(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        if(l[i] % 7 == 0)\n            result[i] = l[i];\n    }\n\
    \    return result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n\
    \        if(l[i] % 11 == 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn only numbers in the list that are divisible by 13.\n\
    \            \n*/\nlong[] get_divisible_by_13(long[] l) \n{\n    long[] result\
    \ = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n      \
    \  if(l[i] % 13 == 0)\n            result[i] = l[i];\n    }\n    return result;\n\
    }\n/*\nReturn only \nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5pn3qqct.d(114): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5pn3qqct.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = {0};\n\tfor (int\
    \ i = 0; i < l.length; ++i)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tr[r.length] = l[i];\n\
    \t}\n\treturn r;\n}\n/*\nReturn only negative numbers in the list.\n         \
    \   \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] r = {0};\n\tfor (int i =\
    \ 0; i < l.length; ++i)\n\t{\n\t\tif (l[i] < 0)\n\t\t\tr[r.length] = l[i];\n\t\
    }\n\treturn r;\n}\n/*\nReturn only zeros in the list.\n            \n*/\nlong[]\
    \ get_zero(long[] l) \n{\n\tlong[] r = {0};\n\tfor (int i = 0; i < l.length; ++i)\n\
    \t{\n\t\tif (l[i] == 0)\n\t\t\tr[r.length] = l[i];\n\t}\n\treturn r;\n}\n/*\n\
    Return only numbers in the list that are not zero.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l) \n{\n\tlong[] r = {0};\n\tfor (int i = 0; i < l.length; ++i)\n\t{\n\t\tif\
    \ (l[i] != 0)\n\t\t\tr[r.length] = l[i];\n\t}\n\treturn r;\n}\n/*\nReturn only\
    \ numbers in the list that are not negative.\n            \n*/\nlong[] get_not_negative(long[]\
    \ l) \n{\n\tlong[] r = {0};\n\tfor (int i = 0; i < l.length; ++i)\n\t{\n\t\tif\
    \ (l[i] < 0)\n\t\t\tr[r.length] = l[i];\n\t}\n\treturn r;\n}\n/*\nReturn only\
    \ numbers in the list that are not positive.\n            \n*/\nlong[] get_not_positive(long[]\
    \ l) \n{\n\tlong[] r = {0};\n\tfor (int i = 0; i < l.length; ++i)\n\t{\n\t\tif\
    \ (l[i] > 0)\n\t\t\tr[r.length] = l[i];\n\t}\n\treturn r;\n}\n/*\nReturn only\
    \ numbers in the list that are not the given value.\n            \n*/\nlong[]\
    \ get_not_equal_to(long[] l, long value) \n{\n\tlong[] r = {0};\n\tfor (int i\
    \ = 0; i < l.length; ++i)\n\t{\n\t\tif (l[i] != value)\n\t\t\tr[r.length] = l[i];\n\
    \t}\n\treturn r;\n}\n/*\nReturn only numbers in the list that are not the given\
    \ value.\n            \n*/\nlong[] get_not_equal_to(long[] l, double value) \n\
    {\n\tlong[] r = {0};\n\tfor (int i = 0; i < l.length; ++i)\n\t{\n\t\tif (l[i]\
    \ != value)\n\t\t\tr[r.length] = l[i];\n\t}\n\treturn r;\n}\n/*\nReturn only number\n\
    unittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpnxb5r_7k.d(114): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpnxb5r_7k.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only negative\
    \ numbers in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\
    \    long[] result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n\
    \    {\n        if(l[i] < 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        if(l[i] == 0)\n            result[i] = l[i];\n    }\n \
    \   return result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n\
    \        if(l[i] % 3 == 0)\n            result[i] = l[i];\n    }\n    return result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 5.\n            \n\
    */\nlong[] get_divisible_by_5(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] % 5 == 0)\n   \
    \         result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 7.\n            \n*/\nlong[] get_divisible_by_7(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ i++)\n    {\n        if(l[i] % 7 == 0)\n            result[i] = l[i];\n    }\n\
    \    return result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n\
    \        if(l[i] % 11 == 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn only numbers in the list that are divisible by 13.\n\
    \            \n*/\nlong[] get_divisible_by_13(long[] l) \n{\n    long[] result\
    \ = new long[l.length];\n    for(int i = 0; i < l.length; i++)\n    {\n      \
    \  if(l[i] % 13 == 0)\n            result[i] = l[i];\n    }\n    return result;\n\
    }\n/*\nReturn only \nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp5pn3qqct.d(114): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp5pn3qqct.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t\tr[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ r;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmplvt18_e9.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq52490_i.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\t\
    result[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers\
    \ in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\
    \tif (l[i] < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\
    \treturn result;\n}\n/*\nReturn only numbers in the list that are divisible by\
    \ n.\n            \n*/\nlong[] get_divisible_by(long[] l, long n) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\
    \tif (l[i] % n == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are not divisible by n.\n        \
    \    \n*/\nlong[] get_not_divisible_by(long[] l, long n) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i]\
    \ % n != 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n\
    /*\nReturn only numbers in the list that are less than n.\n            \n*/\n\
    long[] get_less_than(long[] l, long n) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] < n) \n\t\t{\n\t\t\t\
    result[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in\
    \ the list that are greater than n.\n            \n*/\nlong[] get_greater_than(long[]\
    \ l, long n) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i <\
    \ l.length; i++) \n\t{\n\t\tif (l[i] > n) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\
    \t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are less\
    \ than or equal to n.\n            \n*/\nlong[] get_less_than_or_equal_to(long\n\
    unittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpb641mx57.d(119): Error: found \''unittest\'' when expecting
    \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpb641mx57.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptxnwkj8d.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_hsjbsu1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9q0konwr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpatumcycs.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgcz_hxrv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\t\
    result[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2147bww_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgcz_hxrv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq52490_i.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] < 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are\
    \ even.\n            \n*/\nlong[] get_even(long[] l) \n{\n\tlong[] result = new\
    \ long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] % 2 ==\
    \ 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers\
    \ in the list that are odd.\n            \n*/\nlong[] get_odd(long[] l) \n{\n\t\
    long[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t{\n\
    \t\tif(l[i] % 2 != 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\n\
    Return only numbers in the list that are divisible by 3.\n            \n*/\nlong[]\
    \ get_divisible_by_3(long[] l) \n{\n\tlong[] result = new long[l.length];\n\t\
    for(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] % 3 == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 5.\n            \n*/\nlong[] get_divisible_by_5(long[] l) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t{\n\t\tif(l[i] % 5 == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n\
    /*\nReturn only numbers in the list that are divisible by 7.\n            \n*/\n\
    long[] get_divisible_by_7(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] % 7 == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l)\
    \ \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t{\n\t\tif(l[i] % 11 == 0)\n\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvx783r8_.d(111): Error: found \''unittest\'' instead of statement\n/tmp/tmpvx783r8_.d(120):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpvx783r8_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}\n/*\nReturn\
    \ only negative numbers in the list.\n            \n*/\nlong[] get_negative(long[]\
    \ l) \n{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ ++i)\n    {\n        if(l[i] < 0)\n        {\n            res[i] = l[i];\n \
    \       }\n    }\n    return res;\n}\n/*\nReturn only zeros in the list.\n   \
    \         \n*/\nlong[] get_zero(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] == 0)\n       \
    \ {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\n/*\nReturn\
    \ only numbers in the list that are not zero.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l) \n{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ ++i)\n    {\n        if(l[i] != 0)\n        {\n            res[i] = l[i];\n\
    \        }\n    }\n    return res;\n}\n/*\nReturn only numbers in the list that\
    \ are not negative.\n            \n*/\nlong[] get_not_negative(long[] l) \n{\n\
    \    long[] res = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n\
    \    {\n        if(l[i] < 0)\n        {\n            res[i] = l[i];\n        }\n\
    \    }\n    return res;\n}\n/*\nReturn only numbers in the list that are not positive.\n\
    \            \n*/\nlong[] get_not_positive(long[] l) \n{\n    long[] res = new\
    \ long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i]\
    \ > 0)\n        {\n            res[i] = l[i];\n        }\n    }\n    return res;\n\
    }\n/*\nReturn only numbers in the list that are not even.\n            \n*/\n\
    long[] get_not_even(long[] l) \n{\n    long[] res = new long[l.length];\n    for(int\
    \ i = 0; i < l.length; ++i)\n    {\n        if(l[i] % 2 == 0)\n        {\n   \
    \         res[i] = l[i];\n        }\n    }\n    return res;\n}\n/*\nReturn only\
    \ numbers in the list that are not odd.\n            \n*/\nlong[] get_not_odd(long[]\
    \ l) \n{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp_1o_8kho.d(122): Error: identifier expected following \''.\'',
    not \''unittest\''\n/tmp/tmp_1o_8kho.d(123): Error: found \''{\'' when expecting
    \'';\'' following for condition\n/tmp/tmp_1o_8kho.d(124): Error: expression expected,
    not \''alias\''\n/tmp/tmp_1o_8kho.d(124): Error: found \''candidate\'' when expecting
    \'')\''\n/tmp/tmp_1o_8kho.d(124): Error: found \''=\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_1o_8kho.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe_n17xc0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in\
    \ the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i]\
    \ < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\n\
    Return only zeros in the list.\n            \n*/\nlong[] get_zero(long[] l) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n/*\nReturn only numbers in the list that are not zero, negative\
    \ or positive.\n            \n*/\nlong[] get_not_zero(long[] l) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\t\
    if(l[i] != 0 && l[i] != -1 && l[i] != 1) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t\
    }\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are not\
    \ zero, negative or positive.\n            \n*/\nlong[] get_not_negative(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif(l[i] != 0 && l[i] != -1 && l[i] != 1) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list\
    \ that are not zero, negative or positive.\n            \n*/\nlong[] get_not_positive(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif(l[i] != 0 && l[i] != -1 && l[i] != 1) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list\
    \ that are not zero, negative or positive.\n            \n*/\nlong[] get_not_negative_and_not_zero(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif(l[i] != 0 && l[i] != -1 && l[i] != 1) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmppt7c2p3v.d(110): Error: found \''unittest\'' instead of statement\n/tmp/tmppt7c2p3v.d(119):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\n/tmp/tmppt7c2p3v.d(119):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmppt7c2p3v.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsn9tnh8t.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsn9tnh8t.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}\n/*\nReturn\
    \ only negative numbers in the list.\n            \n*/\nlong[] get_negative(long[]\
    \ l) \n{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ ++i)\n    {\n        if(l[i] < 0)\n        {\n            res[i] = l[i];\n \
    \       }\n    }\n    return res;\n}\n/*\nReturn only zeros in the list.\n   \
    \         \n*/\nlong[] get_zero(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] == 0)\n       \
    \ {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\n/*\nReturn\
    \ only numbers in the list that are not zero.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l) \n{\n    long[] res = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ ++i)\n    {\n        if(l[i] != 0)\n        {\n            res[i] = l[i];\n\
    \        }\n    }\n    return res;\n}\n/*\nReturn only numbers in the list that\
    \ are not negative.\n            \n*/\nlong[] get_not_negative(long[] l) \n{\n\
    \    long[] res = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n\
    \    {\n        if(l[i] < 0)\n        {\n            res[i] = l[i];\n        }\n\
    \    }\n    return res;\n}\n/*\nReturn only numbers in the list that are not positive.\n\
    \            \n*/\nlong[] get_not_positive(long[] l) \n{\n    long[] res = new\
    \ long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i]\
    \ > 0)\n        {\n            res[i] = l[i];\n        }\n    }\n    return res;\n\
    }\n/*\nReturn only numbers in the list that are not the given value.\n       \
    \     \n*/\nlong[] get_not_equal_to(long[] l, long value) \n{\n    long[] res\
    \ = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n      \
    \  if(l[i] != value)\n        {\n            res[i] = l[i];\n        }\n    }\n\
    \    return res;\n}\n/*\nReturn only numbers in the list that are not the given\
    \ value.\n            \n*/\nlong[] get_not_equal_to(long[] l, double value) \n\
    {\n    long[] res = new long[l.length\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpejsla3to.d(121): Error: found \''unittest\'' when expecting
    \'']\''\n/tmp/tmpejsla3to.d(122): Error: semicolon expected, not \''{\''\n/tmp/tmpejsla3to.d(130):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpejsla3to.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq52490_i.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only negative\
    \ numbers in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\
    \    long[] result = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n\
    \    {\n        if(l[i] < 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ ++i)\n    {\n        if(l[i] == 0)\n            result[i] = l[i];\n    }\n \
    \   return result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n\
    \        if(l[i] % 3 == 0)\n            result[i] = l[i];\n    }\n    return result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 5.\n            \n\
    */\nlong[] get_divisible_by_5(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] % 5 == 0)\n   \
    \         result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 7.\n            \n*/\nlong[] get_divisible_by_7(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ ++i)\n    {\n        if(l[i] % 7 == 0)\n            result[i] = l[i];\n    }\n\
    \    return result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n\
    \        if(l[i] % 11 == 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn only numbers in the list that are divisible by 13.\n\
    \            \n*/\nlong[] get_divisible_by_13(long[] l) \n{\n    long[] result\
    \ = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n      \
    \  if(l[i] % 13 == 0)\n            result[i] = l[i];\n    }\n\nunittest\n{\n \
    \   alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L,\
    \ 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L,\
    \ 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptdg5utwz.d(113): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptdg5utwz.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpatumcycs.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpni_beasv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    int i = 0;\n    for(; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n \
    \       {\n            result[i] = l[i];\n        }\n    }\n    return result;\n\
    }\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[] get_negative(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    int i = 0;\n    for(; i\
    \ < l.length; ++i)\n    {\n        if(l[i] < 0)\n        {\n            result[i]\
    \ = l[i];\n        }\n    }\n    return result;\n}\n/*\nReturn only zeros in the\
    \ list.\n            \n*/\nlong[] get_zero(long[] l) \n{\n    long[] result =\
    \ new long[l.length];\n    int i = 0;\n    for(; i < l.length; ++i)\n    {\n \
    \       if(l[i] == 0)\n        {\n            result[i] = l[i];\n        }\n \
    \   }\n    return result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    int i = 0;\n    for(; i < l.length; ++i)\n\
    \    {\n        if(l[i] % 3 == 0)\n        {\n            result[i] = l[i];\n\
    \        }\n    }\n    return result;\n}\n/*\nReturn only numbers in the list\
    \ that are divisible by 5.\n            \n*/\nlong[] get_divisible_by_5(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    int i = 0;\n    for(; i\
    \ < l.length; ++i)\n    {\n        if(l[i] % 5 == 0)\n        {\n            result[i]\
    \ = l[i];\n        }\n    }\n    return result;\n}\n/*\nReturn only numbers in\
    \ the list that are divisible by 7.\n            \n*/\nlong[] get_divisible_by_7(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    int i = 0;\n    for(; i\
    \ < l.length; ++i)\n    {\n        if(l[i] % 7 == 0)\n        {\n            result[i]\
    \ = l[i];\n        }\n    }\n    return result;\n}\n/*\nReturn only numbers in\
    \ the list that are divisible by 11.\n            \n*/\nlong[] get_divisible_by_11(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    int i = 0;\n    for(; i\
    \ < l.length; ++i)\n    {\n        if(l[i] % 11 == 0)\n        {\n           \
    \ result[i] = l[i];\n        }\n    }\n    return result;\n}\n/*\nReturn only\
    \ numbers in the list that are divisible by 13.\n            \n*/\nlong\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpzh7gkuyd.d(126): Error: no identifier for declarator long\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpzh7gkuyd.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only negative numbers in the list.\n       \
    \     \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] < 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only zeros in the list.\n            \n*/\n\
    long[] get_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i\
    \ = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] == 0) \n\t\t\tres[i] = l[i];\n\t\
    }\n\treturn res;\n}\n/*\nReturn only numbers in the list that are not zero.\n\
    \            \n*/\nlong[] get_not_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] != 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are not\
    \ negative.\n            \n*/\nlong[] get_not_negative(long[] l) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i]\
    \ < 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not positive.\n            \n*/\nlong[] get_not_positive(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\n\
    Return only numbers in the list that are not even.\n            \n*/\nlong[] get_not_even(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] % 2 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n\
    /*\nReturn only numbers in the list that are not odd.\n            \n*/\nlong[]\
    \ get_not_odd(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i =\
    \ 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 2 != 0) \n\t\t\tres[i] = l[i];\n\t\
    }\n\treturn res;\n}\n/*\nReturn \nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpme407eti.d(114): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpme407eti.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq52490_i.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpni_beasv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcvj95udf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n      \
    \  {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe3pn7ma7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpatumcycs.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n      \
    \  {\n            result[i] = l[i];\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr170w7mz.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpatumcycs.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7nzo45xl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgcz_hxrv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] < 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only zeros in the list.\n         \
    \   \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\t\
    for (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list.\n       \
    \     \n*/\nlong[] get_number(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] != 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list.\n     \
    \       \n*/\nlong[] get_number_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list.\n       \
    \     \n*/\nlong[] get_number_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] < 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list.\n       \
    \     \n*/\nlong[] get_number_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list.\n     \
    \       \n*/\nlong[] get_number_number(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] != 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list.\n     \
    \       \n*/\nlong[] get_number_number_positive(long[] l) \n{\n\tlong[] \nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpy7d8t74_.d(121): Error: no identifier for declarator long[]\n/tmp/tmpy7d8t74_.d(121):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpy7d8t74_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcrotcdxh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] < 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are\
    \ even numbers.\n            \n*/\nlong[] get_even(long[] l) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i]\
    \ % 2 == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only\
    \ numbers in the list that are odd numbers.\n            \n*/\nlong[] get_odd(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ i++)\n\t{\n\t\tif(l[i] % 2 != 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 3.\n            \n\
    */\nlong[] get_divisible_by_3(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] % 3 == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 5.\n            \n*/\nlong[] get_divisible_by_5(long[] l) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t{\n\t\tif(l[i] % 5 == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n\
    /*\nReturn only numbers in the list that are divisible by 7.\n            \n*/\n\
    long[] get_divisible_by_7(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] % 7 == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l)\
    \ \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t{\n\t\tif(l[i] % 11 == 0)\n\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp7rkhlc3x.d(111): Error: found \''unittest\'' instead of statement\n/tmp/tmp7rkhlc3x.d(120):
    Error: found \''EOF\'' when expecting \''}\'' following compound statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7rkhlc3x.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\t\
    result[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2147bww_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[]\
    \ get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i\
    \ = 0; i < l.length; ++i)\n\t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn res;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ ++i)\n\t\tres[i] = l[i] == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only ones\
    \ in the list.\n            \n*/\nlong[] get_one(long[] l) \n{\n\tlong[] res =\
    \ new long[l.length];\n\tfor (int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i]\
    \ == 1 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only twos in the list.\n       \
    \     \n*/\nlong[] get_two(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] == 2 ? 1 : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only threes in the list.\n            \n*/\nlong[] get_three(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ ++i)\n\t\tres[i] = l[i] == 3 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only fours\
    \ in the list.\n            \n*/\nlong[] get_four(long[] l) \n{\n\tlong[] res\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i]\
    \ == 4 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only fives in the list.\n      \
    \      \n*/\nlong[] get_five(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] == 5 ? 1 : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only sixes in the list.\n            \n*/\nlong[] get_six(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ ++i)\n\t\tres[i] = l[i] == 6 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only sevens\
    \ in the list.\n            \n*/\nlong[] get_seven(long[] l) \n\nunittest\n{\n\
    \    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L,\
    \ 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L,\
    \ 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1470o09w.d(107): Error: semicolon expected following function
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1470o09w.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcvj95udf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n      \
    \  {\n            result[i] = l[i];\n        }\n    }\n    return result;\n}\n\
    unittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr170w7mz.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n      \
    \  {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe3pn7ma7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4rmi_y25.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only negative numbers in the list.\n       \
    \     \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] < 0)\n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only zeros in the list.\n            \n*/\n\
    long[] get_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int\
    \ i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] == 0)\n\t\t\tres[i] = l[i];\n\t\
    }\n\treturn res;\n}\n/*\nReturn only numbers in the list that are not zero, negative\
    \ or positive.\n            \n*/\nlong[] get_not_zero(long[] l) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif\
    \ (l[i] != 0)\n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not zero, negative or positive.\n            \n*/\nlong[]\
    \ get_not_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int\
    \ i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] != 0)\n\t\t\tres[i] = l[i];\n\t\
    }\n\treturn res;\n}\n/*\nReturn only numbers in the list that are not zero, negative\
    \ or positive.\n            \n*/\nlong[] get_not_positive(long[] l) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif\
    \ (l[i] != 0)\n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not zero, negative or positive.\n            \n*/\nlong[]\
    \ get_not_zero_and_not_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] != 0 && l[i] != 0)\n\t\
    \t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list\
    \ that are not zero, negative or positive.\n            \n*/\nlong[] get_not_zero_and_not_positive(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t{\n\t\tif (\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpvxcnily9.d(110): Error: expression expected, not \''unittest\''\n/tmp/tmpvxcnily9.d(111):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmpvxcnily9.d(119): Error: found
    \''EOF\'' when expecting \''}\'' following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmpvxcnily9.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcvj95udf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tr[i] = l[i];\n\
    \t}\n\treturn r;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf0gqkqmc.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = {0};\n\tfor (int\
    \ i = 0; i < l.length; ++i)\n\t\tif (l[i] > 0)\n\t\t\tr[r.length] = l[i];\n\t\
    return r;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_uw8z6co.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7nzo45xl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    int i = 0;\n    for (; i < l.length; ++i)\n    {\n        if (l[i] > 0)\n\
    \            result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only\
    \ negative numbers in the list.\n            \n*/\nlong[] get_negative(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    int i = 0;\n    for (;\
    \ i < l.length; ++i)\n    {\n        if (l[i] < 0)\n            result[i] = l[i];\n\
    \    }\n    return result;\n}\n/*\nReturn only zeros in the list.\n          \
    \  \n*/\nlong[] get_zero(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    int i = 0;\n    for (; i < l.length; ++i)\n    {\n        if (l[i] == 0)\n\
    \            result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only\
    \ numbers in the list that are not zero.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    int i = 0;\n    for (;\
    \ i < l.length; ++i)\n    {\n        if (l[i] != 0)\n            result[i] = l[i];\n\
    \    }\n    return result;\n}\n/*\nReturn only numbers in the list that are not\
    \ negative.\n            \n*/\nlong[] get_not_negative(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    int i = 0;\n    for (; i < l.length; ++i)\n\
    \    {\n        if (l[i] < 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn only numbers in the list that are not positive.\n   \
    \         \n*/\nlong[] get_not_positive(long[] l) \n{\n    long[] result = new\
    \ long[l.length];\n    int i = 0;\n    for (; i < l.length; ++i)\n    {\n    \
    \    if (l[i] > 0)\n            result[i] = l[i];\n    }\n    return result;\n\
    }\n/*\nReturn only numbers in the list that are not in the list.\n           \
    \ \n*/\nlong[] get_not_in(long[] l, long[] l2) \n{\n    long[] result = new long[l.length];\n\
    \    int i = 0;\n    for (; i < l.length; ++i)\n    {\n        if (l[i] != l2[i])\n\
    \            result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only\
    \ numbers in the list that are not in the list 2.\n            \n*/\nlong[] get_not_in_2(long[]\
    \ l, long[] l2) \n{\n    long[] result = new long[l.length];\n    int i = 0;\n\
    \    for (; i < l.length; ++i)\n    {\n        if (l[i] != l2[i])\n          \
    \  result[i] = l[i];\n    }\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp65uqae30.d(120): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp65uqae30.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\t\
    result[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2147bww_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq8hg88zo.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4rmi_y25.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        \
    \    res[i] = l[i];\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr689y_mi.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpni_beasv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] < 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only zeros in the list.\n    \
    \        \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] == 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by n.\n            \n*/\nlong[] get_divisible_by(long[] l, long\
    \ n) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t{\n\t\tif (l[i] % n == 0)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by n and are less than\
    \ n.\n            \n*/\nlong[] get_less_than(long[] l, long n) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i]\
    \ % n != 0 && l[i] < n)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\n\
    Return only numbers in the list that are divisible by n and are greater than n.\n\
    \            \n*/\nlong[] get_greater_than(long[] l, long n) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i]\
    \ % n != 0 && l[i] > n)\n\t\t\tresult[i] = l[i];\n\t}\n\treturn result;\n}\n/*\n\
    Return only numbers in the list that are divisible by n and are less than or equal\
    \ to n.\n            \n*/\nlong[] get_less_than_or_equal_to(long[] l, long n)\
    \ \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t{\n\t\tif (l[i] % n != 0 && l[i] <= n)\n\t\t\tresult[i] = l[i];\n\t\
    }\n\treturn result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by n and are greater than or equal to n.\n            \n*/\nlong[] get_greater_\n\
    unittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp97reit_o.d(105): Error: semicolon expected, not \''unittest\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp97reit_o.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe_n17xc0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\t\
    result[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers\
    \ in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\
    \tif (l[i] < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\
    \treturn result;\n}\n/*\nReturn only numbers in the list that are divisible by\
    \ given number.\n            \n*/\nlong[] get_divisible_by(long[] l, long d) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif (l[i] % d == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\
    \treturn result;\n}\n/*\nReturn only numbers in the list that are not divisible\
    \ by given number.\n            \n*/\nlong[] get_not_divisible_by(long[] l, long\
    \ d) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % d != 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\
    \t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are less than\
    \ given number.\n            \n*/\nlong[] get_less_than(long[] l, long d) \n{\n\
    \tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\
    \t{\n\t\tif (l[i] < d) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n/*\nReturn only numbers in the list that are greater than given\
    \ number.\n            \n*/\nlong[] get_greater_than(long[] l, long d) \n{\n\t\
    long[] result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t\
    {\n\t\tif (l[i] > d) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are less than or equal to given number.\n\
    \            \n*/\nlong[] get_less_than_or_equal_to(long[] \nunittest\n{\n   \
    \ alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L])\
    \ == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L,\
    \ 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpopc1jh3s.d(119): Error: found \''unittest\'' when expecting
    \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpopc1jh3s.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[]\
    \ get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i\
    \ = 0; i < l.length; i++)\n\t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn res;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t\tres[i] = l[i] == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only ones\
    \ in the list.\n            \n*/\nlong[] get_one(long[] l) \n{\n\tlong[] res =\
    \ new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i]\
    \ == 1 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ divisible by given number.\n            \n*/\nlong[] get_divisible_by(long[]\
    \ l, long d) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t\tres[i] = l[i] % d == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only\
    \ numbers in the list that are divisible by given number.\n            \n*/\n\
    long[] get_divisible_by_2(long[] l, long d) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] % d == 0 ? 1 : 0;\n\t\
    return res;\n}\n/*\nReturn only numbers in the list that are divisible by given\
    \ number.\n            \n*/\nlong[] get_divisible_by_3(long[] l, long d) \n{\n\
    \tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\n\t\t\
    res[i] = l[i] % d == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in\
    \ the list that are divisible by given number.\n            \n*/\nlong[] get_divisible_by_4(long[]\
    \ l, long d) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++)\n\t\tres[i] = l[i] % d == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only\
    \ numbers in the list that are divisible by given number.\n            \n*/\n\
    long[] get_divisible_by_5(long[] l, long d) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < \nunittest\n{\n    alias candidate = get_positive;\n\n \
    \   assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcf74uv_9.d(98): Error: expression expected, not \''unittest\''\n/tmp/tmpcf74uv_9.d(99):
    Error: found \''{\'' when expecting \'';\'' following for condition\n/tmp/tmpcf74uv_9.d(100):
    Error: expression expected, not \''alias\''\n/tmp/tmpcf74uv_9.d(100): Error: found
    \''candidate\'' when expecting \'')\''\n/tmp/tmpcf74uv_9.d(100): Error: found
    \''=\'' instead of statement\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcf74uv_9.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpni_beasv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    int i = 0;\n    for(; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n \
    \           result[i] = l[i];\n    }\n    return result;\n}\nunittest\n{\n   \
    \ alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L])\
    \ == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L,\
    \ 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp8f0ifa0a.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq52490_i.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq52490_i.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpni_beasv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq8hg88zo.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptxnwkj8d.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu20xv4dg.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9q0konwr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\t\
    result[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers\
    \ in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\
    \tif (l[i] < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\
    \treturn result;\n}\n/*\nReturn only numbers in the list that are divisible by\
    \ 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i]\
    \ % 3 == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n\
    /*\nReturn only numbers in the list that are divisible by 5.\n            \n*/\n\
    long[] get_divisible_by_5(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] % 5 == 0) \n\t\t{\n\t\
    \t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 7.\n            \n*/\nlong[] get_divisible_by_7(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % 7 == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\
    \t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\
    \tif (l[i] % 11 == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 13.\n           \
    \ \n*/\nlong[] get_divisible_by_13(long[] \nunittest\n{\n    alias candidate =\
    \ get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n\
    \    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L,\
    \ 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) == []);\n\
    \    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpc5rcvpgs.d(119): Error: found \''unittest\'' when expecting
    \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpc5rcvpgs.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcvj95udf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\t\
    result[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp2147bww_.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] < 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only zeros in the list.\n         \
    \   \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\t\
    for (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n\tlong[] res\
    \ = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i]\
    \ % 3 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 5.\n            \n*/\nlong[] get_divisible_by_5(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % 5 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 7.\n            \n\
    */\nlong[] get_divisible_by_7(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] % 7 == 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ divisible by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l) \n\
    {\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\
    \t{\n\t\tif (l[i] % 11 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\n\
    Return only numbers in the list that are divisible by 13.\n            \n*/\n\
    long[] get_divisible_by_13(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l\nunittest\n{\n    alias\
    \ candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) ==\
    \ [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L,\
    \ 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpudatyv5w.d(110): Error: found \''unittest\'' when expecting
    \'')\''\n/tmp/tmpudatyv5w.d(119): Error: found \''EOF\'' when expecting \''}\''
    following compound statement\n/tmp/tmpudatyv5w.d(119): Error: found \''EOF\''
    when expecting \''}\'' following compound statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmpudatyv5w.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate =\
    \ get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n\
    \    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L,\
    \ 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) == []);\n\
    \    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd_nv73i6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tr[i] = l[i];\n\
    \t}\n\treturn r;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpa1dxhz29.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4rmi_y25.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = std.math.rem(l[i], 1);\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpaxgj89vf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tr[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n/*\nReturn only negative numbers in the\
    \ list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] r = new\
    \ long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] < 0)\
    \ \n\t\t{\n\t\t\tr[i] = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n/*\nReturn only zeros\
    \ in the list.\n            \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] r =\
    \ new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i]\
    \ == 0) \n\t\t{\n\t\t\tr[i] = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n/*\nReturn only\
    \ numbers in the list that are divisible by 3.\n            \n*/\nlong[] get_divisible_by_3(long[]\
    \ l) \n{\n\tlong[] r = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] % 3 == 0) \n\t\t{\n\t\t\tr[i] = l[i];\n\t\t}\n\t}\n\treturn\
    \ r;\n}\n/*\nReturn only numbers in the list that are divisible by 5.\n      \
    \      \n*/\nlong[] get_divisible_by_5(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 5 == 0) \n\t\t{\n\t\t\
    \tr[i] = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n/*\nReturn only numbers in the list\
    \ that are divisible by 7.\n            \n*/\nlong[] get_divisible_by_7(long[]\
    \ l) \n{\n\tlong[] r = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] % 7 == 0) \n\t\t{\n\t\t\tr[i] = l[i];\n\t\t}\n\t}\n\treturn\
    \ r;\n}\n/*\nReturn only numbers in the list that are divisible by 11.\n     \
    \       \n*/\nlong[] get_divisible_by_11(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 11 == 0) \n\t\t{\n\t\t\
    \tr[i] = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n/*\nReturn only numbers in the list\
    \ that are divisible by 13.\n            \n*/\nlong[] get_divisible_by_13(long[]\
    \ \nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpe5nc7q44.d(119): Error: found \''unittest\'' when expecting
    \'')\''\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe5nc7q44.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgcz_hxrv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[]\
    \ get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i\
    \ = 0; i < l.length; i++)\n\t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn res;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in\
    \ the list that are not zero.\n            \n*/\nlong[] get_not_zero(long[] l)\
    \ \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] != 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in\
    \ the list that are not negative.\n            \n*/\nlong[] get_not_negative(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] < 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the\
    \ list that are not positive.\n            \n*/\nlong[] get_not_positive(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] > 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the\
    \ list that are not odd.\n            \n*/\nlong[] get_odd(long[] l) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\tres[i] =\
    \ l[i] % 2 != 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list\
    \ that are not even.\n            \n*/\nlong[] get_even(long[] l) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\t\tres[i] =\
    \ l[i] % 2 == 0 ? 1 : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list\
    \ that are not divisible by 2.\n            \n*/\nlong[] get_not_divisible_by_2(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] % 2 != 0 ? 1 : 0;\n\treturn \nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpcy_jyev2.d(100): Error: expression expected, not \''unittest\''\n/tmp/tmpcy_jyev2.d(101):
    Error: found \''{\'' when expecting \'';\'' following return statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcy_jyev2.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp7nzo45xl.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq52490_i.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp4rmi_y25.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp89jv1enh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe_n17xc0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n        if(l[i] > 0)\n            res[i]\
    \ = l[i];\n    return res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpajieexs1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpni_beasv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n      \
    \  {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe3pn7ma7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tresult[i] = l[i] > 0 ? l[i] : 0;\n\t\
    return result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpxs2k6amg.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpq8hg88zo.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcrotcdxh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        \
    \    res[i] = l[i];\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr689y_mi.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu20xv4dg.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsn9tnh8t.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcrotcdxh.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp_hsjbsu1.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tresult[i]\
    \ = l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpsn9tnh8t.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpwqytnz9o.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = {0};\n\tfor (int\
    \ i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\tr[r.length]\
    \ = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n/*\nReturn only negative numbers in the\
    \ list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] r = {0};\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] < 0) \n\t\t{\n\t\t\t\
    r[r.length] = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n/*\nReturn only zeros in the\
    \ list.\n            \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] r = {0};\n\t\
    for (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t{\n\t\t\tr[r.length]\
    \ = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n/*\nReturn only numbers in the list that\
    \ are divisible by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n\
    {\n\tlong[] r = {0};\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i]\
    \ % 3 == 0) \n\t\t{\n\t\t\tr[r.length] = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n/*\n\
    Return only numbers in the list that are divisible by 5.\n            \n*/\nlong[]\
    \ get_divisible_by_5(long[] l) \n{\n\tlong[] r = {0};\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % 5 == 0) \n\t\t{\n\t\t\tr[r.length] = l[i];\n\t\t\
    }\n\t}\n\treturn r;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 7.\n            \n*/\nlong[] get_divisible_by_7(long[] l) \n{\n\tlong[] r\
    \ = {0};\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] % 7 == 0) \n\
    \t\t{\n\t\t\tr[r.length] = l[i];\n\t\t}\n\t}\n\treturn r;\n}\n/*\nReturn only\
    \ numbers in the list that are divisible by 11.\n            \n*/\nlong[] get_divisible_by_11(long[]\
    \ l) \n{\n\tlong[] r = {0};\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\t\
    if (l[i] % 11 == 0) \n\t\t{\n\t\t\tr[r.length] = l[i];\n\t\t}\n\t}\n\treturn r;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 13.\n           \
    \ \n*/\nlong[] get_divisible_by_13(long[] l) \n{\n\tlong\nunittest\n{\n    alias\
    \ candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) ==\
    \ [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L,\
    \ 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp3xy6cgo_.d(121): Error: no identifier for declarator long\n/tmp/tmp3xy6cgo_.d(121):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp3xy6cgo_.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate =\
    \ get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n\
    \    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L,\
    \ 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) == []);\n\
    \    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd_nv73i6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; i++) \n    {\n        if(l[i] > 0) \n      \
    \  {\n            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe3pn7ma7.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tres[i] = std.math.max(l[i], 0);\n\t\
    return res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp747oheau.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9q0konwr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tr[i] = l[i];\n\
    \t}\n\treturn r;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpt0beo9ty.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t{\n\t\tif(l[i] > 0)\n\t\t\tresult[i] =\
    \ l[i];\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpe_n17xc0.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tr[i] = l[i];\n\
    \t}\n\treturn r;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpf0gqkqmc.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu63i7qni.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgcz_hxrv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        \
    \    result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only negative\
    \ numbers in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\
    \    long[] result = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n\
    \    {\n        if(l[i] < 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ ++i)\n    {\n        if(l[i] == 0)\n            result[i] = l[i];\n    }\n \
    \   return result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n\
    \        if(l[i] % 3 == 0)\n            result[i] = l[i];\n    }\n    return result;\n\
    }\n/*\nReturn only numbers in the list that are divisible by 5.\n            \n\
    */\nlong[] get_divisible_by_5(long[] l) \n{\n    long[] result = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] % 5 == 0)\n   \
    \         result[i] = l[i];\n    }\n    return result;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 7.\n            \n*/\nlong[] get_divisible_by_7(long[]\
    \ l) \n{\n    long[] result = new long[l.length];\n    for(int i = 0; i < l.length;\
    \ ++i)\n    {\n        if(l[i] % 7 == 0)\n            result[i] = l[i];\n    }\n\
    \    return result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l) \n{\n    long[]\
    \ result = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n\
    \        if(l[i] % 11 == 0)\n            result[i] = l[i];\n    }\n    return\
    \ result;\n}\n/*\nReturn only numbers in the list that are divisible by 13.\n\
    \            \n*/\nlong[] get_divisible_by_13(long[] l) \n{\n    long[] result\
    \ = new long[l.length];\n    for(int i = 0; i < l.length; ++i)\n    {\n      \
    \  if(l[i] % 13 == 0)\n            result[i] = l[i];\n    }\n\nunittest\n{\n \
    \   alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L,\
    \ 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L,\
    \ 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmptdg5utwz.d(113): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptdg5utwz.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpcvj95udf.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9q0konwr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgcz_hxrv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers in\
    \ the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] result\
    \ = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i]\
    \ < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\n\
    Return only zeros in the list.\n            \n*/\nlong[] get_zero(long[] l) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n/*\nReturn only numbers in the list that are not zero.\n       \
    \     \n*/\nlong[] get_not_zero(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] != 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list\
    \ that are not negative.\n            \n*/\nlong[] get_not_negative(long[] l)\
    \ \n{\n\tlong[] result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn\
    \ result;\n}\n/*\nReturn only numbers in the list that are not positive.\n   \
    \         \n*/\nlong[] get_not_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only numbers in the list\
    \ that are not odd.\n            \n*/\nlong[] get_odd(long[] l) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\t\
    if(l[i] % 2 != 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\nReturn only numbers in the list that are not even.\n            \n*/\n\
    long[] get_even(long[] l) \n{\n\tlong[] result = new long[l.length];\n\tfor(int\
    \ i = 0; i < l.length; i++) \nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1h6w9sxu.d(122): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1h6w9sxu.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] r = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++)\n\t\tr[i] = std.math.min(l[i], 0L);\n\treturn\
    \ r;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmptzai0vf4.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[]\
    \ get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i\
    \ = 0; i < l.length; ++i)\n\t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn res;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; ++i)\n\
    \t\tres[i] = l[i] == 0 ? 0 : l[i];\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by given number.\n            \n*/\nlong[] get_divisible_by(long[]\
    \ l, long d) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length;\
    \ ++i)\n\t\tres[i] = l[i] % d == 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only\
    \ numbers in the list that are divisible by given number.\n            \n*/\n\
    long[] get_divisible_by_array(long[] l, long[] d) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] % d[i] == 0 ? l[i] : 0;\n\
    \treturn res;\n}\n/*\nReturn only numbers in the list that are divisible by given\
    \ number.\n            \n*/\nlong[] get_divisible_by_array(long[] l, long[] d,\
    \ int len) \n{\n\tlong[] res = new long[len];\n\tfor(int i = 0; i < len; ++i)\n\
    \t\tres[i] = l[i] % d[i] == 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by given number.\n            \n*/\nlong[] get_divisible_by_array(long[]\
    \ l, long[] d, long[] m) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i\
    \ = 0; i < l.length; ++i)\n\t\tres[i] = l[i] % d[i] == 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only numbers in the list that are divisible by given number.\n\
    \            \n*/\nlong[] get_divisible_by_array(long[] l, long[] d, long[] m,\
    \ int len) \n{\n\tlong[] res = new long[len];\n\tfor(int i = 0; i < len; ++i)\n\
    \t\tres[i] = l[i] % d[i] == 0 ? l[i] : 0;\n\treturn res;\n\nunittest\n{\n    alias\
    \ candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) ==\
    \ [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L,\
    \ 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp1nhqkk4f.d(90): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp1nhqkk4f.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        \
    \    res[i] = l[i];\n    }\n    return res;\n}\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpr689y_mi.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only negative numbers in the list.\n       \
    \     \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] < 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only zeros in the list.\n            \n*/\n\
    long[] get_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i\
    \ = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] == 0) \n\t\t\tres[i] = l[i];\n\t\
    }\n\treturn res;\n}\n/*\nReturn only numbers in the list that are not zero.\n\
    \            \n*/\nlong[] get_not_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] != 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are not\
    \ negative.\n            \n*/\nlong[] get_not_negative(long[] l) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i]\
    \ < 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not positive.\n            \n*/\nlong[] get_not_positive(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\n\
    Return only numbers in the list that are not odd.\n            \n*/\nlong[] get_odd(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] % 2 != 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n\
    /*\nReturn only numbers in the list that are not even.\n            \n*/\nlong[]\
    \ get_even(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0;\
    \ i < l.length; i++) \n\t{\n\t\tif(l[i] % 2 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\
    \treturn res;\n}\n/*\nReturn only number\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp10edyuy9.d(114): Error: unterminated /* */ comment\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp10edyuy9.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpni_beasv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t{\n\t\t\t\
    result[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n}\n/*\nReturn only negative numbers\
    \ in the list.\n            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[]\
    \ result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\
    \tif (l[i] < 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\treturn result;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\
    \treturn result;\n}\n/*\nReturn only numbers in the list that are divisible by\
    \ given number.\n            \n*/\nlong[] get_divisible_by(long[] l, long d) \n\
    {\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif (l[i] % d == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\t}\n\
    \treturn result;\n}\n/*\nReturn only numbers in the list that are divisible by\
    \ given number.\n            \n*/\nlong[] get_divisible_by_2(long[] l, long d)\
    \ \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % d == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\
    \t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by given number.\n            \n*/\nlong[] get_divisible_by_3(long[] l, long\
    \ d) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % d == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\
    \t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by given number.\n            \n*/\nlong[] get_divisible_by_4(long[] l, long\
    \ d) \n{\n\tlong[] result = new long[l.length];\n\tfor (int i = 0; i < l.length;\
    \ i++) \n\t{\n\t\tif (l[i] % d == 0) \n\t\t{\n\t\t\tresult[i] = l[i];\n\t\t}\n\
    \t}\n\treturn result;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by given number.\n            \n*/\nlong[] get_di\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpi08a926t.d(119): Error: semicolon expected, not \''unittest\''\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpi08a926t.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only negative numbers in the list.\n       \
    \     \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] < 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n\tlong[] res\
    \ = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i]\
    \ % 3 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 5.\n            \n*/\nlong[] get_divisible_by_5(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(l[i] % 5 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n\
    /*\nReturn only numbers in the list that are divisible by 7.\n            \n*/\n\
    long[] get_divisible_by_7(long[] l) \n{\n\tlong[] res = new long[l.length];\n\t\
    for(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 7 == 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ divisible by 11.\n            \n*/\nlong[] get_divisible_by_11(long[] l) \n\
    {\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t\
    {\n\t\tif(l[i] % 11 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\n\
    Return only numbers in the list that are divisible by 15.\n            \n*/\n\
    long[] get_divisible_by_15(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 15 == 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ divisible by 17.\n            \n*/\nlong[] get_divisible_by_17(long[] l) \n\
    {\n\tlong[] res = new long[l.length];\n\t\nunittest\n{\n    alias candidate =\
    \ get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n\
    \    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L,\
    \ 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) == []);\n\
    \    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp51zt3klt.d(108): Error: found \''unittest\'' instead of statement\nFailed:
    ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp51zt3klt.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpatumcycs.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n    long[] res = new long[l.length];\n\
    \    for(int i = 0; i < l.length; ++i)\n    {\n        if(l[i] > 0)\n        {\n\
    \            res[i] = l[i];\n        }\n    }\n    return res;\n}\nunittest\n\
    {\n    alias candidate = get_positive;\n\n    assert(candidate([-1L, -2L, 4L,\
    \ 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L,\
    \ 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L,\
    \ -2L]) == []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpgcz_hxrv.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; ++i)\n\t\tresult[i] = std.math.get_positive(l[i]);\n\
    \treturn result;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpndzaqbx2.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\n/*\nReturn only negative numbers in the list.\n            \n*/\nlong[]\
    \ get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i\
    \ = 0; i < l.length; i++)\n\t\tres[i] = l[i] < 0 ? l[i] : 0;\n\treturn res;\n\
    }\n/*\nReturn only zeros in the list.\n            \n*/\nlong[] get_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] == 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not zero in the list.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\n\
    \t\tres[i] = l[i] != 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not zero in the list.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l, int len) \n{\n\tlong[] res = new long[len];\n\tfor(int i = 0; i < len; i++)\n\
    \t\tres[i] = l[i] != 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not zero in the list.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l, long[] len) \n{\n\tlong[] res = new long[len.length];\n\tfor(int i = 0; i\
    \ < len.length; i++)\n\t\tres[i] = l[i] != 0 ? l[i] : 0;\n\treturn res;\n}\n/*\n\
    Return only numbers in the list that are not zero in the list.\n            \n\
    */\nlong[] get_not_zero(long[] l, long[] len, int len2) \n{\n\tlong[] res = new\
    \ long[len2];\n\tfor(int i = 0; i < len2; i++)\n\t\tres[i] = l[i] != 0 ? l[i]\
    \ : 0;\n\treturn res;\n}\n/*\nReturn only numbers in the list that are not zero\
    \ in the list.\n            \n*/\nlong[] get_not_zero(long[] l, long[] len, long[]\
    \ len2) \n{\n\tlong[] res = new long[len2];\n\tfor(int i = 0; i < len2; i++)\n\
    \t\tres[i] = l[i] != 0 ? l[i] : 0;\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are not zero in the list.\n            \n*/\nlong[] get_not_zero(long[]\
    \ l, long[] len, long[] len2, int len3) \nunittest\n{\n    alias candidate = get_positive;\n\
    \n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmpp0bvztvr.d(95): Error: semicolon expected following function
    declaration\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpp0bvztvr.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9q0konwr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t{\n\t\tif (l[i] > 0)\n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9uwbmoks.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] > 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only negative numbers in the list.\n\
    \            \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] < 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only zeros in the list.\n         \
    \   \n*/\nlong[] get_zero(long[] l) \n{\n\tlong[] res = new long[l.length];\n\t\
    for (int i = 0; i < l.length; i++) \n\t{\n\t\tif (l[i] == 0) \n\t\t\tres[i] =\
    \ l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are not\
    \ zero in the list.\n            \n*/\nlong[] get_not_zero(long[] l) \n{\n\tlong[]\
    \ res = new long[l.length];\n\tfor (int i = 0; i < l.length; i++) \n\t{\n\t\t\
    if (l[i] != 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only\
    \ numbers in the list that are not in the list in the list.\n            \n*/\n\
    long[] get_not_in(long[] l, long[] l2) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; i++) \n\t{\n\t\tif (!std.array.contains(l2, l[i]))\
    \ \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the\
    \ list that are not in the list in the list.\n            \n*/\nlong[] get_not_in_long(long[]\
    \ l, long[] l2) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i <\
    \ l.length; i++) \n\t{\n\t\tif (!std.array.contains(l2, l[i])) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ not in the list in the list.\n            \n*/\nlong[] get_not_in_double(long[]\
    \ l, long[] l2) \n{\n\tlong[] res = new long[l.length];\n\tfor (int i = 0; i <\
    \ l.length; i++) \n\t{\n\t\tif (!std.array.contains(l2, l[i])) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ not in the list in the list.\n            \n*/\nlong[] get_not_in_string(long[]\
    \ l, long[] l2) \n{\n\tlong[] res = new long\nunittest\n{\n    alias candidate\
    \ = get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L,\
    \ 6L]);\n    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L])\
    \ == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) ==\
    \ []);\n    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp6o32_3ac.d(107): Error: semicolon expected, not \''unittest\''\n/tmp/tmp6o32_3ac.d(107):
    Error: found \''unittest\'' instead of statement\nFailed: ["dmd", "-unittest",
    "-v", "-o-", "/tmp/tmp6o32_3ac.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only negative numbers in the list.\n       \
    \     \n*/\nlong[] get_negative(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] < 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are even.\n  \
    \          \n*/\nlong[] get_even(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 2 == 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ odd.\n            \n*/\nlong[] get_odd(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 2 != 0) \n\t\t\tres[i]\
    \ = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are\
    \ divisible by 3.\n            \n*/\nlong[] get_divisible_by_3(long[] l) \n{\n\
    \tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\
    \t\tif(l[i] % 3 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn\
    \ only numbers in the list that are divisible by 5.\n            \n*/\nlong[]\
    \ get_divisible_by_5(long[] l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int\
    \ i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] % 5 == 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\n/*\nReturn only numbers in the list that are divisible\
    \ by 7.\n            \n*/\nlong[] get_divisible_by_7(long[] l) \n{\n\tlong[] res\
    \ = new long[l.length];\n\tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i]\
    \ % 7 == 0) \n\t\t\tres[i] = l[i];\n\t}\n\treturn res;\n}\n/*\nReturn only numbers\
    \ in the list that are divisible by 11.\n            \n*/\nlong[] get_divisible_by_11(long[]\
    \ l) \n{\n\tlong[] res = new long[l.length];\n\tfor(int i = 0; i < l.length; i++)\
    \ \n\t{\n\t\tif(\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''/tmp/tmp67noago1.d(110): Error: expression expected, not \''unittest\''\n/tmp/tmp67noago1.d(111):
    Error: found \''{\'' when expecting \'')\''\n/tmp/tmp67noago1.d(119): Error: found
    \''EOF\'' when expecting \''}\'' following compound statement\nFailed: ["dmd",
    "-unittest", "-v", "-o-", "/tmp/tmp67noago1.d", "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t\tres[i] = l[i];\n\
    \t}\n\treturn res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n  \
    \  assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L,\
    \ 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L,\
    \ 1L]);\n    assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) ==\
    \ []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmp9q0konwr.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] result = new long[l.length];\n\
    \tfor(int i = 0; i < l.length; i++) \n\t{\n\t\tif(l[i] > 0) \n\t\t{\n\t\t\tresult[i]\
    \ = l[i];\n\t\t}\n\t}\n\treturn result;\n}\nunittest\n{\n    alias candidate =\
    \ get_positive;\n\n    assert(candidate([-1L, -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n\
    \    assert(candidate([5L, 3L, -5L, 2L, 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L,\
    \ 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n    assert(candidate([-1L, -2L]) == []);\n\
    \    assert(candidate([]) == []);\n}\nvoid main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpd_nv73i6.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
- exit_code: 1
  program: "import std.math;\n/*\nReturn only positive numbers in the list.\n    \
    \        \n*/\nlong[] get_positive(long[] l) \n{\n\tlong[] res = new long[l.length];\n\
    \tfor (int i = 0; i < l.length; ++i)\n\t\tres[i] = l[i] > 0 ? l[i] : 0;\n\treturn\
    \ res;\n}\nunittest\n{\n    alias candidate = get_positive;\n\n    assert(candidate([-1L,\
    \ -2L, 4L, 5L, 6L]) == [4L, 5L, 6L]);\n    assert(candidate([5L, 3L, -5L, 2L,\
    \ 3L, 3L, 9L, 0L, 123L, 1L, -10L]) == [5L, 3L, 2L, 3L, 3L, 9L, 123L, 1L]);\n \
    \   assert(candidate([-1L, -2L]) == []);\n    assert(candidate([]) == []);\n}\n\
    void main(){}"
  status: SyntaxError
  stderr: 'b''Error: cannot find source code for runtime library file \''object.d\''\n       dmd
    might not be correctly installed. Run \''dmd -man\'' for installation instructions.\nimport
    path[0] = /tmp\nFailed: ["dmd", "-unittest", "-v", "-o-", "/tmp/tmpu63i7qni.d",
    "-I/tmp"]\n'''
  stdout: b''
  timestamp: 1659978111
