language: cpp
name: HumanEval_69_search
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100000];\n    for(long i = 0; i <\
    \ lst.size(); i++) {\n        freq[lst[i]]++;\n    }\n    for(long i = 0; i <\
    \ 100001; i++) {\n        if(freq[i] >= lst.size()) {\n            break;\n  \
    \      }\n        if(freq[i] >= lst.size()) {\n            ans = i;\n        \
    \    break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp29etcdmg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq > ans) {\n            ans = freq;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xy21uz3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i : lst) {\n        if (freq[i]\
    \ >= i) {\n            ans = i;\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpbtizno9g.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i : lst) {\n        if (freq[i]\
    \ > ans) {\n            ans = freq[i];\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpazzuh6vi.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq >= i) {\n            ans = i;\n         \
    \   freq -= i;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqp5a2m2t.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for(long i = 0; i < lst.size();\
    \ i++) {\n        freq[lst[i]]++;\n    }\n    for(long i = 0; i < 1000; i++) {\n\
    \        if(freq[i] >= lst.size()) {\n            ans = i;\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpoc3boihj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq++;\n        if (freq > i) {\n            freq = i;\n            ans\
    \ = i;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpb4q_eqbr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for(long i : lst) {\n \
    \       freq[i] = freq[i] + 1;\n    }\n    for(long i : lst) {\n        if(freq[i]\
    \ >= i) {\n            ans = i;\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_jjm3x7_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[10000];\n    long maxfreq = 0;\n \
    \   for (long i = 0; i < lst.size(); i++) {\n        freq[lst[i]]++;\n       \
    \ if (freq[lst[i]] > maxfreq) {\n            maxfreq = freq[lst[i]];\n       \
    \     ans = lst[i];\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5,\
    \ (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpymgloesp.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i : lst) {\n        if (freq[i]\
    \ >= i) {\n            ans = i;\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpbtizno9g.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for(long i : lst) {\n \
    \       freq[i] = freq[i] + 1;\n    }\n    for(long i : lst) {\n        if(freq[i]\
    \ >= i) {\n            ans = i;\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_jjm3x7_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Write your code here\n    long maxVal = -1, maxFreq = -1;\n \
    \   for (long i = 0; i < lst.size(); i++) {\n        if (lst[i] > maxVal) {\n\
    \            maxVal = lst[i];\n            maxFreq = i;\n        } else if (lst[i]\
    \ == maxVal) {\n            maxFreq++;\n        }\n    }\n    return maxVal;\n\
    }\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpb8kig_ty.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100000];\n    for (long i = 0; i <\
    \ lst.size(); i++) {\n        freq[lst[i]]++;\n    }\n    for (long i = 0; i <\
    \ 100001; i++) {\n        if (freq[i] >= lst.size()) {\n            ans = i;\n\
    \            break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5,\
    \ (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmplgb_v7nj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Write your code here\n    long ans = -1;\n    long freq[1000];\n\
    \    for (long i : lst) {\n        freq[i] = freq[i] + 1;\n    }\n    for (long\
    \ i : lst) {\n        if (freq[i] >= i) {\n            ans = i;\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqljr_6ys.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for (long i : lst) {\n\
    \        freq[i]++;\n    }\n    for (long i : lst) {\n        if (freq[i] > ans)\
    \ {\n            ans = freq[i];\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpi238v6ji.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq >= i) {\n            ans = i;\n         \
    \   freq -= i;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqp5a2m2t.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long maxVal = -1;\n    long maxFreq = -1;\n    for(long i = 0; i\
    \ < lst.size(); i++) {\n        if(lst[i] > maxVal) {\n            maxVal = lst[i];\n\
    \            maxFreq = i;\n        }\n    }\n    return maxFreq;\n}\nint main()\
    \ {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprp6qocar.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i : lst) {\n        if (freq[i]\
    \ > ans) {\n            ans = freq[i];\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpazzuh6vi.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for(long i = 0; i < lst.size();\
    \ i++){\n        freq[lst[i]]++;\n    }\n    for(long i = 0; i < 100; i++){\n\
    \        if(freq[i] >= lst.size()){\n            return -1;\n        }\n    }\n\
    \    for(long i = 0; i < lst.size(); i++){\n        if(freq[lst[i]] >= lst.size()){\n\
    \            ans = lst[i];\n            break;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpgf7bw2b7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq > ans) {\n            ans = freq;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xy21uz3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Write your code here\n    long ans = -1;\n    long freq = 0;\n\
    \    for(long i : lst) {\n        freq++;\n        if(freq > i) {\n          \
    \  freq = i;\n            ans = i;\n        }\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpp0ayxjew.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for (long i = 0; i < lst.size();\
    \ i++) {\n        freq[lst[i]]++;\n    }\n    for (long i = 0; i < 1000; i++)\
    \ {\n        if (freq[i] >= ans) {\n            ans = i;\n        }\n    }\n \
    \   return ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpfqx1pxsk.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for(long i : lst) {\n \
    \       freq[i] = freq[i] + 1;\n    }\n    for(long i : lst) {\n        if(freq[i]\
    \ >= i) {\n            ans = i;\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_jjm3x7_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[10000];\n    for (long i = 0; i <\
    \ lst.size(); i++) {\n        freq[lst[i]]++;\n    }\n    for (long i = 0; i <\
    \ 10000; i++) {\n        if (freq[i] >= lst.size()) {\n            ans = i;\n\
    \            break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5,\
    \ (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpouqxhf9m.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Write your code here.\n    long ans = -1;\n    long freq[100];\n\
    \    for(long i = 0; i < lst.size(); i++) {\n        freq[lst[i]]++;\n    }\n\
    \    for(long i = 0; i < lst.size(); i++) {\n        if(freq[lst[i]] >= ans) {\n\
    \            ans = freq[lst[i]];\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpihub0p9t.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[10000];\n    for(long i = 0; i < lst.size();\
    \ i++) {\n        freq[lst[i]]++;\n    }\n    for(long i = 0; i < 10000; i++)\
    \ {\n        if(freq[i] >= lst.size()) {\n            ans = i;\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpy8u_x4_5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100000];\n    for(long i = 0; i <\
    \ lst.size(); i++) {\n        freq[lst[i]]++;\n    }\n    for(long i = 0; i <\
    \ 100000; i++) {\n        if(freq[i] >= lst.size()) {\n            ans = i;\n\
    \            break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5,\
    \ (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpk_y41h52.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Your code here\n    long ans = -1;\n    long freq[100];\n   \
    \ for(long i : lst){\n        freq[i] = freq[i] + 1;\n    }\n    for(long i :\
    \ freq){\n        if(freq[i] >= i){\n            ans = i;\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpjtbg8y1v.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq > ans) {\n            ans = freq;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xy21uz3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for(long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for(long i : lst) {\n        if(freq[i]\
    \ >= i) {\n            ans = i;\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpwn_s98rj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Write your code here\n    long ans = -1;\n    long freq = 0;\n\
    \    for (long i : lst) {\n        freq += i;\n        if (freq > ans) {\n   \
    \         ans = freq;\n        }\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp2q_chcpr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq > ans) {\n            ans = freq;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xy21uz3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i : lst) {\n        if (freq[i]\
    \ >= i) {\n            ans = i;\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpbtizno9g.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long maxVal = -1, freq = -1;\n    for(long i = 0; i < lst.size();\
    \ i++){\n        if(lst[i] > 0 && lst[i] <= maxVal && lst[i] >= freq){\n     \
    \       maxVal = lst[i];\n            freq = lst[i];\n        }\n    }\n    return\
    \ maxVal;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp56w6s9tf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq++;\n        if (i > 0 && freq > i) {\n            ans = i;\n    \
    \        freq = i;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5,\
    \ (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpodt9bc6c.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long maxVal = lst[0];\n    long maxFreq = lst[0];\n    for(long\
    \ i = 1; i < lst.size(); i++) {\n        if(lst[i] > maxVal) {\n            maxVal\
    \ = lst[i];\n            maxFreq = lst[i];\n        }\n        else if(lst[i]\
    \ == maxVal) {\n            maxFreq++;\n        }\n    }\n    return maxVal;\n\
    }\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmphjzdp5b5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Write your code here\n    long ans = -1;\n    long freq = 0;\n\
    \    for (long i : lst) {\n        freq += i;\n        if (freq > ans) {\n   \
    \         ans = freq;\n        }\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp2q_chcpr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for(long i = 0; i < lst.size();\
    \ i++) {\n        freq[lst[i]]++;\n    }\n    for(long i = 1; i < 1000; i++) {\n\
    \        if(freq[i] >= freq[i-1]) {\n            ans = i;\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpdgldsd7y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for(long i : lst) {\n\
    \        freq[i]++;\n    }\n    for(long i = 1; i <= 1000; i++) {\n        if(freq[i]\
    \ >= i) {\n            ans = i;\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprnmcythr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for (long i : lst) {\n\
    \        freq[i]++;\n    }\n    for (long i : lst) {\n        if (freq[i] > ans)\
    \ {\n            ans = freq[i];\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpi238v6ji.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq > ans) {\n            ans = freq;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xy21uz3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq >= i) {\n            ans = i;\n         \
    \   break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqguy5q0w.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for(long i = 0; i < lst.size();\
    \ i++) {\n        freq[lst[i]]++;\n    }\n    for(long i = 0; i < 1000; i++) {\n\
    \        if(freq[i] >= lst.size()) {\n            ans = i;\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpoc3boihj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i : lst) {\n        if (freq[i]\
    \ > ans) {\n            ans = freq[i];\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpgsp59_6s.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i : lst) {\n        if (freq[i]\
    \ > ans) {\n            ans = freq[i];\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpazzuh6vi.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[10000];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i = 0; i < 10000; i++) {\n\
    \        if (freq[i] >= lst[0]) {\n            ans = i;\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9j6gl7aj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[10000];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i = 1; i < 10000; i++) {\n\
    \        if (freq[i] >= i) {\n            ans = i;\n            break;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpr3lzufx_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Your code here\n    long ans = -1;\n    long freq[100000];\n\
    \    for (long i : lst) {\n        freq[i] = freq[i] + 1;\n    }\n    for (long\
    \ i = 0; i < 100000; i++) {\n        if (freq[i] > 0 && freq[i] >= i) {\n    \
    \        ans = i;\n            break;\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqts2dd87.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for(long i = 0; i < lst.size();\
    \ i++) {\n        freq[lst[i]]++;\n    }\n    for(long i = 1; i < 1000; i++) {\n\
    \        if(freq[i] > freq[ans]) {\n            ans = i;\n        }\n    }\n \
    \   return ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp1t7dedq2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq > ans) {\n            ans = freq;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xy21uz3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for (long i = 0; i < lst.size();\
    \ i++) {\n        freq[lst[i]]++;\n    }\n    for (long i = 0; i < 100; i++) {\n\
    \        if (freq[i] > 0 && freq[i] >= lst[0]) {\n            ans = i;\n     \
    \       break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp75yjlyss.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq++;\n        if (freq > i) {\n            freq = i;\n            ans\
    \ = i;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpb4q_eqbr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for(long i : lst) {\n\
    \        freq[i]++;\n    }\n    for(long i : lst) {\n        if(freq[i] >= i)\
    \ {\n            ans = i;\n            break;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmppv7t7i8j.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq++;\n        if (freq > i) {\n            freq = i;\n            ans\
    \ = i;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpb4q_eqbr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i : lst) {\n        if (freq[i]\
    \ >= i) {\n            ans = i;\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpbtizno9g.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for(long i = 0; i < lst.size();\
    \ i++) {\n        freq[lst[i]]++;\n    }\n    for(long i = 0; i < 1000; i++) {\n\
    \        if(freq[i] >= lst.size()) {\n            ans = i;\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpoc3boihj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long maxVal = -1, maxCount = 0;\n    for (long i = 0; i < lst.size();\
    \ i++) {\n        if (lst[i] > maxVal) {\n            maxVal = lst[i];\n     \
    \       maxCount = 1;\n        } else if (lst[i] == maxVal) {\n            maxCount++;\n\
    \        }\n    }\n    return maxVal;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxs1eaft1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100] = {0};\n    for (long i : lst)\
    \ {\n        freq[i]++;\n    }\n    for (long i : lst) {\n        if (freq[i]\
    \ >= i) {\n            ans = i;\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmptm2_1hk4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Your code here\n    long ans = -1;\n    long freq = 0;\n    for\
    \ (long i : lst) {\n        freq++;\n        if (i > 0 && freq >= i) {\n     \
    \       ans = i;\n            freq--;\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp6us4ptvn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i : lst) {\n        if (freq[i]\
    \ > ans) {\n            ans = freq[i];\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpazzuh6vi.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[10000];\n    for (long i = 0; i <\
    \ lst.size(); i++) {\n        freq[lst[i]]++;\n    }\n    for (long i = 0; i <\
    \ 10000; i++) {\n        if (freq[i] >= lst.size()) {\n            ans = i;\n\
    \            break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5,\
    \ (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpouqxhf9m.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq > ans) {\n            ans = freq;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xy21uz3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i : lst) {\n        if (freq[i]\
    \ >= i) {\n            ans = i;\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmps79d71um.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i : lst) {\n        if (freq[i]\
    \ >= i) {\n            ans = i;\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpbtizno9g.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Write your code here\n    long ans = -1;\n    long freq = 0;\n\
    \    for(long i = 0; i < lst.size(); i++){\n        freq += lst[i];\n        if(freq\
    \ > ans){\n            ans = freq;\n        }\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpnm6chtir.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for(long i = 0; i < lst.size();\
    \ i++) {\n        freq[lst[i]]++;\n    }\n    for(long i = 0; i < 100; i++) {\n\
    \        if(freq[i] >= lst.size()) {\n            ans = i;\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9usg6xh2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for(long i = 0; i < lst.size();\
    \ i++) {\n        freq[lst[i]]++;\n    }\n    for(long i = 0; i < 1000; i++) {\n\
    \        if(freq[i] >= lst.size()) {\n            ans = i;\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpoc3boihj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    long long maxFreq = -1;\n\
    \    for(long i = 0; i < lst.size(); i++) {\n        freq[lst[i]]++;\n       \
    \ if(freq[lst[i]] > maxFreq) {\n            maxFreq = freq[lst[i]];\n        \
    \    ans = lst[i];\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5,\
    \ (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpz0ijph4n.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Your code here\n    long ans = -1;\n    long freq = 0;\n    for(long\
    \ i : lst) {\n        freq++;\n        if(freq > i) {\n            freq = i;\n\
    \            ans = i;\n        }\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp1ufigeqs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for(long i : lst) {\n\
    \        freq[i]++;\n    }\n    for(long i : lst) {\n        if(freq[i] > ans)\
    \ {\n            ans = freq[i];\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpj1rle4zr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for(long i : lst) {\n  \
    \      freq += i;\n        if(freq > ans) {\n            ans = freq;\n       \
    \ }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n \
    \   assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5, (long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)4,\
    \ (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmphvyu_qix.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for (long i : lst) {\n\
    \        freq[i]++;\n    }\n    for (long i = 1; i < 1000; i++) {\n        if\
    \ (freq[i] > freq[i - 1]) {\n            ans = i;\n            break;\n      \
    \  }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9fs4ustg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long maxVal = -1;\n    long freq = -1;\n    for(long i = 0; i <\
    \ lst.size(); i++) {\n        if(lst[i] > 0 && lst[i] <= maxVal) {\n         \
    \   freq++;\n            if(lst[i] == maxVal) {\n                maxVal = lst[i];\n\
    \            }\n        }\n    }\n    return maxVal;\n}\nint main() {\n    auto\
    \ candidate = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5,\
    \ (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5g0q473f.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Write your code here\n    long ans = -1;\n    long freq[1000];\n\
    \    for(long i : lst){\n        freq[i]++;\n    }\n    for(long i : lst){\n \
    \       if(freq[i] >= ans){\n            ans = freq[i];\n        }\n    }\n  \
    \  return ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7gtuqz7z.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq++;\n        if (freq > i) {\n            freq = i;\n            ans\
    \ = i;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpb4q_eqbr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for (long i = 0; i < lst.size();\
    \ i++) {\n        freq[lst[i]]++;\n    }\n    for (long i = 0; i < 1000; i++)\
    \ {\n        if (freq[i] >= lst.size()) {\n            ans = i;\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpcm0kchzr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for(long i : lst) {\n  \
    \      freq = freq + i;\n        if(freq > ans) {\n            ans = freq;\n \
    \       }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpoqwxty9f.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq > ans) {\n            ans = freq;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xy21uz3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i : lst) {\n        if (freq[i]\
    \ >= i) {\n            ans = i;\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpbtizno9g.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for(long i : lst) {\n  \
    \      freq += i;\n        if(freq > ans) {\n            ans = freq;\n       \
    \ }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n \
    \   assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5, (long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)4,\
    \ (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmphvyu_qix.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[10000];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i : lst) {\n        if (freq[i]\
    \ >= i) {\n            ans = i;\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmptufvcuc3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq > ans) {\n            ans = freq;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xy21uz3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq >= i) {\n            ans = i;\n         \
    \   break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqguy5q0w.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Write your code here\n    long ans = -1;\n    long freq[10000];\n\
    \    for(long i : lst){\n        freq[i] = freq[i] + 1;\n    }\n    for(long i\
    \ : lst){\n        if(freq[i] >= ans){\n            ans = freq[i];\n        }\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9y6mr7xv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for(long i : lst) {\n \
    \       freq[i] = freq[i] + 1;\n    }\n    for(long i : lst) {\n        if(freq[i]\
    \ >= i) {\n            ans = i;\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_jjm3x7_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i = 0; i < 100; i++) {\n\
    \        if (freq[i] >= lst[0]) {\n            ans = i;\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp6go491_c.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for(long i = 0; i < lst.size();\
    \ i++) {\n        freq[lst[i]]++;\n    }\n    for(long i = 0; i < 100; i++) {\n\
    \        if(freq[i] >= lst.size()) {\n            ans = i;\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9usg6xh2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Write your code here.\n    long ans = -1;\n    long freq = 0;\n\
    \    for (long i : lst) {\n        freq++;\n        if (freq > i) {\n        \
    \    freq = i;\n            ans = i;\n        }\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpyarem7y_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Your code here\n    long ans = -1;\n    long freq = 0;\n    for\
    \ (long i : lst) {\n        freq++;\n        if (freq >= i) {\n            ans\
    \ = i;\n            freq--;\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpovym2g2e.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Write your code here\n    long ans = -1;\n    long freq = 0;\n\
    \    for(long i : lst){\n        freq++;\n        if(freq > i){\n            freq\
    \ = i;\n            ans = i;\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmptv55fs5_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq > ans) {\n            ans = freq;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xy21uz3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq >= i) {\n            ans = i;\n         \
    \   freq -= i;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqp5a2m2t.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq > ans) {\n            ans = freq;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xy21uz3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq++;\n        if (i > 0 && freq >= i) {\n            ans = i;\n   \
    \         freq -= i;\n        }\n    }\n    return ans;\n}\nint main() {\n   \
    \ auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpn1ix1lup.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i : lst) {\n        if (freq[i]\
    \ > ans) {\n            ans = freq[i];\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpgsp59_6s.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq >= i) {\n            ans = i;\n         \
    \   freq -= i;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqp5a2m2t.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for(long i : lst) {\n \
    \       freq[i] = freq[i] + 1;\n    }\n    for(long i : lst) {\n        if(freq[i]\
    \ >= i) {\n            ans = i;\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_jjm3x7_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Write your code here\n    long ans = -1;\n    long freq[100];\n\
    \    for(long i : lst) {\n        freq[i] = freq[i] + 1;\n    }\n    for(long\
    \ i : freq) {\n        if(freq[i] > ans) {\n            ans = freq[i];\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpbcgez2su.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq >= i) {\n            ans = i;\n         \
    \   break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqguy5q0w.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[10000];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i = 0; i < 10000; i++) {\n\
    \        if (freq[i] > ans) {\n            ans = freq[i];\n        }\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpd0j5c7gh.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for (long i : lst) {\n\
    \        freq[i]++;\n    }\n    for (long i : lst) {\n        if (freq[i] >= i)\
    \ {\n            ans = i;\n            break;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpp09jzb5t.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // code here\n    long ans = -1;\n    long freq[1000];\n    for\
    \ (long i : lst) {\n        freq[i] = freq[i] + 1;\n    }\n    for (long i = 1;\
    \ i <= 1000; i++) {\n        if (freq[i] >= i) {\n            ans = i;\n     \
    \       break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpk52t67lj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100] = {0};\n    for(long i : lst)\
    \ {\n        freq[i]++;\n    }\n    for(long i = 1; i < 100; i++) {\n        if(freq[i]\
    \ > freq[i-1]) {\n            ans = i;\n            break;\n        }\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0jsp2w5y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for(long i = 0; i < lst.size();\
    \ i++) {\n        freq[lst[i]]++;\n    }\n    for(long i = 0; i < 1000; i++) {\n\
    \        if(freq[i] >= lst.size()) {\n            ans = i;\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpoc3boihj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Your code here\n    long ans = -1;\n    long freq[100];\n   \
    \ for (long i : lst) {\n        freq[i] = freq[i] + 1;\n    }\n    for (long i\
    \ : lst) {\n        if (freq[i] > ans) {\n            ans = freq[i];\n       \
    \ }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n \
    \   assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5, (long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)4,\
    \ (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmppcaeh8ep.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq > ans) {\n            ans = freq;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xy21uz3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for(long i : lst) {\n\
    \        freq[i]++;\n    }\n    for(long i : lst) {\n        if(freq[i] > ans)\
    \ {\n            ans = freq[i];\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpj1rle4zr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq >= i) {\n            ans = i;\n         \
    \   freq -= i;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqp5a2m2t.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i : lst) {\n        if (freq[i]\
    \ >= i) {\n            ans = i;\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmps79d71um.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i : lst) {\n        if (freq[i]\
    \ > ans) {\n            ans = freq[i];\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpazzuh6vi.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Write your code here.\n    long max = 0;\n    long freq = 0;\n\
    \    for(long i = 0; i < lst.size(); i++){\n        if(lst[i] > 0){\n        \
    \    freq++;\n            if(lst[i] > max){\n                max = lst[i];\n \
    \           }\n        }\n    }\n    if(freq > 0){\n        return max;\n    }\n\
    \    return -1;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpby0t1qc_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i = 1; i <= 1000; i++) {\n\
    \        if (freq[i] >= i) {\n            ans = i;\n            break;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpoz6w7v88.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i : lst) {\n        if (freq[i]\
    \ > ans) {\n            ans = freq[i];\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpazzuh6vi.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for(long i : lst) {\n  \
    \      freq += i;\n        if(freq > ans) {\n            ans = freq;\n       \
    \ }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n \
    \   assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5, (long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1, (long)4,\
    \ (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmphvyu_qix.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Your code here\n    long ans = -1;\n    long freq[1000];\n  \
    \  for (long i : lst) {\n        freq[i] = freq[i] + 1;\n    }\n    for (long\
    \ i : lst) {\n        if (freq[i] >= i) {\n            ans = i;\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpckxi4jjj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Write your code here\n    long ans = -1;\n    long freq[100000];\n\
    \    for(long i : lst){\n        freq[i]++;\n    }\n    for(long i : freq){\n\
    \        if(freq[i] >= ans){\n            ans = i;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp1ei6957t.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Write your code here\n    long ans = -1;\n    long freq = 0;\n\
    \    for(long i : lst) {\n        freq++;\n        if(freq > i) {\n          \
    \  freq = i;\n            ans = i;\n        }\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpp0ayxjew.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long maxVal = lst[0];\n    long freq = lst[0];\n    for(long i =\
    \ 1; i < lst.size(); i++) {\n        if(lst[i] > maxVal) {\n            maxVal\
    \ = lst[i];\n            freq = lst[i];\n        }\n    }\n    if(freq >= lst[0])\
    \ {\n        return maxVal;\n    } else {\n        return -1;\n    }\n}\nint main()\
    \ {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpc3iztyi7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for(long i : lst) {\n  \
    \      freq += i;\n        if(freq >= i) {\n            ans = i;\n           \
    \ break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpr1ulvfgv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq >= i) {\n            ans = i;\n         \
    \   freq -= i;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqp5a2m2t.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for(long i : lst) {\n  \
    \      freq += i;\n        if(freq >= i) {\n            ans = i;\n           \
    \ break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpr1ulvfgv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq >= i) {\n            ans = i;\n         \
    \   freq -= i;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqp5a2m2t.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i : lst) {\n        if (freq[i]\
    \ >= i) {\n            ans = i;\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmps79d71um.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Write your code here\n    long ans = -1;\n    long freq[1000];\n\
    \    for(long i = 0; i < lst.size(); i++){\n        freq[lst[i]]++;\n    }\n \
    \   for(long i = 0; i < 1000; i++){\n        if(freq[i] >= lst.size()){\n    \
    \        ans = i;\n            break;\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpkaagnwxd.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for(long i : lst) {\n  \
    \      freq++;\n        if(freq > i) {\n            freq = i;\n            ans\
    \ = i;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmptdg9vyad.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for(long i = 0; i < lst.size();\
    \ i++) {\n        freq[lst[i]]++;\n    }\n    for(long i = 0; i < 1000; i++) {\n\
    \        if(freq[i] >= lst.size()) {\n            ans = i;\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpoc3boihj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for(long i = 0; i < lst.size();\
    \ i++) {\n        freq[lst[i]]++;\n    }\n    for(long i = 0; i < lst.size();\
    \ i++) {\n        if(freq[lst[i]] >= lst[i]) {\n            ans = lst[i];\n  \
    \          break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5,\
    \ (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5tyeauph.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for(long i : lst) {\n  \
    \      freq = freq + i;\n        if(freq >= i) {\n            ans = i;\n     \
    \       break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp3q5ts9sm.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for(long i = 0; i < lst.size();\
    \ i++) {\n        freq[lst[i]]++;\n    }\n    for(long i = 0; i < 1000; i++) {\n\
    \        if(freq[i] >= lst.size()) {\n            ans = i;\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpoc3boihj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq++;\n        if (i > 0 && freq >= i) {\n            ans = i;\n   \
    \         freq = i;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5,\
    \ (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpwn85w050.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for(long i : lst) {\n  \
    \      freq++;\n        if(freq > i) {\n            freq = i;\n            ans\
    \ = i;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmptdg9vyad.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i : lst) {\n        if (freq[i]\
    \ >= i) {\n            ans = i;\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpbtizno9g.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for(long i : lst) {\n\
    \        freq[i]++;\n    }\n    for(long i : lst) {\n        if(freq[i] >= i)\
    \ {\n            ans = i;\n            break;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmppv7t7i8j.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq++;\n        if (freq >= i) {\n            ans = i;\n            freq--;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9g57v7fj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for(long i = 0; i < lst.size();\
    \ i++) {\n        freq[lst[i]]++;\n    }\n    for(long i = 0; i < 1000; i++) {\n\
    \        if(freq[i] >= lst.size()) {\n            ans = i;\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpoc3boihj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for(long i = 0; i < lst.size();\
    \ i++) {\n        freq[lst[i]]++;\n    }\n    for(long i = 0; i < 1000; i++) {\n\
    \        if(freq[i] >= lst.size()) {\n            ans = i;\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpoc3boihj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq > ans) {\n            ans = freq;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xy21uz3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for(long i : lst) {\n  \
    \      freq += i;\n        if(freq >= i) {\n            ans = i;\n           \
    \ break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpr1ulvfgv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for(long i : lst) {\n  \
    \      freq++;\n        if(freq > i) {\n            ans = i;\n            freq\
    \ = i;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxufdl03_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for(long i : lst) {\n\
    \        freq[i]++;\n    }\n    for(long i : lst) {\n        if(freq[i] >= i)\
    \ {\n            ans = i;\n            break;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmppv7t7i8j.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for(long i = 0; i < lst.size();\
    \ i++) {\n        freq[lst[i]]++;\n    }\n    for(long i = 0; i < 100; i++) {\n\
    \        if(freq[i] >= lst.size()) {\n            ans = i;\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9usg6xh2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i : lst) {\n        if (freq[i]\
    \ > ans) {\n            ans = freq[i];\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpazzuh6vi.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i : lst) {\n        if (freq[i]\
    \ >= i) {\n            ans = i;\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpbtizno9g.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for(long i = 0; i < lst.size();\
    \ i++) {\n        freq[lst[i]]++;\n    }\n    for(long i = 0; i < 100; i++) {\n\
    \        if(freq[i] >= lst.size()) {\n            return -1;\n        }\n    \
    \    if(freq[i] > ans) {\n            ans = freq[i];\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp3g3won3l.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq > ans) {\n            ans = freq;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xy21uz3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for(long i = 0; i < lst.size();\
    \ i++) {\n        freq[lst[i]]++;\n    }\n    for(long i = 0; i < 100; i++) {\n\
    \        if(freq[i] >= lst.size()) {\n            ans = i;\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9usg6xh2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100000];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i = 0; i < 100000; i++)\
    \ {\n        if (freq[i] >= lst[0]) {\n            ans = i;\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp2mfttrsn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq > ans) {\n            ans = freq;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xy21uz3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[10000];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i = 0; i < 10000; i++) {\n\
    \        if (freq[i] >= lst[0]) {\n            ans = i;\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9j6gl7aj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i : lst) {\n        if (freq[i]\
    \ >= i) {\n            ans = i;\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmps79d71um.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    long max = 0;\n    for(long\
    \ i = 0; i < lst.size(); i++) {\n        freq[lst[i]]++;\n        if(lst[i] >\
    \ max) {\n            max = lst[i];\n        }\n    }\n    for(long i = 0; i <\
    \ lst.size(); i++) {\n        if(freq[lst[i]] >= max) {\n            ans = lst[i];\n\
    \            break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5,\
    \ (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpoo7lrb7p.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq > ans) {\n            ans = freq;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xy21uz3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq > ans) {\n            ans = freq;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xy21uz3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for(long &i : lst) {\n\
    \        freq[i]++;\n    }\n    for(long i : freq) {\n        if(freq[i] > ans)\
    \ {\n            ans = freq[i];\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp08tfs_9a.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for(long i = 0; i < lst.size();\
    \ i++) {\n        freq[lst[i]]++;\n    }\n    for(long i = 0; i < 100; i++) {\n\
    \        if(freq[i] >= lst.size()) {\n            ans = i;\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9usg6xh2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq >= i) {\n            ans = i;\n         \
    \   freq -= i;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqp5a2m2t.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq > ans) {\n            ans = freq;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xy21uz3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq > ans) {\n            ans = freq;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xy21uz3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Write your code here\n    long ans = -1;\n    long freq[100];\n\
    \    for(long i = 0; i < lst.size(); ++i)\n        freq[lst[i]]++;\n    for(long\
    \ i = 0; i < 100; ++i)\n        if(freq[i] > 0)\n            ans = max(ans, i);\n\
    \    return ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpkyivmmbg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Write your code here\n    long ans = -1;\n    long freq[100];\n\
    \    for(long i : lst) {\n        freq[i] = freq[i] + 1;\n    }\n    for(long\
    \ i : lst) {\n        if(freq[i] >= i) {\n            ans = i;\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprwzb2svt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for(long i = 0; i < lst.size();\
    \ ++i)\n        freq[lst[i]]++;\n    for(long i = 1; i < 1000; ++i)\n        if(freq[i]\
    \ >= freq[ans])\n            ans = i;\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5,\
    \ (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpkmtyq7mm.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq > ans) {\n            ans = freq;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xy21uz3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // code here\n    long maxVal = -1;\n    long maxFreq = -1;\n  \
    \  long currFreq = 0;\n    for(long i = 0; i < lst.size(); i++){\n        if(lst[i]\
    \ > 0){\n            currFreq++;\n            if(currFreq > maxFreq){\n      \
    \          maxFreq = currFreq;\n                maxVal = lst[i];\n           \
    \ }\n        }\n    }\n    return maxVal;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp3_7ek0ux.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for(long i : lst) {\n\
    \        freq[i]++;\n    }\n    for(long i : lst) {\n        if(freq[i] >= i)\
    \ {\n            ans = i;\n            break;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmppv7t7i8j.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Your code here\n    long ans = -1;\n    long freq[100];\n   \
    \ for (long i = 0; i < lst.size(); i++) {\n        freq[lst[i]]++;\n    }\n  \
    \  for (long i = 0; i < 100; i++) {\n        if (freq[i] >= lst.size()) {\n  \
    \          ans = i;\n            break;\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpzbvohsf0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for(long i : lst) {\n\
    \        freq[i]++;\n    }\n    for(long i : lst) {\n        if(freq[i] >= i)\
    \ {\n            ans = i;\n            break;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmppv7t7i8j.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Write your code here\n    long ans = -1;\n    long freq[1000];\n\
    \    for(long i = 0; i < lst.size(); ++i){\n        freq[lst[i]]++;\n    }\n \
    \   for(long i = 0; i < 1000; ++i){\n        if(freq[i] >= lst.size()){\n    \
    \        ans = i;\n            break;\n        }\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmps1sarfav.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for(long i : lst) {\n  \
    \      freq += i;\n        if(freq >= i) {\n            ans = i;\n           \
    \ break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpr1ulvfgv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq++;\n        if (freq > i) {\n            ans = i;\n            freq\
    \ = i;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp4m0g9d0w.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq > ans) {\n            ans = freq;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xy21uz3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq > ans) {\n            ans = freq;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xy21uz3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i = 1; i <= 1000; i++) {\n\
    \        if (freq[i] >= i) {\n            ans = i;\n            break;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpoz6w7v88.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq > ans) {\n            ans = freq;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xy21uz3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Write your code here\n    long ans = -1;\n    long freq = 0;\n\
    \    for (long i : lst) {\n        freq++;\n        if (i > 0 && freq >= i) {\n\
    \            ans = i;\n            freq--;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmphl7af1b8.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Write your code here\n    long ans = -1;\n    long freq[100];\n\
    \    for (long i : lst) {\n        freq[i] = freq[i] + 1;\n    }\n    for (long\
    \ i : lst) {\n        if (freq[i] >= i) {\n            ans = i;\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpl1hr04tm.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for(long i : lst) {\n \
    \       freq[i]++;\n    }\n    for(long i : lst) {\n        if(freq[i] >= i) {\n\
    \            ans = i;\n            break;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpt4pcgq6a.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // code here\n    long ans = -1;\n    long freq = 0;\n    for (long\
    \ i : lst) {\n        freq += i;\n        if (freq > ans) {\n            ans =\
    \ freq;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9vatx4vh.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028438
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i : lst) {\n        if (freq[i]\
    \ >= i) {\n            ans = i;\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpbtizno9g.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i : lst) {\n        if (freq[i]\
    \ >= i) {\n            ans = i;\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpbtizno9g.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for(long i = 0; i < lst.size();\
    \ i++) {\n        freq[lst[i]]++;\n    }\n    for(long i = 0; i < 100; i++) {\n\
    \        if(freq[i] > 0 && freq[i] >= lst[0]) {\n            ans = i;\n      \
    \      break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpea2neo8y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028438
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Your code here\n    long ans = -1;\n    long freq = 0;\n    for\
    \ (long i : lst) {\n        freq++;\n        if (freq > i) {\n            freq\
    \ = i;\n            ans = i;\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpiyookbhh.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028438
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Your code here\n    long ans = -1;\n    long freq = 0;\n    for\
    \ (long i : lst) {\n        freq++;\n        if (freq >= i) {\n            ans\
    \ = i;\n            break;\n        }\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpa25mz79p.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028438
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Your code here\n    long ans = -1;\n    long freq = 0;\n    for\
    \ (long i : lst) {\n        freq += i;\n        if (freq >= i) {\n           \
    \ ans = i;\n            break;\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpyqdd_x1_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028438
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for(long i : lst) {\n\
    \        freq[i]++;\n    }\n    for(long i : lst) {\n        if(freq[i] >= i)\
    \ {\n            ans = i;\n            break;\n        }\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmppv7t7i8j.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq >= i) {\n            ans = i;\n         \
    \   freq -= i;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqp5a2m2t.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i : lst) {\n        if (freq[i]\
    \ >= i) {\n            ans = i;\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmps79d71um.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq > ans) {\n            ans = freq;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xy21uz3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long maxVal = lst[0];\n    long maxFreq = lst[0];\n    for(long\
    \ i = 1; i < lst.size(); i++) {\n        if(lst[i] > maxVal) {\n            maxVal\
    \ = lst[i];\n            maxFreq = i;\n        }\n    }\n    return maxFreq;\n\
    }\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpgtnzud62.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028438
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq > ans) {\n            ans = freq;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xy21uz3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq >= i) {\n            ans = i;\n         \
    \   freq -= i;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqp5a2m2t.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i : lst) {\n        if (freq[i]\
    \ >= i) {\n            ans = i;\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmps79d71um.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100000];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i = 1; i <= 100000; i++)\
    \ {\n        if (freq[i] >= i) {\n            ans = i;\n            break;\n \
    \       }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqbufbw6v.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028438
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[100];\n    for(long i = 0; i < lst.size();\
    \ i++) {\n        freq[lst[i]]++;\n    }\n    for(long i = 0; i < 100; i++) {\n\
    \        if(freq[i] >= lst.size()) {\n            ans = i;\n            break;\n\
    \        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9usg6xh2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    long maxfreq = 0;\n  \
    \  for (long i = 0; i < lst.size(); i++) {\n        freq[lst[i]]++;\n        if\
    \ (freq[lst[i]] > maxfreq) {\n            maxfreq = freq[lst[i]];\n          \
    \  ans = lst[i];\n        }\n    }\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5,\
    \ (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8u1c9zh9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028438
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[10000];\n    for (long i : lst) {\n\
    \        freq[i] = freq[i] + 1;\n    }\n    for (long i : lst) {\n        if (freq[i]\
    \ >= i) {\n            ans = i;\n            break;\n        }\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmptufvcuc3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028437
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq[1000];\n    for(long i = 0; i < lst.size();\
    \ i++){\n        freq[lst[i]]++;\n    }\n    for(long i = 0; i < 1000; i++){\n\
    \        if(freq[i] >= lst.size()){\n            return -1;\n        }\n     \
    \   else{\n            if(freq[i] > ans){\n                ans = freq[i];\n  \
    \          }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = search;\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5,\
    \ (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpa75dlt8g.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028438
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long maxVal = -1;\n    long maxFreq = -1;\n    long currFreq = 0;\n\
    \    for (long i = 0; i < lst.size(); i++) {\n        if (lst[i] > 0 && currFreq\
    \ >= lst[i]) {\n            maxVal = lst[i];\n            maxFreq = currFreq;\n\
    \        }\n        currFreq++;\n    }\n    return maxVal;\n}\nint main() {\n\
    \    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpnwc49btg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028438
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    // Your code here\n    long ans = -1;\n    long freq = 0;\n    for\
    \ (long i : lst) {\n        freq++;\n        if (freq > i) {\n            freq\
    \ = i;\n            ans = i;\n        }\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = search;\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)5, (long)5, (long)5, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)1, (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpiyookbhh.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028438
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq > ans) {\n            ans = freq;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xy21uz3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a non-empty\
    \ list of positive integers. Return the greatest integer that is greater than\
    \ \n// zero, and has a frequency greater than or equal to the value of the integer\
    \ itself. \n// The frequency of an integer is the number of times it appears in\
    \ the list.\n// If no such a value exist, return -1.\n// Examples:\nlong search(std::vector<long>\
    \ lst) {\n    long ans = -1;\n    long freq = 0;\n    for (long i : lst) {\n \
    \       freq += i;\n        if (freq > ans) {\n            ans = freq;\n     \
    \   }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = search;\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)5, (long)5, (long)5,\
    \ (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)4, (long)1,\
    \ (long)4, (long)1, (long)4, (long)4}))) == (4));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)3}))) == (-1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)8, (long)8, (long)8, (long)8, (long)8, (long)8}))) == (8));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)3, (long)3, (long)2, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)7, (long)8, (long)8, (long)4, (long)8, (long)7, (long)3, (long)9, (long)6,\
    \ (long)5, (long)10, (long)4, (long)3, (long)6, (long)7, (long)1, (long)7, (long)4,\
    \ (long)10, (long)8, (long)1}))) == (1));\n    assert(candidate((std::vector<long>({(long)3,\
    \ (long)2, (long)8, (long)2}))) == (2));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)7, (long)1, (long)8, (long)8, (long)10, (long)5, (long)8, (long)5, (long)3,\
    \ (long)10}))) == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8,\
    \ (long)3, (long)6, (long)5, (long)6, (long)4}))) == (-1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)6, (long)7, (long)1, (long)4, (long)7, (long)1, (long)8, (long)8,\
    \ (long)9, (long)8, (long)10, (long)10, (long)8, (long)4, (long)10, (long)4, (long)10,\
    \ (long)1, (long)2, (long)9, (long)5, (long)7, (long)9}))) == (1));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)9, (long)10, (long)1, (long)3}))) == (1));\n    assert(candidate((std::vector<long>({(long)6,\
    \ (long)9, (long)7, (long)5, (long)8, (long)7, (long)5, (long)3, (long)7, (long)5,\
    \ (long)10, (long)10, (long)3, (long)6, (long)10, (long)2, (long)8, (long)6, (long)5,\
    \ (long)4, (long)9, (long)5, (long)3, (long)10}))) == (5));\n    assert(candidate((std::vector<long>({(long)1})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)8, (long)8, (long)10,\
    \ (long)6, (long)4, (long)3, (long)5, (long)8, (long)2, (long)4, (long)2, (long)8,\
    \ (long)4, (long)6, (long)10, (long)4, (long)2, (long)1, (long)10, (long)2, (long)1,\
    \ (long)1, (long)5}))) == (4));\n    assert(candidate((std::vector<long>({(long)2,\
    \ (long)10, (long)4, (long)8, (long)2, (long)10, (long)5, (long)1, (long)2, (long)9,\
    \ (long)5, (long)5, (long)6, (long)3, (long)8, (long)6, (long)4, (long)10})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)1, (long)6, (long)10,\
    \ (long)1, (long)6, (long)9, (long)10, (long)8, (long)6, (long)8, (long)7, (long)3})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)9, (long)2, (long)4,\
    \ (long)1, (long)5, (long)1, (long)5, (long)2, (long)5, (long)7, (long)7, (long)7,\
    \ (long)3, (long)10, (long)1, (long)5, (long)4, (long)2, (long)8, (long)4, (long)1,\
    \ (long)9, (long)10, (long)7, (long)10, (long)2, (long)8, (long)10, (long)9, (long)4})))\
    \ == (4));\n    assert(candidate((std::vector<long>({(long)2, (long)6, (long)4,\
    \ (long)2, (long)8, (long)7, (long)5, (long)6, (long)4, (long)10, (long)4, (long)6,\
    \ (long)3, (long)7, (long)8, (long)8, (long)3, (long)1, (long)4, (long)2, (long)2,\
    \ (long)10, (long)7}))) == (4));\n    assert(candidate((std::vector<long>({(long)9,\
    \ (long)8, (long)6, (long)10, (long)2, (long)6, (long)10, (long)2, (long)7, (long)8,\
    \ (long)10, (long)3, (long)8, (long)2, (long)6, (long)2, (long)3, (long)1})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)5, (long)3,\
    \ (long)9, (long)5, (long)6, (long)3, (long)2, (long)8, (long)5, (long)6, (long)10,\
    \ (long)10, (long)6, (long)8, (long)4, (long)10, (long)7, (long)7, (long)10, (long)8})))\
    \ == (-1));\n    assert(candidate((std::vector<long>({(long)10}))) == (-1));\n\
    \    assert(candidate((std::vector<long>({(long)9, (long)7, (long)7, (long)2,\
    \ (long)4, (long)7, (long)2, (long)10, (long)9, (long)7, (long)5, (long)7, (long)2})))\
    \ == (2));\n    assert(candidate((std::vector<long>({(long)5, (long)4, (long)10,\
    \ (long)2, (long)1, (long)1, (long)10, (long)3, (long)6, (long)1, (long)8})))\
    \ == (1));\n    assert(candidate((std::vector<long>({(long)7, (long)9, (long)9,\
    \ (long)9, (long)3, (long)4, (long)1, (long)5, (long)9, (long)1, (long)2, (long)1,\
    \ (long)1, (long)10, (long)7, (long)5, (long)6, (long)7, (long)6, (long)7, (long)7,\
    \ (long)6}))) == (1));\n    assert(candidate((std::vector<long>({(long)3, (long)10,\
    \ (long)10, (long)9, (long)2}))) == (-1));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_xy21uz3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1660028436
