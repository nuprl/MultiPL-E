name: HumanEval_87_get_row
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a 2 dimensional\
  \ data, as a nested lists,\n// which is similar to matrix, however, unlike matrices,\n\
  // each row may contain a different number of columns.\n// Given lst, and integer\
  \ x, find integers x in the list,\n// and return list of tuples, [(x1, y1), (x2,\
  \ y2) ...] such that\n// each tuple is a coordinate - (row, columns), starting with\
  \ 0.\n// Sort coordinates initially by rows in ascending order.\n// Also, sort coordinates\
  \ of the row by columns in descending order.\n// Examples:\nstd::vector<std::tuple<long,\
  \ long>> get_row(std::vector<std::vector<long>> lst, long x) {\n"
tests: "}\nint main() {\n    auto candidate = get_row;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long,\
  \ long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1,\
  \ 4), (std::tuple<long, long>)std::make_tuple(1, 0), (std::tuple<long, long>)std::make_tuple(2,\
  \ 5), (std::tuple<long, long>)std::make_tuple(2, 0)})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4, (long)5, (long)6})})), (2)) == (std::vector<std::tuple<long,\
  \ long>>({(std::tuple<long, long>)std::make_tuple(0, 1), (std::tuple<long, long>)std::make_tuple(1,\
  \ 1), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(3,\
  \ 1), (std::tuple<long, long>)std::make_tuple(4, 1), (std::tuple<long, long>)std::make_tuple(5,\
  \ 1)})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1,\
  \ (long)1, (long)3, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)1, (long)4, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)1, (long)5, (long)6}), (std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4, (long)1, (long)6}), (std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4, (long)5, (long)1})})), (1)) == (std::vector<std::tuple<long,\
  \ long>>({(std::tuple<long, long>)std::make_tuple(0, 0), (std::tuple<long, long>)std::make_tuple(1,\
  \ 0), (std::tuple<long, long>)std::make_tuple(2, 1), (std::tuple<long, long>)std::make_tuple(2,\
  \ 0), (std::tuple<long, long>)std::make_tuple(3, 2), (std::tuple<long, long>)std::make_tuple(3,\
  \ 0), (std::tuple<long, long>)std::make_tuple(4, 3), (std::tuple<long, long>)std::make_tuple(4,\
  \ 0), (std::tuple<long, long>)std::make_tuple(5, 4), (std::tuple<long, long>)std::make_tuple(5,\
  \ 0), (std::tuple<long, long>)std::make_tuple(6, 5), (std::tuple<long, long>)std::make_tuple(6,\
  \ 0)})));\n    assert(candidate((std::vector<std::vector<long>>()), (1)) == (std::vector<std::tuple<long,\
  \ long>>()));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1})})),\
  \ (2)) == (std::vector<std::tuple<long, long>>()));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>(),\
  \ (std::vector<long>)std::vector<long>({(long)1}), (std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)3})})), (3)) == (std::vector<std::tuple<long, long>>({(std::tuple<long,\
  \ long>)std::make_tuple(2, 2)})));\n}\n"
completions: ["    std::vector<std::tuple<long, long>> res;\n    for (auto &row :\
    \ lst) {\n        auto it = std::find(row.begin(), row.end(), x);\n        if\
    \ (it != row.end()) {\n            auto y = std::distance(row.begin(), it);\n\
    \            res.push_back({y, x});\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](auto &a, auto &b) { return a.first < b.first; });\n    std::sort(res.begin(),\
    \ res.end(), [](auto &a, auto &b) { return a.second > b.second; });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        for (auto &col : row) {\n            if (col == x) {\n          \
    \      res.emplace_back(std::make_tuple(row, col));\n            }\n        }\n\
    \    }\n    std::sort(res.begin(), res.end(), [](std::tuple<long, long> a, std::tuple<long,\
    \ long> b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](std::tuple<long, long> a, std::tuple<long, long> b) {\n      \
    \  return std::get<1>(a) > std::get<1>(b);\n    });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) < std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for(auto &row : lst)\
    \ {\n        for(auto &val : row) {\n            if(val == x) {\n            \
    \    res.push_back(std::make_tuple(row.size(), row.size() - 1));\n           \
    \ }\n        }\n    }\n    std::sort(res.begin(), res.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n        return std::get<0>(a)\
    \ > std::get<0>(b);\n    });\n    std::sort(res.begin(), res.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n        return std::get<1>(a)\
    \ > std::get<1>(b);\n    });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    std::vector<long> row;\n    for (auto &i : lst) {\n       \
    \ row.push_back(i.size());\n    }\n    std::sort(row.begin(), row.end(), std::greater<long>());\n\
    \    for (auto &i : row) {\n        std::sort(i.begin(), i.end(), std::greater<long>());\n\
    \    }\n    for (auto &i : row) {\n        for (auto &j : i) {\n            if\
    \ (j == x) {\n                res.push_back({i - 1, j});\n            }\n    \
    \    }\n    }\n    return res;", "    std::vector<std::tuple<long, long>> res;\n\
    \    for(auto &row : lst) {\n        for(auto &col : row) {\n            if(col\
    \ == x) {\n                res.push_back(std::make_tuple(row, col));\n       \
    \     }\n        }\n    }\n    std::sort(res.begin(), res.end(), [](auto &a, auto\
    \ &b) { return std::get<0>(a) < std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](auto &a, auto &b) { return std::get<1>(a) > std::get<1>(b); });\n\
    \    return res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto\
    \ &row : lst) {\n        auto it = std::find(row.begin(), row.end(), x);\n   \
    \     if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) < std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    long row = 0;\n  \
    \  long col = 0;\n    for (auto &row : lst) {\n        long row_size = row.size();\n\
    \        long col_size = 1;\n        for (auto &col : row) {\n            if (col\
    \ == x) {\n                res.emplace_back(std::make_tuple(row, col));\n    \
    \            break;\n            }\n            col_size *= col;\n        }\n\
    \        if (row_size == col_size) {\n            row += 1;\n        }\n    }\n\
    \    std::sort(res.begin(), res.end(), [](const std::tuple<long, long> &a, const\
    \ std::tuple<long, long> &b) {\n        return std::get<0>(a) < std::get<0>(b);\n\
    \    });\n    std::sort(res.begin(), res.end(), [](const std::tuple<long, long>\
    \ &a, const std::tuple<long, long> &b) {\n        return std::get<1>(a) < std::get<1>(b);\n\
    \    });\n    return res;", "    std::vector<std::tuple<long, long>> res;\n  \
    \  for (auto &row : lst) {\n        auto it = std::find(row.begin(), row.end(),\
    \ x);\n        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        for (auto &elem : row) {\n\
    \            if (elem == x) {\n                res.emplace_back(std::make_tuple(row,\
    \ row.size()));\n            }\n        }\n    }\n    std::sort(res.begin(), res.end(),\
    \ [](const std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n   \
    \     return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) < std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        auto it = std::find(row.begin(), row.end(), x);\n        if (it !=\
    \ row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](std::tuple<long, long> a, std::tuple<long, long> b) { return std::get<0>(a)\
    \ > std::get<0>(b); });\n    std::sort(res.begin(), res.end(), [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) { return std::get<1>(a) > std::get<1>(b);\
    \ });\n    return res;", "    std::vector<std::tuple<long, long>> res;\n    for\
    \ (auto &row : lst) {\n        for (auto &val : row) {\n            if (val ==\
    \ x) {\n                res.emplace_back(std::make_tuple(row.size(), row.size()\
    \ - 1));\n            }\n        }\n    }\n    std::sort(res.begin(), res.end(),\
    \ [](const std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n   \
    \     return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        auto it = std::find(row.begin(), row.end(), x);\n        if (it !=\
    \ row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for(auto &row : lst)\
    \ {\n        for(auto &el : row) {\n            if(el == x) {\n              \
    \  res.emplace_back(std::make_tuple(row.size(), row.size()));\n            }\n\
    \        }\n    }\n    std::sort(res.begin(), res.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n        return std::get<0>(a)\
    \ > std::get<0>(b);\n    });\n    std::sort(res.begin(), res.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n        return std::get<1>(a)\
    \ > std::get<1>(b);\n    });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    long row = 0;\n    long col = 0;\n    for (auto &v : lst) {\n\
    \        if (v == x) {\n            res.push_back({row, col});\n        }\n  \
    \      ++col;\n        if (col == v.size()) {\n            ++row;\n          \
    \  col = 0;\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        std::sort(row.begin(), row.end());\n\
    \        std::sort(row.rbegin(), row.rend());\n        for (auto &col : row) {\n\
    \            if (col == x) {\n                res.emplace_back(std::make_tuple(row,\
    \ col));\n            }\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        for (auto &col : row) {\n\
    \            if (col == x) {\n                res.push_back(std::make_tuple(row,\
    \ col));\n            }\n        }\n    }\n    std::sort(res.begin(), res.end(),\
    \ [](const std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n   \
    \     return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) < std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        auto it = std::find(row.begin(), row.end(), x);\n        if (it !=\
    \ row.end()) {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    long row = 0;\n    long col = 0;\n    for (auto &v : lst) {\n\
    \        auto it = std::find(v.begin(), v.end(), x);\n        if (it != v.end())\
    \ {\n            res.emplace_back(row, col);\n            row += 1;\n        }\n\
    \        col += 1;\n    }\n    std::sort(res.begin(), res.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n        return std::get<0>(a)\
    \ < std::get<0>(b);\n    });\n    std::sort(res.begin(), res.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n        return std::get<1>(a)\
    \ < std::get<1>(b);\n    });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    std::vector<long> row;\n    std::vector<long> col;\n    for\
    \ (auto &i : lst) {\n        row.push_back(i[0]);\n        col.push_back(i[1]);\n\
    \    }\n    std::sort(row.begin(), row.end());\n    std::sort(col.begin(), col.end());\n\
    \    for (long i = 0; i < row.size(); i++) {\n        for (long j = 0; j < col.size();\
    \ j++) {\n            if (row[i] == x && col[j] == x) {\n                res.push_back(std::make_tuple(i,\
    \ j));\n            }\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](auto &a, auto &b) { return std::get<0>(a) > std::get<0>(b); });\n\
    \    std::sort(res.begin(), res.end(), [](auto &a, auto &b) { return std::get<1>(a)\
    \ > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long, long>>\
    \ res;\n    for(auto &row : lst) {\n        for(auto &val : row) {\n         \
    \   if(val == x) {\n                res.push_back(std::make_tuple(row.size(),\
    \ row.size()));\n            }\n        }\n    }\n    std::sort(res.begin(), res.end(),\
    \ [](const std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n   \
    \     return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        std::sort(row.begin(), row.end());\n        std::reverse(row.begin(),\
    \ row.end());\n        std::sort(row.begin(), row.end());\n        std::reverse(row.begin(),\
    \ row.end());\n        for (auto &col : row) {\n            if (col == x) {\n\
    \                res.emplace_back(std::make_tuple(row, col));\n            }\n\
    \        }\n    }\n    return res;", "    std::vector<std::tuple<long, long>>\
    \ res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        auto it = std::find(row.begin(), row.end(), x);\n        if (it !=\
    \ row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](auto &a, auto &b) { return std::get<0>(a) > std::get<0>(b); });\n\
    \    std::sort(res.begin(), res.end(), [](auto &a, auto &b) { return std::get<1>(a)\
    \ > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long, long>>\
    \ res;\n    for (auto &row : lst) {\n        std::sort(row.begin(), row.end());\n\
    \        std::reverse(row.begin(), row.end());\n        std::sort(row.begin(),\
    \ row.end());\n        std::reverse(row.begin(), row.end());\n        for (auto\
    \ &col : row) {\n            if (col == x) {\n                res.emplace_back(std::make_tuple(row.size(),\
    \ col.size()));\n            }\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for(auto &row : lst) {\n        for(auto &col : row) {\n  \
    \          if(col == x) {\n                res.push_back(std::make_tuple(row,\
    \ col));\n            }\n        }\n    }\n    std::sort(res.begin(), res.end(),\
    \ [](auto &a, auto &b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](auto &a, auto &b) { return std::get<1>(a) > std::get<1>(b); });\n\
    \    return res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto\
    \ &row : lst) {\n        auto it = std::find(row.begin(), row.end(), x);\n   \
    \     if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) < std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for(auto &row : lst)\
    \ {\n        for(auto &el : row) {\n            if(el == x) {\n              \
    \  res.push_back(std::make_tuple(row.size(), row.size()));\n            }\n  \
    \      }\n    }\n    std::sort(res.begin(), res.end(), [](auto &a, auto &b) {\n\
    \        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](auto &a, auto &b) {\n        return std::get<1>(a) > std::get<1>(b);\n\
    \    });\n    return res;", "    std::vector<std::tuple<long, long>> res;\n  \
    \  for(auto &row : lst) {\n        for(auto &col : row) {\n            if(col\
    \ == x) {\n                res.push_back(std::make_tuple(row, col));\n       \
    \     }\n        }\n    }\n    std::sort(res.begin(), res.end(), [](auto &a, auto\
    \ &b) { return std::get<0>(a) < std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](auto &a, auto &b) { return std::get<1>(a) < std::get<1>(b); });\n\
    \    return res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto\
    \ &row : lst) {\n        auto it = std::find(row.begin(), row.end(), x);\n   \
    \     if (it != row.end()) {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), std::prev(it))));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](auto &a, auto &b) { return std::get<0>(a) > std::get<0>(b); });\n\
    \    std::sort(res.begin(), res.end(), [](auto &a, auto &b) { return std::get<1>(a)\
    \ > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long, long>>\
    \ res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), std::prev(it))));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](auto &a, auto &b) { return std::get<0>(a) > std::get<0>(b); });\n\
    \    std::sort(res.begin(), res.end(), [](auto &a, auto &b) { return std::get<1>(a)\
    \ > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long, long>>\
    \ res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            std::tuple<long,\
    \ long> coord = std::make_tuple(std::distance(row.begin(), it), std::distance(row.begin(),\
    \ std::prev(it)));\n            res.push_back(coord);\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) < std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        std::sort(row.begin(), row.end());\n        std::sort(row.rbegin(),\
    \ row.rend());\n        for (auto &col : row) {\n            if (col == x) {\n\
    \                res.emplace_back(std::make_tuple(row, col));\n            }\n\
    \        }\n    }\n    return res;", "    std::vector<std::tuple<long, long>>\
    \ res;\n    for (auto &row : lst) {\n        std::sort(row.begin(), row.end());\n\
    \        std::sort(row.rbegin(), row.rend());\n        for (auto &col : row) {\n\
    \            if (col == x) {\n                res.push_back(std::make_tuple(row,\
    \ col));\n            }\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for(auto &row : lst) {\n        for(auto &el : row) {\n   \
    \         if(el == x) {\n                res.push_back({row, row.size()});\n \
    \           }\n        }\n    }\n    std::sort(res.begin(), res.end(), [](auto\
    \ &a, auto &b) { return std::get<0>(a) < std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](auto &a, auto &b) { return std::get<1>(a) < std::get<1>(b); });\n\
    \    return res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto\
    \ &row : lst) {\n        for (auto &col : row) {\n            if (col == x) {\n\
    \                res.emplace_back(std::make_tuple(row, col));\n            }\n\
    \        }\n    }\n    std::sort(res.begin(), res.end(), [](auto &a, auto &b)\
    \ {\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](auto &a, auto &b) {\n        return std::get<1>(a) < std::get<1>(b);\n\
    \    });\n    return res;", "    std::vector<std::tuple<long, long>> res;\n  \
    \  for (auto &row : lst) {\n        for (auto &val : row) {\n            if (val\
    \ == x) {\n                res.emplace_back(std::make_tuple(row.size(), row.size()));\n\
    \            }\n        }\n    }\n    std::sort(res.begin(), res.end(), [](const\
    \ std::tuple<long, long> &a, const std::tuple<long, long> &b) -> bool {\n    \
    \    return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) -> bool {\n        return std::get<1>(a) < std::get<1>(b);\n    });\n  \
    \  return res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto\
    \ &row : lst) {\n        auto it = std::find(row.begin(), row.end(), x);\n   \
    \     if (it != row.end()) {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        for (auto &val : row) {\n\
    \            if (val == x) {\n                res.push_back(std::make_tuple(row.size(),\
    \ row.size() - 1));\n                break;\n            }\n        }\n    }\n\
    \    std::sort(res.begin(), res.end(), [](const std::tuple<long, long> &a, const\
    \ std::tuple<long, long> &b) {\n        return std::get<0>(a) < std::get<0>(b);\n\
    \    });\n    std::sort(res.begin(), res.end(), [](const std::tuple<long, long>\
    \ &a, const std::tuple<long, long> &b) {\n        return std::get<1>(a) < std::get<1>(b);\n\
    \    });\n    return res;", "    std::vector<std::tuple<long, long>> res;\n  \
    \  for (auto &row : lst) {\n        std::sort(row.begin(), row.end());\n     \
    \   std::sort(row.rbegin(), row.rend());\n        for (auto &col : row) {\n  \
    \          if (col == x) {\n                res.push_back(std::make_tuple(row,\
    \ col));\n            }\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for(auto &row : lst) {\n        for(auto &col : row) {\n  \
    \          if(col == x) {\n                res.emplace_back(std::make_tuple(row,\
    \ col));\n            }\n        }\n    }\n    std::sort(res.begin(), res.end(),\
    \ [](const std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n   \
    \     return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) < std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        for (auto &elem : row) {\n            if (elem == x) {\n        \
    \        res.push_back(std::make_tuple(row, row.size()));\n            }\n   \
    \     }\n    }\n    std::sort(res.begin(), res.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n        return std::get<0>(a)\
    \ > std::get<0>(b);\n    });\n    std::sort(res.begin(), res.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n        return std::get<1>(a)\
    \ > std::get<1>(b);\n    });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    long row = 0;\n    for (auto &row : lst) {\n        long col\
    \ = 0;\n        for (auto &col : row) {\n            if (col == x) {\n       \
    \         res.emplace_back(row, col);\n            }\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) < std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        auto it = std::find(row.begin(), row.end(), x);\n        if (it !=\
    \ row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        auto it = std::find(row.begin(), row.end(), x);\n        if (it !=\
    \ row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            std::sort(row.begin(),\
    \ row.end(), [](long a, long b) { return b < a; });\n            std::sort(row.rbegin(),\
    \ row.rend(), [](long a, long b) { return b < a; });\n            res.push_back(std::make_tuple(row.front(),\
    \ row.back()));\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for(auto &row : lst) {\n        for(auto &el : row) {\n   \
    \         if(el == x) {\n                res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ std::find(row.begin(), row.end(), x)), std::distance(row.rbegin(), std::find(row.rbegin(),\
    \ row.rend(), x))));\n            }\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) < std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) < std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    std::vector<std::tuple<long, long>> temp;\n    for (auto &row\
    \ : lst) {\n        std::sort(row.begin(), row.end());\n        std::sort(row.rbegin(),\
    \ row.rend());\n        for (auto &col : row) {\n            if (col == x) {\n\
    \                temp.emplace_back(std::make_tuple(row, col));\n            }\n\
    \        }\n        res.emplace_back(std::move(temp));\n        temp.clear();\n\
    \    }\n    return res;", "    std::vector<std::tuple<long, long>> res;\n    for\
    \ (auto &row : lst) {\n        auto it = std::find(row.begin(), row.end(), x);\n\
    \        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) < std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        auto it = std::find(row.begin(), row.end(), x);\n        if (it !=\
    \ row.end()) {\n            auto index = std::distance(row.begin(), it);\n   \
    \         std::sort(row.begin(), row.end());\n            std::reverse(row.begin(),\
    \ row.end());\n            res.emplace_back(index + 1, std::distance(row.begin(),\
    \ it));\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        std::sort(row.begin(), row.end());\n\
    \        std::sort(row.rbegin(), row.rend());\n        std::sort(row.begin(),\
    \ row.end());\n        std::sort(row.rbegin(), row.rend());\n        for (auto\
    \ &col : row) {\n            if (col == x) {\n                res.emplace_back(row,\
    \ col);\n            }\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        for (auto &el : row) {\n \
    \           if (el == x) {\n                res.push_back(std::make_tuple(row,\
    \ el));\n            }\n        }\n    }\n    std::sort(res.begin(), res.end(),\
    \ [](const std::tuple<long, long> &a, const std::tuple<long, long> &b) -> bool\
    \ {\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) -> bool {\n        return std::get<1>(a) < std::get<1>(b);\n    });\n  \
    \  return res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto\
    \ &row : lst) {\n        std::sort(row.begin(), row.end());\n        std::sort(row.rbegin(),\
    \ row.rend());\n        std::reverse(row.begin(), row.end());\n        std::reverse(row.rbegin(),\
    \ row.rend());\n        std::set<long> rowset;\n        for (auto &el : row) {\n\
    \            rowset.insert(el);\n        }\n        if (rowset.find(x) != rowset.end())\
    \ {\n            res.push_back(std::make_tuple(row.front(), row.back()));\n  \
    \      }\n    }\n    return res;", "    std::vector<std::tuple<long, long>> res;\n\
    \    for (auto &row : lst) {\n        std::sort(row.begin(), row.end());\n   \
    \     std::sort(row.rbegin(), row.rend());\n        std::reverse(row.begin(),\
    \ row.end());\n        std::reverse(row.rbegin(), row.rend());\n        for (auto\
    \ &col : row) {\n            if (col == x) {\n                res.emplace_back(std::make_tuple(row.size(),\
    \ col.size()));\n            }\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) < std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    long row = 0;\n  \
    \  long col = 0;\n    for (auto &row : lst) {\n        long col = 0;\n       \
    \ for (auto &col : row) {\n            if (col == x) {\n                res.push_back({row,\
    \ col});\n            }\n            ++col;\n        }\n        ++row;\n    }\n\
    \    std::sort(res.begin(), res.end(), [](auto &a, auto &b) { return std::get<0>(a)\
    \ < std::get<0>(b); });\n    std::sort(res.begin(), res.end(), [](auto &a, auto\
    \ &b) { return std::get<1>(a) < std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        auto it = std::find(row.begin(), row.end(), x);\n        if (it !=\
    \ row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for(auto &row : lst)\
    \ {\n        for(auto &col : row) {\n            if(col == x) {\n            \
    \    res.push_back(std::make_tuple(row, col));\n            }\n        }\n   \
    \ }\n    std::sort(res.begin(), res.end(), [](const std::tuple<long, long> &a,\
    \ const std::tuple<long, long> &b) { return std::get<0>(a) > std::get<0>(b); });\n\
    \    std::sort(res.begin(), res.end(), [](const std::tuple<long, long> &a, const\
    \ std::tuple<long, long> &b) { return std::get<1>(a) > std::get<1>(b); });\n \
    \   return res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto\
    \ &row : lst) {\n        for (auto &el : row) {\n            if (el == x) {\n\
    \                res.push_back(std::make_tuple(row, row.size()));\n          \
    \  }\n        }\n    }\n    std::sort(res.begin(), res.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n        return std::get<0>(a)\
    \ > std::get<0>(b);\n    });\n    std::sort(res.begin(), res.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n        return std::get<1>(a)\
    \ > std::get<1>(b);\n    });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](auto &a, auto &b) { return std::get<0>(a) > std::get<0>(b); });\n\
    \    std::sort(res.begin(), res.end(), [](auto &a, auto &b) { return std::get<1>(a)\
    \ > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long, long>>\
    \ res;\n    for (auto &row : lst) {\n        for (auto &val : row) {\n       \
    \     if (val == x) {\n                res.push_back({row.size(), row.size() -\
    \ 1});\n            }\n        }\n    }\n    std::sort(res.begin(), res.end(),\
    \ [](const std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n   \
    \     return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) < std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        auto it = std::find(row.begin(), row.end(), x);\n        if (it !=\
    \ row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    long row = 0;\n  \
    \  long col = 0;\n    long max_row = 0, max_col = 0;\n    for (auto &row : lst)\
    \ {\n        col = row.size();\n        if (row == x) {\n            res.push_back({row,\
    \ col});\n        }\n        if (row > x) {\n            break;\n        }\n \
    \       max_row = row;\n        max_col = col;\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) < std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        auto it = std::find(row.begin(), row.end(), x);\n        if (it !=\
    \ row.end()) {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), std::prev(it))));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        std::sort(row.begin(), row.end());\n\
    \        std::sort(row.rbegin(), row.rend());\n        for (auto &col : row) {\n\
    \            if (col == x) {\n                res.emplace_back(row.size(), col.size());\n\
    \            }\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for(auto &row : lst) {\n        for(auto &val : row) {\n  \
    \          if(val == x) {\n                res.push_back({row.size(), row.size()});\n\
    \            }\n        }\n    }\n    std::sort(res.begin(), res.end(), [](auto\
    \ &a, auto &b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](auto &a, auto &b) { return std::get<1>(a) > std::get<1>(b); });\n\
    \    return res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto\
    \ &row : lst) {\n        for (auto &col : row) {\n            if (col == x) {\n\
    \                res.push_back(std::make_tuple(row, col));\n            }\n  \
    \      }\n    }\n    std::sort(res.begin(), res.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) { return std::get<0>(a) < std::get<0>(b);\
    \ });\n    std::sort(res.begin(), res.end(), [](const std::tuple<long, long> &a,\
    \ const std::tuple<long, long> &b) { return std::get<1>(a) < std::get<1>(b); });\n\
    \    return res;", "    std::vector<std::tuple<long, long>> res;\n    long row\
    \ = 0;\n    long col = 0;\n    for (auto &v : lst) {\n        if (v == x) {\n\
    \            res.push_back(std::make_tuple(row, col));\n        }\n        ++col;\n\
    \        if (col == v.length) {\n            row++;\n            col = 0;\n  \
    \      }\n    }\n    return res;", "    std::vector<std::tuple<long, long>> res;\n\
    \    for(auto &row : lst) {\n        for(auto &col : row) {\n            if(col\
    \ == x) {\n                res.push_back(std::make_tuple(row, col));\n       \
    \     }\n        }\n    }\n    std::sort(res.begin(), res.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) { return std::get<0>(a) < std::get<0>(b);\
    \ });\n    std::sort(res.begin(), res.end(), [](const std::tuple<long, long> &a,\
    \ const std::tuple<long, long> &b) { return std::get<1>(a) > std::get<1>(b); });\n\
    \    return res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto\
    \ &row : lst) {\n        for (auto &el : row) {\n            if (el == x) {\n\
    \                res.push_back(std::make_tuple(row.size() - 1, row.size() - 1));\n\
    \            }\n        }\n    }\n    std::sort(res.begin(), res.end(), [](const\
    \ std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n        return\
    \ std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(), res.end(),\
    \ [](const std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n   \
    \     return std::get<1>(a) > std::get<1>(b);\n    });\n    return res;", "  \
    \  std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst) {\n   \
    \     auto it = std::find(row.begin(), row.end(), x);\n        if (it != row.end())\
    \ {\n            res.push_back(std::make_tuple(std::distance(row.begin(), it),\
    \ std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        auto it = std::find(row.begin(), row.end(), x);\n        if (it !=\
    \ row.end()) {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        auto it = std::find(row.begin(), row.end(), x);\n        if (it !=\
    \ row.end()) {\n            std::sort(row.begin(), row.end(), [](long a, long\
    \ b) { return a > b; });\n            std::sort(row.rbegin(), row.rend(), [](long\
    \ a, long b) { return b > a; });\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.rbegin(), it)));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](std::tuple<long, long> a, std::tuple<long, long> b) { return std::get<0>(a)\
    \ > std::get<0>(b); });\n    std::sort(res.rbegin(), res.rend(), [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) { return std::get<1>(a) > std::get<1>(b);\
    \ });\n    return res;", "    std::vector<std::tuple<long, long>> res;\n    for\
    \ (auto &row : lst) {\n        auto it = std::find(row.begin(), row.end(), x);\n\
    \        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        auto it = std::find(row.begin(), row.end(), x);\n        if (it !=\
    \ row.end()) {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for(auto &row : lst)\
    \ {\n        for(auto &col : row) {\n            if(col == x) {\n            \
    \    res.push_back(std::make_tuple(row, col));\n            }\n        }\n   \
    \ }\n    std::sort(res.begin(), res.end(), [](const std::tuple<long, long> &a,\
    \ const std::tuple<long, long> &b) {\n        return std::get<0>(a) < std::get<0>(b);\n\
    \    });\n    std::sort(res.begin(), res.end(), [](const std::tuple<long, long>\
    \ &a, const std::tuple<long, long> &b) {\n        return std::get<1>(a) < std::get<1>(b);\n\
    \    });\n    return res;", "    std::vector<std::tuple<long, long>> res;\n  \
    \  for(auto &row : lst) {\n        for(auto &col : row) {\n            if(col\
    \ == x) {\n                res.emplace_back(row, col);\n            }\n      \
    \  }\n    }\n    std::sort(res.begin(), res.end(), [](const std::tuple<long, long>\
    \ &a, const std::tuple<long, long> &b) { return std::get<0>(a) < std::get<0>(b);\
    \ });\n    std::sort(res.begin(), res.end(), [](const std::tuple<long, long> &a,\
    \ const std::tuple<long, long> &b) { return std::get<1>(a) < std::get<1>(b); });\n\
    \    return res;", "    std::vector<std::tuple<long, long>> res;\n    for(auto\
    \ &row : lst) {\n        for(auto &val : row) {\n            if(val == x) {\n\
    \                res.push_back(std::make_tuple(row.size(), row.size() - 1));\n\
    \            }\n        }\n    }\n    std::sort(res.begin(), res.end(), [](const\
    \ std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n        return\
    \ std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(), res.end(),\
    \ [](const std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n   \
    \     return std::get<1>(a) < std::get<1>(b);\n    });\n    return res;", "  \
    \  std::vector<std::tuple<long, long>> res;\n    for(auto &row : lst) {\n    \
    \    for(auto &col : row) {\n            if(col == x) {\n                res.emplace_back(std::make_tuple(row,\
    \ col));\n            }\n        }\n    }\n    std::sort(res.begin(), res.end(),\
    \ [](std::tuple<long, long> a, std::tuple<long, long> b) {\n        return std::get<0>(a)\
    \ < std::get<0>(b);\n    });\n    std::sort(res.begin(), res.end(), [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) {\n        return std::get<1>(a) > std::get<1>(b);\n\
    \    });\n    return res;", "    std::vector<std::tuple<long, long>> res;\n  \
    \  for (auto &row : lst) {\n        auto it = std::find(row.begin(), row.end(),\
    \ x);\n        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        auto it = std::find(row.begin(), row.end(), x);\n        if (it !=\
    \ row.end()) {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), std::prev(it))));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for(auto &row : lst) {\n        for(auto &col : row) {\n  \
    \          if(col == x) {\n                res.emplace_back(std::make_tuple(row,\
    \ col));\n            }\n        }\n    }\n    std::sort(res.begin(), res.end(),\
    \ [](const std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n   \
    \     return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        for (auto &col : row) {\n            if (col == x) {\n          \
    \      res.emplace_back(std::make_tuple(row, col));\n            }\n        }\n\
    \    }\n    std::sort(res.begin(), res.end(), [](auto &a, auto &b) { return std::get<0>(a)\
    \ < std::get<0>(b); });\n    std::sort(res.begin(), res.end(), [](auto &a, auto\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    std::vector<long> row;\n    std::vector<long> col;\n    for\
    \ (auto &i : lst) {\n        row.push_back(i[0]);\n        col.push_back(i[1]);\n\
    \    }\n    std::sort(row.begin(), row.end());\n    std::sort(col.begin(), col.end());\n\
    \    for (auto &i : row) {\n        for (auto &j : col) {\n            if (i ==\
    \ j) {\n                res.push_back({i, j});\n            }\n        }\n   \
    \ }\n    return res;", "    std::vector<std::tuple<long, long>> res;\n    for\
    \ (auto &row : lst) {\n        for (auto &val : row) {\n            if (val ==\
    \ x) {\n                res.push_back({row.size(), row.size() - 1});\n       \
    \     }\n        }\n    }\n    std::sort(res.begin(), res.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n        return std::get<0>(a)\
    \ > std::get<0>(b);\n    });\n    std::sort(res.begin(), res.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n        return std::get<1>(a)\
    \ > std::get<1>(b);\n    });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        std::sort(row.begin(), row.end());\n\
    \        std::sort(row.rbegin(), row.rend());\n        std::sort(row.begin(),\
    \ row.end());\n        std::sort(row.rbegin(), row.rend());\n        std::sort(row.begin(),\
    \ row.end());\n        std::sort(row.rbegin(), row.rend());\n        std::sort(row.begin(),\
    \ row.end());\n        std::sort(row.rbegin(), row.rend());\n        std::sort(row.begin(),\
    \ row.end());\n        std::sort(row.rbegin(), row.rend());\n        std::sort(row.begin(),\
    \ row.end());\n        std::sort(row.rbegin(), row.rend());\n        std::sort(row.begin(),\
    \ row.end());\n        std::sort(row.rbegin(), row.rend());\n        std::sort(row.begin(),\
    \ row.end());\n        std::sort(row.rbegin(), row.rend());\n        std::sort(row.begin(),\
    \ row.end());\n        std::sort(row.rbegin(), row.rend());\n        std::sort(row.begin(),\
    \ row.end());\n        std::sort(row.rbegin(), row.rend());\n        std::sort(row.begin(),\
    \ row.end());\n        std::sort(row.rbegin(), row.rend());\n        std::sort(row.begin(),\
    \ row.end());\n        std::sort(row.rbegin(), row.rend());\n        std::sort(row.begin(),\
    \ row.end());\n        std::sort(row.rbegin(), row.rend());\n        std::sort(row.begin(),\
    \ row.end());\n        std::sort(row.rbegin(), row.rend());\n        std::sort(row.begin(),\
    \ row.end());\n        std::sort(row.rbegin(), row.rend());\n        std::sort(row.begin(),\
    \ row.end());\n        std::sort(row.rbegin(), row.rend());\n        std::sort(row.begin(),\
    \ row.end());\n        std::sort(row.rbegin(), row.rend());\n        std::sort(row.begin(),\
    \ row.end());\n        std::sort(row.rbegin(), row.rend());\n        std::sort(row.begin(),\
    \ row.end());\n        std::sort(row.rbegin(), row.rend());\n        std::sort(row.begin(),\
    \ row.end());\n        std::sort(row.rbegin(), row.rend());\n        std::sort(row.begin(),\
    \ row.end());\n        std::sort(row.rbegin(), row.rend());\n        std::sort(row.begin(),\
    \ row.end());\n        std::sort(row.rbegin(), row.rend());\n        std::sort(row.begin(),\
    \ row.end());\n        std::sort(row.rbegin(), row.rend());\n        std::sort(row.begin(),\
    \ row.end());\n        ", "    std::vector<std::tuple<long, long>> res;\n    for\
    \ (auto &row : lst) {\n        for (auto &el : row) {\n            if (el == x)\
    \ {\n                res.emplace_back(std::make_tuple(row, row.size()));\n   \
    \         }\n        }\n    }\n    std::sort(res.begin(), res.end(), [](const\
    \ std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n        return\
    \ std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(), res.end(),\
    \ [](const std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n   \
    \     return std::get<1>(a) < std::get<1>(b);\n    });\n    return res;", "  \
    \  std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst) {\n   \
    \     auto it = std::find(row.begin(), row.end(), x);\n        if (it != row.end())\
    \ {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(), it),\
    \ std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) < std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) < std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        std::sort(row.begin(), row.end());\n\
    \        std::sort(row.rbegin(), row.rend());\n        for (auto &col : row) {\n\
    \            if (col == x) {\n                res.push_back(std::make_tuple(row.size(),\
    \ col));\n            }\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        std::sort(row.begin(), row.end());\n        std::sort(row.rbegin(),\
    \ row.rend());\n        if (std::find(row.begin(), row.end(), x) != row.end())\
    \ {\n            res.push_back(std::make_tuple(row.front(), row.back()));\n  \
    \      }\n    }\n    return res;", "    std::vector<std::tuple<long, long>> res;\n\
    \    for (auto &row : lst) {\n        for (auto &col : row) {\n            if\
    \ (col == x) {\n                res.emplace_back(std::make_tuple(row, col));\n\
    \            }\n        }\n    }\n    std::sort(res.begin(), res.end(), [](const\
    \ std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n        return\
    \ std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(), res.end(),\
    \ [](const std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n   \
    \     return std::get<1>(a) < std::get<1>(b);\n    });\n    return res;", "  \
    \  std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst) {\n   \
    \     std::sort(row.begin(), row.end());\n        std::sort(row.rbegin(), row.rend());\n\
    \        std::sort(row.begin(), row.end());\n        std::sort(row.rbegin(), row.rend());\n\
    \        for (auto &col : row) {\n            if (col == x) {\n              \
    \  res.push_back(std::make_tuple(row, col));\n            }\n        }\n    }\n\
    \    return res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto\
    \ &row : lst) {\n        auto it = std::find(row.begin(), row.end(), x);\n   \
    \     if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](auto &a, auto &b) { return std::get<0>(a) > std::get<0>(b); });\n\
    \    std::sort(res.begin(), res.end(), [](auto &a, auto &b) { return std::get<1>(a)\
    \ > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long, long>>\
    \ res;\n    for (auto &row : lst) {\n        for (auto &col : row) {\n       \
    \     if (col == x) {\n                res.push_back(std::make_tuple(row, col));\n\
    \            }\n        }\n    }\n    std::sort(res.begin(), res.end(), [](auto\
    \ &a, auto &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n \
    \   std::sort(res.begin(), res.end(), [](auto &a, auto &b) {\n        return std::get<1>(a)\
    \ > std::get<1>(b);\n    });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        std::sort(row.begin(), row.end());\n\
    \        std::sort(row.rbegin(), row.rend());\n        std::reverse(row.begin(),\
    \ row.end());\n        std::reverse(row.rbegin(), row.rend());\n        for (auto\
    \ &col : row) {\n            if (col == x) {\n                res.emplace_back(std::make_tuple(row,\
    \ col));\n            }\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        std::sort(row.begin(), row.end());\n\
    \        std::sort(row.rbegin(), row.rend());\n        for (auto &col : row) {\n\
    \            if (col == x) {\n                res.emplace_back(std::make_tuple(row,\
    \ col));\n            }\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        for (auto &val : row) {\n\
    \            if (val == x) {\n                res.push_back(std::make_tuple(row.size(),\
    \ row.size() - 1));\n            }\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        for (auto &col : row) {\n            if (col == x) {\n          \
    \      res.emplace_back(std::make_tuple(row, col));\n            }\n        }\n\
    \    }\n    std::sort(res.begin(), res.end(), [](const std::tuple<long, long>\
    \ &a, const std::tuple<long, long> &b) {\n        return std::get<0>(a) < std::get<0>(b);\n\
    \    });\n    std::sort(res.begin(), res.end(), [](const std::tuple<long, long>\
    \ &a, const std::tuple<long, long> &b) {\n        return std::get<1>(a) < std::get<1>(b);\n\
    \    });\n    return res;", "    std::vector<std::tuple<long, long>> res;\n  \
    \  for (auto &row : lst) {\n        auto it = std::find(row.begin(), row.end(),\
    \ x);\n        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for(auto &row : lst)\
    \ {\n        for(auto &elem : row) {\n            if(elem == x) {\n          \
    \      res.push_back(std::make_tuple(row, row.size()));\n            }\n     \
    \   }\n    }\n    std::sort(res.begin(), res.end(), [](auto &a, auto &b) {\n \
    \       return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](auto &a, auto &b) {\n        return std::get<1>(a) > std::get<1>(b);\n\
    \    });\n    return res;", "    std::vector<std::tuple<long, long>> res;\n  \
    \  long row = 0;\n    long col = 0;\n    for (auto &row : lst) {\n        long\
    \ col = 0;\n        for (auto &col : row) {\n            if (col == x) {\n   \
    \             res.push_back(std::make_tuple(row, col));\n            }\n     \
    \       col++;\n        }\n        row++;\n    }\n    std::sort(res.begin(), res.end(),\
    \ [](const std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n   \
    \     return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        auto it = std::find(row.begin(), row.end(), x);\n        if (it !=\
    \ row.end()) {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        std::sort(row.begin(), row.end());\n\
    \        std::sort(row.rbegin(), row.rend());\n        for (auto &col : row) {\n\
    \            if (col == x) {\n                res.emplace_back(std::make_tuple(row.size(),\
    \ col.size()));\n            }\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        std::sort(row.begin(), row.end());\n\
    \        std::reverse(row.begin(), row.end());\n        std::sort(row.begin(),\
    \ row.end());\n        std::reverse(row.begin(), row.end());\n        for (auto\
    \ &col : row) {\n            if (col == x) {\n                res.emplace_back(std::make_tuple(row.size(),\
    \ col.size()));\n            }\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for(auto &row : lst) {\n        for(auto &el : row) {\n   \
    \         if(el == x) {\n                res.emplace_back(std::make_tuple(row.size(),\
    \ row.size() - 1));\n            }\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), std::prev(it))));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        for (auto &el : row) {\n \
    \           if (el == x) {\n                res.push_back({std::get<0>(row), std::get<1>(row)});\n\
    \            }\n        }\n    }\n    std::sort(res.begin(), res.end(), [](const\
    \ std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n        return\
    \ std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(), res.end(),\
    \ [](const std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n   \
    \     return std::get<1>(a) < std::get<1>(b);\n    });\n    return res;", "  \
    \  std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst) {\n   \
    \     for (auto &el : row) {\n            if (el == x) {\n                res.push_back(std::make_tuple(row.size()\
    \ - 1, row.size() - 1));\n            }\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        auto it = std::find(row.begin(), row.end(), x);\n        if (it !=\
    \ row.end()) {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) < std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        auto it = std::find(row.begin(), row.end(), x);\n        if (it !=\
    \ row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) < std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        auto it = std::find(row.begin(), row.end(), x);\n        if (it !=\
    \ row.end()) {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        auto it = std::find(row.begin(), row.end(), x);\n        if (it !=\
    \ row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    long n = lst.size();\n\
    \    long m = lst[0].size();\n    long i, j, k;\n    for (i = 0; i < n; i++) {\n\
    \        long sum = 0;\n        for (j = 0; j < m; j++) {\n            sum +=\
    \ lst[i][j];\n        }\n        if (sum == x) {\n            res.push_back({i,\
    \ n - 1 - i});\n        }\n    }\n    std::sort(res.begin(), res.end(), [](const\
    \ std::tuple<long, long> &a, const std::tuple<long, long> &b) { return std::get<0>(a)\
    \ < std::get<0>(b); });\n    std::sort(res.begin(), res.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) { return std::get<1>(a) > std::get<1>(b);\
    \ });\n    return res;", "    std::vector<std::tuple<long, long>> res;\n    for\
    \ (auto &row : lst) {\n        auto it = std::find(row.begin(), row.end(), x);\n\
    \        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) < std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        std::sort(row.begin(), row.end(), [](long a, long b) { return a >\
    \ b; });\n        std::sort(row.rbegin(), row.rend(), [](long a, long b) { return\
    \ a > b; });\n        for (auto &col : row) {\n            if (col == x) {\n \
    \               res.emplace_back(std::make_tuple(row, col));\n            }\n\
    \        }\n    }\n    return res;", "    std::vector<std::tuple<long, long>>\
    \ res;\n    for (auto &row : lst) {\n        std::sort(row.begin(), row.end());\n\
    \        std::sort(row.rbegin(), row.rend());\n        if (std::find(row.begin(),\
    \ row.end(), x) != row.end()) {\n            std::sort(row.rbegin(), row.rend());\n\
    \            res.push_back(std::make_tuple(row.front(), row.back()));\n      \
    \  }\n    }\n    return res;", "    std::vector<std::tuple<long, long>> res;\n\
    \    for (auto &row : lst) {\n        auto it = std::find(row.begin(), row.end(),\
    \ x);\n        if (it != row.end()) {\n            std::tuple<long, long> coord(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1);\n            res.push_back(coord);\n\
    \        }\n    }\n    std::sort(res.begin(), res.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) -> bool {\n        return std::get<0>(a)\
    \ < std::get<0>(b);\n    });\n    std::sort(res.begin(), res.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) -> bool {\n        return std::get<1>(a)\
    \ < std::get<1>(b);\n    });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), std::prev(it))));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](auto &a, auto &b) {\n        return std::get<0>(a) > std::get<0>(b);\n\
    \    });\n    std::sort(res.begin(), res.end(), [](auto &a, auto &b) {\n     \
    \   return std::get<1>(a) > std::get<1>(b);\n    });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    std::vector<std::tuple<long, long>> row;\n    for (auto &i\
    \ : lst) {\n        row.push_back(i);\n    }\n    std::sort(row.begin(), row.end(),\
    \ [](const std::tuple<long, long> &a, const std::tuple<long, long> &b) { return\
    \ std::get<0>(a) < std::get<0>(b); });\n    std::sort(row.begin(), row.end(),\
    \ [](const std::tuple<long, long> &a, const std::tuple<long, long> &b) { return\
    \ std::get<1>(a) < std::get<1>(b); });\n    for (auto &i : row) {\n        if\
    \ (std::get<0>(i) == x) {\n            res.push_back(std::make_tuple(std::get<0>(i),\
    \ std::get<1>(i)));\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), std::prev(it))));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](auto &a, auto &b) { return std::get<0>(a) > std::get<0>(b); });\n\
    \    std::sort(res.begin(), res.end(), [](auto &a, auto &b) { return std::get<1>(a)\
    \ > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long, long>>\
    \ res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        auto it = std::find(row.begin(), row.end(), x);\n        if (it !=\
    \ row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), std::prev(it))));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) < std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) < std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        for (auto &el : row) {\n \
    \           if (el == x) {\n                res.emplace_back(std::make_tuple(row.size(),\
    \ row.size() - 1));\n            }\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        std::sort(row.begin(), row.end());\n\
    \        std::sort(row.rbegin(), row.rend());\n        for (auto &col : row) {\n\
    \            if (col == x) {\n                res.push_back(std::make_tuple(row.size(),\
    \ col.size()));\n            }\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for(auto &row : lst) {\n        for(auto &val : row) {\n  \
    \          if(val == x) {\n                res.emplace_back(std::make_tuple(row.size(),\
    \ row.size()));\n            }\n        }\n    }\n    std::sort(res.begin(), res.end(),\
    \ [](const std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n   \
    \     return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        auto it = std::find(row.begin(), row.end(), x);\n        if (it !=\
    \ row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](auto &a, auto &b) { return std::get<0>(a) < std::get<0>(b); });\n\
    \    std::sort(res.begin(), res.end(), [](auto &a, auto &b) { return std::get<1>(a)\
    \ < std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long, long>>\
    \ res;\n    for (auto &row : lst) {\n        std::sort(row.begin(), row.end());\n\
    \        std::sort(row.rbegin(), row.rend());\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        res.push_back({std::distance(row.begin(), it), std::distance(row.rbegin(),\
    \ it)});\n    }\n    return res;", "    std::vector<std::tuple<long, long>> res;\n\
    \    for (auto &row : lst) {\n        auto it = std::find(row.begin(), row.end(),\
    \ x);\n        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for(auto &row : lst)\
    \ {\n        for(auto &val : row) {\n            if(val == x) {\n            \
    \    res.push_back(std::make_tuple(row.size(), row.size()));\n            }\n\
    \        }\n    }\n    std::sort(res.begin(), res.end(), [](auto &a, auto &b)\
    \ { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(), res.end(),\
    \ [](auto &a, auto &b) { return std::get<1>(a) > std::get<1>(b); });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        std::sort(row.begin(), row.end());\n        std::reverse(row.begin(),\
    \ row.end());\n        std::sort(row.begin(), row.end());\n        std::reverse(row.begin(),\
    \ row.end());\n        for (auto &col : row) {\n            if (col == x) {\n\
    \                res.push_back(std::make_tuple(row.size(), col.size()));\n   \
    \         }\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        for (auto &el : row) {\n \
    \           if (el == x) {\n                res.emplace_back(std::make_tuple(row.size(),\
    \ row.size() - 1));\n            }\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        std::sort(row.begin(), row.end());\n\
    \        std::sort(row.rbegin(), row.rend());\n        for (auto &col : row) {\n\
    \            if (col == x) {\n                res.emplace_back(std::make_tuple(row.size(),\
    \ col.size()));\n            }\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for(auto &row : lst) {\n        for(auto &col : row) {\n  \
    \          if(col == x) {\n                res.push_back(std::make_tuple(row,\
    \ col));\n            }\n        }\n    }\n    std::sort(res.begin(), res.end(),\
    \ [](const std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n   \
    \     return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    std::vector<std::tuple<long,\
    \ long>> row;\n    for (auto &i : lst) {\n        row.emplace_back(i, 0);\n  \
    \  }\n    std::sort(row.begin(), row.end(), [](const std::tuple<long, long> &a,\
    \ const std::tuple<long, long> &b) {\n        return std::get<0>(a) < std::get<0>(b);\n\
    \    });\n    for (auto &i : row) {\n        if (std::get<0>(i) == x) {\n    \
    \        res.emplace_back(std::get<1>(i), std::get<1>(row.back()));\n        }\n\
    \    }\n    return res;", "    std::vector<std::tuple<long, long>> res;\n    for(auto\
    \ &row : lst) {\n        for(auto &col : row) {\n            if(col == x) {\n\
    \                res.push_back(std::make_tuple(row, col));\n            }\n  \
    \      }\n    }\n    std::sort(res.begin(), res.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n        return std::get<0>(a)\
    \ < std::get<0>(b);\n    });\n    std::sort(res.begin(), res.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n        return std::get<1>(a)\
    \ < std::get<1>(b);\n    });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        std::sort(row.begin(), row.end());\n\
    \        std::sort(row.rbegin(), row.rend());\n        for (auto &col : row) {\n\
    \            if (col == x) {\n                res.emplace_back(std::make_tuple(row,\
    \ col));\n            }\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        std::sort(row.begin(), row.end());\n\
    \        std::sort(row.rbegin(), row.rend());\n        std::reverse(row.begin(),\
    \ row.end());\n        std::reverse(row.rbegin(), row.rend());\n        for (auto\
    \ &col : row) {\n            if (col == x) {\n                res.emplace_back(std::make_tuple(row,\
    \ col));\n            }\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    long row = 0;\n    long col = 0;\n    for (auto &row : lst)\
    \ {\n        long col = 0;\n        for (auto &col : row) {\n            if (col\
    \ == x) {\n                res.push_back(std::make_tuple(row, col));\n       \
    \     }\n            col++;\n        }\n        row++;\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        std::sort(row.begin(), row.end());\n        std::sort(row.rbegin(),\
    \ row.rend());\n        for (auto &col : row) {\n            if (col == x) {\n\
    \                res.push_back(std::make_tuple(row.size(), col.size()));\n   \
    \         }\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    long row = 0;\n    long col = 0;\n    for (auto &i : lst) {\n\
    \        row += i;\n        col += i;\n    }\n    res.push_back(std::make_tuple(row,\
    \ col));\n    return res;", "    std::vector<std::tuple<long, long>> res;\n  \
    \  for (auto &row : lst) {\n        auto it = std::find(row.begin(), row.end(),\
    \ x);\n        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        for (auto &el : row) {\n \
    \           if (el == x) {\n                res.push_back(std::make_tuple(row,\
    \ row.size()));\n            }\n        }\n    }\n    std::sort(res.begin(), res.end(),\
    \ [](const std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n   \
    \     return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        auto it = std::find(row.begin(), row.end(), x);\n        if (it !=\
    \ row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](auto &a, auto &b) {\n        return std::get<0>(a) > std::get<0>(b);\n\
    \    });\n    std::sort(res.begin(), res.end(), [](auto &a, auto &b) {\n     \
    \   return std::get<1>(a) > std::get<1>(b);\n    });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), std::prev(it))));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) < std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        for (auto &el : row) {\n            if (el == x) {\n            \
    \    res.push_back(std::make_tuple(row, el));\n            }\n        }\n    }\n\
    \    std::sort(res.begin(), res.end(), [](const std::tuple<long, long> &a, const\
    \ std::tuple<long, long> &b) {\n        return std::get<0>(a) > std::get<0>(b);\n\
    \    });\n    std::sort(res.begin(), res.end(), [](const std::tuple<long, long>\
    \ &a, const std::tuple<long, long> &b) {\n        return std::get<1>(a) > std::get<1>(b);\n\
    \    });\n    return res;", "    std::vector<std::tuple<long, long>> res;\n  \
    \  for (auto &row : lst) {\n        auto it = std::find(row.begin(), row.end(),\
    \ x);\n        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        std::sort(row.begin(), row.end(), [](long a, long b) { return a <\
    \ b; });\n        std::sort(row.rbegin(), row.rend(), [](long a, long b) { return\
    \ b < a; });\n        for (auto &col : row) {\n            if (col == x) {\n \
    \               res.emplace_back(row, col);\n            }\n        }\n    }\n\
    \    return res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto\
    \ &row : lst) {\n        auto it = std::find(row.begin(), row.end(), x);\n   \
    \     if (it != row.end()) {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        auto it = std::find(row.begin(), row.end(), x);\n        if (it !=\
    \ row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](auto &a, auto &b) { return std::get<0>(a) > std::get<0>(b); });\n\
    \    std::sort(res.begin(), res.end(), [](auto &a, auto &b) { return std::get<1>(a)\
    \ > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long, long>>\
    \ res;\n    for (auto &row : lst) {\n        std::sort(row.begin(), row.end());\n\
    \        std::sort(row.rbegin(), row.rend());\n        for (auto &col : row) {\n\
    \            if (col == x) {\n                res.emplace_back(std::make_tuple(row.size(),\
    \ col.size()));\n            }\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), std::prev(it))));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](auto &a, auto &b) { return std::get<0>(a) > std::get<0>(b); });\n\
    \    std::sort(res.begin(), res.end(), [](auto &a, auto &b) { return std::get<1>(a)\
    \ > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long, long>>\
    \ res;\n    for (auto &row : lst) {\n        std::sort(row.begin(), row.end());\n\
    \        std::reverse(row.begin(), row.end());\n        for (auto &col : row)\
    \ {\n            if (col == x) {\n                res.push_back(std::make_tuple(row,\
    \ col));\n            }\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](std::tuple<long, long> a, std::tuple<long, long> b) {\n      \
    \  return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](std::tuple<long, long> a, std::tuple<long, long> b) {\n      \
    \  return std::get<1>(a) > std::get<1>(b);\n    });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        for (auto &el : row) {\n            if (el == x) {\n            \
    \    res.push_back(std::make_tuple(row, el));\n            }\n        }\n    }\n\
    \    std::sort(res.begin(), res.end(), [](const std::tuple<long, long> &a, const\
    \ std::tuple<long, long> &b) {\n        return std::get<0>(a) < std::get<0>(b);\n\
    \    });\n    std::sort(res.begin(), res.end(), [](const std::tuple<long, long>\
    \ &a, const std::tuple<long, long> &b) {\n        return std::get<1>(a) < std::get<1>(b);\n\
    \    });\n    return res;", "    std::vector<std::tuple<long, long>> res;\n  \
    \  for (auto &row : lst) {\n        auto it = std::find(row.begin(), row.end(),\
    \ x);\n        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        std::sort(row.begin(), row.end());\n\
    \        std::sort(row.rbegin(), row.rend());\n        if (std::find(row.begin(),\
    \ row.end(), x) != row.end()) {\n            res.push_back(std::make_tuple(row.front(),\
    \ row.back()));\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        for (auto &val : row) {\n\
    \            if (val == x) {\n                res.emplace_back(std::make_tuple(row.size()\
    \ - 1, row.size() - 1));\n            }\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) < std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        auto it = std::find(row.begin(), row.end(), x);\n        if (it !=\
    \ row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        std::sort(row.begin(), row.end());\n        std::sort(row.rbegin(),\
    \ row.rend());\n        if (std::find(row.begin(), row.end(), x) != row.end())\
    \ {\n            res.push_back(std::make_tuple(row.front(), row.back()));\n  \
    \      }\n    }\n    return res;", "    std::vector<std::tuple<long, long>> res;\n\
    \    for (auto &row : lst) {\n        auto it = std::find(row.begin(), row.end(),\
    \ x);\n        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for(auto &row : lst)\
    \ {\n        for(auto &ele : row) {\n            if(ele == x) {\n            \
    \    res.emplace_back(std::make_tuple(row.size(), row.size() - 1));\n        \
    \    }\n        }\n    }\n    std::sort(res.begin(), res.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n        return std::get<0>(a)\
    \ < std::get<0>(b);\n    });\n    std::sort(res.begin(), res.end(), [](const std::tuple<long,\
    \ long> &a, const std::tuple<long, long> &b) {\n        return std::get<1>(a)\
    \ < std::get<1>(b);\n    });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        std::sort(row.begin(), row.end(),\
    \ [](long a, long b) { return a < b; });\n        std::sort(row.rbegin(), row.rend(),\
    \ [](long a, long b) { return a > b; });\n        for (auto &col : row) {\n  \
    \          if (col == x) {\n                res.emplace_back(std::make_tuple(row.size(),\
    \ col.size()));\n            }\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        auto it = std::find(row.begin(), row.end(), x);\n        if (it !=\
    \ row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) < std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        std::sort(row.begin(), row.end(), [](long a, long b) { return a <\
    \ b; });\n        std::sort(row.rbegin(), row.rend(), [](long a, long b) { return\
    \ a > b; });\n        for (auto &col : row) {\n            if (col == x) {\n \
    \               res.push_back(std::make_tuple(row, col));\n            }\n   \
    \     }\n    }\n    return res;", "    std::vector<std::tuple<long, long>> res;\n\
    \    for(auto &row : lst) {\n        for(auto &col : row) {\n            if(col\
    \ == x) {\n                res.push_back(std::make_tuple(row, col));\n       \
    \     }\n        }\n    }\n    std::sort(res.begin(), res.end(), [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) { return std::get<0>(a) > std::get<0>(b);\
    \ });\n    std::sort(res.begin(), res.end(), [](std::tuple<long, long> a, std::tuple<long,\
    \ long> b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", " \
    \   std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst) {\n  \
    \      auto it = std::find(row.begin(), row.end(), x);\n        if (it != row.end())\
    \ {\n            std::sort(row.begin(), row.end(), [](long a, long b) { return\
    \ b < a; });\n            std::sort(row.rbegin(), row.rend(), [](long a, long\
    \ b) { return b < a; });\n            res.push_back(std::make_tuple(row.front(),\
    \ row.back()));\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for(auto &row : lst) {\n        for(auto &col : row) {\n  \
    \          if(col == x) {\n                res.push_back({row, col});\n      \
    \      }\n        }\n    }\n    std::sort(res.begin(), res.end(), [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) {\n        return std::get<0>(a) > std::get<0>(b);\n\
    \    });\n    std::sort(res.begin(), res.end(), [](std::tuple<long, long> a, std::tuple<long,\
    \ long> b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        std::sort(row.begin(), row.end());\n        std::sort(row.rbegin(),\
    \ row.rend());\n        std::reverse(row.begin(), row.end());\n        std::reverse(row.rbegin(),\
    \ row.rend());\n        for (auto &col : row) {\n            if (col == x) {\n\
    \                res.emplace_back(std::make_tuple(row.size(), col.size()));\n\
    \            }\n        }\n    }\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        for (auto &el : row) {\n            if (el == x) {\n            \
    \    res.push_back(std::make_tuple(row, el));\n            }\n        }\n    }\n\
    \    std::sort(res.begin(), res.end(), [](const std::tuple<long, long> &a, const\
    \ std::tuple<long, long> &b) {\n        return std::get<0>(a) < std::get<0>(b);\n\
    \    });\n    std::sort(res.begin(), res.end(), [](const std::tuple<long, long>\
    \ &a, const std::tuple<long, long> &b) {\n        return std::get<1>(a) < std::get<1>(b);\n\
    \    });\n    return res;", "    std::vector<std::tuple<long, long>> res;\n  \
    \  for (auto &row : lst) {\n        auto it = std::find(row.begin(), row.end(),\
    \ x);\n        if (it != row.end()) {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](auto &a, auto &b) { return std::get<0>(a) < std::get<0>(b); });\n\
    \    std::sort(res.begin(), res.end(), [](auto &a, auto &b) { return std::get<1>(a)\
    \ < std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long, long>>\
    \ res;\n    for(auto &row : lst) {\n        for(auto &val : row) {\n         \
    \   if(val == x) {\n                res.push_back(std::make_tuple(row.size(),\
    \ row.size()));\n            }\n        }\n    }\n    std::sort(res.begin(), res.end(),\
    \ [](const std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n   \
    \     return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) < std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto &row : lst)\
    \ {\n        std::sort(row.begin(), row.end());\n        std::sort(row.rbegin(),\
    \ row.rend());\n        std::reverse(row.begin(), row.end());\n        std::reverse(row.rbegin(),\
    \ row.rend());\n        std::set<long> row_set;\n        for (auto &elem : row)\
    \ {\n            if (elem == x) {\n                res.push_back(std::make_tuple(row.size(),\
    \ row.size()));\n                row_set.insert(elem);\n            }\n      \
    \  }\n        for (auto &elem : row_set) {\n            std::sort(row.begin(),\
    \ row.end());\n            std::sort(row.rbegin(), row.rend());\n            std::reverse(row.begin(),\
    \ row.end());\n            std::reverse(row.rbegin(), row.rend());\n         \
    \   std::set<long> col_set;\n            for (auto &elem : row) {\n          \
    \      if (elem == elem) {\n                    col_set.insert(elem);\n      \
    \          }\n            }\n            for (auto &elem : col_set) {\n      \
    \          res.push_back(std::make_tuple(row.size(), row.size()));\n         \
    \   }\n        }\n    }\n    return res;", "    std::vector<std::tuple<long, long>>\
    \ res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            auto y = std::distance(row.begin(),\
    \ it);\n            res.push_back({y, x});\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<0>(a) > std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) { return std::get<1>(a) > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long,\
    \ long>> res;\n    for (auto &row : lst) {\n        auto it = std::find(row.begin(),\
    \ row.end(), x);\n        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) < std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) < std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for(auto &row : lst)\
    \ {\n        for(auto &col : row) {\n            if(col == x) {\n            \
    \    res.emplace_back(std::make_tuple(row, col));\n            }\n        }\n\
    \    }\n    std::sort(res.begin(), res.end(), [](const std::tuple<long, long>\
    \ &a, const std::tuple<long, long> &b) {\n        return std::get<0>(a) < std::get<0>(b);\n\
    \    });\n    std::sort(res.begin(), res.end(), [](const std::tuple<long, long>\
    \ &a, const std::tuple<long, long> &b) {\n        return std::get<1>(a) < std::get<1>(b);\n\
    \    });\n    return res;", "    std::vector<std::tuple<long, long>> res;\n  \
    \  for (auto &row : lst) {\n        auto it = std::find(row.begin(), row.end(),\
    \ x);\n        if (it != row.end()) {\n            res.push_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](auto &a, auto &b) { return std::get<0>(a) > std::get<0>(b); });\n\
    \    std::sort(res.begin(), res.end(), [](auto &a, auto &b) { return std::get<1>(a)\
    \ > std::get<1>(b); });\n    return res;", "    std::vector<std::tuple<long, long>>\
    \ res;\n    for(auto &row : lst) {\n        for(auto &col : row) {\n         \
    \   if(col == x) {\n                res.emplace_back(std::make_tuple(row, col));\n\
    \            }\n        }\n    }\n    std::sort(res.begin(), res.end(), [](std::tuple<long,\
    \ long> a, std::tuple<long, long> b) {\n        return std::get<0>(a) < std::get<0>(b);\n\
    \    });\n    std::sort(res.begin(), res.end(), [](std::tuple<long, long> a, std::tuple<long,\
    \ long> b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    long row = 0;\n  \
    \  long col = 0;\n    for (auto &v : lst) {\n        if (v == x) {\n         \
    \   std::tuple<long, long> t(row, col);\n            res.push_back(t);\n     \
    \   }\n        ++col;\n        if (col == v.size()) {\n            ++row;\n  \
    \          col = 0;\n        }\n    }\n    std::sort(res.begin(), res.end(), [](auto\
    \ &a, auto &b) { return std::get<0>(a) < std::get<0>(b); });\n    std::sort(res.begin(),\
    \ res.end(), [](auto &a, auto &b) { return std::get<1>(a) > std::get<1>(b); });\n\
    \    return res;", "    std::vector<std::tuple<long, long>> res;\n    for (auto\
    \ &row : lst) {\n        auto it = std::find(row.begin(), row.end(), x);\n   \
    \     if (it != row.end()) {\n            res.emplace_back(std::make_tuple(std::distance(row.begin(),\
    \ it), std::distance(row.begin(), it) - 1));\n        }\n    }\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;", "    std::vector<std::tuple<long, long>> res;\n    for(auto &row : lst)\
    \ {\n        for(auto &col : row) {\n            if(col == x) {\n            \
    \    res.emplace_back(std::make_tuple(row, col));\n            }\n        }\n\
    \    }\n    std::sort(res.begin(), res.end(), [](const std::tuple<long, long>\
    \ &a, const std::tuple<long, long> &b) {\n        return std::get<0>(a) < std::get<0>(b);\n\
    \    });\n    std::sort(res.begin(), res.end(), [](const std::tuple<long, long>\
    \ &a, const std::tuple<long, long> &b) {\n        return std::get<1>(a) < std::get<1>(b);\n\
    \    });\n    return res;", "    std::vector<std::tuple<long, long>> res;\n  \
    \  long row = 0;\n    long col = 0;\n    for (auto &row : lst) {\n        col\
    \ = 0;\n        for (auto &val : row) {\n            if (val == x) {\n       \
    \         res.emplace_back(std::make_tuple(row, col));\n            }\n      \
    \      ++col;\n        }\n        ++row;\n    }\n    std::sort(res.begin(), res.end(),\
    \ [](const std::tuple<long, long> &a, const std::tuple<long, long> &b) {\n   \
    \     return std::get<0>(a) > std::get<0>(b);\n    });\n    std::sort(res.begin(),\
    \ res.end(), [](const std::tuple<long, long> &a, const std::tuple<long, long>\
    \ &b) {\n        return std::get<1>(a) > std::get<1>(b);\n    });\n    return\
    \ res;"]
stop_tokens:
- "\n}"
