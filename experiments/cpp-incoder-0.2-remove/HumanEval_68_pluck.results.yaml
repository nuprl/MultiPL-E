language: cpp
name: HumanEval_68_pluck
results:
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // Your code here\n    long\
    \ smalest_value = 0;\n    int smalest_index = 0;\n    long smalest_even_value\
    \ = 0;\n    int smalest_even_index = 0;\n    long smalest_even_value_pos = 0;\n\
    \    int smalest_even_index_pos = 0;\n    long smalest_even_value_neg = 0;\n \
    \   int smalest_even_index_neg = 0;\n    long smalest_even_value_zero = 0;\n \
    \   int smalest_even_index_zero = 0;\n    long smalest_even_value_one = 0;\n \
    \   int smalest_even_index_one = 0;\n    long smalest_even_value_two = 0;\n  \
    \  int smalest_even_index_two = 0;\n    long smalest_even_value_three = 0;\n \
    \   int smalest_even_index_three = 0;\n    long smalest_even_value_four = 0;\n\
    \    int smalest_even_index_four = 0;\n    long smalest_even_value_five = 0;\n\
    \    int smalest_even_index_five = 0;\n    long smalest_even_value_six = 0;\n\
    \    int smalest_even_index_six = 0;\n    long smalest_even_value_seven = 0;\n\
    \    int smalest_even_index_seven = 0;\n    long smalest_even_value_eight = 0;\n\
    \    int smalest_even_index_eight = 0;\n    long smalest_even_value_nine = 0;\n\
    \    int smalest_even_index_nine = 0;\n    long smalest_even_value_ten = 0;\n\
    \    int smalest_even_index_ten = 0;\n    long smalest_even_value_eleven = 0;\n\
    \    int smalest_even_index_eleven = 0;\n    long smalest_even_value_twelve =\
    \ 0;\n    int smalest_even_index_twelve = 0;\n    long smalest_even_value_thirteen\
    \ = 0;\n    int smalest_even_index_thirteen = 0;\n    long smalest_even_value_fourteen\
    \ = 0;\n    int smalest_even_index_fourteen = 0;\n    long smalest_even_value_fifteen\
    \ = 0;\n    int smalest_even_index_fifteen = 0;\n    long smalest_even_value_sixteen\
    \ = 0;\n    int smalest_even_index_sixteen = 0;\n    long smalest_even_value_seventeen\
    \ = 0;\n    int smalest_even_index_seventeen = 0;\n    long smalest_even_value_eighteen\
    \ = 0;\n    int smalest_even_index_eighteen = 0;\n    long smalest_even_value_nineteen\
    \ = 0;\n    int smalest_even_index_nineteen = 0;\n    long smalest_even_value_twenty\
    \ = 0;\n    int smalest_even_index_twenty = 0;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpc5mbz2sf: /tmp/tmpc5mbz2sf.cpp:75: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long smalest_even_value = 0;\n    long\
    \ smalest_even_index = 0;\n    long smalest_even_index_count = 0;\n    long smalest_even_index_count_max\
    \ = 0;\n    long smalest_even_index_count_min = 0;\n    long smalest_even_index_count_temp\
    \ = 0;\n    long smalest_even_index_count_temp_max = 0;\n    long smalest_even_index_count_temp_min\
    \ = 0;\n    long smalest_even_index_count_temp_max = 0;\n    long smalest_even_index_count_temp_min\
    \ = 0;\n    long smalest_even_index_count_temp_max = 0;\n    long smalest_even_index_count_temp_min\
    \ = 0;\n    long smalest_even_index_count_temp_max = 0;\n    long smalest_even_index_count_temp_min\
    \ = 0;\n    long smalest_even_index_count_temp_max = 0;\n    long smalest_even_index_count_temp_min\
    \ = 0;\n    long smalest_even_index_count_temp_max = 0;\n    long smalest_even_index_count_temp_min\
    \ = 0;\n    long smalest_even_index_count_temp_max = 0;\n    long smalest_even_index_count_temp_min\
    \ = 0;\n    long smalest_even_index_count_temp_max = 0;\n    long smalest_even_index_count_temp_min\
    \ = 0;\n    long smalest_even_index_count_temp_max = 0;\n    long smalest_even_index_count_temp_min\
    \ = 0;\n    long smalest_even_index_count_temp_max = 0;\n    long smalest_even_index_count_temp_min\
    \ = 0;\n    long smalest_even_index_count_temp_max = 0;\n    long smalest_even_index_count_temp_min\
    \ = 0;\n    long smalest_even_index_count_temp_max = 0;\n    long smalest_even_index_count_temp_min\
    \ = 0;\n    long smalest_even_index_count_temp_max = 0;\n    long smalest_even_index_count_temp_min\
    \ = 0;\n    long smalest_even_index_count_temp_max = 0;\n    long smalest_even_index_count_temp_min\
    \ = 0;\n    long smalest_even_index_count_temp_max = 0;\n    long smalest_even_index_count_temp_min\
    \ = 0;\n    long smalest_even_index_count_temp_max = 0;\n    long smalest_even_index_count_temp_min\
    \ = 0;\n    long smalest_even_index_count_temp_max = 0;\n    long smalest_even_index_count_temp_min\
    \ = 0;\n    long smalest_even_index_count_temp_max = 0;\n    long smalest_even_index_count_temp_min\
    \ = 0;\n\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpktipqda1.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpktipqda1.cpp:32:10: error: redeclaration of \u2018long\
    \ int smalest_even_index_count_temp_max\u2019\n   32 |     long smalest_even_index_count_temp_max\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpktipqda1.cpp:30:10:\
    \ note: \u2018long int smalest_even_index_count_temp_max\u2019 previously declared\
    \ here\n   30 |     long smalest_even_index_count_temp_max = 0;\n      |     \
    \     ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpktipqda1.cpp:33:10: error: redeclaration\
    \ of \u2018long int smalest_even_index_count_temp_min\u2019\n   33 |     long\
    \ smalest_even_index_count_temp_min = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpktipqda1.cpp:31:10: note: \u2018long int smalest_even_index_count_temp_min\u2019\
    \ previously declared here\n   31 |     long smalest_even_index_count_temp_min\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpktipqda1.cpp:34:10:\
    \ error: redeclaration of \u2018long int smalest_even_index_count_temp_max\u2019\
    \n   34 |     long smalest_even_index_count_temp_max = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpktipqda1.cpp:30:10: note: \u2018long int smalest_even_index_count_temp_max\u2019\
    \ previously declared here\n   30 |     long smalest_even_index_count_temp_max\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpktipqda1.cpp:35:10:\
    \ error: redeclaration of \u2018long int smalest_even_index_count_temp_min\u2019\
    \n   35 |     long smalest_even_index_count_temp_min = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpktipqda1.cpp:31:10: note: \u2018long int smalest_even_index_count_temp_min\u2019\
    \ previously declared here\n   31 |     long smalest_even_index_count_temp_min\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmpktipqda1.cpp:36:10:\
    \ error: redeclaration of \u2018long int smalest_even_index_count_temp_max\u2019\
    \n   36 |     long smalest_even_index_count_temp_max = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpktipqda1.cpp:30:10: note: \u2018long int smalest_even_index_count_temp_max\u2019\
    \ previously declar"
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long smallest_even_value = 0;\n    std::vector<long>\
    \ result;\n    for(long i = 0; i < arr.size(); i++) {\n        if(arr[i] % 2 ==\
    \ 0) {\n            if(smallest_even_value < arr[i]) {\n                smallest_even_value\
    \ = arr[i];\n                smalest_value = arr[i];\n                smalest_index\
    \ = i;\n            }\n        }\n    }\n    if(smallest_even_value == 0) {\n\
    \        return result;\n    }\n    result.push_back(smalest_value);\n    result.push_back(smalest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp_06rsks2: /tmp/tmp_06rsks2.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = 0;\n\
    \    long smalest_index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n  \
    \      if (arr[i] % 2 == 0) {\n            if (smalest_value < arr[i]) {\n   \
    \             smalest_value = arr[i];\n                smalest_index = i;\n  \
    \          }\n        }\n    }\n    std::vector<long> result;\n    if (smalest_value\
    \ != 0) {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp0qvcugpr: /tmp/tmp0qvcugpr.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // write your code here\n\
    \    long smalest_value = arr[0];\n    long smalest_index = 0;\n    for (long\
    \ i = 1; i < arr.size(); i++) {\n        if (arr[i] < smalest_value) {\n     \
    \       smalest_value = arr[i];\n            smalest_index = i;\n        }\n \
    \   }\n    std::vector<long> res;\n    res.push_back(smalest_value);\n    res.push_back(smalest_index);\n\
    \    return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpr9twehxn: /tmp/tmpr9twehxn.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // Your code here\n    long\
    \ smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_even_value\
    \ = 0;\n    long smalest_even_index = 0;\n    long smalest_even_index_temp = 0;\n\
    \    long smalest_even_index_temp_temp = 0;\n    long smalest_even_index_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp = 0;\n    long\
    \ smalest_even_index_temp_temp_temp_temp_temp_temp_temp = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkzt5vv1p.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpkzt5vv1p.cpp:36:10: error: redeclaration of \u2018long\
    \ int smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\u2019\
    \n   36 |     long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpkzt5vv1p.cpp:35:10: note: \u2018long int smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\u2019\
    \ previously declared here\n   35 |     long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpkzt5vv1p.cpp:41:10: error: redeclaration of \u2018long int smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\u2019\
    \n   41 |     long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpkzt5vv1p.cpp:40:10: note: \u2018long int smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\u2019\
    \ previously declared here\n   40 |     long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpkzt5vv1p.cpp:43:10: error: redeclaration of \u2018long int smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\u2019\
    \n   43 |     long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpkzt5vv1p.cpp:42:10: note: \u2018long int smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\u2019\
    \ previously declared here\n   42 |     long smalest_even_index_temp_t"
  stdout: ''
  timestamp: 1660085845
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long smalest_index_of_smalest_value =\
    \ 0;\n    long smalest_index_of_smalest_value2 = 0;\n    long smalest_index_of_smalest_value3\
    \ = 0;\n    long smalest_index_of_smalest_value4 = 0;\n    long smalest_index_of_smalest_value5\
    \ = 0;\n    long smalest_index_of_smalest_value6 = 0;\n    long smalest_index_of_smalest_value7\
    \ = 0;\n    long smalest_index_of_smalest_value8 = 0;\n    long smalest_index_of_smalest_value9\
    \ = 0;\n    long smalest_index_of_smalest_value10 = 0;\n    long smalest_index_of_smalest_value11\
    \ = 0;\n    long smalest_index_of_smalest_value12 = 0;\n    long smalest_index_of_smalest_value13\
    \ = 0;\n    long smalest_index_of_smalest_value14 = 0;\n    long smalest_index_of_smalest_value15\
    \ = 0;\n    long smalest_index_of_smalest_value16 = 0;\n    long smalest_index_of_smalest_value17\
    \ = 0;\n    long smalest_index_of_smalest_value18 = 0;\n    long smalest_index_of_smalest_value19\
    \ = 0;\n    long smalest_index_of_smalest_value20 = 0;\n    long smalest_index_of_smalest_value21\
    \ = 0;\n    long smalest_index_of_smalest_value22 = 0;\n    long smalest_index_of_smalest_value23\
    \ = 0;\n    long smalest_index_of_smalest_value24 = 0;\n    long smalest_index_of_smalest_value25\
    \ = 0;\n    long smalest_index_of_smalest_value26 = 0;\n    long smalest_index_of_smalest_value27\
    \ = 0;\n    long smalest_index_of_smalest_value28 = 0;\n    long smalest_index_of_smalest_value29\
    \ = 0;\n    long smalest_index_of_smalest_value30 = 0;\n    long smalest_index_of_smalest_value31\
    \ = 0;\n    long smalest_index_of_smalest_value32 = 0;\n    long smalest_index_of_smalest_value33\
    \ = 0;\n    long smalest_index_of_smalest_value34 = 0;\n    long smalest_index_of_smalest_value35\
    \ = 0;\n    long smalest_index_of_\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7t8ohfok.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp7t8ohfok.cpp:60:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   60 | }\n      | ^\n/tmp/tmp7t8ohfok.cpp:60:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long smalest_index_value = arr[0];\n    for\
    \ (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < smalest_value) {\n\
    \            smalest_value = arr[i];\n            smalest_index = i;\n       \
    \     smalest_index_value = arr[i];\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_index_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    } else {\n        result.push_back(smalest_index_value);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmppua1kblk: /tmp/tmppua1kblk.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    } else {\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp1jm38vav: /tmp/tmp1jm38vav.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpb__mwrec: /tmp/tmpb__mwrec.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0, smalest_index = 0;\n    long even_value = 0;\n    long index = 0;\n   \
    \ long size = arr.size();\n    for (long i = 0; i < size; i++) {\n        if (arr[i]\
    \ % 2 == 0) {\n            even_value = arr[i];\n            index = i;\n    \
    \    }\n        if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n\
    \            smalest_index = index;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value == 0) {\n        return result;\n    }\n    result.push_back(smalest_value);\n\
    \    result.push_back(smalest_index);\n    return result;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmppjbxeur4: /tmp/tmppjbxeur4.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpqc2154h1: /tmp/tmpqc2154h1.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    for (long i = 0; i < arr.size(); i++)\
    \ {\n        if (arr[i] % 2 == 0) {\n            if (smalest_value == 0) {\n \
    \               smalest_value = arr[i];\n                smalest_index = i;\n\
    \            } else if (smalest_value < arr[i]) {\n                smalest_value\
    \ = arr[i];\n                smalest_index = i;\n            }\n        }\n  \
    \  }\n    std::vector<long> result;\n    if (smalest_value != 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp5ziol6x2: /tmp/tmp5ziol6x2.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value=0;\n\
    \    long smalest_index=0;\n    long smallest_value=INT_MAX;\n    long smallest_index=0;\n\
    \    long smallest_even_value=INT_MAX;\n    long smallest_even_count=0;\n    long\
    \ smallest_even_node=INT_MAX;\n    long smallest_even_node_index=0;\n    long\
    \ smallest_even_node_even_value=INT_MAX;\n    long smallest_even_node_even_count=0;\n\
    \    long smallest_even_node_even_node_index=0;\n    long smallest_even_node_even_node_even_value=INT_MAX;\n\
    \    long smallest_even_node_even_node_even_count=0;\n    long smallest_even_node_even_node_even_node_index=0;\n\
    \    long smallest_even_node_even_node_even_node_even_value=INT_MAX;\n    long\
    \ smallest_even_node_even_node_even_node_even_count=0;\n    long smallest_even_node_even_node_even_node_even_node_index=0;\n\
    \    long smallest_even_node_even_node_even_node_even_node_even_value=INT_MAX;\n\
    \    long smallest_even_node_even_node_even_node_even_node_even_count=0;\n   \
    \ long smallest_even_node_even_node_even_node_even_node_even_node_index=0;\n \
    \   long smallest_even_node_even_node_even_node_even_node_even_node_even_value=INT_MAX;\n\
    \    long smallest_even_node_even_node_even_node_even_node_even_node_even_count=0;\n\
    \    long smallest_even_node_even_node_even_node_even_node_even_node_even_node_index=0;\n\
    \    long smallest_even_node_even_node_even_node_even_node_even_node_even_node_even_value=INT_MAX;\n\
    \    long smallest_even_node_even_node_even_node_even_node_even_node_even_node_even_count=0;\n\
    \    long smallest_even_node_even_node_even_node_even_node_even_node_even_node_even_node_index=0;\n\
    \    long smallest_even_node_even_node_even_node_even_node_even_node_even_node_even_node_even_value=INT_MAX;\n\
    \    long smallest_even_node_even_node_even_node_even_node_even_node_even_node_even_node_even_count=0;\n\
    \    long smalle\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0tagk7tb.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp0tagk7tb.cpp:51:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   51 | }\n      | ^\n/tmp/tmp0tagk7tb.cpp:51:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    int smallest_index = 0;\n    for(int i = 0; i < arr.size(); i++){\n\
    \        if(arr[i] % 2 == 0){\n            if(arr[i] < smalest_value){\n     \
    \           smalest_value = arr[i];\n                smallest_index = i;\n   \
    \         }\n        }\n    }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n\
    \    result.push_back(smallest_index);\n    return result;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp3bt0e06c: /tmp/tmp3bt0e06c.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    int smallest_index = 0;\n    int size = arr.size();\n    for (int\
    \ i = 0; i < size; i++) {\n        if (arr[i] % 2 == 0) {\n            smalest_value\
    \ = arr[i];\n            smallest_index = i;\n        }\n    }\n    if (smalest_value\
    \ == 0) {\n        return {};\n    }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n\
    \    result.push_back(smallest_index);\n    return result;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp34qx5e_a: /tmp/tmp34qx5e_a.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)5,
    (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,
    (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    } else {\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp1jm38vav: /tmp/tmp1jm38vav.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smallest_index = arr[0];\n    long index = 0;\n    for (long i = 1;\
    \ i < arr.size(); i++) {\n        if (arr[i] < smalest_value) {\n            smalest_value\
    \ = arr[i];\n            smallest_index = index;\n        }\n        if (arr[i]\
    \ % 2 == 0) {\n            index = i;\n        }\n    }\n    std::vector<long>\
    \ result;\n    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smallest_index);\n    } else {\n        result.push_back(smallest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpxsms3mhk: /tmp/tmpxsms3mhk.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smallest_value\
    \ = 0;\n    long smallest_index = 0;\n    long smallest_even_value = 0;\n    long\
    \ smallest_even_count = 0;\n    long index = 0;\n    long even_value = 0;\n  \
    \  long even_count = 0;\n    long even_index = 0;\n    for (long i = 0; i < arr.size();\
    \ i++) {\n        if (arr[i] % 2 == 0) {\n            even_value = arr[i];\n \
    \           even_count++;\n        } else {\n            if (even_count > smallest_even_count)\
    \ {\n                smallest_even_value = even_value;\n                smallest_even_count\
    \ = even_count;\n                smallest_even_index = even_index;\n         \
    \   }\n            even_value = 0;\n            even_count = 0;\n            even_index++;\n\
    \        }\n    }\n    if (smallest_even_count == 0) {\n        return {};\n \
    \   }\n    if (smallest_even_count == 1) {\n        smallest_value = smallest_even_value;\n\
    \        smallest_index = smallest_even_index;\n    } else {\n        smallest_value\
    \ = arr[smallest_even_index];\n        smallest_index = smallest_even_index;\n\
    \    }\n    std::vector<long> result;\n    for (long i = 0; i < arr.size(); i++)\
    \ {\n        if (arr[i] % 2 == 0) {\n            result.push_back(arr[i]);\n \
    \       }\n    }\n    result.push_back(smallest_value);\n    result.push_back(smallest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpf090vosd.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpf090vosd.cpp:38:17: error: \u2018smallest_even_index\u2019\
    \ was not declared in this scope; did you mean \u2018smallest_even_count\u2019\
    ?\n   38 |                 smallest_even_index = even_index;\n      |        \
    \         ^~~~~~~~~~~~~~~~~~~\n      |                 smallest_even_count\n/tmp/tmpf090vosd.cpp:50:26:\
    \ error: \u2018smallest_even_index\u2019 was not declared in this scope; did you\
    \ mean \u2018smallest_even_count\u2019?\n   50 |         smallest_index = smallest_even_index;\n\
    \      |                          ^~~~~~~~~~~~~~~~~~~\n      |               \
    \           smallest_even_count\n/tmp/tmpf090vosd.cpp:52:30: error: \u2018smallest_even_index\u2019\
    \ was not declared in this scope; did you mean \u2018smallest_even_count\u2019\
    ?\n   52 |         smallest_value = arr[smallest_even_index];\n      |       \
    \                       ^~~~~~~~~~~~~~~~~~~\n      |                         \
    \     smallest_even_count\n"
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long smallest_even_value = arr[0];\n    long\
    \ smallest_even_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n    \
    \    if (arr[i] % 2 == 0) {\n            if (arr[i] < smallest_even_value) {\n\
    \                smallest_even_value = arr[i];\n                smallest_even_index\
    \ = i;\n            }\n        }\n        else if (arr[i] < smallest_even_value)\
    \ {\n            smallest_even_value = arr[i];\n            smallest_even_index\
    \ = i;\n        }\n        else if (arr[i] == smallest_even_value) {\n       \
    \     if (i < smallest_even_index) {\n                smallest_even_index = i;\n\
    \            }\n        }\n    }\n    std::vector<long> result;\n    if (smallest_even_value\
    \ == arr[0]) {\n        result.push_back(smallest_even_value);\n        result.push_back(smallest_even_index);\n\
    \    }\n    else {\n        result.push_back(smallest_even_value);\n        result.push_back(smallest_even_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpm3umqp4n: /tmp/tmpm3umqp4n.cpp:56: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // Your code here\n    long\
    \ smalest_value = 0;\n    long smalest_index = 0;\n    long smallest_even_value\
    \ = 0;\n    long smallest_even_index = 0;\n    long smallest_value_index = 0;\n\
    \    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n\
    \            if (smallest_even_value == 0) {\n                smallest_even_value\
    \ = arr[i];\n                smallest_even_index = i;\n            } else if (arr[i]\
    \ < smallest_even_value) {\n                smallest_even_value = arr[i];\n  \
    \              smallest_even_index = i;\n            }\n        } else if (arr[i]\
    \ < smallest_even_value) {\n            smallest_even_value = arr[i];\n      \
    \      smallest_even_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smallest_even_value != 0) {\n        result.push_back(smallest_even_value);\n\
    \        result.push_back(smallest_even_index);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpqp7_tn50: /tmp/tmpqp7_tn50.cpp:53: int main(): Assertion `candidate((std::vector<long>({(long)5,
    (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,
    (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> res;\n\
    \    res.push_back(smalest_value);\n    res.push_back(smalest_index);\n    return\
    \ res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp59rv0og3: /tmp/tmp59rv0og3.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> ans;\n\
    \    ans.push_back(smalest_value);\n    ans.push_back(smalest_index);\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpskcf2_p4: /tmp/tmpskcf2_p4.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = 0;\n\
    \    long smalest_index = 0;\n    long smalest_even_value = 0;\n    long smalest_even_index\
    \ = 0;\n    long smalest_even_value_pos = 0;\n    long smalest_even_index_pos\
    \ = 0;\n    long smalest_even_value_neg = 0;\n    long smalest_even_index_neg\
    \ = 0;\n    long smalest_index_neg = 0;\n    long smalest_value_neg = 0;\n   \
    \ long smalest_index_pos = 0;\n    long smalest_value_pos = 0;\n    long smalest_index_neg\
    \ = 0;\n    long smalest_value_neg = 0;\n    long smalest_index_pos = 0;\n   \
    \ long smalest_value_pos = 0;\n    long smalest_index_neg = 0;\n    long smalest_value_neg\
    \ = 0;\n    long smalest_index_pos = 0;\n    long smalest_value_pos = 0;\n   \
    \ long smalest_index_neg = 0;\n    long smalest_value_neg = 0;\n    long smalest_index_pos\
    \ = 0;\n    long smalest_value_pos = 0;\n    long smalest_index_neg = 0;\n   \
    \ long smalest_value_neg = 0;\n    long smalest_index_pos = 0;\n    long smalest_value_pos\
    \ = 0;\n    long smalest_index_neg = 0;\n    long smalest_value_neg = 0;\n   \
    \ long smalest_index_pos = 0;\n    long smalest_value_pos = 0;\n    long smalest_index_neg\
    \ = 0;\n    long smalest_value_neg = 0;\n    long smalest_index_pos = 0;\n   \
    \ long smalest_value_pos = 0;\n    long smalest_index_neg = 0;\n    long smalest_value_neg\
    \ = 0;\n    long smalest_index_pos = 0;\n    long smalest_value_pos = 0;\n   \
    \ long smalest_index_neg = 0;\n    long smalest_value_neg = 0;\n    long smalest_index_pos\
    \ = 0;\n    long smalest_value_pos = 0;\n    long smalest_index_neg = 0;\n   \
    \ long smalest_value_neg = 0;\n    long smalest_index_pos = 0;\n    long smalest_value_pos\
    \ = 0;\n    long smalest_index_neg = 0;\n    long smalest_value_neg = 0;\n   \
    \ long smalest_index_pos = 0;\n    long smalest_value_pos = 0;\n    long smalest_index_neg\
    \ = 0;\n    long smalest_value_neg = 0;\n    long smalest_index_pos = 0;\n   \
    \ long smalest_value_pos = 0;\n    long smalest_index_\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4, (long)2,\
    \ (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpcckv0hhl.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpcckv0hhl.cpp:33:10: error: redeclaration of \u2018long\
    \ int smalest_index_neg\u2019\n   33 |     long smalest_index_neg = 0;\n     \
    \ |          ^~~~~~~~~~~~~~~~~\n/tmp/tmpcckv0hhl.cpp:29:10: note: \u2018long int\
    \ smalest_index_neg\u2019 previously declared here\n   29 |     long smalest_index_neg\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~\n/tmp/tmpcckv0hhl.cpp:34:10: error:\
    \ redeclaration of \u2018long int smalest_value_neg\u2019\n   34 |     long smalest_value_neg\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~\n/tmp/tmpcckv0hhl.cpp:30:10: note:\
    \ \u2018long int smalest_value_neg\u2019 previously declared here\n   30 |   \
    \  long smalest_value_neg = 0;\n      |          ^~~~~~~~~~~~~~~~~\n/tmp/tmpcckv0hhl.cpp:35:10:\
    \ error: redeclaration of \u2018long int smalest_index_pos\u2019\n   35 |    \
    \ long smalest_index_pos = 0;\n      |          ^~~~~~~~~~~~~~~~~\n/tmp/tmpcckv0hhl.cpp:31:10:\
    \ note: \u2018long int smalest_index_pos\u2019 previously declared here\n   31\
    \ |     long smalest_index_pos = 0;\n      |          ^~~~~~~~~~~~~~~~~\n/tmp/tmpcckv0hhl.cpp:36:10:\
    \ error: redeclaration of \u2018long int smalest_value_pos\u2019\n   36 |    \
    \ long smalest_value_pos = 0;\n      |          ^~~~~~~~~~~~~~~~~\n/tmp/tmpcckv0hhl.cpp:32:10:\
    \ note: \u2018long int smalest_value_pos\u2019 previously declared here\n   32\
    \ |     long smalest_value_pos = 0;\n      |          ^~~~~~~~~~~~~~~~~\n/tmp/tmpcckv0hhl.cpp:37:10:\
    \ error: redeclaration of \u2018long int smalest_index_neg\u2019\n   37 |    \
    \ long smalest_index_neg = 0;\n      |          ^~~~~~~~~~~~~~~~~\n/tmp/tmpcckv0hhl.cpp:29:10:\
    \ note: \u2018long int smalest_index_neg\u2019 previously declared here\n   29\
    \ |     long smalest_index_neg = 0;\n      |          ^~~~~~~~~~~~~~~~~\n/tmp/tmpcckv0hhl.cpp:38:10:\
    \ error: redeclaration of \u2018long int smalest_value_neg\u2019\n   38 |    \
    \ long smalest_value_neg = 0;\n      |          ^~~~~~~~~~~~~~~~~\n/tmp/tmpcckv0hhl.cpp:30:10:\
    \ note: \u2018long int smalest_value_neg\u2019 previously declared here\n   30\
    \ |     long smalest_value_neg = 0;\n      |          ^~~~~~~~~~~~~~~~~\n/tmp/tmpcckv0hhl.cpp:39:10:\
    \ error: redeclarati"
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpb__mwrec: /tmp/tmpb__mwrec.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    result.push_back(smalest_value);\n    result.push_back(smalest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmph8wuhtzc: /tmp/tmph8wuhtzc.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085847
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    int smalest_index = 0;\n    for (int i = 1; i < arr.size(); i++) {\n    \
    \    if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n    \
    \        smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    } else {\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpmc3e6oq_: /tmp/tmpmc3e6oq_.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085847
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    result.push_back(smalest_value);\n    result.push_back(smalest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpgve2n5s0: /tmp/tmpgve2n5s0.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085847
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpb__mwrec: /tmp/tmpb__mwrec.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0, smalest_index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n     \
    \   if (arr[i] % 2 == 0) {\n            if (smalest_value == 0) {\n          \
    \      smalest_value = arr[i];\n                smalest_index = i;\n         \
    \   } else if (smalest_value < arr[i]) {\n                smalest_value = arr[i];\n\
    \                smalest_index = i;\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    if (smalest_value != 0) {\n        ans.push_back(smalest_value);\n\
    \        ans.push_back(smalest_index);\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp7l11qxu4: /tmp/tmp7l11qxu4.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085847
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpb__mwrec: /tmp/tmpb__mwrec.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = 0;\n\
    \    long smalest_index = 0;\n    long index = 0;\n    for (auto i : arr) {\n\
    \        if (i % 2 == 0) {\n            if (smalest_value == 0) {\n          \
    \      smalest_value = i;\n                smalest_index = index;\n          \
    \  } else if (smalest_value < i) {\n                smalest_value = i;\n     \
    \           smalest_index = index;\n            }\n            index++;\n    \
    \    }\n    }\n    if (smalest_value == 0) {\n        return {};\n    }\n    return\
    \ {smalest_value, smalest_index};\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp5ajwvaw8: /tmp/tmp5ajwvaw8.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085847
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long smallest_index = 0;\n    long smallest_value\
    \ = 0;\n    long index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n   \
    \     if (arr[i] % 2 == 0) {\n            if (smallest_value == 0) {\n       \
    \         smallest_value = arr[i];\n                smallest_index = i;\n    \
    \        } else if (arr[i] < smallest_value) {\n                smallest_value\
    \ = arr[i];\n                smallest_index = i;\n            }\n        }\n \
    \   }\n    if (smallest_value == 0) {\n        return {};\n    }\n    for (long\
    \ i = 0; i < arr.size(); i++) {\n        if (arr[i] == smallest_value) {\n   \
    \         index = i;\n        }\n    }\n    smalest_value = smallest_value;\n\
    \    smalest_index = index;\n    return { smalest_value, smalest_index };\n}\n\
    int main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpu7ibuc9p: /tmp/tmpu7ibuc9p.cpp:55: int main(): Assertion `candidate((std::vector<long>({(long)5,
    (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,
    (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085847
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpb__mwrec: /tmp/tmpb__mwrec.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long smalest_even_value = 0;\n    long\
    \ smalest_even_index = 0;\n    long smalest_even_value_pos = 0;\n    long smalest_even_index_pos\
    \ = 0;\n    long smalest_even_value_neg = 0;\n    long smalest_even_index_neg\
    \ = 0;\n    long smalest_even_value_zero = 0;\n    long smalest_even_index_zero\
    \ = 0;\n    long smalest_even_value_one = 0;\n    long smalest_even_index_one\
    \ = 0;\n    long smalest_even_value_two = 0;\n    long smalest_even_index_two\
    \ = 0;\n    long smalest_even_value_three = 0;\n    long smalest_even_index_three\
    \ = 0;\n    long smalest_even_value_four = 0;\n    long smalest_even_index_four\
    \ = 0;\n    long smalest_even_value_five = 0;\n    long smalest_even_index_five\
    \ = 0;\n    long smalest_even_value_six = 0;\n    long smalest_even_index_six\
    \ = 0;\n    long smalest_even_value_seven = 0;\n    long smalest_even_index_seven\
    \ = 0;\n    long smalest_even_value_eight = 0;\n    long smalest_even_index_eight\
    \ = 0;\n    long smalest_even_value_ten = 0;\n    long smalest_even_index_ten\
    \ = 0;\n    long smalest_even_value_eleven = 0;\n    long smalest_even_index_eleven\
    \ = 0;\n    long smalest_even_value_twelve = 0;\n    long smalest_even_index_twelve\
    \ = 0;\n    long smalest_even_value_thirteen = 0;\n    long smalest_even_index_thirteen\
    \ = 0;\n    long smalest_even_value_fourteen = 0;\n    long smalest_even_index_fourteen\
    \ = 0;\n    long smalest_even_value_fifteen = 0;\n    long smalest_even_index_fifteen\
    \ = 0;\n    long smalest_even_value_sixteen = 0;\n    long smalest_even_index_sixteen\
    \ = 0;\n    long smalest_even_value_seventeen = 0;\n    long smalest_even_index_seventeen\
    \ = 0;\n    long smalest_even_value_eighteen = 0;\n    long smalest_even_index_eighteen\
    \ = 0;\n    long smalest_even_value_nineteen = 0;\n    long smalest_even_index_nineteen\
    \ = 0;\n    long smalest_even_value_twenty = 0;\n    long smalest_even_index_twent\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp22olv9rj.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp22olv9rj.cpp:70:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   70 | }\n      | ^\n/tmp/tmp22olv9rj.cpp:70:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660085847
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = arr[0];\n    int smalest_index = 0;\n    for (int i = 1; i < arr.size(); i++)\
    \ {\n        if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n\
    \            smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpb7go77lv: /tmp/tmpb7go77lv.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085848
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> ans;\n\
    \    ans.push_back(smalest_value);\n    ans.push_back(smalest_index);\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpskcf2_p4: /tmp/tmpskcf2_p4.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smallest_value\
    \ = 0;\n    long smallest_index = 0;\n    long max_value = arr[0];\n    long max_index\
    \ = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] > max_value)\
    \ {\n            max_value = arr[i];\n            max_index = i;\n        }\n\
    \    }\n    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] == max_value)\
    \ {\n            if (arr[i] % 2 == 0) {\n                if (smallest_value ==\
    \ 0) {\n                    smallest_value = arr[i];\n                    smallest_index\
    \ = i;\n                } else {\n                    if (arr[i] < smallest_value)\
    \ {\n                        smallest_value = arr[i];\n                      \
    \  smallest_index = i;\n                    }\n                }\n           \
    \ }\n        }\n    }\n    std::vector<long> result;\n    if (smallest_value !=\
    \ 0) {\n        result.push_back(smallest_value);\n        result.push_back(smallest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpsy7y99vu: /tmp/tmpsy7y99vu.cpp:56: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085848
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // Your code here\n    long\
    \ smalest_value = arr[0];\n    int smalest_index = 0;\n    for (int i = 1; i <\
    \ arr.size(); i++) {\n        if (arr[i] < smalest_value) {\n            smalest_value\
    \ = arr[i];\n            smalest_index = i;\n        }\n    }\n    std::vector<long>\
    \ result;\n    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp0lrosatm: /tmp/tmp0lrosatm.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085848
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long min_value = arr[0];\n    long min_index\
    \ = 0;\n    for (int i = 1; i < arr.size(); i++) {\n        if (arr[i] < min_value)\
    \ {\n            min_value = arr[i];\n            min_index = i;\n        }\n\
    \    }\n    if (min_value % 2 == 0) {\n        smalest_value = min_value;\n  \
    \      smalest_index = min_index;\n    }\n    std::vector<long> ans;\n    ans.push_back(smalest_value);\n\
    \    ans.push_back(smalest_index);\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4, (long)2,\
    \ (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp4sifr4hf: /tmp/tmp4sifr4hf.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085848
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // write your code here\n\
    \    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_index_of_smalest_value\
    \ = 0;\n    long smalest_index_of_smalest_value2 = 0;\n    long smalest_index_of_smalest_value3\
    \ = 0;\n    long smalest_index_of_smalest_value4 = 0;\n    long smalest_index_of_smalest_value5\
    \ = 0;\n    long smalest_index_of_smalest_value6 = 0;\n    long smalest_index_of_smalest_value7\
    \ = 0;\n    long smalest_index_of_smalest_value8 = 0;\n    long smalest_index_of_smalest_value9\
    \ = 0;\n    long smalest_index_of_smalest_value10 = 0;\n    long smalest_index_of_smalest_value11\
    \ = 0;\n    long smalest_index_of_smalest_value12 = 0;\n    long smalest_index_of_smalest_value13\
    \ = 0;\n    long smalest_index_of_smalest_value14 = 0;\n    long smalest_index_of_smalest_value15\
    \ = 0;\n    long smalest_index_of_smalest_value16 = 0;\n    long smalest_index_of_smalest_value17\
    \ = 0;\n    long smalest_index_of_smalest_value18 = 0;\n    long smalest_index_of_smalest_value19\
    \ = 0;\n    long smalest_index_of_smalest_value20 = 0;\n    long smalest_index_of_smalest_value21\
    \ = 0;\n    long smalest_index_of_smalest_value22 = 0;\n    long smalest_index_of_smalest_value23\
    \ = 0;\n    long smalest_index_of_smalest_value24 = 0;\n    long smalest_index_of_smalest_value25\
    \ = 0;\n    long smalest_index_of_smalest_value26 = 0;\n    long smalest_index_of_smalest_value27\
    \ = 0;\n    long smalest_index_of_smalest_value28 = 0;\n    long smalest_index_of_smalest_value29\
    \ = 0;\n    long smalest_index_of_smalest_value30 = 0;\n    long smalest_index_of_smalest_value31\
    \ = 0;\n    long smalest_index_of_smalest_value32 = 0;\n    long smalest_index_of_smalest_value33\
    \ = 0;\n    long smalest_index_of_smalest_value34 = 0;\n    long smalest_index_of_smalest_value35\
    \ = 0;\n    long smalest_index_\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppqyhyng5.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmppqyhyng5.cpp:60:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   60 | }\n      | ^\n/tmp/tmppqyhyng5.cpp:60:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660085847
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // write your code here\n\
    \    long smalest_value=0;\n    long smalest_index=0;\n    long smallest_value=arr[0];\n\
    \    long smallest_index=0;\n    for(int i=0;i<arr.size();i++){\n        if(arr[i]<smallest_value){\n\
    \            smallest_value=arr[i];\n            smallest_index=i;\n        }\n\
    \    }\n    for(int i=0;i<arr.size();i++){\n        if(arr[i]==smallest_value){\n\
    \            smalest_value=arr[i];\n            smalest_index=i;\n        }\n\
    \    }\n    std::vector<long> res;\n    res.push_back(smalest_value);\n    res.push_back(smalest_index);\n\
    \    return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpb6mfevsx: /tmp/tmpb6mfevsx.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085848
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long index = 0;\n    for (long i = 1; i < arr.size();\
    \ i++) {\n        if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n\
    \            smalest_index = i;\n        }\n    }\n    if (smalest_value == 0)\
    \ {\n        return {};\n    }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n\
    \    result.push_back(smalest_index);\n    return result;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpjk_nfoe7: /tmp/tmpjk_nfoe7.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085848
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    } else {\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp1jm38vav: /tmp/tmp1jm38vav.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long smalest_even_value = 0;\n    for (long\
    \ i = 1; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (smalest_value == 0) {\n                smalest_value = arr[i];\n          \
    \      smalest_index = i;\n                smalest_even_value = arr[i] / 2;\n\
    \            } else if (smalest_value == arr[i]) {\n                smalest_index\
    \ = i;\n                smalest_even_value = arr[i] / 2;\n            } else if\
    \ (smalest_value < arr[i]) {\n                smalest_value = arr[i];\n      \
    \          smalest_index = i;\n                smalest_even_value = arr[i] / 2;\n\
    \            }\n        }\n    }\n    if (smalest_value == 0) {\n        return\
    \ {};\n    }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n\
    \    result.push_back(smalest_index);\n    return result;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpwp_i15jl: /tmp/tmpwp_i15jl.cpp:50: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085848
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    } else {\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp1jm38vav: /tmp/tmp1jm38vav.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // write your code here\n\
    \    long smalest_value = arr[0];\n    long smalest_index = 0;\n    for (long\
    \ i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (smalest_value < arr[i]) {\n                smalest_value = arr[i];\n      \
    \          smalest_index = i;\n            }\n        }\n    }\n    std::vector<long>\
    \ result;\n    if (smalest_value == 0) {\n        return result;\n    }\n    result.push_back(smalest_value);\n\
    \    result.push_back(smalest_index);\n    return result;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpdyi0ov7y: /tmp/tmpdyi0ov7y.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085848
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long index = 0;\n    for (long i = 0;\
    \ i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if (smalest_value\
    \ == 0) {\n                smalest_value = arr[i];\n                smalest_index\
    \ = i;\n            } else if (smalest_value < arr[i]) {\n                smalest_value\
    \ = arr[i];\n                smalest_index = i;\n            }\n        }\n  \
    \  }\n    if (smalest_value == 0) {\n        return {};\n    }\n    std::vector<long>\
    \ res;\n    res.push_back(smalest_value);\n    res.push_back(smalest_index);\n\
    \    return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmph380b0xz: /tmp/tmph380b0xz.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085848
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long smalest_index_value = 0;\n    long smalest_index_value_2\
    \ = 0;\n    long smalest_index_value_3 = 0;\n    long smalest_index_value_4 =\
    \ 0;\n    long smalest_index_value_5 = 0;\n    long smalest_index_value_6 = 0;\n\
    \    long smalest_index_value_7 = 0;\n    long smalest_index_value_8 = 0;\n  \
    \  long smalest_index_value_9 = 0;\n    long smalest_index_value_10 = 0;\n   \
    \ long smalest_index_value_11 = 0;\n    long smalest_index_value_12 = 0;\n   \
    \ long smalest_index_value_13 = 0;\n    long smalest_index_value_14 = 0;\n   \
    \ long smalest_index_value_15 = 0;\n    long smalest_index_value_16 = 0;\n   \
    \ long smalest_index_value_17 = 0;\n    long smalest_index_value_18 = 0;\n   \
    \ long smalest_index_value_19 = 0;\n    long smalest_index_value_20 = 0;\n   \
    \ long smalest_index_value_21 = 0;\n    long smalest_index_value_22 = 0;\n   \
    \ long smalest_index_value_23 = 0;\n    long smalest_index_value_24 = 0;\n   \
    \ long smalest_index_value_25 = 0;\n    long smalest_index_value_26 = 0;\n   \
    \ long smalest_index_value_27 = 0;\n    long smalest_index_value_28 = 0;\n   \
    \ long smalest_index_value_29 = 0;\n    long smalest_index_value_30 = 0;\n   \
    \ long smalest_index_value_31 = 0;\n    long smalest_index_value_32 = 0;\n   \
    \ long smalest_index_value_33 = 0;\n    long smalest_index_value_34 = 0;\n   \
    \ long smalest_index_value_35 = 0;\n    long smalest_index_value_36 = 0;\n   \
    \ long smalest_index_value_37 = 0;\n    long smalest_index_value_38 = 0;\n   \
    \ long smalest_index_value_39 = 0;\n    long smalest_index_value_40 = 0;\n   \
    \ long smalest_index_value_41 = 0;\n    long smalest_index_value_42 = 0;\n   \
    \ long smalest_index_value_43 = 0;\n    long smalest_index_value_44 = 0;\n   \
    \ long smalest_index_value_45 = 0;\n    long smalest_index_value_46 = 0;\n   \
    \ long smalest_index_value_47 = 0;\n    long smalest_index_value_48 = 0;\n   \
    \ long smalest_index_value_49 = 0;\n    long smalest_index_value_50 = 0;\n\n}\n\
    int main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpjz7dlkh1: /tmp/tmpjz7dlkh1.cpp:77: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085848
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // Your code here\n    long\
    \ smalest_value = 0;\n    long smalest_index = 0;\n    for (long i = 0; i < arr.size();\
    \ i++) {\n        if (arr[i] % 2 == 0) {\n            if (smalest_value == 0)\
    \ {\n                smalest_value = arr[i];\n                smalest_index =\
    \ i;\n            } else if (smalest_value < arr[i]) {\n                smalest_value\
    \ = arr[i];\n                smalest_index = i;\n            }\n        }\n  \
    \  }\n    std::vector<long> result;\n    if (smalest_value != 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpkjjlf25b: /tmp/tmpkjjlf25b.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085848
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = 0;\n\
    \    long smalest_index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n  \
    \      if (arr[i] % 2 == 0) {\n            if (smalest_value == 0) {\n       \
    \         smalest_value = arr[i];\n                smalest_index = i;\n      \
    \      } else if (smalest_value < arr[i]) {\n                smalest_value = arr[i];\n\
    \                smalest_index = i;\n            }\n        }\n    }\n    std::vector<long>\
    \ result;\n    if (smalest_value != 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpy98qjabg: /tmp/tmpy98qjabg.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085848
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> res;\n\
    \    res.push_back(smalest_value);\n    res.push_back(smalest_index);\n    return\
    \ res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp59rv0og3: /tmp/tmp59rv0og3.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // write your code here\n\
    \    long smallest_value = 0;\n    long smallest_index = 0;\n    long index =\
    \ 0;\n    long value = 0;\n    long temp = 0;\n    long count = 0;\n    long sum\
    \ = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long\
    \ temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n\
    \    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12\
    \ = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n   \
    \ long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19\
    \ = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n   \
    \ long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26\
    \ = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n   \
    \ long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33\
    \ = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n   \
    \ long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40\
    \ = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n   \
    \ long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47\
    \ = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n   \
    \ long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54\
    \ = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n   \
    \ long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61\
    \ = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n   \
    \ long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68\
    \ = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n   \
    \ long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75\
    \ = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n   \
    \ long temp79 = 0;\n    long temp80 = 0;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpql0f677w: /tmp/tmpql0f677w.cpp:111: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085848
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = 0;\n\
    \    long smalest_index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n  \
    \      if (arr[i] % 2 == 0) {\n            if (arr[i] < smalest_value) {\n   \
    \             smalest_value = arr[i];\n                smalest_index = i;\n  \
    \          }\n        }\n    }\n    if (smalest_value == 0) {\n        return\
    \ {};\n    }\n    std::vector<long> res;\n    res.push_back(smalest_value);\n\
    \    res.push_back(smalest_index);\n    return res;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4, (long)2,\
    \ (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmprcyjt8sg: /tmp/tmprcyjt8sg.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085848
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = 0;\n\
    \    long smalest_index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n  \
    \      if (arr[i] % 2 == 0) {\n            if (smalest_value < arr[i]) {\n   \
    \             smalest_value = arr[i];\n                smalest_index = i;\n  \
    \          }\n        }\n    }\n    if (smalest_value == 0) {\n        return\
    \ {};\n    }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n\
    \    result.push_back(smalest_index);\n    return result;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpxof65q1l: /tmp/tmpxof65q1l.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085848
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = arr[0];\n    long smallest_index = 0;\n    long smallest_even_value = 0;\n\
    \    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n\
    \            if (arr[i] < smallest_even_value) {\n                smallest_even_value\
    \ = arr[i];\n                smallest_index = i;\n            }\n        }\n \
    \   }\n    std::vector<long> result;\n    if (smallest_even_value) {\n       \
    \ result.push_back(smallest_even_value);\n        result.push_back(smallest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpurlvpo00: /tmp/tmpurlvpo00.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085849
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long smalest_index_of_smallest_value = 0;\n\
    \    long smallest_value = arr[0];\n    long smallest_index = 0;\n    long smallest_index_of_smallest_value\
    \ = 0;\n    long smallest_index_of_smallest_value2 = 0;\n    long smallest_index_of_smallest_value3\
    \ = 0;\n    long smallest_index_of_smallest_value4 = 0;\n    long smallest_index_of_smallest_value5\
    \ = 0;\n    long smallest_index_of_smallest_value6 = 0;\n    long smallest_index_of_smallest_value7\
    \ = 0;\n    long smallest_index_of_smallest_value8 = 0;\n    long smallest_index_of_smallest_value9\
    \ = 0;\n    long smallest_index_of_smallest_value10 = 0;\n    long smallest_index_of_smallest_value11\
    \ = 0;\n    long smallest_index_of_smallest_value12 = 0;\n    long smallest_index_of_smallest_value13\
    \ = 0;\n    long smallest_index_of_smallest_value14 = 0;\n    long smallest_index_of_smallest_value15\
    \ = 0;\n    long smallest_index_of_smallest_value16 = 0;\n    long smallest_index_of_smallest_value17\
    \ = 0;\n    long smallest_index_of_smallest_value18 = 0;\n    long smallest_index_of_smallest_value19\
    \ = 0;\n    long smallest_index_of_smallest_value20 = 0;\n    long smallest_index_of_smallest_value21\
    \ = 0;\n    long smallest_index_of_smallest_value22 = 0;\n    long smallest_index_of_smallest_value23\
    \ = 0;\n    long smallest_index_of_smallest_value24 = 0;\n    long smallest_index_of_smallest_value25\
    \ = 0;\n    long smallest_index_of_smallest_value26 = 0;\n    long smallest_index_of_smallest_value27\
    \ = 0;\n    long smallest_index_of_smallest_value28 = 0;\n    long smallest_index_of_smallest_value29\
    \ = 0;\n    long smallest_index_of_smallest_value30 = 0;\n    long smallest_index_of_smallest_value31\
    \ = 0;\n    long smallest_index_of_smallest_value32 = 0;\n    long smallest_index_of_smallest_value33\
    \ = 0;\n    long smallest_index_of_smallest_value34 = 0;\n    long smallest_index_of_smallest_value35\
    \ = 0;\n    long smallest_index_of_smallest_value36 = 0;\n    long smallest_index_of_smallest_value37\
    \ = 0;\n    long smallest_index_of_smallest_value38 = 0;\n    long smallest_index_of_smallest_value39\
    \ = 0;\n    long smallest_index_\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq7jqpic1.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpq7jqpic1.cpp:66:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   66 | }\n      | ^\n/tmp/tmpq7jqpic1.cpp:66:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660085849
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long smalest_even_value = 0;\n    long\
    \ smalest_even_index = 0;\n    long smalest_even_index_in_array = 0;\n    long\
    \ smalest_even_index_in_array_in_array = 0;\n    long smalest_even_index_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array = 0;\n\
    \    long smalest_even_index_in_array_in_array_in_array_in_array_in_array = 0;\n\
    \    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpofgmdgun.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpofgmdgun.cpp:40:10: error: redeclaration of \u2018long\
    \ int smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\u2019\
    \n   40 |     long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpofgmdgun.cpp:39:10: note: \u2018long int smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\u2019\
    \ previously declared here\n   39 |     long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpofgmdgun.cpp:44:1: error: expected initializer before \u2018}\u2019 token\n\
    \   44 | }\n      | ^\n/tmp/tmpofgmdgun.cpp:44:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660085849
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    } else {\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp1jm38vav: /tmp/tmp1jm38vav.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> ans;\n\
    \    ans.push_back(smalest_value);\n    ans.push_back(smalest_index);\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp7kr_huqk: /tmp/tmp7kr_huqk.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085850
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long smalest_even_value = 0;\n    long\
    \ smalest_even_index = 0;\n    long smalest_even_index_2 = 0;\n    long smalest_even_index_3\
    \ = 0;\n    long smalest_even_index_4 = 0;\n    long smalest_even_index_5 = 0;\n\
    \    long smalest_even_index_6 = 0;\n    long smalest_even_index_7 = 0;\n    long\
    \ smalest_even_index_8 = 0;\n    long smalest_even_index_9 = 0;\n    long smalest_even_index_10\
    \ = 0;\n    long smalest_even_index_11 = 0;\n    long smalest_even_index_12 =\
    \ 0;\n    long smalest_even_index_13 = 0;\n    long smalest_even_index_14 = 0;\n\
    \    long smalest_even_index_15 = 0;\n    long smalest_even_index_16 = 0;\n  \
    \  long smalest_even_index_17 = 0;\n    long smalest_even_index_18 = 0;\n    long\
    \ smalest_even_index_19 = 0;\n    long smalest_even_index_20 = 0;\n    long smalest_even_index_21\
    \ = 0;\n    long smalest_even_index_22 = 0;\n    long smalest_even_index_23 =\
    \ 0;\n    long smalest_even_index_24 = 0;\n    long smalest_even_index_25 = 0;\n\
    \    long smalest_even_index_26 = 0;\n    long smalest_even_index_27 = 0;\n  \
    \  long smalest_even_index_28 = 0;\n    long smalest_even_index_29 = 0;\n    long\
    \ smalest_even_index_30 = 0;\n    long smalest_even_index_31 = 0;\n    long smalest_even_index_32\
    \ = 0;\n    long smalest_even_index_33 = 0;\n    long smalest_even_index_34 =\
    \ 0;\n    long smalest_even_index_35 = 0;\n    long smalest_even_index_36 = 0;\n\
    \    long smalest_even_index_37 = 0;\n    long smalest_even_index_38 = 0;\n  \
    \  long smalest_even_index_39 = 0;\n    long smalest_even_index_40 = 0;\n    long\
    \ smalest_even_index_41 = 0;\n    long smalest_even_index_42 = 0;\n    long smalest_even_index_43\
    \ = 0;\n    long smalest_even_index_44 = 0;\n    long smalest_even_index_45 =\
    \ 0;\n    long smalest_even_index_46 = 0;\n    long smalest_even_index_47 = 0;\n\
    \    long smalest_even_index_48 = 0;\n    long smalest_even_index_49\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4gqpbc8y.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp4gqpbc8y.cpp:74:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   74 | }\n      | ^\n/tmp/tmp4gqpbc8y.cpp:74:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660085849
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    } else {\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp6xfda3xq: /tmp/tmp6xfda3xq.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085850
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long smalest_index_value = 0;\n    for\
    \ (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n      \
    \      if (smalest_value == 0) {\n                smalest_value = arr[i];\n  \
    \              smalest_index = i;\n                smalest_index_value = arr[i];\n\
    \            } else if (smalest_index_value > arr[i]) {\n                smalest_index_value\
    \ = arr[i];\n                smalest_index = i;\n            }\n        }\n  \
    \  }\n    std::vector<long> result;\n    if (smalest_value != 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpitjqt5ry: /tmp/tmpitjqt5ry.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085850
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0, smalest_index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n     \
    \   if (arr[i] % 2 == 0) {\n            if (smalest_value < arr[i]) {\n      \
    \          smalest_value = arr[i];\n                smalest_index = i;\n     \
    \       }\n        }\n    }\n    std::vector<long> result;\n    if (smalest_value\
    \ != 0) {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpg1v2vkg8: /tmp/tmpg1v2vkg8.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085850
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = arr[0];\n    int smalest_index = 0;\n    for (int i = 1; i < arr.size(); i++)\
    \ {\n        if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n\
    \            smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    result.push_back(smalest_value);\n    result.push_back(smalest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpxu9ese7d: /tmp/tmpxu9ese7d.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085850
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long index = 0;\n    long smallest_even_value\
    \ = 0;\n    long smallest_even_index = 0;\n    long even_value = 0;\n    long\
    \ even_index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i]\
    \ % 2 == 0) {\n            if (arr[i] < smallest_even_value) {\n             \
    \   smallest_even_value = arr[i];\n                smallest_even_index = i;\n\
    \            }\n            if (arr[i] == smallest_even_value) {\n           \
    \     even_value = arr[i];\n                even_index = i;\n            }\n \
    \       }\n    }\n    if (smallest_even_value == 0) {\n        return {};\n  \
    \  }\n    std::vector<long> result;\n    result.push_back(even_value);\n    result.push_back(even_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp50y0q4ll: /tmp/tmp50y0q4ll.cpp:50: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085850
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpb__mwrec: /tmp/tmpb__mwrec.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    } else {\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp6xfda3xq: /tmp/tmp6xfda3xq.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085850
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpb__mwrec: /tmp/tmpb__mwrec.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = 0;\n\
    \    long smalest_index = 0;\n    long smalest_index_of_smalest_value = 0;\n \
    \   long smalest_index_of_smalest_value2 = 0;\n    for (long i = 0; i < arr.size();\
    \ i++) {\n        if (arr[i] % 2 == 0) {\n            if (smalest_value == 0)\
    \ {\n                smalest_value = arr[i];\n                smalest_index =\
    \ i;\n                smalest_index_of_smalest_value = i;\n                smalest_index_of_smalest_value2\
    \ = i;\n            } else if (smalest_value == arr[i]) {\n                smalest_index_of_smalest_value\
    \ = i;\n                smalest_index_of_smalest_value2 = i;\n            } else\
    \ if (smalest_value < arr[i]) {\n                smalest_value = arr[i];\n   \
    \             smalest_index = i;\n                smalest_index_of_smalest_value\
    \ = i;\n                smalest_index_of_smalest_value2 = i;\n            }\n\
    \        }\n    }\n    if (smalest_value == 0) {\n        return {};\n    }\n\
    \    std::vector<long> res;\n    res.push_back(smalest_value);\n    res.push_back(smalest_index);\n\
    \    if (smalest_index_of_smalest_value == smalest_index_of_smalest_value2) {\n\
    \        res.push_back(smalest_index_of_smalest_value);\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpn0arxqmb: /tmp/tmpn0arxqmb.cpp:56: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085850
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long smallest_index = INT_MAX;\n    for (long\
    \ i = 0; i < arr.size(); i++) {\n        if (arr[i] < smallest_index) {\n    \
    \        smallest_index = arr[i];\n            smalest_value = arr[i];\n     \
    \       smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    result.push_back(smalest_value);\n    result.push_back(smalest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpbhec3kuz: /tmp/tmpbhec3kuz.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085850
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpb__mwrec: /tmp/tmpb__mwrec.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long smalest_even_value = 0;\n    long\
    \ smalest_even_index = 0;\n    long smalest_even_index_count = 0;\n    long smalest_even_index_count_max\
    \ = 0;\n    long smalest_even_index_count_min = 0;\n    long smalest_even_index_count_min_index\
    \ = 0;\n    long smalest_even_index_count_min_index2 = 0;\n    long smalest_even_index_count_min_index2_index\
    \ = 0;\n    long smalest_even_index_count_min_index2_index2 = 0;\n    long smalest_even_index_count_min_index2_index2_index\
    \ = 0;\n    long smalest_even_index_count_min_index2_index2_index2 = 0;\n    long\
    \ smalest_even_index_count_min_index2_index2_index2_index = 0;\n    long smalest_even_index_count_min_index2_index2_index2_index2\
    \ = 0;\n    long smalest_even_index_count_min_index2_index2_index2_index2 = 0;\n\
    \    long smalest_even_index_count_min_index2_index2_index2_index2 = 0;\n    long\
    \ smalest_even_index_count_min_index2_index2_index2_index2_index = 0;\n    long\
    \ smalest_even_index_count_min_index2_index2_index2_index2_index2 = 0;\n    long\
    \ smalest_even_index_count_min_index2_index2_index2_index2_index2 = 0;\n    long\
    \ smalest_even_index_count_min_index2_index2_index2_index2_index2 = 0;\n    long\
    \ smalest_even_index_count_min_index2_index2_index2_index2_index2 = 0;\n    long\
    \ smalest_even_index_count_min_index2_index2_index2_index2_index2 = 0;\n    long\
    \ smalest_even_index_count_min_index2_index2_index2_index2_index2 = 0;\n    long\
    \ smalest_even_index_count_min_index2_index2_index2_index2_index2 = 0;\n    long\
    \ smalest_even_index_count_min_index2_index2_index2_index2_index2 = 0;\n    long\
    \ smalest_even_index_count_min_index2_index2_index2_index2_index2 = 0;\n    long\
    \ smalest_even_index_count_min_index2_index2_index2_index2_index2 = 0;\n    long\
    \ smalest_even_index_count_min_index2_index2_index2_index2_index2 = 0;\n    long\
    \ smalest_even_index_count_min_index2_index2_index2_index2_index2 = 0;\n    long\
    \ smalest_even_index_count_min_index2_index2_index2_index2_index2 = 0;\n    long\
    \ smalest_even_index_\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp14nrtded.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp14nrtded.cpp:37:10: error: redeclaration of \u2018long\
    \ int smalest_even_index_count_min_index2_index2_index2_index2\u2019\n   37 |\
    \     long smalest_even_index_count_min_index2_index2_index2_index2 = 0;\n   \
    \   |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp14nrtded.cpp:36:10:\
    \ note: \u2018long int smalest_even_index_count_min_index2_index2_index2_index2\u2019\
    \ previously declared here\n   36 |     long smalest_even_index_count_min_index2_index2_index2_index2\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp14nrtded.cpp:38:10: error: redeclaration of \u2018long int smalest_even_index_count_min_index2_index2_index2_index2\u2019\
    \n   38 |     long smalest_even_index_count_min_index2_index2_index2_index2 =\
    \ 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp14nrtded.cpp:36:10: note: \u2018long int smalest_even_index_count_min_index2_index2_index2_index2\u2019\
    \ previously declared here\n   36 |     long smalest_even_index_count_min_index2_index2_index2_index2\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp14nrtded.cpp:41:10: error: redeclaration of \u2018long int smalest_even_index_count_min_index2_index2_index2_index2_index2\u2019\
    \n   41 |     long smalest_even_index_count_min_index2_index2_index2_index2_index2\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp14nrtded.cpp:40:10: note: \u2018long int smalest_even_index_count_min_index2_index2_index2_index2_index2\u2019\
    \ previously declared here\n   40 |     long smalest_even_index_count_min_index2_index2_index2_index2_index2\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp14nrtded.cpp:42:10: error: redeclaration of \u2018long int smalest_even_index_count_min_index2_index2_index2_index2_index2\u2019\
    \n   42 |     long smalest_even_index_count_min_index2_index2_index2_index2_index2\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660085850
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = 0;\n\
    \    long smalest_index = 0;\n    long index = 0;\n    long value = 0;\n    for\
    \ (auto i : arr) {\n        if (i % 2 == 0) {\n            if (value < smalest_value)\
    \ {\n                smalest_value = value;\n                smalest_index = index;\n\
    \            }\n            index = i;\n            value = i;\n        } else\
    \ {\n            if (value < smalest_value) {\n                smalest_value =\
    \ value;\n                smalest_index = index;\n            }\n        }\n \
    \   }\n    if (smalest_value == 0) {\n        return {};\n    }\n    return {smalest_value,\
    \ smalest_index};\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpb2ba0elf: /tmp/tmpb2ba0elf.cpp:47: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085850
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpb__mwrec: /tmp/tmpb__mwrec.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = arr[0];\n    long smalest_index = 0;\n    long smalest_even_value = 0;\n \
    \   long smalest_even_index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n\
    \        if (arr[i] % 2 == 0) {\n            if (smalest_even_value == 0) {\n\
    \                smalest_even_value = arr[i];\n                smalest_even_index\
    \ = i;\n            } else if (smalest_even_value < arr[i]) {\n              \
    \  smalest_even_value = arr[i];\n                smalest_even_index = i;\n   \
    \         }\n        } else {\n            if (smalest_value == 0) {\n       \
    \         smalest_value = arr[i];\n                smalest_index = i;\n      \
    \      } else if (smalest_value < arr[i]) {\n                smalest_value = arr[i];\n\
    \                smalest_index = i;\n            }\n        }\n    }\n    std::vector<long>\
    \ res;\n    res.push_back(smalest_value);\n    res.push_back(smalest_index);\n\
    \    return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpkzfym1bl: /tmp/tmpkzfym1bl.cpp:52: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085850
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    } else {\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp1jm38vav: /tmp/tmp1jm38vav.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long smalest_index_of_smalest_value = 0;\n \
    \   long smalest_index_of_smalest_value2 = 0;\n    long smalest_index_of_smalest_value3\
    \ = 0;\n    long smalest_index_of_smalest_value4 = 0;\n    long smalest_index_of_smalest_value5\
    \ = 0;\n    long smalest_index_of_smalest_value6 = 0;\n    long smalest_index_of_smalest_value7\
    \ = 0;\n    long smalest_index_of_smalest_value8 = 0;\n    long smalest_index_of_smalest_value9\
    \ = 0;\n    long smalest_index_of_smalest_value10 = 0;\n    long smalest_index_of_smalest_value11\
    \ = 0;\n    long smalest_index_of_smalest_value12 = 0;\n    long smalest_index_of_smalest_value13\
    \ = 0;\n    long smalest_index_of_smalest_value14 = 0;\n    long smalest_index_of_smalest_value15\
    \ = 0;\n    long smalest_index_of_smalest_value16 = 0;\n    long smalest_index_of_smalest_value17\
    \ = 0;\n    long smalest_index_of_smalest_value18 = 0;\n    long smalest_index_of_smalest_value19\
    \ = 0;\n    long smalest_index_of_smalest_value20 = 0;\n    long smalest_index_of_smalest_value21\
    \ = 0;\n    long smalest_index_of_smalest_value22 = 0;\n    long smalest_index_of_smalest_value23\
    \ = 0;\n    long smalest_index_of_smalest_value24 = 0;\n    long smalest_index_of_smalest_value25\
    \ = 0;\n    long smalest_index_of_smalest_value26 = 0;\n    long smalest_index_of_smalest_value27\
    \ = 0;\n    long smalest_index_of_smalest_value28 = 0;\n    long smalest_index_of_smalest_value29\
    \ = 0;\n    long smalest_index_of_smalest_value30 = 0;\n    long smalest_index_of_smalest_value31\
    \ = 0;\n    long smalest_index_of_smalest_value32 = 0;\n    long smalest_index_of_smalest_value33\
    \ = 0;\n    long smalest_index_of_smalest_value34 = 0;\n    long smalest_index_of_smalest_value35\
    \ = 0;\n    long smalest_index_of_smalest_\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppiudqyar.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmppiudqyar.cpp:59:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   59 | }\n      | ^\n/tmp/tmppiudqyar.cpp:59:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660085850
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smallest_value\
    \ = arr[0];\n    long smallest_index = 0;\n    for (int i = 1; i < arr.size();\
    \ i++) {\n        if (arr[i] < smallest_value) {\n            smallest_value =\
    \ arr[i];\n            smallest_index = i;\n        }\n    }\n    std::vector<long>\
    \ result;\n    result.push_back(smallest_value);\n    result.push_back(smallest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpw0i9hu3k: /tmp/tmpw0i9hu3k.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085850
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    int smalest_index = 0;\n    long smalest_even_value = 0;\n    int\
    \ smalest_even_index = 0;\n    long smalest_even_value_index = 0;\n    for (int\
    \ i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (smalest_value == 0) {\n                smalest_value = arr[i];\n          \
    \      smalest_index = i;\n                smalest_even_value = arr[i] % 2;\n\
    \                smalest_even_index = i;\n                smalest_even_value_index\
    \ = i;\n            } else if (smalest_value == arr[i]) {\n                smalest_even_value_index\
    \ = i;\n            } else if (smalest_value == arr[i] && smalest_even_value_index\
    \ == i) {\n                smalest_even_index = i;\n            }\n        }\n\
    \    }\n    if (smalest_value == 0 && arr.size() > 0) {\n        smalest_value\
    \ = arr[0];\n        smalest_index = arr.size() - 1;\n        smalest_even_value\
    \ = arr[0] % (arr.size() - 1);\n        smalest_even_index = arr.size() - 1;\n\
    \        smalest_even_value_index = arr.size() - 1;\n    }\n    std::vector<long>\
    \ result;\n    if (smalest_value == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n        result.push_back(smalest_even_value);\n\
    \        result.push_back(smalest_even_index);\n        result.push_back(smalest_even_value_index);\n\
    \        return result;\n    }\n    result.push_back(smalest_value);\n    result.push_back(smalest_index);\n\
    \    result.push_back(smalest_even_value);\n    result.push_back(smalest_even_index);\n\
    \    result.push_back(smalest_even_value_index);\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp6_5lydl6: /tmp/tmp6_5lydl6.cpp:67: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085850
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // Your code here\n    long\
    \ smallest_even_value = 0;\n    long smallest_index = 0;\n    long smallest_value\
    \ = 0;\n    long smallest_index2 = 0;\n    long smallest_value2 = 0;\n    long\
    \ smallest_index3 = 0;\n    long smallest_value3 = 0;\n    long smallest_index4\
    \ = 0;\n    long smallest_value4 = 0;\n    long smallest_index5 = 0;\n    long\
    \ smallest_value5 = 0;\n    long smallest_index6 = 0;\n    long smallest_value6\
    \ = 0;\n    long smallest_index7 = 0;\n    long smallest_value7 = 0;\n    long\
    \ smallest_index8 = 0;\n    long smallest_value8 = 0;\n    long smallest_index9\
    \ = 0;\n    long smallest_value9 = 0;\n    long smallest_index10 = 0;\n    long\
    \ smallest_value10 = 0;\n    long smallest_index11 = 0;\n    long smallest_value11\
    \ = 0;\n    long smallest_index12 = 0;\n    long smallest_value12 = 0;\n    long\
    \ smallest_index13 = 0;\n    long smallest_value13 = 0;\n    long smallest_index14\
    \ = 0;\n    long smallest_value14 = 0;\n    long smallest_index15 = 0;\n    long\
    \ smallest_value15 = 0;\n    long smallest_index16 = 0;\n    long smallest_value16\
    \ = 0;\n    long smallest_index17 = 0;\n    long smallest_value17 = 0;\n    long\
    \ smallest_index18 = 0;\n    long smallest_value18 = 0;\n    long smallest_index19\
    \ = 0;\n    long smallest_value19 = 0;\n    long smallest_index20 = 0;\n    long\
    \ smallest_value20 = 0;\n    long smallest_index21 = 0;\n    long smallest_value21\
    \ = 0;\n    long smallest_index22 = 0;\n    long smallest_value22 = 0;\n    long\
    \ smallest_index23 = 0;\n    long smallest_value23 = 0;\n    long smallest_index24\
    \ = 0;\n    long smallest_value24 = 0;\n    long smallest_index25 = 0;\n    long\
    \ smallest_value25 = 0;\n    long smallest_index26 = 0;\n    long smallest_value26\
    \ = 0;\n    long smallest_index27 = 0;\n    long smallest_value27 = 0;\n    long\
    \ smallest_index28 = 0;\n    long smallest_value28 = 0;\n    long smallest_index29\
    \ = 0;\n    long smallest_value29 = 0;\n    long smallest_index30 = 0;\n    long\
    \ smallest_value30 = 0;\n    long smallest_index31 = 0;\n    long smallest_value31\
    \ = 0;\n    long smallest_index32 = 0;\n    long smallest_value\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnke3n376.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpnke3n376.cpp:87:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   87 | }\n      | ^\n/tmp/tmpnke3n376.cpp:87:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660085850
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpb__mwrec: /tmp/tmpb__mwrec.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = INT_MIN;\n    long smalest_index = 0;\n    long smalest_index_value = INT_MIN;\n\
    \    long smalest_index_value = INT_MIN;\n    long smalest_index_value = INT_MIN;\n\
    \    long smalest_index_value = INT_MIN;\n    long smalest_index_value = INT_MIN;\n\
    \    long smalest_index_value = INT_MIN;\n    long smalest_index_value = INT_MIN;\n\
    \    long smalest_index_value = INT_MIN;\n    long smalest_index_value = INT_MIN;\n\
    \    long smalest_index_value = INT_MIN;\n    long smalest_index_value = INT_MIN;\n\
    \    long smalest_index_value = INT_MIN;\n    long smalest_index_value = INT_MIN;\n\
    \    long smalest_index_value = INT_MIN;\n    long smalest_index_value = INT_MIN;\n\
    \    long smalest_index_value = INT_MIN;\n    long smalest_index_value = INT_MIN;\n\
    \    long smalest_index_value = INT_MIN;\n    long smalest_index_value = INT_MIN;\n\
    \    long smalest_index_value = INT_MIN;\n    long smalest_index_value = INT_MIN;\n\
    \    long smalest_index_value = INT_MIN;\n    long smalest_index_value = INT_MIN;\n\
    \    long smalest_index_value = INT_MIN;\n    long smalest_index_value = INT_MIN;\n\
    \    long smalest_index_value = INT_MIN;\n    long smalest_index_value = INT_MIN;\n\
    \    long smalest_index_value = INT_MIN;\n    long smalest_index_value = INT_MIN;\n\
    \    long smalest_index_value = INT_MIN;\n    long smalest_index_value = INT_MIN;\n\
    \    long smalest_index_value = INT_MIN;\n    long smalest_index_value = INT_MIN;\n\
    \    long smalest_index_value = INT_MIN;\n    long smalest_index_value = INT_MIN;\n\
    \    long smalest_index_value = INT_MIN;\n    long smalest_index_value = INT_MIN;\n\
    \    long smalest_index_value = INT_MIN;\n    long smalest_index_value = INT_MIN;\n\
    \    long smalest_index_value = INT_MIN;\n    long smalest_index_value = INT_MIN;\n\
    \    long smalest_index_value = INT_MIN;\n    long smalest_index_value = INT_MIN;\n\
    \    long smalest_index_value = INT_MIN;\n    long smalest_index_\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4xfrdj0f.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp4xfrdj0f.cpp:25:10: error: redeclaration of \u2018long\
    \ int smalest_index_value\u2019\n   25 |     long smalest_index_value = INT_MIN;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~\n/tmp/tmp4xfrdj0f.cpp:24:10: note: \u2018\
    long int smalest_index_value\u2019 previously declared here\n   24 |     long\
    \ smalest_index_value = INT_MIN;\n      |          ^~~~~~~~~~~~~~~~~~~\n/tmp/tmp4xfrdj0f.cpp:26:10:\
    \ error: redeclaration of \u2018long int smalest_index_value\u2019\n   26 |  \
    \   long smalest_index_value = INT_MIN;\n      |          ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp4xfrdj0f.cpp:24:10: note: \u2018long int smalest_index_value\u2019 previously\
    \ declared here\n   24 |     long smalest_index_value = INT_MIN;\n      |    \
    \      ^~~~~~~~~~~~~~~~~~~\n/tmp/tmp4xfrdj0f.cpp:27:10: error: redeclaration of\
    \ \u2018long int smalest_index_value\u2019\n   27 |     long smalest_index_value\
    \ = INT_MIN;\n      |          ^~~~~~~~~~~~~~~~~~~\n/tmp/tmp4xfrdj0f.cpp:24:10:\
    \ note: \u2018long int smalest_index_value\u2019 previously declared here\n  \
    \ 24 |     long smalest_index_value = INT_MIN;\n      |          ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp4xfrdj0f.cpp:28:10: error: redeclaration of \u2018long int smalest_index_value\u2019\
    \n   28 |     long smalest_index_value = INT_MIN;\n      |          ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp4xfrdj0f.cpp:24:10: note: \u2018long int smalest_index_value\u2019 previously\
    \ declared here\n   24 |     long smalest_index_value = INT_MIN;\n      |    \
    \      ^~~~~~~~~~~~~~~~~~~\n/tmp/tmp4xfrdj0f.cpp:29:10: error: redeclaration of\
    \ \u2018long int smalest_index_value\u2019\n   29 |     long smalest_index_value\
    \ = INT_MIN;\n      |          ^~~~~~~~~~~~~~~~~~~\n/tmp/tmp4xfrdj0f.cpp:24:10:\
    \ note: \u2018long int smalest_index_value\u2019 previously declared here\n  \
    \ 24 |     long smalest_index_value = INT_MIN;\n      |          ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp4xfrdj0f.cpp:30:10: error: redeclaration of \u2018long int smalest_index_value\u2019\
    \n   30 |     long smalest_index_value = INT_MIN;\n      |          ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp4xfrdj0f.cpp:24:10: note: \u2018long int smalest_index_value\u2019 previously\
    \ d"
  stdout: ''
  timestamp: 1660085850
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long smalest_even_value = 0;\n    long\
    \ smalest_even_index = 0;\n    long smalest_even_value_counter = 0;\n    long\
    \ smalest_even_index_counter = 0;\n    long smalest_even_value_counter2 = 0;\n\
    \    long smalest_even_index_counter2 = 0;\n    long smalest_even_value_counter3\
    \ = 0;\n    long smalest_even_index_counter3 = 0;\n    long smalest_even_value_counter4\
    \ = 0;\n    long smalest_even_index_counter4 = 0;\n    long smalest_even_value_counter5\
    \ = 0;\n    long smalest_even_index_counter5 = 0;\n    long smalest_even_value_counter6\
    \ = 0;\n    long smalest_even_index_counter6 = 0;\n    long smalest_even_value_counter7\
    \ = 0;\n    long smalest_even_index_counter7 = 0;\n    long smalest_even_value_counter8\
    \ = 0;\n    long smalest_even_index_counter8 = 0;\n    long smalest_even_value_counter9\
    \ = 0;\n    long smalest_even_index_counter9 = 0;\n    long smalest_even_value_counter10\
    \ = 0;\n    long smalest_even_index_counter10 = 0;\n    long smalest_even_value_counter11\
    \ = 0;\n    long smalest_even_index_counter11 = 0;\n    long smalest_even_value_counter12\
    \ = 0;\n    long smalest_even_index_counter12 = 0;\n    long smalest_even_value_counter13\
    \ = 0;\n    long smalest_even_index_counter13 = 0;\n    long smalest_even_value_counter14\
    \ = 0;\n    long smalest_even_index_counter14 = 0;\n    long smalest_even_value_counter15\
    \ = 0;\n    long smalest_even_index_counter15 = 0;\n    long smalest_even_value_counter16\
    \ = 0;\n    long smalest_even_index_counter16 = 0;\n    long smalest_even_value_counter17\
    \ = 0;\n    long smalest_even_index_counter17 = 0;\n    long smalest_even_value_counter18\
    \ = 0;\n    long smalest_even_index_counter18 = 0;\n    long smalest_even_value_counter19\
    \ = 0;\n    long smalest_even_index_counter19 = 0;\n    long smalest_even_value_counter20\
    \ = 0;\n    long smalest_even_index_counter20 = 0;\n    long smalest_even_value_counter21\
    \ = 0;\n    long smalest_even_index_counter21 = 0;\n    long smalest_even_value_counter22\
    \ = 0;\n    long smalest_even_index_counter22 = 0;\n\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4, (long)2,\
    \ (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp4d599d2p: /tmp/tmp4d599d2p.cpp:74: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085850
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long smallest_index = 0;\n    long smallest_value\
    \ = 0;\n    long index = 0;\n    for (auto i : arr) {\n        if (i % 2 == 0)\
    \ {\n            if (smallest_value == 0) {\n                smallest_value =\
    \ i;\n                smallest_index = index;\n            } else if (smallest_value\
    \ < i) {\n                smallest_value = i;\n                smallest_index\
    \ = index;\n            }\n            index++;\n        } else {\n          \
    \  if (smallest_value == 0) {\n                smallest_value = i;\n         \
    \       smallest_index = index;\n            } else if (smallest_value < i) {\n\
    \                smallest_value = i;\n                smallest_index = index;\n\
    \            }\n            index++;\n        }\n    }\n    std::vector<long>\
    \ result;\n    if (smallest_value == 0) {\n        return result;\n    }\n   \
    \ result.push_back(smallest_value);\n    result.push_back(smallest_index);\n \
    \   return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp290nzcgn: /tmp/tmp290nzcgn.cpp:58: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085850
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // Your code here\n    long\
    \ smalest_value = arr[0];\n    long smalest_index = 0;\n    long index = 0;\n\
    \    for (int i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n\
    \            if (smalest_value == arr[i]) {\n                smalest_index = i;\n\
    \            }\n        }\n    }\n    std::vector<long> result;\n    if (smalest_index\
    \ != 0) {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmprzd59ary: /tmp/tmprzd59ary.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085850
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long smallest_even_value = arr[0];\n    long\
    \ smallest_even_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n    \
    \    if (arr[i] % 2 == 0) {\n            if (arr[i] < smallest_even_value) {\n\
    \                smallest_even_value = arr[i];\n                smallest_even_index\
    \ = i;\n            }\n        }\n        else if (arr[i] < smallest_even_value)\
    \ {\n            smallest_even_value = arr[i];\n            smallest_even_index\
    \ = i;\n        }\n        else if (arr[i] == smallest_even_value) {\n       \
    \     if (i < smallest_even_index) {\n                smallest_even_index = i;\n\
    \            }\n        }\n    }\n    std::vector<long> result;\n    if (smallest_even_value\
    \ == 0) {\n        return result;\n    }\n    result.push_back(smallest_even_value);\n\
    \    result.push_back(smallest_even_index);\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpnqvm32bj: /tmp/tmpnqvm32bj.cpp:53: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085852
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // write your code here\n\
    \    long smalest_value = 0, smalest_index = 0;\n    for (long i = 0; i < arr.size();\
    \ i++) {\n        if (arr[i] % 2 == 0) {\n            if (smalest_value == 0)\
    \ {\n                smalest_value = arr[i];\n                smalest_index =\
    \ i;\n            } else if (smalest_value < arr[i]) {\n                smalest_value\
    \ = arr[i];\n                smalest_index = i;\n            }\n        }\n  \
    \  }\n    if (smalest_value == 0) {\n        return {};\n    }\n    std::vector<long>\
    \ res;\n    res.push_back(smalest_value);\n    res.push_back(smalest_index);\n\
    \    return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpesuo2hfe: /tmp/tmpesuo2hfe.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085852
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long smallest_even_value = 0;\n    long\
    \ smallest_even_index = 0;\n    long smallest_even_index_in_array = 0;\n    long\
    \ smallest_even_index_in_array_in_array = 0;\n    long smallest_even_index_in_array_in_array_in_array\
    \ = 0;\n    long smallest_even_index_in_array_in_array_in_array_in_array = 0;\n\
    \    long smallest_even_index_in_array_in_array_in_array_in_array_in_array = 0;\n\
    \    long smallest_even_index_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smallest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smallest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smallest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smallest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smallest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smallest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smallest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smallest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smallest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smallest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smallest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smallest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smallest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpan2ho151.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpan2ho151.cpp:33:10: error: redeclaration of \u2018long\
    \ int smallest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array\u2019\
    \n   33 |     long smallest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpan2ho151.cpp:32:10: note: \u2018long int smallest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array\u2019\
    \ previously declared here\n   32 |     long smallest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpan2ho151.cpp:37:10: error: redeclaration of \u2018long int smallest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\u2019\
    \n   37 |     long smallest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpan2ho151.cpp:36:10: note: \u2018long int smallest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\u2019\
    \ previously declared here\n   36 |     long smallest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpan2ho151.cpp:45:1: error: expected initializer before \u2018}\u2019 token\n\
    \   45 | }\n      | ^\n/tmp/tmpan2ho151.cpp:45:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660085851
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // write your code here\n\
    \    long smalest_value = arr[0];\n    long smalest_index = 0;\n    for (long\
    \ i = 1; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (arr[i] < smalest_value) {\n                smalest_value = arr[i];\n      \
    \          smalest_index = i;\n            }\n        }\n    }\n    std::vector<long>\
    \ res;\n    res.push_back(smalest_value);\n    res.push_back(smalest_index);\n\
    \    return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpnim4zjtg: /tmp/tmpnim4zjtg.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085852
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smallest_value\
    \ = 0;\n    long smallest_index = 0;\n    long index = 0;\n    for (auto i : arr)\
    \ {\n        if (i % 2 == 0) {\n            if (smallest_value == 0) {\n     \
    \           smallest_value = i;\n                smallest_index = index;\n   \
    \         } else if (smallest_value < i) {\n                smallest_value = i;\n\
    \                smallest_index = index;\n            }\n            index++;\n\
    \        }\n    }\n    if (smallest_value == 0) {\n        return {};\n    }\n\
    \    std::vector<long> result;\n    result.push_back(smallest_value);\n    result.push_back(smallest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmps3f7jf5b: /tmp/tmps3f7jf5b.cpp:47: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085852
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long min_value = arr[0];\n    long min_index\
    \ = 0;\n    for (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < min_value)\
    \ {\n            min_value = arr[i];\n            min_index = i;\n        }\n\
    \        if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n\
    \            smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value == 0) {\n        return result;\n    }\n    result.push_back(smalest_value);\n\
    \    result.push_back(smalest_index);\n    return result;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpy_ky_gsb: /tmp/tmpy_ky_gsb.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085852
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smallest_value\
    \ = 0;\n    long smallest_index = 0;\n    long smallest_even_value = 0;\n    long\
    \ smallest_even_index = 0;\n    long index = 0;\n    long even_value = 0;\n  \
    \  long even_index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n       \
    \ if (arr[i] % 2 == 0) {\n            even_value = arr[i];\n            even_index\
    \ = i;\n        }\n        if (arr[i] < smallest_value) {\n            smallest_value\
    \ = arr[i];\n            smallest_index = i;\n        }\n        if (arr[i] <\
    \ smallest_even_value) {\n            smallest_even_value = arr[i];\n        \
    \    smallest_even_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smallest_even_index != smallest_index) {\n        result.push_back(smallest_even_value);\n\
    \        result.push_back(smallest_even_index);\n    } else {\n        result.push_back(smallest_value);\n\
    \        result.push_back(index);\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpwetgyx4x: /tmp/tmpwetgyx4x.cpp:55: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085852
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // write your code here\n\
    \    long smalest_value=0;\n    long smalest_index=0;\n    long smalest_index_value=0;\n\
    \    long smalest_index_value2=0;\n    long smalest_index_value3=0;\n    long\
    \ smalest_index_value4=0;\n    long smalest_index_value5=0;\n    long smalest_index_value6=0;\n\
    \    long smalest_index_value7=0;\n    long smalest_index_value8=0;\n    long\
    \ smalest_index_value9=0;\n    long smalest_index_value10=0;\n    long smalest_index_value11=0;\n\
    \    long smalest_index_value12=0;\n    long smalest_index_value13=0;\n    long\
    \ smalest_index_value14=0;\n    long smalest_index_value15=0;\n    long smalest_index_value16=0;\n\
    \    long smalest_index_value17=0;\n    long smalest_index_value18=0;\n    long\
    \ smalest_index_value19=0;\n    long smalest_index_value20=0;\n    long smalest_index_value21=0;\n\
    \    long smalest_index_value22=0;\n    long smalest_index_value23=0;\n    long\
    \ smalest_index_value24=0;\n    long smalest_index_value25=0;\n    long smalest_index_value26=0;\n\
    \    long smalest_index_value27=0;\n    long smalest_index_value28=0;\n    long\
    \ smalest_index_value29=0;\n    long smalest_index_value30=0;\n    long smalest_index_value31=0;\n\
    \    long smalest_index_value32=0;\n    long smalest_index_value33=0;\n    long\
    \ smalest_index_value34=0;\n    long smalest_index_value35=0;\n    long smalest_index_value36=0;\n\
    \    long smalest_index_value37=0;\n    long smalest_index_value38=0;\n    long\
    \ smalest_index_value39=0;\n    long smalest_index_value40=0;\n    long smalest_index_value41=0;\n\
    \    long smalest_index_value42=0;\n    long smalest_index_value43=0;\n    long\
    \ smalest_index_value44=0;\n    long smalest_index_value45=0;\n    long smalest_index_value46=0;\n\
    \    long smalest_index_value47=0;\n    long smalest_index_value48=0;\n    long\
    \ smalest_index_value49=0;\n    \n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpi008yqk2: /tmp/tmpi008yqk2.cpp:77: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085852
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = 0;\n\
    \    long smalest_index = 0;\n    long smallest_index = 0;\n    long smallest_value\
    \ = 0;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 ==\
    \ 0) {\n            if (smallest_value == 0) {\n                smallest_value\
    \ = arr[i];\n                smallest_index = i;\n            } else if (arr[i]\
    \ < smallest_value) {\n                smallest_value = arr[i];\n            \
    \    smallest_index = i;\n            }\n        }\n    }\n    std::vector<long>\
    \ res;\n    res.push_back(smallest_value);\n    res.push_back(smallest_index);\n\
    \    return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpt00kgiad: /tmp/tmpt00kgiad.cpp:45: int main(): Assertion `candidate((std::vector<long>()))
    == (std::vector<long>())'' failed.

    '
  stdout: ''
  timestamp: 1660085852
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long smalest_even_value = 0;\n    long\
    \ smalest_even_index = 0;\n    long smalest_even_index_2 = 0;\n    long smalest_even_index_3\
    \ = 0;\n    long smalest_even_index_4 = 0;\n    long smalest_even_index_5 = 0;\n\
    \    long smalest_even_index_6 = 0;\n    long smalest_even_index_7 = 0;\n    long\
    \ smalest_even_index_8 = 0;\n    long smalest_even_index_9 = 0;\n    long smalest_even_index_10\
    \ = 0;\n    long smalest_even_index_11 = 0;\n    long smalest_even_index_12 =\
    \ 0;\n    long smalest_even_index_13 = 0;\n    long smalest_even_index_14 = 0;\n\
    \    long smalest_even_index_15 = 0;\n    long smalest_even_index_16 = 0;\n  \
    \  long smalest_even_index_17 = 0;\n    long smalest_even_index_18 = 0;\n    long\
    \ smalest_even_index_19 = 0;\n    long smalest_even_index_20 = 0;\n    long smalest_even_index_21\
    \ = 0;\n    long smalest_even_index_22 = 0;\n    long smalest_even_index_23 =\
    \ 0;\n    long smalest_even_index_24 = 0;\n    long smalest_even_index_25 = 0;\n\
    \    long smalest_even_index_26 = 0;\n    long smalest_even_index_27 = 0;\n  \
    \  long smalest_even_index_28 = 0;\n    long smalest_even_index_29 = 0;\n    long\
    \ smalest_even_index_30 = 0;\n    long smalest_even_index_31 = 0;\n    long smalest_even_index_32\
    \ = 0;\n    long smalest_even_index_33 = 0;\n    long smalest_even_index_34 =\
    \ 0;\n    long smalest_even_index_35 = 0;\n    long smalest_even_index_36 = 0;\n\
    \    long smalest_even_index_37 = 0;\n    long smalest_even_index_38 = 0;\n  \
    \  long smalest_even_index_39 = 0;\n    long smalest_even_index_40 = 0;\n    long\
    \ smalest_even_index_41 = 1;\n    long smalest_even_index_42 = 1;\n    long smalest_even_index_43\
    \ = 1;\n    long smalest_even_index_44 = 1;\n    long smalest_even_index_45 =\
    \ 1;\n    long smalest_even_index_46 = 1;\n    long smalest_even_index_47 = 1;\n\
    \    long smalest_even_index_48 = 1;\n    long smalest_even\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpu3s8nwl0.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpu3s8nwl0.cpp:74:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   74 | }\n      | ^\n/tmp/tmpu3s8nwl0.cpp:74:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660085852
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long smallest_index = 0;\n    long smallest_value\
    \ = 0;\n    long index = 0;\n    long value = 0;\n    long even_value = 0;\n \
    \   long even_index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n      \
    \  value = arr[i];\n        even_value = value % 2;\n        if (value == 0) {\n\
    \            even_value = 0;\n        }\n        if (value == 1) {\n         \
    \   even_value = 1;\n        }\n        if (smalest_value == 0) {\n          \
    \  smalest_value = value;\n            smalest_index = i;\n        } else if (smalest_value\
    \ == 1) {\n            if (smalest_index > i) {\n                smalest_value\
    \ = value;\n                smalest_index = i;\n            }\n        } else\
    \ if (smalest_value == 2) {\n            if (smalest_index > i) {\n          \
    \      smalest_value = value;\n                smalest_index = i;\n          \
    \  }\n        } else if (smalest_value == 3) {\n            if (smalest_index\
    \ > i) {\n                smalest_value = value;\n                smalest_index\
    \ = i;\n            }\n        } else if (smalest_value == 4) {\n            if\
    \ (smalest_index > i) {\n                smalest_value = value;\n            \
    \    smalest_index = i;\n            }\n        } else if (smalest_value == 5)\
    \ {\n            if (smalest_index > i) {\n                smalest_value = value;\n\
    \                smalest_index = i;\n            }\n        } else if (smalest_value\
    \ == 6) {\n            if (smalest_index > i) {\n                smalest_value\
    \ = value;\n                smalest_index = i;\n            }\n        } else\
    \ if (smalest_value == 7) {\n            if (smalest_index > i) {\n          \
    \      smalest_value = value;\n                smalest_index = i;\n          \
    \  }\n        } else if (smalest_value == 8) {\n            if (smalest_index\
    \ > i) {\n                smalest_value = value;\n                smalest_index\
    \ = i;\n            }\n        } else if (smalest_value == 9) {\n            if\
    \ (smalest_index > i) {\n                smalest_value = value;\n            \
    \    smalest_index = i;\n            }\n        } else if (smalest_value == 10)\
    \ {\n            if (smalest_index > i) {\n                smalest_value = value;\n\
    \                smalest_index = i;\n            }\n        } else if (smalest_value\
    \ == 11) {\n            if (smalest_index > i) {\n                smalest_value\
    \ = value;\n                smalest_index = i;\n            }\n        } else\
    \ if (smalest_value == 12) {\n            if (smalest_index > i) {\n         \
    \       smalest_value = value;\n                smalest_index = i;\n         \
    \   }\n        } else if (smalest_value == 13) {\n            if (smalest_index\
    \ > i) {\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdm_okk9i.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpdm_okk9i.cpp:105:12: error: a function-definition is not\
    \ allowed here before \u2018{\u2019 token\n  105 | int main() {\n      |     \
    \       ^\n/tmp/tmpdm_okk9i.cpp:115:1: error: expected \u2018}\u2019 at end of\
    \ input\n  115 | }\n      | ^\n/tmp/tmpdm_okk9i.cpp:102:41: note: to match this\
    \ \u2018{\u2019\n  102 |         } else if (smalest_value == 13) {\n      |  \
    \                                       ^\n/tmp/tmpdm_okk9i.cpp:115:1: error:\
    \ expected \u2018}\u2019 at end of input\n  115 | }\n      | ^\n/tmp/tmpdm_okk9i.cpp:30:43:\
    \ note: to match this \u2018{\u2019\n   30 |     for (long i = 0; i < arr.size();\
    \ i++) {\n      |                                           ^\n/tmp/tmpdm_okk9i.cpp:115:1:\
    \ error: expected \u2018}\u2019 at end of input\n  115 | }\n      | ^\n/tmp/tmpdm_okk9i.cpp:20:48:\
    \ note: to match this \u2018{\u2019\n   20 | std::vector<long> pluck(std::vector<long>\
    \ arr) {\n      |                                                ^\n/tmp/tmpdm_okk9i.cpp:115:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  115 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660085852
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    result.push_back(smalest_value);\n    result.push_back(smalest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpgve2n5s0: /tmp/tmpgve2n5s0.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085847
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n  \
    \      if (arr[i] % 2 == 0) {\n            if (smalest_value < arr[i]) {\n   \
    \             smalest_value = arr[i];\n                smalest_index = i;\n  \
    \          }\n        }\n    }\n    std::vector<long> result;\n    if (smalest_value\
    \ == 0) {\n        return result;\n    }\n    result.push_back(smalest_value);\n\
    \    result.push_back(smalest_index);\n    return result;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmppml7yh53: /tmp/tmppml7yh53.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085852
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    int smalest_index = 0;\n    long smalest_even_value = 0;\n    int\
    \ smalest_even_index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n     \
    \   if (arr[i] % 2 == 0) {\n            if (smalest_value == 0) {\n          \
    \      smalest_value = arr[i];\n                smalest_index = i;\n         \
    \       smalest_even_value = arr[i] / 2;\n                smalest_even_index =\
    \ i;\n            } else if (arr[i] < smalest_value) {\n                smalest_value\
    \ = arr[i];\n                smalest_index = i;\n                smalest_even_value\
    \ = arr[i] / 2;\n                smalest_even_index = i;\n            }\n    \
    \    } else if (arr[i] % 2 != 0) {\n            if (smalest_value == 0) {\n  \
    \              smalest_value = arr[i];\n                smalest_index = i;\n \
    \               smalest_even_value = arr[i] / 2;\n                smalest_even_index\
    \ = i;\n            } else if (arr[i] < smalest_value) {\n                smalest_value\
    \ = arr[i];\n                smalest_index = i;\n                smalest_even_value\
    \ = arr[i] / 2;\n                smalest_even_index = i;\n            }\n    \
    \    }\n    }\n    if (smalest_value == 0) {\n        return {};\n    }\n    std::vector<long>\
    \ result;\n    result.push_back(smalest_value);\n    result.push_back(smalest_index);\n\
    \    result.push_back(smalest_even_value);\n    result.push_back(smalest_even_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpvugvs1pp: /tmp/tmpvugvs1pp.cpp:65: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085852
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long smallest_index = 0;\n    for (long\
    \ i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (smalest_value < arr[i]) {\n                smalest_value = arr[i];\n      \
    \          smalest_index = i;\n            }\n            if (smalest_value ==\
    \ arr[i]) {\n                smallest_index = i;\n            }\n        }\n \
    \   }\n    std::vector<long> result;\n    if (smalest_index != 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smallest_index);\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp32alb6nu: /tmp/tmp32alb6nu.cpp:45: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085852
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long smalest_index_value = 0;\n    for (long\
    \ i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (smalest_value == arr[i]) {\n                smalest_index = i;\n          \
    \      smalest_index_value = arr[i];\n            }\n            if (smalest_value\
    \ < arr[i]) {\n                smalest_value = arr[i];\n                smalest_index\
    \ = i;\n                smalest_index_value = arr[i];\n            }\n       \
    \ }\n    }\n    std::vector<long> ans;\n    ans.push_back(smalest_value);\n  \
    \  ans.push_back(smalest_index);\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp8gm10r9w: /tmp/tmp8gm10r9w.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085853
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpb__mwrec: /tmp/tmpb__mwrec.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long smalest_even_value = 0;\n    long\
    \ smalest_even_index = 0;\n    long smalest_even_index_count = 0;\n    long smalest_even_index_count_max\
    \ = 0;\n    long smalest_even_index_count_min = 0;\n    long smalest_even_index_count_min_index\
    \ = 0;\n    long smalest_even_index_count_min_index2 = 0;\n    long smalest_even_index_count_min_index3\
    \ = 0;\n    long smalest_even_index_count_min_index4 = 0;\n    long smalest_even_index_count_min_index5\
    \ = 0;\n    long smalest_even_index_count_min_index6 = 0;\n    long smalest_even_index_count_min_index7\
    \ = 0;\n    long smalest_even_index_count_min_index8 = 0;\n    long smalest_even_index_count_min_index9\
    \ = 0;\n    long smalest_even_index_count_min_index10 = 0;\n    long smalest_even_index_count_min_index11\
    \ = 0;\n    long smalest_even_index_count_min_index12 = 0;\n    long smalest_even_index_count_min_index13\
    \ = 0;\n    long smalest_even_index_count_min_index14 = 0;\n    long smalest_even_index_count_min_index15\
    \ = 0;\n    long smalest_even_index_count_min_index16 = 0;\n    long smalest_even_index_count_min_index17\
    \ = 0;\n    long smalest_even_index_count_min_index18 = 0;\n    long smalest_even_index_count_min_index19\
    \ = 0;\n    long smalest_even_index_count_min_index20 = 0;\n    long smalest_even_index_count_min_index21\
    \ = 0;\n    long smalest_even_index_count_min_index22 = 0;\n    long smalest_even_index_count_min_index23\
    \ = 0;\n    long smalest_even_index_count_min_index24 = 0;\n    long smalest_even_index_count_min_index25\
    \ = 0;\n    long smalest_even_index_count_min_index26 = 0;\n    long smalest_even_index_count_min_index27\
    \ = 0;\n    long smalest_even_index_count_min_index28 = 0;\n    long smalest_even_index_count_min_index29\
    \ = 0;\n    long smalest_even_index_count_min_index30 = 0;\n    long smalest_even_index_count_min_index31\
    \ = 0;\n    long smalest_even_index_count_min_index32 = 0;\n    long smalest_even_index_count_min_index33\
    \ = 0;\n    long smalest_even_index_count_min_index34 = 0;\n    long smalest_even\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxh4xllpf.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpxh4xllpf.cpp:64:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   64 | }\n      | ^\n/tmp/tmpxh4xllpf.cpp:64:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660085852
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = 0;\n\
    \    long smalest_index = 0;\n    long smallest_index = 0;\n    long smallest_value\
    \ = 0;\n    long index = 0;\n    for (auto i : arr) {\n        if (i % 2 == 0)\
    \ {\n            if (smallest_value == 0) {\n                smallest_value =\
    \ i;\n                smallest_index = index;\n            } else if (smallest_value\
    \ < i) {\n                smallest_value = i;\n                smallest_index\
    \ = index;\n            }\n            index++;\n        }\n    }\n    std::vector<long>\
    \ result;\n    if (smallest_value != 0) {\n        result.push_back(smallest_value);\n\
    \        result.push_back(smallest_index);\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpxgmmbqmn: /tmp/tmpxgmmbqmn.cpp:47: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085853
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = 0;\n\
    \    long smalest_index = 0;\n    long smalest_even_value = 0;\n    long smalest_even_index\
    \ = 0;\n    long smalest_even_index_count = 0;\n    long smalest_even_index_count_max\
    \ = 0;\n    long smalest_even_index_count_min = 0;\n    long smalest_even_index_count_sum\
    \ = 0;\n    long smalest_even_index_count_sum_max = 0;\n    long smalest_even_index_count_sum_min\
    \ = 0;\n    long smalest_even_index_count_sum_sum = 0;\n    long smalest_even_index_count_sum_sum_max\
    \ = 0;\n    long smalest_even_index_count_sum_sum_min = 0;\n    long smalest_even_index_count_sum_sum_sum\
    \ = 0;\n    long smalest_even_index_count_sum_sum_max = 0;\n    long smalest_even_index_count_sum_sum_min\
    \ = 0;\n    long smalest_even_index_count_sum_sum_sum = 0;\n    long smalest_even_index_count_sum_sum_max\
    \ = 0;\n    long smalest_even_index_count_sum_sum_min = 0;\n    long smalest_even_index_count_sum_sum_sum\
    \ = 0;\n    long smalest_even_index_count_sum_sum_max = 0;\n    long smalest_even_index_count_sum_sum_min\
    \ = 0;\n    long smalest_even_index_count_sum_sum_sum = 0;\n    long smalest_even_index_count_sum_sum_max\
    \ = 0;\n    long smalest_even_index_count_sum_sum_min = 0;\n    long smalest_even_index_count_sum_sum_sum\
    \ = 0;\n    long smalest_even_index_count_sum_sum_max = 0;\n    long smalest_even_index_count_sum_sum_min\
    \ = 0;\n    long smalest_even_index_count_sum_sum_sum = 0;\n    long smalest_even_index_count_sum_sum_max\
    \ = 0;\n    long smalest_even_index_count_sum_sum_min = 0;\n    long smalest_even_index_count_sum_sum_sum\
    \ = 0;\n    long smalest_even_index_count_sum_sum_max = 0;\n    long smalest_even_index_count_sum_sum_min\
    \ = 0;\n    long smalest_even_index_count_sum_sum_sum = 0;\n    long smalest_even_index_count_sum_sum_max\
    \ = 0;\n    long smalest_even_index_count_sum_sum_min = 0;\n    long smalest_even_index_count_sum_sum_sum\
    \ = 0;\n    long smalest_even_index_count_sum_sum_max = 0;\n    long smalest_even_index_count_sum_sum_min\
    \ = 0;\n    long smalest_even_index_count_sum_sum_sum = 0;\n    long smalest_even_index_count_sum_sum_\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5pb0lq0e.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp5pb0lq0e.cpp:35:10: error: redeclaration of \u2018long\
    \ int smalest_even_index_count_sum_sum_max\u2019\n   35 |     long smalest_even_index_count_sum_sum_max\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp5pb0lq0e.cpp:32:10:\
    \ note: \u2018long int smalest_even_index_count_sum_sum_max\u2019 previously declared\
    \ here\n   32 |     long smalest_even_index_count_sum_sum_max = 0;\n      |  \
    \        ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp5pb0lq0e.cpp:36:10: error:\
    \ redeclaration of \u2018long int smalest_even_index_count_sum_sum_min\u2019\n\
    \   36 |     long smalest_even_index_count_sum_sum_min = 0;\n      |         \
    \ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp5pb0lq0e.cpp:33:10: note: \u2018\
    long int smalest_even_index_count_sum_sum_min\u2019 previously declared here\n\
    \   33 |     long smalest_even_index_count_sum_sum_min = 0;\n      |         \
    \ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp5pb0lq0e.cpp:37:10: error: redeclaration\
    \ of \u2018long int smalest_even_index_count_sum_sum_sum\u2019\n   37 |     long\
    \ smalest_even_index_count_sum_sum_sum = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5pb0lq0e.cpp:34:10: note: \u2018long int smalest_even_index_count_sum_sum_sum\u2019\
    \ previously declared here\n   34 |     long smalest_even_index_count_sum_sum_sum\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp5pb0lq0e.cpp:38:10:\
    \ error: redeclaration of \u2018long int smalest_even_index_count_sum_sum_max\u2019\
    \n   38 |     long smalest_even_index_count_sum_sum_max = 0;\n      |        \
    \  ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp5pb0lq0e.cpp:32:10: note: \u2018\
    long int smalest_even_index_count_sum_sum_max\u2019 previously declared here\n\
    \   32 |     long smalest_even_index_count_sum_sum_max = 0;\n      |         \
    \ ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmp5pb0lq0e.cpp:39:10: error: redeclaration\
    \ of \u2018long int smalest_even_index_count_sum_sum_min\u2019\n   39 |     long\
    \ smalest_even_index_count_sum_sum_min = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5pb0lq0"
  stdout: ''
  timestamp: 1660085852
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long smallest_index = 0;\n    long smallest_value\
    \ = 0;\n    long index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n   \
    \     if (arr[i] % 2 == 0) {\n            if (arr[i] < smallest_value) {\n   \
    \             smallest_value = arr[i];\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    smalest_value = smallest_value;\n    smalest_index\
    \ = smallest_index;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i]\
    \ % 2 == 0) {\n            if (arr[i] < smalest_value) {\n                smalest_value\
    \ = arr[i];\n                smalest_index = i;\n            }\n        }\n  \
    \  }\n    std::vector<long> res;\n    res.push_back(smalest_value);\n    res.push_back(smalest_index);\n\
    \    return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpafewam1b: /tmp/tmpafewam1b.cpp:52: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085853
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long smallest_index = 0;\n    for (long i =\
    \ 1; i < arr.size(); i++) {\n        if (arr[i] < arr[0]) {\n            smallest_index\
    \ = i;\n            smalest_value = arr[i];\n        } else if (arr[i] == arr[0])\
    \ {\n            if (arr[i] < smalest_value) {\n                smalest_value\
    \ = arr[i];\n                smalest_index = i;\n            }\n        }\n  \
    \  }\n    std::vector<long> ans;\n    if (smalest_index != 0) {\n        ans.push_back(smalest_value);\n\
    \        ans.push_back(smalest_index);\n    } else {\n        ans.push_back(smalest_value);\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpd95hfrfq: /tmp/tmpd95hfrfq.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085853
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = 0;\n\
    \    long smalest_index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n  \
    \      if (arr[i] % 2 == 0) {\n            if (smalest_value < arr[i]) {\n   \
    \             smalest_value = arr[i];\n                smalest_index = i;\n  \
    \          }\n        }\n    }\n    std::vector<long> ans;\n    if (smalest_value\
    \ != 0) {\n        ans.push_back(smalest_value);\n        ans.push_back(smalest_index);\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp_p2hu25o: /tmp/tmp_p2hu25o.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085853
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    for (long i = 0; i < arr.size(); i++)\
    \ {\n        if (arr[i] % 2 == 0) {\n            if (smalest_value < arr[i]) {\n\
    \                smalest_value = arr[i];\n                smalest_index = i;\n\
    \            }\n        }\n    }\n    std::vector<long> result;\n    if (smalest_value\
    \ != 0) {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp5417_v8t: /tmp/tmp5417_v8t.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085853
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long smalest_index2 = 0;\n    long smalest_index3\
    \ = 0;\n    long smalest_index4 = 0;\n    long smalest_index5 = 0;\n    long smalest_index6\
    \ = 0;\n    long smalest_index7 = 0;\n    long smalest_index8 = 0;\n    long smalest_index9\
    \ = 0;\n    long smalest_index10 = 0;\n    long smalest_index11 = 0;\n    long\
    \ smalest_index12 = 0;\n    long smalest_index13 = 0;\n    long smalest_index14\
    \ = 0;\n    long smalest_index15 = 0;\n    long smalest_index16 = 0;\n    long\
    \ smalest_index17 = 0;\n    long smalest_index18 = 0;\n    long smalest_index19\
    \ = 0;\n    long smalest_index20 = 0;\n    long smalest_index21 = 0;\n    long\
    \ smalest_index22 = 0;\n    long smalest_index23 = 0;\n    long smalest_index24\
    \ = 0;\n    long smalest_index25 = 0;\n    long smalest_index26 = 0;\n    long\
    \ smalest_index27 = 0;\n    long smalest_index28 = 0;\n    long smalest_index29\
    \ = 0;\n    long smalest_index30 = 0;\n    long smalest_index31 = 0;\n    long\
    \ smalest_index32 = 0;\n    long smalest_index33 = 0;\n    long smalest_index34\
    \ = 0;\n    long smalest_index35 = 0;\n    long smalest_index36 = 0;\n    long\
    \ smalest_index37 = 0;\n    long smalest_index38 = 0;\n    long smalest_index39\
    \ = 0;\n    long smalest_index40 = 0;\n    long smalest_index41 = 0;\n    long\
    \ smalest_index42 = 0;\n    long smalest_index43 = 0;\n    long smalest_index44\
    \ = 0;\n    long smalest_index45 = 0;\n    long smalest_index46 = 0;\n    long\
    \ smalest_index47 = 0;\n    long smalest_index48 = 0;\n    long smalest_index49\
    \ = 0;\n    long smalest_index50 = 0;\n    long smalest_index51 = 0;\n    long\
    \ smalest_index52 = 0;\n    long smalest_index53 = 0;\n    long smalest_index54\
    \ = 0;\n    long smalest_index55 = 0;\n    long smalest_index56 = 0;\n    \n}\n\
    int main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpuhuqea8r: /tmp/tmpuhuqea8r.cpp:83: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085852
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // Your code here\n    long\
    \ smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_even_value\
    \ = 0;\n    long smalest_even_index = 0;\n    long smalest_even_index_count =\
    \ 0;\n    long smalest_even_index_count_index = 0;\n    long smalest_even_index_count_value\
    \ = 0;\n    long smalest_even_index_count_index2 = 0;\n    long smalest_even_index_count_value2\
    \ = 0;\n    long smalest_even_index_count_index3 = 0;\n    long smalest_even_index_count_value3\
    \ = 0;\n    long smalest_even_index_count_index4 = 0;\n    long smalest_even_index_count_value4\
    \ = 0;\n    long smalest_even_index_count_index5 = 0;\n    long smalest_even_index_count_value5\
    \ = 0;\n    long smalest_even_index_count_index6 = 0;\n    long smalest_even_index_count_value6\
    \ = 0;\n    long smalest_even_index_count_index7 = 0;\n    long smalest_even_index_count_value7\
    \ = 0;\n    long smalest_even_index_count_index8 = 0;\n    long smalest_even_index_count_value8\
    \ = 0;\n    long smalest_even_index_count_index9 = 0;\n    long smalest_even_index_count_value9\
    \ = 0;\n    long smalest_even_index_count_index10 = 0;\n    long smalest_even_index_count_value10\
    \ = 0;\n    long smalest_even_index_count_index11 = 0;\n    long smalest_even_index_count_value11\
    \ = 0;\n    long smalest_even_index_count_index12 = 0;\n    long smalest_even_index_count_value12\
    \ = 0;\n    long smalest_even_index_count_index13 = 0;\n    long smalest_even_index_count_value13\
    \ = 0;\n    long smalest_even_index_count_index14 = 0;\n    long smalest_even_index_count_value14\
    \ = 0;\n    long smalest_even_index_count_index15 = 0;\n    long smalest_even_index_count_value15\
    \ = 0;\n    long smalest_even_index_count_index16 = 0;\n    long smalest_even_index_count_value16\
    \ = 0;\n    long smalest_even_index_count_index17 = 0;\n    long smalest_even_index_count_value17\
    \ = 0;\n    long smalest_even_index_count_index18 = 0;\n    long smalest_even_index_count_value18\
    \ = 0;\n    long smalest_even_index_count_index19 = 0;\n    long smalest_even_index_count_value19\
    \ = 0;\n    long smalest_even_index_count_index20 = 0;\n    long smalest_even\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7xeqj2vq.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp7xeqj2vq.cpp:67:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   67 | }\n      | ^\n/tmp/tmp7xeqj2vq.cpp:67:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660085853
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value=0;\n\
    \    long smalest_index=0;\n    long smallest_value=0;\n    long smallest_index=0;\n\
    \    long max_value=0;\n    long max_index=0;\n    long temp=0;\n    long temp2=0;\n\
    \    long temp3=0;\n    long temp4=0;\n    long temp5=0;\n    long temp6=0;\n\
    \    long temp7=0;\n    long temp8=0;\n    long temp9=0;\n    long temp10=0;\n\
    \    long temp11=0;\n    long temp12=0;\n    long temp13=0;\n    long temp14=0;\n\
    \    long temp15=0;\n    long temp16=0;\n    long temp17=0;\n    long temp18=0;\n\
    \    long temp19=0;\n    long temp20=0;\n    long temp21=0;\n    long temp22=0;\n\
    \    long temp23=0;\n    long temp24=0;\n    long temp25=0;\n    long temp26=0;\n\
    \    long temp27=0;\n    long temp28=0;\n    long temp29=0;\n    long temp30=0;\n\
    \    long temp31=0;\n    long temp32=0;\n    long temp33=0;\n    long temp34=0;\n\
    \    long temp35=0;\n    long temp36=0;\n    long temp37=0;\n    long temp38=0;\n\
    \    long temp39=0;\n    long temp40=0;\n    long temp41=0;\n    long temp42=0;\n\
    \    long temp43=0;\n    long temp44=0;\n    long temp45=0;\n    long temp46=0;\n\
    \    long temp47=0;\n    long temp48=0;\n    long temp49=0;\n    long temp50=0;\n\
    \    long temp51=0;\n    long temp52=0;\n    long temp53=0;\n    long temp54=0;\n\
    \    long temp55=0;\n    long temp56=0;\n    long temp57=0;\n    long temp58=0;\n\
    \    long temp59=0;\n    long temp60=0;\n    long temp61=0;\n    long temp62=0;\n\
    \    long temp63=0;\n    long temp64=0;\n    long temp65=0;\n    long temp66=0;\n\
    \    long temp67=0;\n    long temp68=0;\n    long temp69=0;\n    long temp70=0;\n\
    \    long temp71=0;\n    long temp72=0;\n    long temp73=0;\n    long temp74=0;\n\
    \    long temp75=0;\n    long temp76=0;\n    long temp77=0;\n    long \n}\nint\
    \ main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppdfus7v6.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmppdfus7v6.cpp:106:1: error: expected unqualified-id before\
    \ \u2018}\u2019 token\n  106 | }\n      | ^\n/tmp/tmppdfus7v6.cpp:106:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660085854
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = 0;\n\
    \    long smalest_index = 0;\n    long smalest_even_value = 0;\n    long smalest_even_index\
    \ = 0;\n    long smalest_even_index_in_array = 0;\n    long smalest_even_index_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array = 0;\n    long\
    \ smalest_even_index_in_array_in_array_in_array_in_array = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n    long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq8j7yr9a.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpq8j7yr9a.cpp:36:10: error: redeclaration of \u2018long\
    \ int smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\u2019\
    \n   36 |     long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpq8j7yr9a.cpp:35:10: note: \u2018long int smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\u2019\
    \ previously declared here\n   35 |     long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpq8j7yr9a.cpp:40:10: error: redeclaration of \u2018long int smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\u2019\
    \n   40 |     long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpq8j7yr9a.cpp:39:10: note: \u2018long int smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\u2019\
    \ previously declared here\n   39 |     long smalest_even_index_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array_in_array\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~"
  stdout: ''
  timestamp: 1660085854
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = 0;\n\
    \    long smalest_index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n  \
    \      if (arr[i] % 2 == 0) {\n            if (smalest_value == 0) {\n       \
    \         smalest_value = arr[i];\n                smalest_index = i;\n      \
    \      } else if (smalest_value < arr[i]) {\n                smalest_value = arr[i];\n\
    \                smalest_index = i;\n            }\n        }\n    }\n    std::vector<long>\
    \ result;\n    if (smalest_value != 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpy98qjabg: /tmp/tmpy98qjabg.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085848
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // write your code here\n\
    \    long smalest_value = arr[0];\n    long smalest_index = 0;\n    for (long\
    \ i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (smalest_value < arr[i]) {\n                smalest_value = arr[i];\n      \
    \          smalest_index = i;\n            }\n        }\n    }\n    std::vector<long>\
    \ res;\n    res.push_back(smalest_value);\n    res.push_back(smalest_index);\n\
    \    return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp9431fmb5: /tmp/tmp9431fmb5.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085854
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smallest_value\
    \ = arr[0];\n    long smallest_index = 0;\n    long smallest_even_value = 0;\n\
    \    long smallest_even_count = 0;\n    for (long i = 0; i < arr.size(); i++)\
    \ {\n        if (arr[i] % 2 == 0) {\n            smallest_even_count++;\n    \
    \        if (smallest_even_count == smallest_even_value && smallest_even_count\
    \ > 1) {\n                smallest_even_value = smallest_even_count;\n       \
    \         smallest_index = i;\n            }\n        }\n    }\n    std::vector<long>\
    \ result;\n    if (smallest_even_count == 1) {\n        result.push_back(smallest_even_value);\n\
    \        result.push_back(smallest_index);\n    } else {\n        result.push_back(smallest_even_value);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpbgzlstvl: /tmp/tmpbgzlstvl.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085854
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> res;\n\
    \    res.push_back(smalest_value);\n    res.push_back(smalest_index);\n    return\
    \ res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp59rv0og3: /tmp/tmp59rv0og3.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    int smallest_index = 0;\n    for (int i = 0; i < arr.size(); i++)\
    \ {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < smalest_value) {\n\
    \                smalest_value = arr[i];\n                smallest_index = i;\n\
    \            }\n        }\n    }\n    std::vector<long> result;\n    if (smalest_value\
    \ == 0) {\n        return result;\n    }\n    result.push_back(smalest_value);\n\
    \    result.push_back(smallest_index);\n    return result;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp514wivri: /tmp/tmp514wivri.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085854
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = arr[0];\n    long smalest_index = 0;\n    long smallest_index = 0;\n    long\
    \ smallest_value = 0;\n    for (int i = 0; i < arr.size(); i++) {\n        if\
    \ (arr[i] < smallest_value) {\n            smallest_value = arr[i];\n        \
    \    smallest_index = i;\n        }\n        if (arr[i] == smallest_value) {\n\
    \            if (arr[i] < smalest_value) {\n                smalest_value = arr[i];\n\
    \                smalest_index = i;\n            }\n        }\n    }\n    std::vector<long>\
    \ result;\n    result.push_back(smalest_value);\n    result.push_back(smalest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpo46_g8m9: /tmp/tmpo46_g8m9.cpp:45: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085854
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    } else {\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp1jm38vav: /tmp/tmp1jm38vav.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = 0;\n\
    \    long smalest_index = 0;\n    long smalest_index_value = 0;\n    for (auto\
    \ i : arr) {\n        if (i % 2 == 0) {\n            if (smalest_value == 0) {\n\
    \                smalest_value = i;\n                smalest_index = i;\n    \
    \            smalest_index_value = i;\n            } else if (smalest_index_value\
    \ < i) {\n                smalest_value = i;\n                smalest_index =\
    \ i;\n                smalest_index_value = i;\n            } else if (smalest_index_value\
    \ == i) {\n                smalest_index_value = i;\n            }\n        }\n\
    \    }\n    if (smalest_value == 0) {\n        return {};\n    }\n    std::vector<long>\
    \ result;\n    result.push_back(smalest_value);\n    result.push_back(smalest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpydci9dqq: /tmp/tmpydci9dqq.cpp:49: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085854
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // write your code here\n\
    \    long smalest_value = 0;\n    long smalest_index = 0;\n    long smallest_index\
    \ = 0;\n    long smallest_value = 0;\n    long index = 0;\n    for (auto i : arr)\
    \ {\n        if (i % 2 == 0) {\n            if (smallest_value == 0) {\n     \
    \           smallest_value = i;\n                smallest_index = index;\n   \
    \         } else if (smallest_value < i) {\n                smallest_value = i;\n\
    \                smallest_index = index;\n            }\n            index++;\n\
    \        }\n    }\n    if (smallest_value == 0) {\n        return {};\n    }\n\
    \    std::vector<long> result;\n    result.push_back(smallest_value);\n    result.push_back(smallest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp253_txno: /tmp/tmp253_txno.cpp:49: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085855
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = 0;\n\
    \    long smalest_index = 0;\n    long smalest_index2 = 0;\n    for (long i =\
    \ 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if (smalest_value\
    \ == 0) {\n                smalest_value = arr[i];\n                smalest_index\
    \ = i;\n            } else if (smalest_value < arr[i]) {\n                smalest_value\
    \ = arr[i];\n                smalest_index = i;\n            }\n        }\n  \
    \  }\n    if (smalest_value == 0) {\n        return {};\n    }\n    std::vector<long>\
    \ ans;\n    ans.push_back(smalest_value);\n    ans.push_back(smalest_index);\n\
    \    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n\
    \            if (smalest_value == 0) {\n                smalest_value = arr[i];\n\
    \                smalest_index = i;\n            } else if (smalest_value < arr[i])\
    \ {\n                smalest_value = arr[i];\n                smalest_index =\
    \ i;\n            }\n        }\n    }\n    if (smalest_value == 0) {\n       \
    \ return {};\n    }\n    ans.push_back(smalest_value);\n    ans.push_back(smalest_index);\n\
    \    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpnqk1rdmy: /tmp/tmpnqk1rdmy.cpp:61: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085855
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = 0;\n\
    \    long smalest_index = 0;\n    long index = 0;\n    for (auto i : arr) {\n\
    \        if (i % 2 == 0) {\n            if (smalest_value == 0) {\n          \
    \      smalest_value = i;\n                smalest_index = index;\n          \
    \  } else if (smalest_value < i) {\n                smalest_value = i;\n     \
    \           smalest_index = index;\n            }\n            index++;\n    \
    \    }\n    }\n    if (smalest_value == 0) {\n        return {};\n    }\n    std::vector<long>\
    \ ans;\n    ans.push_back(smalest_value);\n    ans.push_back(smalest_index);\n\
    \    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpceg8vy1o: /tmp/tmpceg8vy1o.cpp:46: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085855
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value=0;\n\
    \    long smalest_index=0;\n    long smalest_even_value=0;\n    long smalest_even_node=0;\n\
    \    long smalest_even_node_index=0;\n    long smalest_even_node_even_value=0;\n\
    \    long smalest_even_node_index=0;\n    long smalest_even_node_even_value_index=0;\n\
    \    long smalest_even_node_index=0;\n    long smalest_even_node_even_value_index=0;\n\
    \    long smalest_even_node_index=0;\n    long smalest_even_node_even_value_index=0;\n\
    \    long smalest_even_node_index=0;\n    long smalest_even_node_even_value_index=0;\n\
    \    long smalest_even_node_index=0;\n    long smalest_even_node_even_value_index=0;\n\
    \    long smalest_even_node_index=0;\n    long smalest_even_node_even_value_index=0;\n\
    \    long smalest_even_node_index=0;\n    long smalest_even_node_even_value_index=0;\n\
    \    long smalest_even_node_index=0;\n    long smalest_even_node_even_value_index=0;\n\
    \    long smalest_even_node_index=0;\n    long smalest_even_node_even_value_index=0;\n\
    \    long smalest_even_node_index=0;\n    long smalest_even_node_even_value_index=0;\n\
    \    long smalest_even_node_index=0;\n    long smalest_even_node_even_value_index=0;\n\
    \    long smalest_even_node_index=0;\n    long smalest_even_node_even_value_index=0;\n\
    \    long smalest_even_node_index=0;\n    long smalest_even_node_even_value_index=0;\n\
    \    long smalest_even_node_index=0;\n    long smalest_even_node_even_value_index=0;\n\
    \    long smalest_even_node_index=0;\n    long smalest_even_node_even_value_index=0;\n\
    \    long smalest_even_node_index=0;\n    long smalest_even_node_even_value_index=0;\n\
    \    long smalest_even_node_index=0;\n    long smalest_even_node_even_value_index=0;\n\
    \    long smalest_even_node_index=0;\n    long smalest_even_node_even_value_index=0;\n\
    \    long smalest_even_node_index=0;\n    long smalest_even_\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplbhc3t9i.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmplbhc3t9i.cpp:28:10: error: redeclaration of \u2018long\
    \ int smalest_even_node_index\u2019\n   28 |     long smalest_even_node_index=0;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplbhc3t9i.cpp:26:10: note: \u2018\
    long int smalest_even_node_index\u2019 previously declared here\n   26 |     long\
    \ smalest_even_node_index=0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplbhc3t9i.cpp:30:10:\
    \ error: redeclaration of \u2018long int smalest_even_node_index\u2019\n   30\
    \ |     long smalest_even_node_index=0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplbhc3t9i.cpp:26:10: note: \u2018long int smalest_even_node_index\u2019\
    \ previously declared here\n   26 |     long smalest_even_node_index=0;\n    \
    \  |          ^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplbhc3t9i.cpp:31:10: error: redeclaration\
    \ of \u2018long int smalest_even_node_even_value_index\u2019\n   31 |     long\
    \ smalest_even_node_even_value_index=0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplbhc3t9i.cpp:29:10: note: \u2018long int smalest_even_node_even_value_index\u2019\
    \ previously declared here\n   29 |     long smalest_even_node_even_value_index=0;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplbhc3t9i.cpp:32:10:\
    \ error: redeclaration of \u2018long int smalest_even_node_index\u2019\n   32\
    \ |     long smalest_even_node_index=0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplbhc3t9i.cpp:26:10: note: \u2018long int smalest_even_node_index\u2019\
    \ previously declared here\n   26 |     long smalest_even_node_index=0;\n    \
    \  |          ^~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplbhc3t9i.cpp:33:10: error: redeclaration\
    \ of \u2018long int smalest_even_node_even_value_index\u2019\n   33 |     long\
    \ smalest_even_node_even_value_index=0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmplbhc3t9i.cpp:29:10: note: \u2018long int smalest_even_node_even_value_index\u2019\
    \ previously declared here\n   29 |     long smalest_even_node_even_value_index=0;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmplbhc3t9i.cpp:34:10:\
    \ error: redeclaration of \u2018long int smalest_eve"
  stdout: ''
  timestamp: 1660085854
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smallest_value\
    \ = arr[0];\n    long smallest_index = 0;\n    for (int i = 1; i < arr.size();\
    \ i++) {\n        if (arr[i] < smallest_value) {\n            smallest_value =\
    \ arr[i];\n            smallest_index = i;\n        }\n    }\n    std::vector<long>\
    \ result;\n    result.push_back(smallest_value);\n    result.push_back(smallest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpw0i9hu3k: /tmp/tmpw0i9hu3k.cpp:38: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085850
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = arr[0];\n    long smalest_index = 0;\n    for (long i = 0; i < arr.size();\
    \ i++) {\n        if (arr[i] % 2 == 0) {\n            if (smalest_value < arr[i])\
    \ {\n                smalest_value = arr[i];\n                smalest_index =\
    \ i;\n            }\n        }\n    }\n    std::vector<long> result;\n    if (smalest_value\
    \ != 0) {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp_uo3c26_: /tmp/tmp_uo3c26_.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085855
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long smallest_even_value = 0;\n    long\
    \ smallest_even_index = 0;\n    long smallest_index = 0;\n    long index = 0;\n\
    \    long even_value = 0;\n    long even_index = 0;\n    long even_smallest_index\
    \ = 0;\n    long even_smallest_value = 0;\n    long even_smallest_even_index =\
    \ 0;\n    long even_smallest_even_value = 0;\n    long even_smallest_index2 =\
    \ 0;\n    long even_smallest_value2 = 0;\n    long even_smallest_even_index2 =\
    \ 0;\n    long even_smallest_even_value2 = 0;\n    long even_smallest_index3 =\
    \ 0;\n    long even_smallest_value3 = 0;\n    long even_smallest_even_index3 =\
    \ 0;\n    long even_smallest_even_value3 = 0;\n    long even_smallest_index4 =\
    \ 0;\n    long even_smallest_value4 = 0;\n    long even_smallest_even_index4 =\
    \ 0;\n    long even_smallest_even_value4 = 0;\n    long even_smallest_index5 =\
    \ 0;\n    long even_smallest_value5 = 0;\n    long even_smallest_even_index5 =\
    \ 0;\n    long even_smallest_even_value5 = 0;\n    long even_smallest_index6 =\
    \ 0;\n    long even_smallest_value6 = 0;\n    long even_smallest_even_index6 =\
    \ 0;\n    long even_smallest_even_value6 = 0;\n    long even_smallest_index7 =\
    \ 0;\n    long even_smallest_value7 = 0;\n    long even_smallest_even_index7 =\
    \ 0;\n    long even_smallest_even_value7 = 0;\n    long even_smallest_index8 =\
    \ 0;\n    long even_smallest_value8 = 0;\n    long even_smallest_even_index8 =\
    \ 0;\n    long even_smallest_even_value8 = 0;\n    long even_smallest_index9 =\
    \ 0;\n    long even_smallest_value9 = 0;\n    long even_smallest_even_index9 =\
    \ 0;\n    long even_smallest_even_value9 = 0;\n    long even_smallest_index10\
    \ = 0;\n    long even_smallest_value10 = 0;\n    long even_smallest_even_index10\
    \ = 0;\n    long even_smallest_even_value10 = 0;\n    long even_smallest_index11\
    \ = 0;\n    long even_smallest_value11 = 0;\n    long even_smallest_even_index11\
    \ = 0;\n    long even_smallest_even_value11 = 0;\n    long even_smallest_index12\
    \ = 0;\n\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpbpxl79su: /tmp/tmpbpxl79su.cpp:79: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085855
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long smallest_index = 0;\n    for (long\
    \ i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (smalest_value == 0) {\n                smalest_value = arr[i];\n          \
    \      smalest_index = i;\n            } else if (smalest_value < arr[i]) {\n\
    \                smalest_value = arr[i];\n                smalest_index = i;\n\
    \            }\n        } else {\n            if (smallest_index == 0) {\n   \
    \             smallest_index = i;\n            } else if (smallest_index < i)\
    \ {\n                smallest_index = i;\n            }\n        }\n    }\n  \
    \  std::vector<long> result;\n    if (smalest_value != 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    if (smallest_index != 0)\
    \ {\n        result.push_back(arr[smallest_index]);\n        result.push_back(smallest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpf6wb1fa8: /tmp/tmpf6wb1fa8.cpp:55: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085855
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smallest_value\
    \ = arr[0];\n    long smallest_index = 0;\n    for (long i = 1; i < arr.size();\
    \ i++) {\n        if (arr[i] < smallest_value) {\n            smallest_value =\
    \ arr[i];\n            smallest_index = i;\n        }\n    }\n    std::vector<long>\
    \ result;\n    if (smallest_value % 2 == 0) {\n        result.push_back(smallest_value);\n\
    \        result.push_back(smallest_index);\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp42saru8x: /tmp/tmp42saru8x.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085855
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long smallest_index = 0;\n    long smallest_value\
    \ = 0;\n    long index = 0;\n    long value = 0;\n    for (auto i : arr) {\n \
    \       if (i % 2 == 0) {\n            value = i;\n            index = i;\n  \
    \      }\n    }\n    for (auto i : arr) {\n        if (i % 2 == 0) {\n       \
    \     if (value < smallest_value) {\n                smallest_value = value;\n\
    \                smallest_index = index;\n            }\n        }\n    }\n  \
    \  std::vector<long> ans;\n    ans.push_back(smallest_value);\n    ans.push_back(smallest_index);\n\
    \    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp4oi65u4p: /tmp/tmp4oi65u4p.cpp:49: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085855
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    } else {\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp6xfda3xq: /tmp/tmp6xfda3xq.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085850
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0, smalest_index = 0;\n    long smalest_even_value = 0;\n    long smalest_even_index\
    \ = 0;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 ==\
    \ 0) {\n            if (smalest_value == 0) {\n                smalest_value =\
    \ arr[i];\n                smalest_index = i;\n                smalest_even_value\
    \ = arr[i] / 2;\n                smalest_even_index = i;\n            } else if\
    \ (smalest_value == arr[i]) {\n                smalest_even_index = i;\n     \
    \       }\n        }\n    }\n    if (smalest_value == 0) {\n        return {};\n\
    \    }\n    std::vector<long> res;\n    res.push_back(smalest_value);\n    res.push_back(smalest_index);\n\
    \    if (smalest_even_index != smalest_index) {\n        res.push_back(smalest_even_index);\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpsb2vc9vp: /tmp/tmpsb2vc9vp.cpp:50: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085855
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long even_value = 0;\n    for (auto i : arr)\
    \ {\n        if (i % 2 == 0) {\n            even_value = i;\n        }\n     \
    \   if (i == smalest_value) {\n            smalest_index = i;\n        }\n   \
    \ }\n    std::vector<long> result;\n    if (smalest_index != 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    } else {\n        result.push_back(smalest_value);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmptlk71cy2: /tmp/tmptlk71cy2.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085855
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long index = 0;\n    for (int i = 1; i < arr.size();\
    \ i++) {\n        if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n\
    \            smalest_index = i;\n        }\n    }\n    if (smalest_value == 0)\
    \ {\n        return {};\n    }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n\
    \    result.push_back(smalest_index);\n    return result;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpm1yd4a8a: /tmp/tmpm1yd4a8a.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085855
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long smallest_value = arr[0];\n    long smallest_index\
    \ = 0;\n    for (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < smallest_value)\
    \ {\n            smallest_value = arr[i];\n            smallest_index = i;\n \
    \       }\n        if (arr[i] < smalest_value) {\n            smalest_value =\
    \ arr[i];\n            smalest_index = i;\n        }\n    }\n    std::vector<long>\
    \ result;\n    result.push_back(smalest_value);\n    result.push_back(smalest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpg6biwtd4: /tmp/tmpg6biwtd4.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085855
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = 0;\n\
    \    long smalest_index = 0;\n    long smalest_even_value = 0;\n    long smalest_even_index\
    \ = 0;\n    long smalest_even_value_pos = 0;\n    long smalest_even_index_pos\
    \ = 0;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 ==\
    \ 0) {\n            if (smalest_value == 0) {\n                smalest_value =\
    \ arr[i];\n                smalest_index = i;\n                smalest_even_value\
    \ = arr[i] % 2;\n                smalest_even_index = i;\n                smalest_even_value_pos\
    \ = i;\n                smalest_even_index_pos = i;\n            } else if (smalest_value\
    \ == arr[i]) {\n                smalest_even_value_pos = i;\n                smalest_even_index_pos\
    \ = i;\n            }\n        } else if (smalest_value == 0) {\n            smalest_even_value_pos\
    \ = i;\n            smalest_even_index_pos = i;\n        }\n    }\n    if (smalest_value\
    \ == 0) {\n        return {};\n    }\n    std::vector<long> res;\n    res.push_back(smalest_value);\n\
    \    res.push_back(smalest_index);\n    if (smalest_even_value_pos == smalest_even_index)\
    \ {\n        res.push_back(smalest_even_value);\n        res.push_back(smalest_even_index);\n\
    \    } else {\n        res.push_back(smalest_even_value);\n        res.push_back(smalest_even_index);\n\
    \        res.push_back(smalest_even_value_pos);\n        res.push_back(smalest_even_index_pos);\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpx1qi7b0g: /tmp/tmpx1qi7b0g.cpp:64: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085855
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // write your code here\n\
    \    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_index_value\
    \ = 0;\n    long smalest_index_value2 = 0;\n    long smalest_index_value3 = 0;\n\
    \    long smalest_index_value4 = 0;\n    long smalest_index_value5 = 0;\n    long\
    \ smalest_index_value6 = 0;\n    long smalest_index_value7 = 0;\n    long smalest_index_value8\
    \ = 0;\n    long smalest_index_value9 = 0;\n    long smalest_index_value10 = 0;\n\
    \    long smalest_index_value11 = 0;\n    long smalest_index_value12 = 0;\n  \
    \  long smalest_index_value13 = 0;\n    long smalest_index_value14 = 0;\n    long\
    \ smalest_index_value15 = 0;\n    long smalest_index_value16 = 0;\n    long smalest_index_value17\
    \ = 0;\n    long smalest_index_value18 = 0;\n    long smalest_index_value19 =\
    \ 0;\n    long smalest_index_value20 = 0;\n    long smalest_index_value21 = 0;\n\
    \    long smalest_index_value22 = 0;\n    long smalest_index_value23 = 0;\n  \
    \  long smalest_index_value24 = 0;\n    long smalest_index_value25 = 0;\n    long\
    \ smalest_index_value26 = 0;\n    long smalest_index_value27 = 0;\n    long smalest_index_value28\
    \ = 0;\n    long smalest_index_value29 = 0;\n    long smalest_index_value30 =\
    \ 0;\n    long smalest_index_value31 = 0;\n    long smalest_index_value32 = 0;\n\
    \    long smalest_index_value33 = 0;\n    long smalest_index_value34 = 0;\n  \
    \  long smalest_index_value35 = 0;\n    long smalest_index_value36 = 0;\n    long\
    \ smalest_index_value37 = 0;\n    long smalest_index_value38 = 0;\n    long smalest_index_value39\
    \ = 0;\n    long smalest_index_value40 = 0;\n    long smalest_index_value41 =\
    \ 0;\n    long smalest_index_value42 = 0;\n    long smalest_index_value43 = 0;\n\
    \    long smalest_index_value44 = 0;\n    long smalest_index_value45 = 0;\n  \
    \  long smalest_index_value46 = 0;\n    long smalest_index_value47 = 0;\n    long\
    \ smalest_index_value48 = 0;\n    long smalest_index_value49 = 0;\n    long smalest_index_\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7yhie042.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp7yhie042.cpp:74:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   74 | }\n      | ^\n/tmp/tmp7yhie042.cpp:74:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660085855
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long smalest_index_value = arr[0];\n    for\
    \ (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < smalest_value) {\n\
    \            smalest_value = arr[i];\n            smalest_index = i;\n       \
    \     smalest_index_value = arr[i];\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_index_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    } else {\n        result.push_back(smalest_value);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp81ttthim: /tmp/tmp81ttthim.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085856
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smallest_value\
    \ = arr[0];\n    long smallest_index = 0;\n    for (long i = 1; i < arr.size();\
    \ i++) {\n        if (arr[i] < smallest_value) {\n            smallest_value =\
    \ arr[i];\n            smallest_index = i;\n        }\n    }\n    std::vector<long>\
    \ result;\n    if (smallest_value % 2 == 0) {\n        result.push_back(smallest_value);\n\
    \        result.push_back(smallest_index);\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp42saru8x: /tmp/tmp42saru8x.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085855
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n  \
    \      if (arr[i] % 2 == 0) {\n            if (smalest_value < arr[i]) {\n   \
    \             smalest_value = arr[i];\n                smalest_index = i;\n  \
    \          }\n        }\n    }\n    std::vector<long> result;\n    if (smalest_index\
    \ != 0) {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp5ue2r7q6: /tmp/tmp5ue2r7q6.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085856
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    int smalest_index = 0;\n    for (long i = 0; i < arr.size(); i++)\
    \ {\n        if (arr[i] % 2 == 0) {\n            if (smalest_value == 0) {\n \
    \               smalest_value = arr[i];\n                smalest_index = i;\n\
    \            } else if (smalest_value < arr[i]) {\n                smalest_value\
    \ = arr[i];\n                smalest_index = i;\n            }\n        }\n  \
    \  }\n    std::vector<long> result;\n    if (smalest_value != 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpggl4u02u: /tmp/tmpggl4u02u.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085856
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smallest_value\
    \ = 0;\n    long smallest_index = 0;\n    long index = 0;\n    long value = 0;\n\
    \    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n\
    \            value = arr[i];\n            index = i;\n        }\n    }\n    if\
    \ (value == 0) {\n        return {};\n    }\n    for (long i = 0; i < arr.size();\
    \ i++) {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < smallest_value)\
    \ {\n                smallest_value = arr[i];\n                smallest_index\
    \ = index;\n            }\n        }\n    }\n    std::vector<long> ans;\n    ans.push_back(smallest_value);\n\
    \    ans.push_back(smallest_index);\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4, (long)2,\
    \ (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpvchxo4_n: /tmp/tmpvchxo4_n.cpp:50: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085856
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long index = 0;\n    for (long i = 1; i < arr.size();\
    \ i++) {\n        if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n\
    \            smalest_index = i;\n        }\n    }\n    if (smalest_value == 0)\
    \ {\n        return {};\n    }\n    std::vector<long> res;\n    res.push_back(smalest_value);\n\
    \    res.push_back(smalest_index);\n    return res;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4, (long)2,\
    \ (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpoppk5rt3: /tmp/tmpoppk5rt3.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085856
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smallest_value\
    \ = 0;\n    long smallest_index = 0;\n    long index = 0;\n    long value = 0;\n\
    \    long i = 0;\n    for (i = 0; i < arr.size(); i++) {\n        if (arr[i] %\
    \ 2 == 0) {\n            value = arr[i];\n            index = i;\n        }\n\
    \    }\n    if (value == 0) {\n        return {};\n    }\n    for (i = 0; i <\
    \ arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] <\
    \ smallest_value) {\n                smallest_value = arr[i];\n              \
    \  smallest_index = index;\n            }\n        }\n    }\n    return {smallest_value,\
    \ smallest_index};\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpswiy0fda: /tmp/tmpswiy0fda.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085857
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long smallest_even_value = arr[0];\n    long\
    \ smallest_even_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n    \
    \    if (arr[i] % 2 == 0) {\n            if (arr[i] < smallest_even_value) {\n\
    \                smallest_even_value = arr[i];\n                smallest_even_index\
    \ = i;\n            }\n        }\n        if (arr[i] < smalest_value) {\n    \
    \        smalest_value = arr[i];\n            smalest_index = i;\n        }\n\
    \    }\n    std::vector<long> res;\n    res.push_back(smalest_value);\n    res.push_back(smalest_index);\n\
    \    return res;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpcqq7ufte: /tmp/tmpcqq7ufte.cpp:45: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085857
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0, smalest_index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n     \
    \   if (arr[i] % 2 == 0) {\n            if (smalest_value == 0 || smalest_value\
    \ < arr[i]) {\n                smalest_value = arr[i];\n                smalest_index\
    \ = i;\n            }\n        }\n    }\n    std::vector<long> ans;\n    if (smalest_value\
    \ != 0) {\n        ans.push_back(smalest_value);\n        ans.push_back(smalest_index);\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp__6r4o3y: /tmp/tmp__6r4o3y.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085857
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0, smalest_index = 0;\n    long smallest_value = INT_MIN;\n    long smallest_index\
    \ = 0;\n    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 ==\
    \ 0) {\n            if (arr[i] < smallest_value) {\n                smallest_value\
    \ = arr[i];\n                smallest_index = i;\n            }\n        }\n \
    \   }\n    std::vector<long> result;\n    if (smallest_value != 0) {\n       \
    \ result.push_back(smallest_value);\n        result.push_back(smallest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpqpxsxi2q: /tmp/tmpqpxsxi2q.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085857
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smallest_value\
    \ = 0;\n    long smallest_index = 0;\n    long index = 0;\n    long value = 0;\n\
    \    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n\
    \            value = arr[i];\n            index = i;\n        }\n    }\n    if\
    \ (value == 0) {\n        return {};\n    }\n    for (long i = 0; i < arr.size();\
    \ i++) {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < smallest_value)\
    \ {\n                smallest_value = arr[i];\n                smallest_index\
    \ = index;\n            }\n        }\n    }\n    std::vector<long> res;\n    res.push_back(smallest_value);\n\
    \    res.push_back(smallest_index);\n    return res;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4, (long)2,\
    \ (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpn3d_bge8: /tmp/tmpn3d_bge8.cpp:50: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085857
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // Your code here\n    long\
    \ smalest_value = 0, smalest_index = 0;\n    long smalest_even_value = 0;\n  \
    \  for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n \
    \           if (smalest_value == 0) {\n                smalest_value = arr[i];\n\
    \                smalest_index = i;\n                smalest_even_value = arr[i]\
    \ / 2;\n            } else if (smalest_value == arr[i]) {\n                smalest_index\
    \ = i;\n                smalest_even_value = arr[i] / 2;\n            } else if\
    \ (smalest_value == arr[i] && smalest_even_value == arr[i] / 2) {\n          \
    \      smalest_index = i;\n                smalest_even_value = arr[i] / 2;\n\
    \            }\n        }\n    }\n    if (smalest_value == 0) {\n        return\
    \ {};\n    }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n\
    \    result.push_back(smalest_index);\n    return result;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpqetqc3lq: /tmp/tmpqetqc3lq.cpp:49: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085857
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long smallest_index = INT_MAX;\n    for (long\
    \ i = 0; i < arr.size(); i++) {\n        if (arr[i] < smallest_index) {\n    \
    \        smallest_index = arr[i];\n        }\n        if (arr[i] < smalest_value)\
    \ {\n            smalest_value = arr[i];\n            smalest_index = i;\n   \
    \     }\n    }\n    std::vector<long> result;\n    if (smalest_index != INT_MAX)\
    \ {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    } else {\n        result.push_back(smalest_value);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpokcqjqrr: /tmp/tmpokcqjqrr.cpp:45: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085857
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long smalest_index_value = 0;\n    for (long\
    \ i = 1; i < arr.size(); i++) {\n        if (arr[i] < smalest_value) {\n     \
    \       smalest_value = arr[i];\n            smalest_index = i;\n            smalest_index_value\
    \ = arr[i];\n        }\n    }\n    std::vector<long> result;\n    if (smalest_index_value\
    \ % 2 == 0) {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    } else {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index\
    \ + 1);\n    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp3ihznlrl: /tmp/tmp3ihznlrl.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085857
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long index = 0;\n    for (auto i : arr) {\n\
    \        if (i % 2 == 0) {\n            if (smalest_value == i) {\n          \
    \      smalest_index = index;\n            }\n            smalest_value = i;\n\
    \            index = i;\n        }\n    }\n    if (smalest_index == 0) {\n   \
    \     return {};\n    }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n\
    \    result.push_back(smalest_index);\n    return result;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpj9ruu2kj: /tmp/tmpj9ruu2kj.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085857
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    } else {\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp1jm38vav: /tmp/tmp1jm38vav.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long smalest_index_of_smalest_value = 0;\n \
    \   for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] < smalest_value)\
    \ {\n            smalest_value = arr[i];\n            smalest_index = i;\n   \
    \         smalest_index_of_smalest_value = i;\n        }\n    }\n    if (smalest_value\
    \ == 0) {\n        return {};\n    }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n\
    \    result.push_back(smalest_index_of_smalest_value);\n    return result;\n}\n\
    int main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpebdt_xmv: /tmp/tmpebdt_xmv.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085857
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long smalest_index_of_smalest_value =\
    \ 0;\n    long smalest_index_of_smalest_value2 = 0;\n    long smalest_index_of_smalest_value3\
    \ = 0;\n    long smalest_index_of_smalest_value4 = 0;\n    long smalest_index_of_smalest_value5\
    \ = 0;\n    long smalest_index_of_smalest_value6 = 0;\n    long smalest_index_of_smalest_value7\
    \ = 0;\n    long smalest_index_of_smalest_value8 = 0;\n    long smalest_index_of_smalest_value9\
    \ = 0;\n    long smalest_index_of_smalest_value10 = 0;\n    long smalest_index_of_smalest_value11\
    \ = 0;\n    long smalest_index_of_smalest_value12 = 0;\n    long smalest_index_of_smalest_value13\
    \ = 0;\n    long smalest_index_of_smalest_value14 = 0;\n    long smalest_index_of_smalest_value15\
    \ = 0;\n    long smalest_index_of_smalest_value16 = 0;\n    long smalest_index_of_smalest_value17\
    \ = 0;\n    long smalest_index_of_smalest_value18 = 0;\n    long smalest_index_of_smalest_value19\
    \ = 0;\n    long smalest_index_of_smalest_value20 = 0;\n    long smalest_index_of_smalest_value21\
    \ = 0;\n    long smalest_index_of_smalest_value22 = 0;\n    long smalest_index_of_smalest_value23\
    \ = 0;\n    long smalest_index_of_smalest_value24 = 0;\n    long smalest_index_of_smalest_value25\
    \ = 0;\n    long smalest_index_of_smalest_value26 = 0;\n    long smalest_index_of_smalest_value27\
    \ = 0;\n    long smalest_index_of_smalest_value28 = 0;\n    long smalest_index_of_smalest_value29\
    \ = 0;\n    long smalest_index_of_smalest_value30 = 0;\n    long smalest_index_of_smalest_value31\
    \ = 0;\n    long smalest_index_of_smalest_value32 = 0;\n    long smalest_index_of_smalest_value33\
    \ = 0;\n    long smalest_index_of_smalest_value34 = 0;\n    long smalest_index_of_smalest_value35\
    \ = 0;\n    long smalest_index_of_\n}\nint main() {\n    auto candidate = pluck;\n\
    \    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7t8ohfok.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp7t8ohfok.cpp:60:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   60 | }\n      | ^\n/tmp/tmp7t8ohfok.cpp:60:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long index = 0;\n    for (auto i : arr) {\n\
    \        if (i % 2 == 0) {\n            if (smalest_value < i) {\n           \
    \     smalest_value = i;\n                smalest_index = index;\n           \
    \ }\n            index++;\n        }\n    }\n    if (smalest_value == 0) {\n \
    \       return {};\n    }\n    return {smalest_value, smalest_index};\n}\nint\
    \ main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpd3yji4b8: /tmp/tmpd3yji4b8.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085857
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // Your code here\n    long\
    \ smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_even_value\
    \ = 0;\n    long smalest_even_index = 0;\n    long smalest_even_index_temp = 0;\n\
    \    long smalest_even_index_temp2 = 0;\n    long smalest_even_index_temp3 = 0;\n\
    \    long smalest_even_index_temp4 = 0;\n    long smalest_even_index_temp5 = 0;\n\
    \    long smalest_even_index_temp6 = 0;\n    long smalest_even_index_temp7 = 0;\n\
    \    long smalest_even_index_temp8 = 0;\n    long smalest_even_index_temp9 = 0;\n\
    \    long smalest_even_index_temp10 = 0;\n    long smalest_even_index_temp11 =\
    \ 0;\n    long smalest_even_index_temp12 = 0;\n    long smalest_even_index_temp13\
    \ = 0;\n    long smalest_even_index_temp14 = 0;\n    long smalest_even_index_temp15\
    \ = 0;\n    long smalest_even_index_temp16 = 0;\n    long smalest_even_index_temp17\
    \ = 0;\n    long smalest_even_index_temp18 = 0;\n    long smalest_even_index_temp19\
    \ = 0;\n    long smalest_even_index_temp20 = 0;\n    long smalest_even_index_temp21\
    \ = 0;\n    long smalest_even_index_temp22 = 0;\n    long smalest_even_index_temp23\
    \ = 0;\n    long smalest_even_index_temp24 = 0;\n    long smalest_even_index_temp25\
    \ = 0;\n    long smalest_even_index_temp26 = 0;\n    long smalest_even_index_temp27\
    \ = 0;\n    long smalest_even_index_temp28 = 0;\n    long smalest_even_index_temp29\
    \ = 0;\n    long smalest_even_index_temp30 = 0;\n    long smalest_even_index_temp31\
    \ = 0;\n    long smalest_even_index_temp32 = 0;\n    long smalest_even_index_temp33\
    \ = 0;\n    long smalest_even_index_temp34 = 0;\n    long smalest_even_index_temp35\
    \ = 0;\n    long smalest_even_index_temp36 = 0;\n    long smalest_even_index_temp37\
    \ = 0;\n    long smalest_even_index_temp38 = 0;\n    long smalest_even_index_temp39\
    \ = 0;\n    long smalest_even_index_temp40 = 0;\n    long smalest_even_index_temp41\
    \ = 0;\n    long smalest_even_index_temp42 = 0;\n    long smalest_even_index_temp43\
    \ = 0;\n    long smalest_\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpc6jtnh4f.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpc6jtnh4f.cpp:70:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   70 | }\n      | ^\n/tmp/tmpc6jtnh4f.cpp:70:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660085857
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpb__mwrec: /tmp/tmpb__mwrec.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smallest_value\
    \ = 0;\n    long smallest_index = 0;\n    long smallest_even_value = 0;\n    long\
    \ index = 0;\n    long even_value = 0;\n    for (long i = 0; i < arr.size(); i++)\
    \ {\n        if (arr[i] % 2 == 0) {\n            even_value = arr[i];\n      \
    \      index = i;\n        }\n        if (arr[i] < smallest_value) {\n       \
    \     smallest_value = arr[i];\n            smallest_index = index;\n        \
    \    smallest_even_value = even_value;\n        }\n    }\n    std::vector<long>\
    \ result;\n    if (smallest_value == 0) {\n        return result;\n    }\n   \
    \ result.push_back(smallest_value);\n    result.push_back(smallest_index);\n \
    \   result.push_back(smallest_even_value);\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpb_7gpn09: /tmp/tmpb_7gpn09.cpp:49: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085857
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = 0;\n\
    \    long smalest_index = 0;\n    long smalest_even_value = 0;\n    long smalest_even_index\
    \ = 0;\n    long smalest_even_index_index = 0;\n    long smalest_even_index_value\
    \ = 0;\n    long smalest_even_index_index2 = 0;\n    long smalest_even_index_index3\
    \ = 0;\n    long smalest_even_index_index4 = 0;\n    long smalest_even_index_index5\
    \ = 0;\n    long smalest_even_index_index6 = 0;\n    long smalest_even_index_index7\
    \ = 0;\n    long smalest_even_index_index8 = 0;\n    long smalest_even_index_index9\
    \ = 0;\n    long smalest_even_index_index10 = 0;\n    long smalest_even_index_index11\
    \ = 0;\n    long smalest_even_index_index12 = 0;\n    long smalest_even_index_index13\
    \ = 0;\n    long smalest_even_index_index14 = 0;\n    long smalest_even_index_index15\
    \ = 0;\n    long smalest_even_index_index16 = 0;\n    long smalest_even_index_index17\
    \ = 0;\n    long smalest_even_index_index18 = 0;\n    long smalest_even_index_index19\
    \ = 0;\n    long smalest_even_index_index20 = 0;\n    long smalest_even_index_index21\
    \ = 0;\n    long smalest_even_index_index22 = 0;\n    long smalest_even_index_index23\
    \ = 0;\n    long smalest_even_index_index24 = 0;\n    long smalest_even_index_index25\
    \ = 0;\n    long smalest_even_index_index26 = 0;\n    long smalest_even_index_index27\
    \ = 0;\n    long smalest_even_index_index28 = 0;\n    long smalest_even_index_index29\
    \ = 0;\n    long smalest_even_index_index30 = 0;\n    long smalest_even_index_index31\
    \ = 0;\n    long smalest_even_index_index32 = 0;\n    long smalest_even_index_index33\
    \ = 0;\n    long smalest_even_index_index34 = 0;\n    long smalest_even_index_index35\
    \ = 0;\n    long smalest_even_index_index36 = 0;\n    long smalest_even_index_index37\
    \ = 0;\n    long smalest_even_index_index38 = 0;\n    long smalest_even_index_index39\
    \ = 0;\n    long smalest_even_index_index40 = 0;\n    long smalest_even_index_index41\
    \ = 0;\n    long smalest_even_index_index42 = 0;\n    long smalest_even_index_index43\
    \ = 0;\n\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpafrg3o82: /tmp/tmpafrg3o82.cpp:73: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085857
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long index = 0;\n    long value = 0;\n\
    \    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4\
    \ = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long\
    \ temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n\
    \    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15\
    \ = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n   \
    \ long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22\
    \ = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n   \
    \ long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29\
    \ = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n   \
    \ long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36\
    \ = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n   \
    \ long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43\
    \ = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n   \
    \ long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50\
    \ = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n   \
    \ long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57\
    \ = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n   \
    \ long temp61 = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64\
    \ = 0;\n    long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n   \
    \ long temp68 = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71\
    \ = 0;\n    long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n   \
    \ long temp75 = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78\
    \ = 0;\n    long temp79 = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n   \
    \ \n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp7o23pu5s: /tmp/tmp7o23pu5s.cpp:111: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085857
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long smalest_index_value = 0;\n    long smalest_index_value_temp\
    \ = 0;\n    long smalest_index_value_temp_temp = 0;\n    long smalest_index_value_temp_temp_temp\
    \ = 0;\n    long smalest_index_value_temp_temp_temp_temp = 0;\n    long smalest_index_value_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_index_value_temp_temp_temp_temp_temp_temp = 0;\n    long\
    \ smalest_index_value_temp_temp_temp_temp_temp_temp_temp = 0;\n    long smalest_index_value_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_index_value_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_index_value_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_index_value_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_index_value_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_index_value_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_index_value_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_index_value_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_index_value_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_index_value_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_index_value_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_index_value_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_index_value_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_index_value_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_index_value_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_index_value_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_index_value_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpse9wz1wh.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpse9wz1wh.cpp:36:10: error: redeclaration of \u2018long\
    \ int smalest_index_value_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\u2019\
    \n   36 |     long smalest_index_value_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpse9wz1wh.cpp:35:10: note: \u2018long int smalest_index_value_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\u2019\
    \ previously declared here\n   35 |     long smalest_index_value_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpse9wz1wh.cpp:38:10: error: redeclaration of \u2018long int smalest_index_value_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\u2019\
    \n   38 |     long smalest_index_value_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpse9wz1wh.cpp:37:10: note: \u2018long int smalest_index_value_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\u2019\
    \ previously declared here\n   37 |     long smalest_index_value_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpse9wz1wh.cpp:41:10: error: redeclaration of \u2018long int smalest_index_value_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\u2019\
    \n   41 |     long smalest_index_value_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpse9wz1wh.cpp:40:10: note: \u2018long int smalest_index_value_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_te"
  stdout: ''
  timestamp: 1660085857
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smallest_index = -1;\n    for (long i = 1; i < arr.size(); i++) {\n\
    \        if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n\
    \            smallest_index = i;\n        }\n    }\n    if (smallest_index ==\
    \ -1) {\n        return {};\n    }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n\
    \    result.push_back(smallest_index);\n    return result;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpg9qowmwg: /tmp/tmpg9qowmwg.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085857
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpb__mwrec: /tmp/tmpb__mwrec.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = arr[0];\n    int smalest_index = 0;\n    for (int i = 0; i < arr.size(); i++)\
    \ {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < smalest_value) {\n\
    \                smalest_value = arr[i];\n                smalest_index = i;\n\
    \            }\n        }\n    }\n    std::vector<long> result;\n    if (smalest_index\
    \ != 0) {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpgrq_2r1k: /tmp/tmpgrq_2r1k.cpp:42: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085857
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n  \
    \      if (arr[i] % 2 == 0) {\n            if (arr[i] < smalest_value) {\n   \
    \             smalest_value = arr[i];\n                smalest_index = i;\n  \
    \          }\n        }\n    }\n    std::vector<long> result;\n    if (smalest_index\
    \ != 0) {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpdqownxkb: /tmp/tmpdqownxkb.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085858
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = arr[0];\n    long smalest_index = 0;\n    long smallest_even_value = 0;\n\
    \    long smallest_even_index = 0;\n    long index = 0;\n    for (auto i : arr)\
    \ {\n        if (i % 2 == 0) {\n            if (smallest_even_value == 0) {\n\
    \                smallest_even_value = i;\n                smallest_even_index\
    \ = index;\n            } else {\n                if (i < smallest_even_value)\
    \ {\n                    smallest_even_value = i;\n                    smallest_even_index\
    \ = index;\n                }\n            }\n        }\n        index++;\n  \
    \  }\n    std::vector<long> result;\n    if (smallest_even_value == 0) {\n   \
    \     return result;\n    }\n    result.push_back(smallest_even_value);\n    result.push_back(smallest_even_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660085858
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    for (long i = 0; i < arr.size(); i++)\
    \ {\n        if (arr[i] % 2 == 0) {\n            if (smalest_value == 0) {\n \
    \               smalest_value = arr[i];\n                smalest_index = i;\n\
    \            } else if (smalest_value < arr[i]) {\n                smalest_value\
    \ = arr[i];\n                smalest_index = i;\n            }\n        }\n  \
    \  }\n    std::vector<long> result;\n    if (smalest_value != 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp5ziol6x2: /tmp/tmp5ziol6x2.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long index = 0;\n    long value = 0;\n\
    \    for (long i = 0; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n\
    \            value = arr[i];\n            index = i;\n        }\n    }\n    if\
    \ (value == 0) {\n        return {};\n    }\n    for (long i = 0; i < arr.size();\
    \ i++) {\n        if (arr[i] % 2 == 0) {\n            if (arr[i] < value) {\n\
    \                smalest_value = value;\n                smalest_index = index;\n\
    \            }\n        }\n    }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n\
    \    result.push_back(smalest_index);\n    return result;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp9cyu65vr: /tmp/tmp9cyu65vr.cpp:50: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085858
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long smalest_even_value = 0;\n    long\
    \ smalest_even_index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n     \
    \   if (arr[i] % 2 == 0) {\n            if (smalest_even_value < arr[i]) {\n \
    \               smalest_even_value = arr[i];\n                smalest_even_index\
    \ = i;\n            }\n            if (smalest_value < arr[i]) {\n           \
    \     smalest_value = arr[i];\n                smalest_index = i;\n          \
    \  }\n        }\n    }\n    std::vector<long> result;\n    if (smalest_even_value\
    \ == 0) {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    } else {\n        result.push_back(smalest_even_value);\n        result.push_back(smalest_even_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp1cvbwoy1: /tmp/tmp1cvbwoy1.cpp:50: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085859
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = 0;\n\
    \    long smalest_index = 0;\n    long smalest_even_value = 0;\n    long smalest_even_index\
    \ = 0;\n    long smalest_even_value_pos = 0;\n    long smalest_even_index_pos\
    \ = 0;\n    long smalest_even_value_neg = 0;\n    long smalest_even_index_neg\
    \ = 0;\n    long smalest_even_value_zero = 0;\n    long smalest_even_index_zero\
    \ = 0;\n    long smalest_even_value_one = 0;\n    long smalest_even_index_one\
    \ = 0;\n    long smalest_even_value_two = 0;\n    long smalest_even_index_two\
    \ = 0;\n    long smalest_even_value_three = 0;\n    long smalest_even_index_three\
    \ = 0;\n    long smalest_even_value_four = 0;\n    long smalest_even_index_four\
    \ = 0;\n    long smalest_even_value_five = 0;\n    long smalest_even_index_five\
    \ = 0;\n    long smalest_even_value_six = 0;\n    long smalest_even_index_six\
    \ = 0;\n    long smalest_even_value_seven = 0;\n    long smalest_even_index_seven\
    \ = 0;\n    long smalest_even_value_eight = 0;\n    long smalest_even_index_eight\
    \ = 0;\n    long smalest_even_value_nine = 0;\n    long smalest_even_index_nine\
    \ = 0;\n    long smalest_even_value_ten = 0;\n    long smalest_even_index_ten\
    \ = 0;\n    long smalest_even_value_eleven = 0;\n    long smalest_even_index_eleven\
    \ = 0;\n    long smalest_even_value_twelve = 0;\n    long smalest_even_index_twelve\
    \ = 0;\n    long smalest_even_value_thirteen = 0;\n    long smalest_even_index_thirteen\
    \ = 0;\n    long smalest_even_value_fourteen = 0;\n    long smalest_even_index_fourteen\
    \ = 0;\n    long smalest_even_value_fifteen = 0;\n    long smalest_even_index_fifteen\
    \ = 0;\n    long smalest_even_value_sixteen = 0;\n    long smalest_even_index_sixteen\
    \ = 0;\n    long smalest_even_value_seventeen = 0;\n    long smalest_even_index_seventeen\
    \ = 0;\n    long smalest_even_value_eighteen = 0;\n    long smalest_even_index_eighteen\
    \ = 0;\n    long smalest_even_value_nineteen = 0;\n    long smalest_even_index_nineteen\
    \ = 0;\n    long sm\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpr5g5yshr.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpr5g5yshr.cpp:70:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   70 | }\n      | ^\n/tmp/tmpr5g5yshr.cpp:70:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660085858
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long smalest_even_value = 0;\n    long smalest_even_index\
    \ = 0;\n    long smalest_even_value_found = 0;\n    long smalest_even_index_found\
    \ = 0;\n    long smalest_index_found = 0;\n    long smalest_index_found2 = 0;\n\
    \    long smalest_index_found3 = 0;\n    long smalest_index_found4 = 0;\n    long\
    \ smalest_index_found5 = 0;\n    long smalest_index_found6 = 0;\n    long smalest_index_found7\
    \ = 0;\n    long smalest_index_found8 = 0;\n    long smalest_index_found9 = 0;\n\
    \    long smalest_index_found10 = 0;\n    long smalest_index_found11 = 0;\n  \
    \  long smalest_index_found12 = 0;\n    long smalest_index_found13 = 0;\n    long\
    \ smalest_index_found14 = 0;\n    long smalest_index_found15 = 0;\n    long smalest_index_found16\
    \ = 0;\n    long smalest_index_found17 = 0;\n    long smalest_index_found18 =\
    \ 0;\n    long smalest_index_found19 = 0;\n    long smalest_index_found20 = 0;\n\
    \    long smalest_index_found21 = 0;\n    long smalest_index_found22 = 0;\n  \
    \  long smalest_index_found23 = 0;\n    long smalest_index_found24 = 0;\n    long\
    \ smalest_index_found25 = 0;\n    long smalest_index_found26 = 0;\n    long smalest_index_found27\
    \ = 0;\n    long smalest_index_found28 = 0;\n    long smalest_index_found29 =\
    \ 0;\n    long smalest_index_found30 = 0;\n    long smalest_index_found31 = 0;\n\
    \    long smalest_index_found32 = 0;\n    long smalest_index_found33 = 0;\n  \
    \  long smalest_index_found34 = 0;\n    long smalest_index_found35 = 0;\n    long\
    \ smalest_index_found36 = 0;\n    long smalest_index_found37 = 0;\n    long smalest_index_found38\
    \ = 0;\n    long smalest_index_found39 = 0;\n    long smalest_index_found40 =\
    \ 0;\n    long smalest_index_found41 = 0;\n    long smalest_index_found42 = 0;\n\
    \    long smalest_index_found43 = 0;\n    long smalest_index_found44 = 0;\n  \
    \  long smalest_index_found45 = 0;\n    long smalest_index_found46 = 0;\n    long\
    \ \n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfdd7rrid.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpfdd7rrid.cpp:74:1: error: expected unqualified-id before\
    \ \u2018}\u2019 token\n   74 | }\n      | ^\n/tmp/tmpfdd7rrid.cpp:74:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660085859
- exit_code: -11
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long smalest_even_value = 0;\n    for (long\
    \ i = 1; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            smalest_even_value\
    \ = arr[i];\n            smalest_index = i;\n        }\n        else if (arr[i]\
    \ < smalest_even_value) {\n            smalest_even_value = arr[i];\n        \
    \    smalest_index = i;\n        }\n        else if (arr[i] == smalest_even_value)\
    \ {\n            smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_index != 0) {\n        result.push_back(smalest_even_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: ''
  stdout: ''
  timestamp: 1660085859
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    int smallest_index = 0;\n    for (int i = 1; i < arr.size(); i++) {\n   \
    \     if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n   \
    \         smallest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smallest_index);\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp1qluvdb0: /tmp/tmp1qluvdb0.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085859
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    int smalest_index = 0;\n    for (int i = 1; i < arr.size(); i++) {\n    \
    \    if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n    \
    \        smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    result.push_back(smalest_value);\n    result.push_back(smalest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpg62p2ffq: /tmp/tmpg62p2ffq.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085859
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value=arr[0];\n\
    \    long smalest_index=0;\n    long smallest_value=arr[0];\n    long smallest_index=0;\n\
    \    for(int i=0;i<arr.size();i++){\n        if(arr[i]%2==0){\n            if(arr[i]<smallest_value){\n\
    \                smallest_value=arr[i];\n                smallest_index=i;\n \
    \           }\n        }\n        else{\n            if(arr[i]<smalest_value){\n\
    \                smalest_value=arr[i];\n                smalest_index=i;\n   \
    \         }\n        }\n    }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n\
    \    result.push_back(smalest_index);\n    return result;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpi1ozrvk6: /tmp/tmpi1ozrvk6.cpp:47: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085859
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smallest_index = -1;\n    for (long i = 1; i < arr.size(); i++) {\n\
    \        if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n\
    \            smallest_index = i;\n        }\n    }\n    if (smallest_index ==\
    \ -1) {\n        return {};\n    }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n\
    \    result.push_back(smallest_index);\n    return result;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpg9qowmwg: /tmp/tmpg9qowmwg.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085857
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    result.push_back(smalest_value);\n    result.push_back(smalest_index);\n\
    \    return result;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpgve2n5s0: /tmp/tmpgve2n5s0.cpp:37: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085847
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = arr[0];\n    long smalest_index = 0;\n    for (long i = 1; i < arr.size();\
    \ i++) {\n        if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n\
    \            smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpxy8ftpya: /tmp/tmpxy8ftpya.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085859
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    int smalest_index = 0;\n    for (int i = 1; i < arr.size(); i++) {\n    \
    \    if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n    \
    \        smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpuqu6tebb: /tmp/tmpuqu6tebb.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085859
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n  \
    \      if (arr[i] % 2 == 0) {\n            if (arr[i] < smalest_value) {\n   \
    \             smalest_value = arr[i];\n                smalest_index = i;\n  \
    \          }\n        }\n    }\n    std::vector<long> result;\n    if (smalest_index\
    \ != 0) {\n        result.push_back(smalest_value);\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpdqownxkb: /tmp/tmpdqownxkb.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085858
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long smalest_index_value = 0;\n    long\
    \ smalest_index_value2 = 0;\n    long smalest_index_value3 = 0;\n    long smalest_index_value4\
    \ = 0;\n    long smalest_index_value5 = 0;\n    long smalest_index_value6 = 0;\n\
    \    long smalest_index_value7 = 0;\n    long smalest_index_value8 = 0;\n    long\
    \ smalest_index_value9 = 0;\n    long smalest_index_value10 = 0;\n    long smalest_index_value11\
    \ = 0;\n    long smalest_index_value12 = 0;\n    long smalest_index_value13 =\
    \ 0;\n    long smalest_index_value14 = 0;\n    long smalest_index_value15 = 0;\n\
    \    long smalest_index_value16 = 0;\n    long smalest_index_value17 = 0;\n  \
    \  long smalest_index_value18 = 0;\n    long smalest_index_value19 = 0;\n    long\
    \ smalest_index_value20 = 0;\n    long smalest_index_value21 = 0;\n    long smalest_index_value22\
    \ = 0;\n    long smalest_index_value23 = 0;\n    long smalest_index_value24 =\
    \ 0;\n    long smalest_index_value25 = 0;\n    long smalest_index_value26 = 0;\n\
    \    long smalest_index_value27 = 0;\n    long smalest_index_value28 = 0;\n  \
    \  long smalest_index_value29 = 0;\n    long smalest_index_value30 = 0;\n    long\
    \ smalest_index_value31 = 0;\n    long smalest_index_value32 = 0;\n    long smalest_index_value33\
    \ = 0;\n    long smalest_index_value34 = 0;\n    long smalest_index_value35 =\
    \ 0;\n    long smalest_index_value36 = 0;\n    long smalest_index_value37 = 0;\n\
    \    long smalest_index_value38 = 0;\n    long smalest_index_value39 = 0;\n  \
    \  long smalest_index_value40 = 0;\n    long smalest_index_value41 = 0;\n    long\
    \ smalest_index_value42 = 0;\n    long smalest_index_value43 = 0;\n    long smalest_index_value44\
    \ = 0;\n    long smalest_index_value45 = 0;\n    long smalest_index_value46 =\
    \ 0;\n    long smalest_index_value47 = 0;\n    long smalest_index_value48 = 0;\n\
    \    long smalest_index_value49 = 0;\n    long smalest_index_value\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp368gtnl0.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp368gtnl0.cpp:74:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   74 | }\n      | ^\n/tmp/tmp368gtnl0.cpp:74:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660085859
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    int smallest_index = -1;\n    for (int i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smallest_index = i;\n        }\n    }\n    if (smallest_index == -1)\
    \ {\n        return {};\n    }\n    std::vector<long> ans;\n    ans.push_back(smalest_value);\n\
    \    ans.push_back(smallest_index);\n    return ans;\n}\nint main() {\n    auto\
    \ candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4, (long)2,\
    \ (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp8ky0rj79: /tmp/tmp8ky0rj79.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085859
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long smallest_even_value = 0;\n    for (long\
    \ i = 1; i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if\
    \ (arr[i] < smallest_even_value) {\n                smallest_even_value = arr[i];\n\
    \                smalest_value = arr[i];\n                smalest_index = i;\n\
    \            }\n        }\n    }\n    std::vector<long> result;\n    if (smallest_even_value\
    \ == 0) {\n        return result;\n    }\n    result.push_back(smallest_even_value);\n\
    \    result.push_back(smalest_index);\n    return result;\n}\nint main() {\n \
    \   auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp1zcfx0t3: /tmp/tmp1zcfx0t3.cpp:43: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085859
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smallest_index = -1;\n    long smallest_even_value = arr[0];\n    long\
    \ smallest_even_index = -1;\n    for (long i = 1; i < arr.size(); i++) {\n   \
    \     if (arr[i] % 2 == 0) {\n            if (arr[i] < smallest_even_value) {\n\
    \                smallest_even_value = arr[i];\n                smallest_even_index\
    \ = i;\n            }\n            if (arr[i] < smallest_value) {\n          \
    \      smallest_value = arr[i];\n                smallest_index = i;\n       \
    \     }\n        }\n    }\n    std::vector<long> result;\n    if (smallest_even_index\
    \ != -1) {\n        result.push_back(smallest_even_value);\n        result.push_back(smallest_even_index);\n\
    \    } else {\n        result.push_back(smallest_value);\n        result.push_back(-1);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpj3p7osbw.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpj3p7osbw.cpp:31:26: error: \u2018smallest_value\u2019\
    \ was not declared in this scope; did you mean \u2018smalest_value\u2019?\n  \
    \ 31 |             if (arr[i] < smallest_value) {\n      |                   \
    \       ^~~~~~~~~~~~~~\n      |                          smalest_value\n/tmp/tmpj3p7osbw.cpp:42:26:\
    \ error: \u2018smallest_value\u2019 was not declared in this scope; did you mean\
    \ \u2018smalest_value\u2019?\n   42 |         result.push_back(smallest_value);\n\
    \      |                          ^~~~~~~~~~~~~~\n      |                    \
    \      smalest_value\n"
  stdout: ''
  timestamp: 1660085859
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = 0;\n\
    \    long smalest_index = 0;\n    long smalest_index_of_smalest_value = 0;\n \
    \   long smalest_index_of_smalest_value2 = 0;\n    long smalest_index_of_smalest_value3\
    \ = 0;\n    long smalest_index_of_smalest_value4 = 0;\n    long smalest_index_of_smalest_value5\
    \ = 0;\n    long smalest_index_of_smalest_value6 = 0;\n    long smalest_index_of_smalest_value7\
    \ = 0;\n    long smalest_index_of_smalest_value8 = 0;\n    long smalest_index_of_smalest_value9\
    \ = 0;\n    long smalest_index_of_smalest_value10 = 0;\n    long smalest_index_of_smalest_value11\
    \ = 0;\n    long smalest_index_of_smalest_value12 = 0;\n    long smalest_index_of_smalest_value13\
    \ = 0;\n    long smalest_index_of_smalest_value14 = 0;\n    long smalest_index_of_smalest_value15\
    \ = 0;\n    long smalest_index_of_smalest_value16 = 0;\n    long smalest_index_of_smalest_value17\
    \ = 0;\n    long smalest_index_of_smalest_value18 = 0;\n    long smalest_index_of_smalest_value19\
    \ = 0;\n    long smalest_index_of_smalest_value20 = 0;\n    long smalest_index_of_smalest_value21\
    \ = 0;\n    long smalest_index_of_smalest_value22 = 0;\n    long smalest_index_of_smalest_value23\
    \ = 0;\n    long smalest_index_of_smalest_value24 = 0;\n    long smalest_index_of_smalest_value25\
    \ = 0;\n    long smalest_index_of_smalest_value26 = 0;\n    long smalest_index_of_smalest_value27\
    \ = 0;\n    long smalest_index_of_smalest_value28 = 0;\n    long smalest_index_of_smalest_value29\
    \ = 0;\n    long smalest_index_of_smalest_value30 = 0;\n    long smalest_index_of_smalest_value31\
    \ = 0;\n    long smalest_index_of_smalest_value32 = 0;\n    long smalest_index_of_smalest_value33\
    \ = 0;\n    long smalest_index_of_smalest_value34 = 0;\n    long smalest_index_of_smalest_value35\
    \ = 0;\n    long smalest_index_of_smalest_value\n}\nint main() {\n    auto candidate\
    \ = pluck;\n    assert(candidate((std::vector<long>({(long)4, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpojxym5be.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpojxym5be.cpp:59:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   59 | }\n      | ^\n/tmp/tmpojxym5be.cpp:59:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660085859
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = arr[0];\n    long smalest_index = 0;\n    long smalest_index_value = arr[0];\n\
    \    for (long i = 1; i < arr.size(); i++) {\n        if (arr[i] < smalest_value)\
    \ {\n            smalest_value = arr[i];\n            smalest_index = i;\n   \
    \         smalest_index_value = arr[i];\n        }\n    }\n    std::vector<long>\
    \ ans;\n    ans.push_back(smalest_value);\n    ans.push_back(smalest_index);\n\
    \    return ans;\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp1znu8j_f: /tmp/tmp1znu8j_f.cpp:40: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085859
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smallest_value\
    \ = 0;\n    long smallest_index = 0;\n    long index = 0;\n    for (long i = 0;\
    \ i < arr.size(); i++) {\n        if (arr[i] % 2 == 0) {\n            if (smallest_value\
    \ == 0) {\n                smallest_value = arr[i];\n                smallest_index\
    \ = i;\n            } else if (arr[i] < smallest_value) {\n                smallest_value\
    \ = arr[i];\n                smallest_index = i;\n            }\n        }\n \
    \   }\n    std::vector<long> result;\n    if (smallest_value != 0) {\n       \
    \ result.push_back(smallest_value);\n        result.push_back(smallest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmplwp7t1e_: /tmp/tmplwp7t1e_.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)5,
    (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,
    (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085859
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // Your code here\n    long\
    \ smalest_value = arr[0];\n    long smalest_index = 0;\n    long smalest_index_value\
    \ = arr[0];\n    for (int i = 1; i < arr.size(); i++) {\n        if (arr[i] <\
    \ smalest_value) {\n            smalest_value = arr[i];\n            smalest_index\
    \ = i;\n            smalest_index_value = arr[i];\n        }\n    }\n    std::vector<long>\
    \ result;\n    if (smalest_index_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    } else {\n        result.push_back(smalest_value);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpegctmvgp: /tmp/tmpegctmvgp.cpp:44: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085859
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long smallest_index = 0;\n    long smallest_value\
    \ = 0;\n    long index = 0;\n    for (auto i : arr) {\n        if (i % 2 == 0)\
    \ {\n            if (smallest_value == 0) {\n                smallest_value =\
    \ i;\n                smallest_index = index;\n            } else if (smallest_value\
    \ < i) {\n                smallest_value = i;\n                smallest_index\
    \ = index;\n            }\n            index++;\n        }\n    }\n    if (smallest_value\
    \ == 0) {\n        return {};\n    }\n    std::vector<long> result;\n    result.push_back(smallest_value);\n\
    \    result.push_back(smallest_index);\n    return result;\n}\nint main() {\n\
    \    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp8_q4q7tx: /tmp/tmp8_q4q7tx.cpp:49: int main(): Assertion `candidate((std::vector<long>({(long)4,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085859
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpb__mwrec: /tmp/tmpb__mwrec.cpp:39: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = 0;\n\
    \    long smalest_index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n  \
    \      if (arr[i] % 2 == 0) {\n            if (smalest_value == 0) {\n       \
    \         smalest_value = arr[i];\n                smalest_index = i;\n      \
    \      } else {\n                if (arr[i] < smalest_value) {\n             \
    \       smalest_value = arr[i];\n                    smalest_index = i;\n    \
    \            }\n            }\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value != 0) {\n        result.push_back(smalest_value);\n   \
    \     result.push_back(smalest_index);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpuyx4db4y: /tmp/tmpuyx4db4y.cpp:48: int main(): Assertion `candidate((std::vector<long>({(long)5,
    (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,
    (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085859
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long smalest_even_value = 0;\n    long\
    \ smalest_even_index = 0;\n    long smalest_even_index_temp = 0;\n    long smalest_even_index_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp = 0;\n    long smalest_even_index_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp = 0;\n\
    \    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n  \
    \  long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp = 0;\n\
    \    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n    long sm\n}\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpl1h0lq1x.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpl1h0lq1x.cpp:36:10: error: redeclaration of \u2018long\
    \ int smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\u2019\
    \n   36 |     long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpl1h0lq1x.cpp:35:10: note: \u2018long int smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\u2019\
    \ previously declared here\n   35 |     long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpl1h0lq1x.cpp:40:10: error: redeclaration of \u2018long int smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\u2019\
    \n   40 |     long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpl1h0lq1x.cpp:39:10: note: \u2018long int smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\u2019\
    \ previously declared here\n   39 |     long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpl1h0lq1x.cpp:42:10: error: redeclaration of \u2018long int smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\u2019\
    \n   42 |     long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\
    \ = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmpl1h0lq1x.cpp:41:10: note: \u2018long int smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp\u2019\
    \ previously declared here\n   41 |     long smalest_even_index_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_temp_t"
  stdout: ''
  timestamp: 1660085859
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    for (long i = 1; i < arr.size(); i++) {\n  \
    \      if (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n  \
    \          smalest_index = i;\n        }\n    }\n    std::vector<long> result;\n\
    \    if (smalest_value % 2 == 0) {\n        result.push_back(smalest_value);\n\
    \        result.push_back(smalest_index);\n    } else {\n        result.push_back(smalest_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmp1jm38vav: /tmp/tmp1jm38vav.cpp:41: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085845
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    long smalest_value = arr[0];\n\
    \    long smalest_index = 0;\n    long smalest_even_value = 0;\n    long smalest_even_count\
    \ = 0;\n    long smalest_even_index = 0;\n    for (long i = 0; i < arr.size();\
    \ i++) {\n        if (arr[i] % 2 == 0) {\n            smalest_even_value = arr[i];\n\
    \            smalest_even_count++;\n            if (smalest_even_count == 1) {\n\
    \                smalest_even_index = i;\n            }\n        }\n        if\
    \ (arr[i] < smalest_value) {\n            smalest_value = arr[i];\n          \
    \  smalest_index = i;\n        }\n    }\n    if (smalest_even_count == 0) {\n\
    \        return {};\n    }\n    std::vector<long> result;\n    result.push_back(smalest_value);\n\
    \    result.push_back(smalest_index);\n    if (smalest_even_count == 1) {\n  \
    \      result.push_back(smalest_even_index);\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpqyzknunf: /tmp/tmpqyzknunf.cpp:53: int main(): Assertion `candidate((std::vector<long>({(long)1,
    (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085860
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // write your code here\n\
    \    long smalest_value = 0;\n    long smalest_index = 0;\n    long smalest_index_value\
    \ = 0;\n    long smalest_index_value2 = 0;\n    long smalest_index_value3 = 0;\n\
    \    long smalest_index_value4 = 0;\n    long smalest_index_value5 = 0;\n    long\
    \ smalest_index_value6 = 0;\n    long smalest_index_value7 = 0;\n    long smalest_index_value8\
    \ = 0;\n    long smalest_index_value9 = 0;\n    long smalest_index_value10 = 0;\n\
    \    long smalest_index_value11 = 0;\n    long smalest_index_value12 = 0;\n  \
    \  long smalest_index_value13 = 0;\n    long smalest_index_value14 = 0;\n    long\
    \ smalest_index_value15 = 0;\n    long smalest_index_value16 = 0;\n    long smalest_index_value17\
    \ = 0;\n    long smalest_index_value18 = 0;\n    long smalest_index_value19 =\
    \ 0;\n    long smalest_index_value20 = 0;\n    long smalest_index_value21 = 0;\n\
    \    long smalest_index_value22 = 0;\n    long smalest_index_value23 = 0;\n  \
    \  long smalest_index_value24 = 0;\n    long smalest_index_value25 = 0;\n    long\
    \ smalest_index_value26 = 0;\n    long smalest_index_value27 = 0;\n    long smalest_index_value28\
    \ = 0;\n    long smalest_index_value29 = 0;\n    long smalest_index_value30 =\
    \ 0;\n    long smalest_index_value31 = 0;\n    long smalest_index_value32 = 0;\n\
    \    long smalest_index_value33 = 0;\n    long smalest_index_value34 = 0;\n  \
    \  long smalest_index_value35 = 0;\n    long smalest_index_value36 = 0;\n    long\
    \ smalest_index_value37 = 0;\n    long smalest_index_value38 = 0;\n    long smalest_index_value39\
    \ = 0;\n    long smalest_index_value40 = 0;\n    long smalest_index_value41 =\
    \ 0;\n    long smalest_index_value42 = 0;\n    long smalest_index_value43 = 0;\n\
    \    long smalest_index_value44 = 0;\n    long smalest_index_value45 = 0;\n  \
    \  long smalest_index_value46 = 0;\n    long smalest_index_value47 = 0;\n    long\
    \ smalest_index_value48 = 0;\n    long smalest_index_value49 = 0;\n    long smalest_index_\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7yhie042.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmp7yhie042.cpp:74:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   74 | }\n      | ^\n/tmp/tmp7yhie042.cpp:74:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660085855
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long smallest_even_value = 0;\n    long\
    \ smallest_even_index = 0;\n    for (long i = 0; i < arr.size(); i++) {\n    \
    \    if (arr[i] % 2 == 0) {\n            if (smallest_even_value == 0) {\n   \
    \             smallest_even_value = arr[i];\n                smallest_even_index\
    \ = i;\n            } else if (arr[i] < smallest_even_value) {\n             \
    \   smallest_even_value = arr[i];\n                smallest_even_index = i;\n\
    \            }\n        }\n    }\n    std::vector<long> result;\n    if (smallest_even_value\
    \ != 0) {\n        result.push_back(smallest_even_value);\n        result.push_back(smallest_even_index);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = pluck;\n   \
    \ assert(candidate((std::vector<long>({(long)4, (long)2, (long)3}))) == (std::vector<long>({(long)2,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3})))\
    \ == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: Exception
  stderr: 'tmpoi34tyc6: /tmp/tmpoi34tyc6.cpp:49: int main(): Assertion `candidate((std::vector<long>({(long)5,
    (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,
    (long)1}))'' failed.

    '
  stdout: ''
  timestamp: 1660085860
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// \"Given an array representing\
    \ a branch of a tree that has non-negative integer nodes\n// your task is to pluck\
    \ one of the nodes and return it.\n// The plucked node should be the node with\
    \ the smallest even value.\n// If multiple nodes with the same smallest even value\
    \ are found return the node that has smallest index.\n// The plucked node should\
    \ be returned in a list, [ smalest_value, its index ],\n// If there are no even\
    \ values or the given array is empty, return [].\n// Example 1:\n// Explanation:\
    \ 2 has the smallest even value, and 2 has the smallest index.\n// Example 2:\n\
    // Explanation: 2 has the smallest even value, and 2 has the smallest index.\n\
    // Example 3:\n// Example 4:\n// Explanation: 0 is the smallest value, but  there\
    \ are two zeros,\n// so we will choose the first zero, which has the smallest\
    \ index.\n// Constraints:\n// * 1 <= nodes.length <= 10000\n// * 0 <= node.value\n\
    std::vector<long> pluck(std::vector<long> arr) {\n    // code here\n    long smalest_value\
    \ = 0;\n    long smalest_index = 0;\n    long smalest_even_value = 0;\n    long\
    \ smalest_even_index = 0;\n    long smalest_even_index_count = 0;\n    long smalest_even_index_count_max\
    \ = 0;\n    long smalest_even_index_count_min = 0;\n    long smalest_even_index_count_min_index\
    \ = 0;\n    long smalest_even_index_count_min_index2 = 0;\n    long smalest_even_index_count_min_index3\
    \ = 0;\n    long smalest_even_index_count_min_index4 = 0;\n    long smalest_even_index_count_min_index5\
    \ = 0;\n    long smalest_even_index_count_min_index6 = 0;\n    long smalest_even_index_count_min_index7\
    \ = 0;\n    long smalest_even_index_count_min_index8 = 0;\n    long smalest_even_index_count_min_index9\
    \ = 0;\n    long smalest_even_index_count_min_index10 = 0;\n    long smalest_even_index_count_min_index11\
    \ = 0;\n    long smalest_even_index_count_min_index12 = 0;\n    long smalest_even_index_count_min_index13\
    \ = 0;\n    long smalest_even_index_count_min_index14 = 0;\n    long smalest_even_index_count_min_index15\
    \ = 0;\n    long smalest_even_index_count_min_index16 = 0;\n    long smalest_even_index_count_min_index17\
    \ = 0;\n    long smalest_even_index_count_min_index18 = 0;\n    long smalest_even_index_count_min_index19\
    \ = 0;\n    long smalest_even_index_count_min_index20 = 0;\n    long smalest_even_index_count_min_index21\
    \ = 0;\n    long smalest_even_index_count_min_index22 = 0;\n    long smalest_even_index_count_min_index23\
    \ = 0;\n    long smalest_even_index_count_min_index24 = 0;\n    long smalest_even_index_count_min_index25\
    \ = 0;\n    long smalest_even_index_count_min_index26 = 0;\n    long smalest_even_index_count_min_index27\
    \ = 0;\n    long smalest_even_index_count_min_index28 = 0;\n    long smalest_even_index_count_min_index29\
    \ = 0;\n    long smalest_even_index_count_min_index30 = 0;\n    long smalest_even_index_count_min_index31\
    \ = 0;\n    long smalest_even_index_count_min_index32 = 0;\n    long smalest_even_index_count_min_index33\
    \ = 0;\n    long smalest_even_index_count_min_index34 = 0;\n    long smalest_even\n\
    }\nint main() {\n    auto candidate = pluck;\n    assert(candidate((std::vector<long>({(long)4,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>({(long)1,\
    \ (long)2, (long)3}))) == (std::vector<long>({(long)2, (long)1})));\n    assert(candidate((std::vector<long>()))\
    \ == (std::vector<long>()));\n    assert(candidate((std::vector<long>({(long)5,\
    \ (long)0, (long)3, (long)0, (long)4, (long)2}))) == (std::vector<long>({(long)0,\
    \ (long)1})));\n    assert(candidate((std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)0, (long)5, (long)3}))) == (std::vector<long>({(long)0, (long)3})));\n\
    \    assert(candidate((std::vector<long>({(long)5, (long)4, (long)8, (long)4,\
    \ (long)8}))) == (std::vector<long>({(long)4, (long)1})));\n    assert(candidate((std::vector<long>({(long)7,\
    \ (long)6, (long)7, (long)1}))) == (std::vector<long>({(long)6, (long)1})));\n\
    \    assert(candidate((std::vector<long>({(long)7, (long)9, (long)7, (long)1})))\
    \ == (std::vector<long>()));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxh4xllpf.cpp: In function \u2018std::vector<long int> pluck(std::vector<long\
    \ int>)\u2019:\n/tmp/tmpxh4xllpf.cpp:64:1: error: expected initializer before\
    \ \u2018}\u2019 token\n   64 | }\n      | ^\n/tmp/tmpxh4xllpf.cpp:64:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660085852
