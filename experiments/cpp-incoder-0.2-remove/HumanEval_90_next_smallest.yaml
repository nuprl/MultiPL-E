name: HumanEval_90_next_smallest
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a list of integers.\n\
  // Write a function next_smallest() that returns the 2nd smallest element of the\
  \ list.\n// Return None if there is no such element.\nstd::optional<long> next_smallest(std::vector<long>\
  \ lst) {\n"
tests: "}\nint main() {\n    auto candidate = next_smallest;\n    assert(candidate((std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4, (long)5}))) == 2);\n    assert(candidate((std::vector<long>({(long)5,\
  \ (long)1, (long)4, (long)3, (long)2}))) == 2);\n    assert(candidate((std::vector<long>()))\
  \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)1, (long)1})))\
  \ == std::nullopt);\n    assert(candidate((std::vector<long>({(long)1, (long)1,\
  \ (long)1, (long)1, (long)0}))) == 1);\n    assert(candidate((std::vector<long>({(long)1,\
  \ (long)1}))) == std::nullopt);\n    assert(candidate((std::vector<long>({(long)-35,\
  \ (long)34, (long)12, (long)-45}))) == -35);\n}\n"
completions: ["    if (lst.size() == 0) {\n        return std::nullopt;\n    }\n \
    \   auto it = lst.begin();\n    auto prev = *it;\n    for (++it; it != lst.end();\
    \ ++it) {\n        if (*it < prev) {\n            return std::nullopt;\n     \
    \   }\n        prev = *it;\n    }\n    return prev;", "    // Your code here\n\
    \    long smallest = *std::min_element(lst.begin(), lst.end());\n    long second_smallest\
    \ = *std::min_element(lst.begin(), lst.end(), [&smallest](long a, long b){return\
    \ a<b;});\n    return second_smallest == smallest ? std::nullopt : second_smallest;",
  "    long min = lst[0];\n    long max = lst[0];\n    for (long i : lst) {\n    \
    \    if (i < min) {\n            min = i;\n        } else if (i > max) {\n   \
    \         max = i;\n        }\n    }\n    if (min == max) {\n        return std::nullopt;\n\
    \    }\n    return max;", "    // Your code here\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    long second_smallest = *std::min_element(lst.begin(), lst.end(),\
    \ [&smallest](long a, long b){return (a<smallest?a:b)<(b<smallest?b:a);});\n \
    \   return second_smallest == smallest ? std::nullopt : second_smallest;", " \
    \   if (lst.empty()) return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end()) return std::nullopt;\n    return *it;",
  "    long smallest = *std::min_element(lst.begin(), lst.end());\n    auto it = std::find(lst.begin(),\
    \ lst.end(), smallest);\n    if (it != lst.end()) {\n        smallest = *it;\n\
    \    }\n    return smallest;", "    if (lst.empty()) return std::nullopt;\n  \
    \  long smallest = *std::min_element(lst.begin(), lst.end());\n    auto it = std::find(lst.begin(),\
    \ lst.end(), smallest);\n    if (it != lst.end()) return *it;\n    return std::nullopt;",
  "    // Your code here\n    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    long second_smallest = *std::min_element(lst.begin(), lst.end(), [&smallest](long\
    \ a, long b){return a<b?a:b;});\n    return second_smallest == smallest ? std::nullopt\
    \ : second_smallest;", "    if (lst.size() == 0)\n        return std::nullopt;\n\
    \    long smallest = *std::min_element(lst.begin(), lst.end());\n    long second_smallest\
    \ = *std::min_element(lst.begin(), lst.end(), [&smallest](long a, long b) { return\
    \ a < b; });\n    if (second_smallest == smallest)\n        return std::nullopt;\n\
    \    return second_smallest;", "    if (lst.size() == 0) return std::nullopt;\n\
    \    auto it = lst.begin();\n    auto prev = *it;\n    ++it;\n    if (it == lst.end())\
    \ return std::nullopt;\n    auto next = *it;\n    if (next < prev) return std::nullopt;\n\
    \    if (next == prev) return next;\n    while (it != lst.end()) {\n        prev\
    \ = *it;\n        ++it;\n        if (it == lst.end()) return std::nullopt;\n \
    \       next = *it;\n        if (next < prev) return std::nullopt;\n        if\
    \ (next == prev) return next;\n    }\n    return std::nullopt;", "    // Your\
    \ code here\n    long smallest = std::numeric_limits<long>::max();\n    long secondSmallest\
    \ = std::numeric_limits<long>::max();\n    for (long i : lst) {\n        if (i\
    \ < smallest) {\n            secondSmallest = smallest;\n            smallest\
    \ = i;\n        } else if (i < secondSmallest) {\n            secondSmallest =\
    \ i;\n        }\n    }\n    return secondSmallest;", "    if (lst.size() == 0)\
    \ {\n        return std::nullopt;\n    }\n    auto it = lst.begin();\n    auto\
    \ prev = *it;\n    ++it;\n    if (it == lst.end()) {\n        return std::nullopt;\n\
    \    }\n    auto next = *it;\n    if (prev < next) {\n        std::swap(prev,\
    \ next);\n    }\n    return next;", "    // Your code here\n    long min = lst[0];\n\
    \    long max = lst[0];\n    for (long i : lst) {\n        if (i < min) {\n  \
    \          min = i;\n        } else if (i > max) {\n            max = i;\n   \
    \     }\n    }\n    return max;", "    if (lst.size() == 0)\n        return std::nullopt;\n\
    \    long min = *std::min_element(lst.begin(), lst.end());\n    long max = *std::max_element(lst.begin(),\
    \ lst.end());\n    if (min == max)\n        return min;\n    if (min > max)\n\
    \        return std::nullopt;\n    long mid = min + (max - min) / 2;\n    return\
    \ next_smallest(std::vector<long>{lst.begin() + mid, lst.end()});", "    if(lst.size()\
    \ == 0)\n        return std::nullopt;\n    long min = lst[0];\n    long max =\
    \ lst[0];\n    for(long i : lst) {\n        if(i < min)\n            min = i;\n\
    \        if(i > max)\n            max = i;\n    }\n    if(min == max)\n      \
    \  return std::nullopt;\n    for(long i : lst) {\n        if(i < min)\n      \
    \      min = i;\n        if(i > max)\n            max = i;\n    }\n    return\
    \ max;", "    long smallest = *std::min_element(lst.begin(), lst.end());\n   \
    \ long secondSmallest = *std::min_element(lst.begin(), lst.end(), [smallest](long\
    \ a, long b) { return a < b; });\n    return secondSmallest == smallest ? std::nullopt\
    \ : secondSmallest;", "    if(lst.size() == 0)\n        return std::nullopt;\n\
    \    long smallest = *std::min_element(lst.begin(), lst.end());\n    long secondSmallest\
    \ = *std::min_element(lst.begin(), lst.end(), [&smallest](long a, long b){return\
    \ a<b?a:b;});\n    return smallest==secondSmallest?std::nullopt:secondSmallest;",
  '    // Your code here', "    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    long second_smallest = *std::min_element(lst.begin() + 1, lst.end());\n \
    \   if (second_smallest == smallest)\n        return std::nullopt;\n    return\
    \ second_smallest;", '    // Your code here', "    long min = *std::min_element(lst.begin(),\
    \ lst.end());\n    long max = *std::max_element(lst.begin(), lst.end());\n   \
    \ if (min == max) {\n        return {};\n    }\n    if (min == max) {\n      \
    \  return min;\n    }\n    if (min > max) {\n        return {};\n    }\n    return\
    \ max;", "    if (lst.size() == 0) return std::nullopt;\n    auto it = lst.begin();\n\
    \    auto prev = *it;\n    auto next = *it;\n    for (++it; it != lst.end(); ++it)\
    \ {\n        if (*it < prev) {\n            prev = *it;\n            next = *it;\n\
    \        }\n    }\n    return next;", "    if (lst.size() == 0)\n        return\
    \ std::nullopt;\n    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    long second_smallest = *std::min_element(lst.begin(), lst.begin() + 1);\n\
    \    if (second_smallest == smallest)\n        return std::nullopt;\n    return\
    \ second_smallest;", "    // Your code here\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    long second_smallest = *std::min_element(lst.begin() + 1, lst.end());\n\
    \    return second_smallest == smallest ? std::nullopt : second_smallest;", " \
    \   if(lst.empty()) return std::nullopt;\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    for(auto it = lst.begin(); it != lst.end(); ++it) {\n     \
    \   if(*it < smallest) {\n            smallest = *it;\n        }\n    }\n    return\
    \ smallest;", "    if (lst.empty())\n        return std::nullopt;\n    auto it\
    \ = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end())\n    \
    \    return std::nullopt;\n    return *std::next(it);", "    // Your code here\n\
    \    long smallest = lst[0];\n    long second_smallest = lst[0];\n    for (long\
    \ i : lst) {\n        if (i < smallest) {\n            second_smallest = smallest;\n\
    \            smallest = i;\n        } else if (i < second_smallest) {\n      \
    \      second_smallest = i;\n        }\n    }\n    return second_smallest;", " \
    \   if (lst.empty()) return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end()) return std::nullopt;\n    return *it;",
  "    if (lst.empty()) return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end()) return std::nullopt;\n    return *it;",
  "    long smallest = *std::min_element(lst.begin(), lst.end());\n    long second_smallest\
    \ = *std::min_element(lst.begin(), lst.end(), [&smallest](long a, long b) { return\
    \ a < b ? a : b; });\n    return second_smallest == smallest ? std::nullopt :\
    \ second_smallest;", "    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    long second_smallest = *std::min_element(lst.begin() + 1, lst.end());\n \
    \   if (second_smallest == smallest)\n        return std::nullopt;\n    return\
    \ second_smallest;", "    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    long index = std::distance(std::begin(lst), std::find_if(std::begin(lst),\
    \ std::end(lst), [&smallest](long x) { return x < smallest; }));\n    if (index\
    \ == lst.size()) {\n        return std::nullopt;\n    }\n    return lst[index\
    \ + 1];", "    if(lst.size() == 0) return std::nullopt;\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    for(auto it = lst.begin(); it != lst.end(); ++it) {\n     \
    \   if(*it < smallest) {\n            smallest = *it;\n        }\n    }\n    return\
    \ smallest;", "    if (lst.size() == 0) {\n        return std::nullopt;\n    }\n\
    \    long smallest = lst[0];\n    long second_smallest = lst[1];\n    for (size_t\
    \ i = 2; i < lst.size(); i++) {\n        if (lst[i] < smallest) {\n          \
    \  second_smallest = smallest;\n            smallest = lst[i];\n        } else\
    \ if (lst[i] < second_smallest) {\n            second_smallest = lst[i];\n   \
    \     }\n    }\n    return second_smallest;", "    long min = std::numeric_limits<long>::max();\n\
    \    long max = std::numeric_limits<long>::min();\n    for (auto i : lst) {\n\
    \        if (i < min) {\n            min = i;\n        } else if (i > max) {\n\
    \            max = i;\n        }\n    }\n    if (min == max) {\n        return\
    \ std::nullopt;\n    }\n    return max;", "    // Your code here\n    if(lst.size()\
    \ == 0)\n        return std::nullopt;\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    for(long i : lst) {\n        if(i < smallest)\n           \
    \ smallest = i;\n    }\n    return smallest;", "    // Write your code here\n\
    \    long min = std::numeric_limits<long>::min();\n    long max = std::numeric_limits<long>::max();\n\
    \    for (long i : lst) {\n        if (i < min) {\n            min = i;\n    \
    \    }\n        if (i > max) {\n            max = i;\n        }\n    }\n    if\
    \ (min == max) {\n        return std::nullopt;\n    }\n    return max;", "   \
    \ if (lst.empty()) return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end()) return std::nullopt;\n    return *it;",
  "    if (lst.empty())\n        return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end())\n        return std::nullopt;\n    return\
    \ *it;", "    // Your code here\n    long smallest = lst[0];\n    long second_smallest\
    \ = lst[0];\n    for (long i : lst) {\n        if (i < smallest) {\n         \
    \   second_smallest = smallest;\n            smallest = i;\n        } else if\
    \ (i == smallest) {\n            second_smallest = i;\n        }\n    }\n    return\
    \ second_smallest;", "    if (lst.size() == 0) {\n        return std::nullopt;\n\
    \    }\n    long smallest = *std::min_element(lst.begin(), lst.end());\n    long\
    \ second_smallest = *std::min_element(lst.begin() + 1, lst.end());\n    if (smallest\
    \ == second_smallest) {\n        return std::nullopt;\n    }\n    return second_smallest;",
  "    long min = lst[0];\n    long max = lst[0];\n    for (long i : lst) {\n    \
    \    if (i < min) {\n            min = i;\n        } else if (i > max) {\n   \
    \         max = i;\n        }\n    }\n    return std::nullopt;", "    long min\
    \ = std::numeric_limits<long>::max();\n    long max = std::numeric_limits<long>::min();\n\
    \    for (long i : lst) {\n        if (i < min) {\n            min = i;\n    \
    \    }\n        if (i > max) {\n            max = i;\n        }\n    }\n    if\
    \ (min == max) {\n        return std::nullopt;\n    }\n    return max;", "   \
    \ if (lst.size() == 0)\n        return std::nullopt;\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    long second_smallest = *std::min_element(lst.begin(), lst.end(),\
    \ [smallest](long a, long b) { return a < b ? a : b; });\n    if (second_smallest\
    \ == smallest)\n        return std::nullopt;\n    return second_smallest;", " \
    \   long smallest = *std::min_element(lst.begin(), lst.end());\n    long secondSmallest\
    \ = *std::min_element(lst.begin() + 1, lst.end());\n    return std::optional<long>(secondSmallest\
    \ < smallest ? secondSmallest : smallest);", "    if (lst.size() == 0)\n     \
    \   return std::nullopt;\n    long cur = *lst.begin();\n    long prev = cur;\n\
    \    for (auto it = lst.begin() + 1; it != lst.end(); ++it) {\n        if (*it\
    \ < prev)\n            return std::nullopt;\n        prev = *it;\n    }\n    return\
    \ cur;", "    long smallest = *std::min_element(lst.begin(), lst.end());\n   \
    \ if (lst.size() == 1) {\n        return std::nullopt;\n    }\n    for (long i\
    \ = lst.size() - 2; i >= 0; i--) {\n        if (lst[i] < smallest) {\n       \
    \     smallest = lst[i];\n        }\n    }\n    return smallest;", "    if (lst.empty())\n\
    \        return std::nullopt;\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    auto it = std::find(lst.begin(), lst.end(), smallest);\n  \
    \  if (it == lst.end())\n        return std::nullopt;\n    lst.erase(it);\n  \
    \  return smallest;", "    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    long second_smallest = *std::min_element(lst.begin() + 1, lst.end());\n \
    \   return second_smallest < smallest ? second_smallest : std::nullopt;", "  \
    \  if(lst.size() == 0)\n        return std::nullopt;\n    long min = lst[0];\n\
    \    long max = lst[0];\n    for(long i = 1; i < lst.size(); i++) {\n        if(lst[i]\
    \ < min)\n            min = lst[i];\n        if(lst[i] > max)\n            max\
    \ = lst[i];\n    }\n    return max == min ? std::nullopt : max;", "    if (lst.empty())\
    \ return std::nullopt;\n    long min = *std::min_element(lst.begin(), lst.end());\n\
    \    long max = *std::max_element(lst.begin(), lst.end());\n    if (min == max)\
    \ return min;\n    if (min > max) return std::nullopt;\n    if (min == lst.back())\
    \ return min;\n    if (lst.size() == 2) return min;\n    if (lst.size() == 3)\
    \ return std::nullopt;\n    std::vector<long> sub = lst;\n    sub.pop_back();\n\
    \    return next_smallest(sub);", "    if(lst.size() == 0) return std::nullopt;\n\
    \    long smallest = *std::min_element(lst.begin(), lst.end());\n    for(auto\
    \ it = lst.begin(); it != lst.end(); ++it) {\n        if(*it < smallest) {\n \
    \           smallest = *it;\n        }\n    }\n    return smallest;", "    if(lst.size()\
    \ == 0)\n        return std::nullopt;\n    long curr = lst[0];\n    for(long i\
    \ = 1; i < lst.size(); i++) {\n        if(curr < lst[i]) {\n            curr =\
    \ lst[i];\n        }\n    }\n    return curr;", "    if (lst.size() == 0)\n  \
    \      return std::nullopt;\n    long min = *std::min_element(lst.begin(), lst.end());\n\
    \    auto it = std::find_if(lst.begin(), lst.end(), [min](long x) { return x <\
    \ min; });\n    if (it == lst.end())\n        return std::nullopt;\n    return\
    \ *it;", "    if (lst.empty()) return std::nullopt;\n    long min = lst[0];\n\
    \    long max = lst[0];\n    for (long i : lst) {\n        if (i < min) {\n  \
    \          min = i;\n        } else if (i > max) {\n            max = i;\n   \
    \     }\n    }\n    return max == min ? std::nullopt : max;", "    if (lst.size()\
    \ == 0)\n        return std::nullopt;\n    long min = lst[0];\n    for (long i\
    \ : lst)\n        if (i < min)\n            min = i;\n    return min;", "    if\
    \ (lst.size() == 0) {\n        return std::nullopt;\n    }\n    long smallest\
    \ = *std::min_element(lst.begin(), lst.end());\n    long second_smallest = *std::min_element(std::next(lst.begin()),\
    \ lst.end());\n    if (second_smallest == smallest) {\n        return std::nullopt;\n\
    \    }\n    return second_smallest;", "    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    long second_smallest = *std::min_element(std::next(lst.begin()),\
    \ lst.end());\n    return std::make_optional(second_smallest < smallest ? second_smallest\
    \ : smallest);", "    long min = lst[0];\n    long max = lst[0];\n    for (long\
    \ i : lst) {\n        if (i < min) {\n            min = i;\n        } else if\
    \ (i > max) {\n            max = i;\n        }\n    }\n    if (min == max) {\n\
    \        return std::nullopt;\n    }\n    return max;", "    if (lst.size() ==\
    \ 0) {\n        return std::nullopt;\n    }\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    auto it = std::find(lst.begin(), lst.end(), smallest);\n  \
    \  if (it == lst.end()) {\n        return std::nullopt;\n    }\n    return *std::next(it);",
  "    long smallest = *std::min_element(lst.begin(), lst.end());\n    long secondSmallest\
    \ = *std::min_element(lst.begin(), lst.end(), [&smallest](long a, long b){return\
    \ a<b?a:b;});\n    return secondSmallest < smallest ? secondSmallest : std::nullopt;",
  "    long smallest = *std::min_element(lst.begin(), lst.end());\n    long second_smallest\
    \ = *std::min_element(lst.begin(), lst.end(), [&smallest](int i) { return i <\
    \ smallest; });\n    return second_smallest == lst.end() ? std::nullopt : second_smallest;",
  "    if (lst.size() == 0) {\n        return std::nullopt;\n    }\n    long smallest\
    \ = *std::min_element(lst.begin(), lst.end());\n    auto it = std::find(lst.begin(),\
    \ lst.end(), smallest);\n    if (it == lst.end()) {\n        return std::nullopt;\n\
    \    }\n    long second = *std::next(it);\n    return std::make_optional(std::min(smallest,\
    \ second));", "    if (lst.size() == 0) {\n        return std::nullopt;\n    }\n\
    \    long smallest = lst[0];\n    for (long i : lst) {\n        if (i < smallest)\
    \ {\n            smallest = i;\n        }\n    }\n    return smallest;", "   \
    \ long min = std::numeric_limits<long>::min();\n    long max = std::numeric_limits<long>::max();\n\
    \    long mid = std::numeric_limits<long>::max();\n    for (long i : lst) {\n\
    \        if (i < min) {\n            min = i;\n        } else if (i > max) {\n\
    \            max = i;\n        } else {\n            mid = i;\n        }\n   \
    \ }\n    if (mid == min) {\n        return std::nullopt;\n    }\n    if (mid ==\
    \ max) {\n        return std::nullopt;\n    }\n    if (mid < min) {\n        return\
    \ std::nullopt;\n    }\n    if (mid > max) {\n        return std::nullopt;\n \
    \   }\n    return mid;", "    long min = std::numeric_limits<long>::max();\n \
    \   long max = std::numeric_limits<long>::min();\n    for (long i : lst) {\n \
    \       if (i < min) {\n            min = i;\n        } else if (i > max) {\n\
    \            max = i;\n        }\n    }\n    if (min == max) {\n        return\
    \ std::nullopt;\n    }\n    return max;", "    if (lst.size() == 0) {\n      \
    \  return std::nullopt;\n    }\n    long smallest = lst[0];\n    long second_smallest\
    \ = lst[1];\n    for (size_t i = 2; i < lst.size(); ++i) {\n        if (lst[i]\
    \ < smallest) {\n            second_smallest = smallest;\n            smallest\
    \ = lst[i];\n        } else if (lst[i] < second_smallest) {\n            second_smallest\
    \ = lst[i];\n        }\n    }\n    return second_smallest;", "    if (lst.size()\
    \ <= 1) return std::nullopt;\n    long min = lst[0];\n    long max = lst[0];\n\
    \    for (long i : lst) {\n        if (i < min) min = i;\n        if (i > max)\
    \ max = i;\n    }\n    if (min == max) return std::nullopt;\n    return max;",
  "    if(lst.empty()) return std::nullopt;\n    long min = lst[0];\n    long max\
    \ = lst[0];\n    for(long i : lst) {\n        if(i < min) min = i;\n        if(i\
    \ > max) max = i;\n    }\n    if(min == max) return std::nullopt;\n    return\
    \ max;", "    if (lst.empty()) return std::nullopt;\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    long second_smallest = *std::min_element(lst.begin() + 1, lst.end());\n\
    \    if (second_smallest == smallest) return std::nullopt;\n    return second_smallest;",
  "    // Your code here\n    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    long second_smallest = *std::min_element(lst.begin(), lst.end(), [&smallest](int\
    \ a, int b){return (a<smallest)?(a<b)?a:b:smallest;});\n    return second_smallest\
    \ == smallest?std::nullopt:second_smallest;", "    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    long second_smallest = *std::min_element(lst.begin() + 1, lst.end());\n\
    \    if (smallest == second_smallest)\n        return std::nullopt;\n    return\
    \ second_smallest;", "    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    long second_smallest = *std::min_element(lst.begin(), lst.end(), [smallest](long\
    \ a, long b){return a<b?a:b;});\n    return second_smallest == smallest ? std::nullopt\
    \ : second_smallest;", "    long min = lst[0];\n    long max = lst[0];\n    for\
    \ (long i : lst) {\n        if (i < min) {\n            min = i;\n        } else\
    \ if (i > max) {\n            max = i;\n        }\n    }\n    return std::nullopt;",
  "    long min = *std::min_element(lst.begin(), lst.end());\n    long max = *std::max_element(lst.begin(),\
    \ lst.end());\n    if (min == max) return {};\n    if (min > max) return {};\n\
    \    long mid = min + (max - min) / 2;\n    if (mid == *std::min_element(lst.begin(),\
    \ lst.end())) return {};\n    if (mid == *std::max_element(lst.begin(), lst.end()))\
    \ return {};\n    if (mid > max) return {};\n    return mid;", "    if (lst.size()\
    \ == 0) {\n        return std::nullopt;\n    }\n    auto it = lst.begin();\n \
    \   auto prev = *it;\n    ++it;\n    if (it == lst.end()) {\n        return std::nullopt;\n\
    \    }\n    auto next = *it;\n    if (*it < prev) {\n        std::swap(prev, next);\n\
    \    }\n    if (prev == next) {\n        return std::nullopt;\n    }\n    if (prev\
    \ < next) {\n        std::swap(prev, next);\n    }\n    if (prev == next) {\n\
    \        return std::nullopt;\n    }\n    if (prev < next) {\n        std::swap(prev,\
    \ next);\n    }\n    if (prev == next) {\n        return std::nullopt;\n    }\n\
    \    if (prev < next) {\n        std::swap(prev, next);\n    }\n    if (prev ==\
    \ next) {\n        return std::nullopt;\n    }\n    if (prev < next) {\n     \
    \   std::swap(prev, next);\n    }\n    if (prev == next) {\n        return std::nullopt;\n\
    \    }\n    if (prev < next) {\n        std::swap(prev, next);\n    }\n    if\
    \ (prev == next) {\n        return std::nullopt;\n    }\n    if (prev < next)\
    \ {\n        std::swap(prev, next);\n    }\n    if (prev == next) {\n        return\
    \ std::nullopt;\n    }\n    if (prev < next) {\n        std::swap(prev, next);\n\
    \    }\n    if (prev == next) {\n        return std::nullopt;\n    }\n    if (prev\
    \ < next) {\n        std::swap(prev, next);\n    }\n    if (prev == next) {\n\
    \        return std::nullopt;\n    }\n    if (prev < next) {\n        std::swap(prev,\
    \ next);\n    }\n    if (prev == next) {\n        return std::nullopt;\n    }\n\
    \    if (prev < next) {\n        std::swap(prev, next);\n    }\n    if (prev ==\
    \ next) {\n        return std::nullopt;\n    }\n    if (prev < next) {\n     \
    \   std::swap(prev, next);\n    }\n    if (prev == next) {\n        return std::nullopt;\n\
    \    }\n    if (prev < next) {\n        std::swap(prev, next);\n    }\n    if\
    \ (prev == next) {\n        return std::nullopt;\n    }\n    if (prev < next)\
    \ {\n        std::swap(prev, next);\n    }\n    if (prev == next) {\n        return\
    \ std::nullopt;\n    }\n    if (prev < next", "    if (lst.size() == 0) {\n  \
    \      return std::nullopt;\n    }\n    auto it = lst.begin();\n    auto end =\
    \ lst.end();\n    auto prev = *it;\n    auto next = *it;\n    for (++it; it !=\
    \ end; ++it) {\n        if (*it < prev) {\n            prev = *it;\n         \
    \   next = *it;\n        }\n    }\n    if (next == end) {\n        return std::nullopt;\n\
    \    }\n    return next;", "    if (lst.size() == 0) return std::nullopt;\n  \
    \  long smallest = lst[0];\n    for (long i : lst) {\n        if (i < smallest)\
    \ {\n            smallest = i;\n        }\n    }\n    return smallest;", "   \
    \ long smallest = *std::min_element(lst.begin(), lst.end());\n    if (lst.size()\
    \ == 1) {\n        return std::nullopt;\n    }\n    for (auto it = lst.begin()\
    \ + 1; it != lst.end(); ++it) {\n        if (*it < smallest) {\n            smallest\
    \ = *it;\n        }\n    }\n    return smallest;", "    if (lst.size() == 0)\n\
    \        return std::nullopt;\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    long second_smallest = *std::min_element(lst.begin(), lst.begin()\
    \ + 1);\n    if (second_smallest == smallest)\n        return std::nullopt;\n\
    \    return second_smallest;", "    long min = std::numeric_limits<long>::min();\n\
    \    long max = std::numeric_limits<long>::max();\n    for (long i : lst) {\n\
    \        if (i < min) {\n            min = i;\n        } else if (i > max) {\n\
    \            max = i;\n        }\n    }\n    if (min == max) {\n        return\
    \ std::nullopt;\n    }\n    return max;", "    long min = std::numeric_limits<long>::max();\n\
    \    long max = std::numeric_limits<long>::min();\n    for (auto i : lst) {\n\
    \        if (i < min) {\n            min = i;\n        }\n        if (i > max)\
    \ {\n            max = i;\n        }\n    }\n    if (min == max) {\n        return\
    \ std::nullopt;\n    }\n    return std::optional<long>(min);", "    if(lst.empty())\
    \ return std::nullopt;\n    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    for(auto it = lst.begin(); it != lst.end(); ++it) {\n        if(*it < smallest)\
    \ {\n            smallest = *it;\n        }\n    }\n    return smallest;", " \
    \   if (lst.size() == 0)\n        return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end())\n        return std::nullopt;\n    return\
    \ *it;", '    // Your code here', "    if (lst.size() == 0) {\n        return\
    \ std::nullopt;\n    }\n    long smallest = lst[0];\n    long second_smallest\
    \ = lst[1];\n    for (long i : lst) {\n        if (i < smallest) {\n         \
    \   second_smallest = smallest;\n            smallest = i;\n        } else if\
    \ (i > second_smallest) {\n            second_smallest = i;\n        }\n    }\n\
    \    return second_smallest;", "    long min = lst[0];\n    long max = lst[0];\n\
    \    for (long i : lst) {\n        if (i < min) {\n            min = i;\n    \
    \    } else if (i > max) {\n            max = i;\n        }\n    }\n    return\
    \ std::nullopt;", "    // Your code here\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    long secondSmallest = *std::min_element(lst.begin() + 1, lst.end());\n\
    \    return secondSmallest < smallest ? std::nullopt : secondSmallest;", "   \
    \ long smallest = lst[0];\n    long second_smallest = lst[0];\n    for (long i\
    \ : lst) {\n        if (i < smallest) {\n            second_smallest = smallest;\n\
    \            smallest = i;\n        } else if (i < second_smallest) {\n      \
    \      second_smallest = i;\n        }\n    }\n    return second_smallest == lst[0]\
    \ ? std::nullopt : second_smallest;", "    if (lst.empty()) return std::nullopt;\n\
    \    auto it = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end())\
    \ return std::nullopt;\n    return *it;", "    if (lst.size() == 0) return std::nullopt;\n\
    \    long smallest = *std::min_element(lst.begin(), lst.end());\n    long second_smallest\
    \ = *std::min_element(lst.begin(), lst.begin() + 2);\n    if (second_smallest\
    \ == smallest) return std::nullopt;\n    return second_smallest;", "    if (lst.empty())\n\
    \        return std::nullopt;\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    long second_smallest = *std::min_element(std::next(lst.begin()),\
    \ lst.end());\n    if (second_smallest < smallest)\n        return second_smallest;\n\
    \    return std::nullopt;", "    // Your code here\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    if (lst.size() == 1) {\n        return std::nullopt;\n    }\n\
    \    if (smallest == *std::max_element(lst.begin(), lst.end())) {\n        return\
    \ std::nullopt;\n    }\n    for (long i = lst.size() - 2; i >= 0; i--) {\n   \
    \     if (lst[i] < smallest) {\n            smallest = lst[i];\n        }\n  \
    \  }\n    return smallest;", "    if(lst.empty()) return std::nullopt;\n    long\
    \ min = *std::min_element(lst.begin(), lst.end());\n    long index = std::distance(std::begin(lst),\
    \ std::find(std::begin(lst), std::end(lst), min));\n    if(index == lst.size())\
    \ return std::nullopt;\n    return lst[index + 1];", "    if (lst.empty()) return\
    \ std::nullopt;\n    long min = *std::min_element(lst.begin(), lst.end());\n \
    \   long max = *std::max_element(lst.begin(), lst.end());\n    if (min == max)\
    \ return std::nullopt;\n    if (min < max) {\n        std::optional<long> ret\
    \ = std::nullopt;\n        for (long i = min; i <= max; ++i) {\n            if\
    \ (lst.find(i) != lst.end()) ret = i;\n        }\n        return ret;\n    }\n\
    \    return std::nullopt;", "    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    auto it = std::find_if(lst.begin(), lst.end(), [&smallest](long\
    \ x) { return x < smallest; });\n    if (it == lst.end()) return std::nullopt;\n\
    \    smallest = *it;\n    auto it2 = std::find_if(lst.begin(), lst.end(), [&smallest](long\
    \ x) { return x < smallest; });\n    if (it2 == lst.end()) return std::nullopt;\n\
    \    return *it2;", "    long min = std::numeric_limits<long>::max();\n    long\
    \ max = std::numeric_limits<long>::min();\n    for (long i : lst) {\n        if\
    \ (i < min) {\n            min = i;\n        } else if (i > max) {\n         \
    \   max = i;\n        }\n    }\n    return std::optional<long>(max);", "    if\
    \ (lst.size() == 0) {\n        return std::nullopt;\n    }\n    long smallest\
    \ = *std::min_element(lst.begin(), lst.end());\n    long second_smallest = *std::min_element(lst.begin()\
    \ + 1, lst.end());\n    if (second_smallest == smallest) {\n        return std::nullopt;\n\
    \    }\n    return second_smallest;", "    if (lst.empty()) return std::nullopt;\n\
    \    auto it = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end())\
    \ return std::nullopt;\n    return *it;", "    // Your code here\n    long min\
    \ = lst[0];\n    long max = lst[0];\n    for (long i : lst) {\n        if (i <\
    \ min) {\n            min = i;\n        }\n        if (i > max) {\n          \
    \  max = i;\n        }\n    }\n    return max;", "    if (lst.size() == 0)\n \
    \       return std::nullopt;\n    long min = *std::min_element(lst.begin(), lst.end());\n\
    \    for (auto it = lst.begin(); it != lst.end(); ++it) {\n        if (*it < min)\n\
    \            min = *it;\n    }\n    return min;", "    // Your code here\n   \
    \ long smallest = std::numeric_limits<long>::max();\n    long secondSmallest =\
    \ std::numeric_limits<long>::max();\n    for (long i : lst) {\n        if (i <\
    \ smallest) {\n            secondSmallest = smallest;\n            smallest =\
    \ i;\n        } else if (i < secondSmallest) {\n            secondSmallest = i;\n\
    \        }\n    }\n    return secondSmallest;", '    // Your code here', "   \
    \ if (lst.size() == 0) {\n        return std::nullopt;\n    }\n    long min =\
    \ *std::min_element(lst.begin(), lst.end());\n    for (long i : lst) {\n     \
    \   if (i < min) {\n            min = i;\n        }\n    }\n    return min;",
  "    if (lst.size() == 0)\n        return std::nullopt;\n    long min = lst[0];\n\
    \    long max = lst[0];\n    for (long i : lst) {\n        if (i < min)\n    \
    \        min = i;\n        if (i > max)\n            max = i;\n    }\n    if (min\
    \ == max)\n        return std::nullopt;\n    return max;", "    if (lst.size()\
    \ == 0) {\n        return std::nullopt;\n    }\n    long min = lst[0];\n    for\
    \ (long i : lst) {\n        if (i < min) {\n            min = i;\n        }\n\
    \    }\n    return min;", "    if(lst.size() == 0) return std::nullopt;\n    long\
    \ smallest = *std::min_element(lst.begin(), lst.end());\n    long second_smallest\
    \ = *std::min_element(lst.begin(), lst.end(), [&smallest](long a, long b){return\
    \ (a<smallest?a:b) < smallest; });\n    return second_smallest == smallest ? std::nullopt\
    \ : second_smallest;", "    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    if (lst.size() == 1) {\n        return std::nullopt;\n    }\n    for (auto\
    \ it = lst.begin() + 1; it != lst.end(); ++it) {\n        if (*it < smallest)\
    \ {\n            smallest = *it;\n        }\n    }\n    return smallest;", " \
    \   if (lst.empty()) return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end()) return std::nullopt;\n    return *it;",
  "    long min = std::numeric_limits<long>::max();\n    long max = std::numeric_limits<long>::min();\n\
    \    for (long i : lst) {\n        if (i < min) {\n            min = i;\n    \
    \    } else if (i > max) {\n            max = i;\n        }\n    }\n    return\
    \ std::optional<long>(max);", "    if (lst.empty())\n        return std::nullopt;\n\
    \    auto it = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end())\n\
    \        return std::nullopt;\n    auto next = std::next(it);\n    if (*next <\
    \ std::min(*it, *next))\n        return std::nullopt;\n    return *next;", '    //
    Your code here', "    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    if (lst.size() == 1) {\n        return std::nullopt;\n    }\n    for (long\
    \ i = lst.size() - 2; i >= 0; --i) {\n        if (lst[i] < smallest) {\n     \
    \       smallest = lst[i];\n        }\n    }\n    return smallest;", "    long\
    \ min = *std::min_element(lst.begin(), lst.end());\n    long max = *std::max_element(lst.begin(),\
    \ lst.end());\n    if (min == max) {\n        return std::nullopt;\n    }\n  \
    \  for (long i = min; i <= max; i++) {\n        if (lst.find(i) == lst.end())\
    \ {\n            return std::nullopt;\n        }\n    }\n    return std::optional{lst.find(min)};",
  "    if (lst.empty()) return std::nullopt;\n    auto it = lst.begin();\n    auto\
    \ prev = *it;\n    ++it;\n    for (; it != lst.end(); ++it) {\n        if (*it\
    \ < prev) {\n            prev = *it;\n        }\n    }\n    return prev;", '    //
    Your code here', "    if (lst.empty()) return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end()) return std::nullopt;\n    return *it;",
  "    long min = *std::min_element(lst.begin(), lst.end());\n    long max = *std::max_element(lst.begin(),\
    \ lst.end());\n    if (min == max) {\n        return std::nullopt;\n    }\n  \
    \  if (min > max) {\n        std::swap(min, max);\n    }\n    for (long i = min;\
    \ i <= max; i++) {\n        if (lst.find(i) != lst.end()) {\n            return\
    \ i;\n        }\n    }\n    return std::nullopt;", "    long min = lst[0];\n \
    \   long max = lst[0];\n    for (long i : lst) {\n        if (i < min) {\n   \
    \         min = i;\n        } else if (i > max) {\n            max = i;\n    \
    \    }\n    }\n    return std::optional<long>(max);", "    // Your code here\n\
    \    long min = lst[0];\n    long max = lst[0];\n    for (long i : lst) {\n  \
    \      if (i < min) {\n            min = i;\n        } else if (i > max) {\n \
    \           max = i;\n        }\n    }\n    return std::nullopt;", "    if (lst.empty())\n\
    \        return std::nullopt;\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    long second_smallest = *std::min_element(lst.begin(), lst.end(),\
    \ [&smallest](long a, long b) { return a < b ? a : b; });\n    if (second_smallest\
    \ == smallest)\n        return std::nullopt;\n    return second_smallest;", " \
    \   // Your code here\n    if(lst.size() == 0)\n        return std::nullopt;\n\
    \    long smallest = *std::min_element(lst.begin(), lst.end());\n    long second_smallest\
    \ = *std::min_element(lst.begin(), lst.begin() + 1);\n    if(second_smallest <\
    \ smallest)\n        return second_smallest;\n    return std::nullopt;", "   \
    \ if (lst.size() == 0) {\n        return std::nullopt;\n    }\n    long smallest\
    \ = *std::min_element(lst.begin(), lst.end());\n    long second_smallest = *std::min_element(lst.begin(),\
    \ lst.end(), [&smallest](long a, long b) { return a < b; });\n    if (second_smallest\
    \ == smallest) {\n        return std::nullopt;\n    }\n    return second_smallest;",
  "    // Your code here\n    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    long secondSmallest = *std::min_element(lst.begin() + 1, lst.end());\n  \
    \  return secondSmallest < smallest ? std::nullopt : secondSmallest;", "    if\
    \ (lst.empty()) return std::nullopt;\n    long first = *lst.begin();\n    long\
    \ second = first;\n    long third = first;\n    for (long &i : lst) {\n      \
    \  if (i < first) {\n            first = i;\n        } else if (i > second) {\n\
    \            second = i;\n        } else if (i > third) {\n            third =\
    \ i;\n        }\n    }\n    return std::optional<long>(std::min(third, second));",
  "    if (lst.empty())\n        return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end())\n        return std::nullopt;\n    auto\
    \ next = std::next(it);\n    if (*next < *it)\n        return std::nullopt;\n\
    \    return *next;", "    if (lst.size() == 0) {\n        return std::nullopt;\n\
    \    }\n    long smallest = *std::min_element(lst.begin(), lst.end());\n    long\
    \ second_smallest = *std::min_element(lst.begin(), lst.begin() + 1);\n    if (second_smallest\
    \ < smallest) {\n        return second_smallest;\n    }\n    return std::nullopt;",
  "    long smallest = *std::min_element(lst.begin(), lst.end());\n    long second_smallest\
    \ = *std::min_element(std::next(lst.begin()), lst.end());\n    if (smallest ==\
    \ second_smallest) {\n        return std::nullopt;\n    }\n    return second_smallest;",
  "    if (lst.size() == 0) return std::nullopt;\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    auto it = std::find_if(lst.begin(), lst.end(), [&smallest](long\
    \ x) { return x < smallest; });\n    if (it == lst.end()) return std::nullopt;\n\
    \    return *it;", "    // Your code here\n    long min = lst[0];\n    long max\
    \ = lst[0];\n    for (long i : lst) {\n        if (i < min) {\n            min\
    \ = i;\n        } else if (i > max) {\n            max = i;\n        }\n    }\n\
    \    return max;", '    // Your code here', "    if(lst.size() <= 1) return std::nullopt;\n\
    \    long smallest = lst[0];\n    long second_smallest = lst[1];\n    for(size_t\
    \ i = 2; i < lst.size(); i++) {\n        if(lst[i] < smallest) {\n           \
    \ second_smallest = smallest;\n            smallest = lst[i];\n        } else\
    \ if(lst[i] < second_smallest) {\n            second_smallest = lst[i];\n    \
    \    }\n    }\n    return second_smallest;", "    long min = *std::min_element(lst.begin(),\
    \ lst.end());\n    long max = *std::max_element(lst.begin(), lst.end());\n   \
    \ if (min == max) {\n        return std::nullopt;\n    }\n    if (min < max) {\n\
    \        std::swap(min, max);\n    }\n    long mid = min + (max - min) / 2;\n\
    \    if (mid == min) {\n        return std::nullopt;\n    }\n    if (mid < min)\
    \ {\n        return std::nullopt;\n    }\n    if (mid > max) {\n        return\
    \ std::nullopt;\n    }\n    return std::optional<long>(mid);", '    // Your code
    here', "    long min = std::numeric_limits<long>::max();\n    long max = std::numeric_limits<long>::min();\n\
    \    for (long i : lst) {\n        if (i < min) {\n            min = i;\n    \
    \    } else if (i > max) {\n            max = i;\n        }\n    }\n    if (min\
    \ == max) {\n        return std::nullopt;\n    }\n    return max;", "    // Your\
    \ code here\n    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    long second_smallest = *std::min_element(lst.begin() + 1, lst.end());\n \
    \   if (second_smallest == smallest) {\n        return std::nullopt;\n    }\n\
    \    return second_smallest;", "    long min = *std::min_element(lst.begin(),\
    \ lst.end());\n    long max = *std::max_element(lst.begin(), lst.end());\n   \
    \ if (min == max) {\n        return std::nullopt;\n    }\n    if (min < max) {\n\
    \        std::swap(min, max);\n    }\n    for (auto it = lst.begin(); it != lst.end();\
    \ ++it) {\n        if (*it < min) {\n            min = *it;\n        }\n     \
    \   if (*it > max) {\n            max = *it;\n        }\n    }\n    return max;",
  "    // Your code here\n    long min = std::numeric_limits<long>::min();\n    long\
    \ max = std::numeric_limits<long>::max();\n    long mid = 0;\n    for (long i\
    \ : lst) {\n        if (i < min) {\n            min = i;\n        } else if (i\
    \ > max) {\n            max = i;\n        }\n    }\n    mid = (min + max) / 2;\n\
    \    for (long i : lst) {\n        if (i < mid) {\n            mid = i;\n    \
    \    }\n    }\n    return mid;", "    long min = *std::min_element(lst.begin(),\
    \ lst.end());\n    long max = *std::max_element(lst.begin(), lst.end());\n   \
    \ if (min == max) {\n        return std::nullopt;\n    }\n    if (min > max) {\n\
    \        std::swap(min, max);\n    }\n    for (long i = min; i <= max; i++) {\n\
    \        if (lst.find(i) != lst.end()) {\n            return i;\n        }\n \
    \   }\n    return std::nullopt;", "    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    if (lst.size() == 1) return std::nullopt;\n    for (long i\
    \ = lst.size() - 2; i >= 0; --i) {\n        if (lst[i] < smallest) {\n       \
    \     smallest = lst[i];\n        }\n    }\n    return smallest;", "    if (lst.empty())\n\
    \        return std::nullopt;\n    long min = *std::min_element(lst.begin(), lst.end());\n\
    \    long max = *std::max_element(lst.begin(), lst.end());\n    if (min == max)\n\
    \        return min;\n    if (min > max)\n        return std::nullopt;\n    long\
    \ mid = min + (max - min) / 2;\n    if (mid == *std::min_element(lst.begin(),\
    \ lst.end()))\n        return mid;\n    if (mid > max)\n        return std::nullopt;\n\
    \    return next_smallest(lst);", '    // Your code here', "    long smallest\
    \ = *std::min_element(lst.begin(), lst.end());\n    long second_smallest = *std::min_element(lst.begin()\
    \ + 1, lst.end());\n    if (smallest == second_smallest)\n        return std::nullopt;\n\
    \    return second_smallest;", "    if(lst.empty()) return std::nullopt;\n   \
    \ long smallest = *std::min_element(lst.begin(), lst.end());\n    for(auto it\
    \ = lst.begin(); it != lst.end(); ++it) {\n        if(*it < smallest) {\n    \
    \        smallest = *it;\n        }\n    }\n    return smallest;", "    // Your\
    \ code here\n    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    long second_smallest = *std::min_element(lst.begin(), lst.end(), [smallest](long\
    \ a, long b){return a<b;});\n    return second_smallest == smallest ? std::nullopt\
    \ : second_smallest;", "    if (lst.size() == 0) {\n        return std::nullopt;\n\
    \    }\n    long smallest = *std::min_element(lst.begin(), lst.end());\n    long\
    \ secondSmallest = *std::min_element(lst.begin(), lst.end(), [&smallest](long\
    \ a, long b) { return a < b; });\n    if (secondSmallest == smallest) {\n    \
    \    return std::nullopt;\n    }\n    return secondSmallest;", "    long smallest\
    \ = *std::min_element(lst.begin(), lst.end());\n    long second_smallest = *std::min_element(lst.begin(),\
    \ lst.end(), [smallest](long a, long b){return a<b ? a : b;});\n    return second_smallest\
    \ == smallest ? std::nullopt : second_smallest;", "    // Your code here\n   \
    \ long smallest = lst[0];\n    long secondSmallest = lst[0];\n    for (long i\
    \ = 1; i < lst.size(); i++) {\n        if (lst[i] < smallest) {\n            secondSmallest\
    \ = smallest;\n            smallest = lst[i];\n        } else if (lst[i] < secondSmallest)\
    \ {\n            secondSmallest = lst[i];\n        }\n    }\n    return secondSmallest;",
  "    // Your code here\n    long min = std::numeric_limits<long>::max();\n    long\
    \ max = std::numeric_limits<long>::min();\n    for (long i : lst) {\n        if\
    \ (i < min) {\n            min = i;\n        }\n        if (i > max) {\n     \
    \       max = i;\n        }\n    }\n    return std::nullopt;", "    if (lst.size()\
    \ == 0) return {};\n    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    long secondSmallest = *std::min_element(lst.begin() + 1, lst.end());\n  \
    \  if (smallest != secondSmallest) {\n        return secondSmallest;\n    }\n\
    \    return {};", "    if (lst.size() == 0) return {};\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    long secondSmallest = *std::min_element(lst.begin(), lst.begin()\
    \ + 1);\n    if (secondSmallest == smallest) return {};\n    return secondSmallest;",
  "    // Your code here\n    long smallest = lst[0];\n    long secondSmallest = lst[0];\n\
    \    for (long i = 1; i < lst.size(); i++) {\n        if (lst[i] < smallest) {\n\
    \            secondSmallest = smallest;\n            smallest = lst[i];\n    \
    \    } else if (lst[i] < secondSmallest) {\n            secondSmallest = lst[i];\n\
    \        }\n    }\n    return secondSmallest;", "    if (lst.size() == 0) {\n\
    \        return std::nullopt;\n    }\n    long min = lst[0];\n    long max = lst[0];\n\
    \    for (long i : lst) {\n        if (i < min) {\n            min = i;\n    \
    \    }\n        if (i > max) {\n            max = i;\n        }\n    }\n    if\
    \ (min == max) {\n        return std::nullopt;\n    }\n    return max;", "   \
    \ // Your code here\n    long min = std::numeric_limits<long>::max();\n    long\
    \ max = std::numeric_limits<long>::min();\n    for (long i : lst) {\n        if\
    \ (i < min) {\n            min = i;\n        } else if (i > max) {\n         \
    \   max = i;\n        }\n    }\n    return std::nullopt;", "    if (lst.empty())\
    \ return std::nullopt;\n    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    auto it = std::find(lst.begin(), lst.end(), smallest);\n    if (it == lst.end())\
    \ return std::nullopt;\n    return *std::next(it);", "    if (lst.empty()) return\
    \ std::nullopt;\n    auto it = std::min_element(lst.begin(), lst.end());\n   \
    \ if (it == lst.end()) return std::nullopt;\n    return *it;", "    // Your code\
    \ here\n    long smallest = lst[0];\n    long secondSmallest = lst[0];\n    for\
    \ (long i : lst) {\n        if (i < smallest) {\n            secondSmallest =\
    \ smallest;\n            smallest = i;\n        } else if (i == smallest) {\n\
    \            secondSmallest = i;\n        }\n    }\n    return secondSmallest;",
  "    long smallest = lst[0];\n    long second_smallest = lst[0];\n    for (long\
    \ i : lst) {\n        if (i < smallest) {\n            second_smallest = smallest;\n\
    \            smallest = i;\n        } else if (i < second_smallest) {\n      \
    \      second_smallest = i;\n        }\n    }\n    return second_smallest == lst[0]\
    \ ? std::nullopt : second_smallest;", "    if (lst.size() == 0) return std::nullopt;\n\
    \    long smallest = lst[0];\n    for (long i : lst) {\n        if (i < smallest)\
    \ {\n            smallest = i;\n        }\n    }\n    return smallest;", "   \
    \ if (lst.size() == 0) {\n        return std::nullopt;\n    }\n    long smallest\
    \ = *std::min_element(lst.begin(), lst.end());\n    long secondSmallest = *std::min_element(lst.begin(),\
    \ lst.end(), [&smallest](int i) { return i < smallest; });\n    if (secondSmallest\
    \ == smallest) {\n        return std::nullopt;\n    }\n    return secondSmallest;",
  "    if (lst.empty()) return std::nullopt;\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    for (long i : lst) {\n        if (i < smallest) return std::nullopt;\n\
    \        if (i == smallest) return i;\n    }\n    return std::nullopt;", "   \
    \ if(lst.size() == 0) return std::nullopt;\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    long second_smallest = *std::min_element(lst.begin(), lst.begin()\
    \ + 1);\n    if(smallest == second_smallest) return std::nullopt;\n    return\
    \ second_smallest;", "    if (lst.size() == 0) return std::nullopt;\n    long\
    \ min = lst[0];\n    long max = lst[0];\n    for (long i : lst) {\n        if\
    \ (i < min) min = i;\n        if (i > max) max = i;\n    }\n    if (min == max)\
    \ return std::nullopt;\n    return max;", "    if (lst.size() == 0) {\n      \
    \  return std::nullopt;\n    }\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    std::vector<long> new_lst;\n    for (auto it = lst.begin();\
    \ it != lst.end(); ++it) {\n        if (*it < smallest) {\n            new_lst.push_back(*it);\n\
    \        }\n    }\n    if (new_lst.size() == 0) {\n        return std::nullopt;\n\
    \    }\n    return std::optional<long>(std::min_element(new_lst.begin(), new_lst.end()));",
  "    if (lst.size() == 0) {\n        return std::nullopt;\n    }\n    auto it =\
    \ lst.begin();\n    auto prev = *it;\n    ++it;\n    for (; it != lst.end(); ++it)\
    \ {\n        if (*it < prev) {\n            break;\n        }\n        prev =\
    \ *it;\n    }\n    if (it == lst.end()) {\n        return std::nullopt;\n    }\n\
    \    return *it;", "    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    long second_smallest = *std::min_element(std::next(lst.begin()), lst.end());\n\
    \    if (second_smallest == smallest)\n        return std::nullopt;\n    return\
    \ second_smallest;", "    long min = std::numeric_limits<long>::max();\n    long\
    \ max = std::numeric_limits<long>::min();\n    for (long i : lst) {\n        if\
    \ (i < min) {\n            min = i;\n        } else if (i > max) {\n         \
    \   max = i;\n        }\n    }\n    if (min == max) {\n        return std::nullopt;\n\
    \    }\n    return std::optional<long>(min);", "    if (lst.empty()) return std::nullopt;\n\
    \    auto it = std::min_element(lst.begin(), lst.end());\n    if (it == lst.end())\
    \ return std::nullopt;\n    return *it;", "    if(lst.size() == 0)\n        return\
    \ std::nullopt;\n    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    for(auto it = lst.begin(); it != lst.end(); ++it) {\n        if(*it < smallest)\n\
    \            smallest = *it;\n    }\n    return smallest;", "    // Your code\
    \ here\n    long min = std::numeric_limits<long>::max();\n    long max = std::numeric_limits<long>::min();\n\
    \    for (long i : lst) {\n        if (i < min) {\n            min = i;\n    \
    \    } else if (i > max) {\n            max = i;\n        }\n    }\n    if (min\
    \ == max) {\n        return std::nullopt;\n    }\n    return max;", "    long\
    \ min = lst[0];\n    long max = lst[0];\n    for (long i : lst) {\n        if\
    \ (i < min) {\n            min = i;\n        } else if (i > max) {\n         \
    \   max = i;\n        }\n    }\n    if (min == max) {\n        return std::nullopt;\n\
    \    }\n    return max;", "    // Your code here\n    long smallest = lst[0];\n\
    \    long second_smallest = lst[1];\n    for (long i : lst) {\n        if (i <\
    \ smallest) {\n            second_smallest = smallest;\n            smallest =\
    \ i;\n        } else if (i > second_smallest) {\n            second_smallest =\
    \ i;\n        }\n    }\n    return second_smallest == smallest ? std::nullopt\
    \ : second_smallest;", "    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    if (lst.size() == 1)\n        return std::nullopt;\n    if (lst.size() ==\
    \ 2)\n        return smallest;\n    std::vector<long> new_lst;\n    new_lst.push_back(*std::min_element(lst.begin(),\
    \ lst.end()));\n    new_lst.push_back(*std::max_element(lst.begin(), lst.end()));\n\
    \    return next_smallest(new_lst);", "    long min = lst[0];\n    long max =\
    \ lst[0];\n    for (long i : lst) {\n        if (i < min) {\n            min =\
    \ i;\n        } else if (i > max) {\n            max = i;\n        }\n    }\n\
    \    return max;", "    long min = std::numeric_limits<long>::max();\n    long\
    \ max = std::numeric_limits<long>::min();\n    for (long i : lst) {\n        if\
    \ (i < min) {\n            min = i;\n        } else if (i > max) {\n         \
    \   max = i;\n        }\n    }\n    if (min == max) {\n        return std::nullopt;\n\
    \    }\n    return max;", "    long min = std::numeric_limits<long>::min();\n\
    \    long max = std::numeric_limits<long>::max();\n    long mid = std::numeric_limits<long>::max();\n\
    \    long index = -1;\n    for (long i = 0; i < lst.size(); i++) {\n        if\
    \ (lst[i] < min) {\n            min = lst[i];\n            index = i;\n      \
    \  }\n        if (lst[i] > max) {\n            max = lst[i];\n            index\
    \ = i;\n        }\n        if (lst[i] < mid) {\n            mid = lst[i];\n  \
    \          index = i;\n        }\n    }\n    if (index == -1) {\n        return\
    \ std::nullopt;\n    }\n    if (mid == min) {\n        return min;\n    }\n  \
    \  if (mid == max) {\n        return max;\n    }\n    return mid;", "    long\
    \ min = lst[0];\n    long max = lst[0];\n    for (long i : lst) {\n        if\
    \ (i < min) {\n            min = i;\n        } else if (i > max) {\n         \
    \   max = i;\n        }\n    }\n    return std::nullopt;", '    // Your code here',
  "    if (lst.size() == 0)\n        return std::nullopt;\n    auto it = lst.begin();\n\
    \    auto next = std::next(it);\n    if (*next < *it)\n        return std::nullopt;\n\
    \    while (next != lst.end()) {\n        if (*next < *it)\n            return\
    \ *it;\n        ++it;\n        ++next;\n    }\n    return std::nullopt;", "  \
    \  // Your code here\n    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    long secondSmallest = *std::min_element(lst.begin(), lst.end(), [smallest](long\
    \ a, long b){return a<b;});\n    return secondSmallest == smallest ? std::nullopt\
    \ : secondSmallest;", "    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    long second_smallest = *std::min_element(lst.begin(), lst.end(), [smallest](long\
    \ a, long b){return a<b?a:b;});\n    return second_smallest == smallest ? std::nullopt\
    \ : second_smallest;", "    if(lst.size() == 0)\n        return std::nullopt;\n\
    \    long min = lst[0];\n    long max = lst[0];\n    for(long i = 1; i < lst.size();\
    \ i++) {\n        if(lst[i] < min)\n            min = lst[i];\n        else if(lst[i]\
    \ > max)\n            max = lst[i];\n    }\n    return max;", "    if (lst.size()\
    \ == 0) return std::nullopt;\n    auto it = lst.begin();\n    auto prev = *it;\n\
    \    ++it;\n    for (; it != lst.end(); ++it) {\n        if (*it < prev) {\n \
    \           prev = *it;\n        }\n    }\n    return prev;", "    if (lst.size()\
    \ == 0) return std::nullopt;\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    long second_smallest = *std::min_element(lst.begin(), lst.end(),\
    \ [&smallest](long a, long b) { return a < b ? a : b; });\n    return second_smallest\
    \ == smallest ? std::nullopt : second_smallest;", "    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    if (lst.size() == 1) {\n        return std::nullopt;\n    }\n\
    \    for (long i = lst.size() - 1; i >= 0; --i) {\n        if (lst[i] < smallest)\
    \ {\n            smallest = lst[i];\n        }\n    }\n    return smallest;",
  "    if (lst.empty()) return std::nullopt;\n    auto it = std::min_element(lst.begin(),\
    \ lst.end());\n    if (it == lst.end()) return std::nullopt;\n    return *it;",
  "    if (lst.size() == 0)\n        return std::nullopt;\n    long first = lst[0];\n\
    \    long second = first;\n    for (size_t i = 1; i < lst.size(); ++i) {\n   \
    \     if (lst[i] < second)\n            second = lst[i];\n    }\n    return second;",
  '    // Your code here', "    if (lst.size() <= 1) return std::nullopt;\n    long\
    \ first = *std::min_element(lst.begin(), lst.end());\n    long second = *std::min_element(lst.begin(),\
    \ lst.end(), [first](long a, long b) { return a < b; });\n    if (first == second)\
    \ return std::nullopt;\n    return std::make_optional(first);", "    if (lst.empty())\
    \ return std::nullopt;\n    auto it = std::min_element(lst.begin(), lst.end());\n\
    \    if (it == lst.end()) return std::nullopt;\n    return *it;", "    if (lst.size()\
    \ == 0) return std::nullopt;\n    auto it = lst.begin();\n    auto prev = *it;\n\
    \    ++it;\n    for (; it != lst.end(); ++it) {\n        if (*it < prev) {\n \
    \           prev = *it;\n        }\n    }\n    return prev;", "    if (lst.empty())\
    \ return std::nullopt;\n    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    long second_smallest = *std::min_element(lst.begin() + 1, lst.end());\n \
    \   if (second_smallest == smallest) return std::nullopt;\n    return second_smallest;",
  "    long smallest = *std::min_element(lst.begin(), lst.end());\n    long second_smallest\
    \ = *std::min_element(lst.begin() + 1, lst.end());\n    if (smallest == second_smallest)\
    \ {\n        return std::nullopt;\n    }\n    return second_smallest;", "    //\
    \ Your code here\n    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    long second_smallest = *std::min_element(lst.begin(), lst.end(), [smallest](long\
    \ a, long b){return (a<b)?(a<smallest?a:smallest):(b<smallest?b:smallest);});\n\
    \    return second_smallest == smallest?std::nullopt:second_smallest;", "    //\
    \ Write your code here\n    long smallest = *std::min_element(lst.begin(), lst.end());\n\
    \    long second_smallest = *std::min_element(lst.begin(), lst.end(), [&smallest](long\
    \ a, long b){return a<b?a:b;});\n    return second_smallest;", "    if (lst.size()\
    \ == 0) {\n        return std::nullopt;\n    }\n    long smallest = *std::min_element(lst.begin(),\
    \ lst.end());\n    auto it = std::find(lst.begin(), lst.end(), smallest);\n  \
    \  if (it == lst.end()) {\n        return std::nullopt;\n    }\n    long second\
    \ = *std::next(it);\n    return std::make_optional(std::min(smallest, second));",
  "    if (lst.empty()) return std::nullopt;\n    long min = *std::min_element(lst.begin(),\
    \ lst.end());\n    long max = *std::max_element(lst.begin(), lst.end());\n   \
    \ if (min == max) return std::nullopt;\n    if (min == max) return max;\n    if\
    \ (min > max) return std::nullopt;\n    long mid = min + (max - min) / 2;\n  \
    \  if (mid == max) return max;\n    if (mid == min) return min;\n    if (mid >\
    \ max) return std::nullopt;\n    if (mid < min) return std::nullopt;\n    return\
    \ next_smallest({min, mid, max});", "    // Your code here\n    long smallest\
    \ = lst[0];\n    long second_smallest = lst[0];\n    for (long i : lst) {\n  \
    \      if (i < smallest) {\n            second_smallest = smallest;\n        \
    \    smallest = i;\n        } else if (i > second_smallest) {\n            second_smallest\
    \ = i;\n        }\n    }\n    return second_smallest;", "    if (lst.empty())\
    \ return std::nullopt;\n    auto it = std::min_element(lst.begin(), lst.end());\n\
    \    if (it == lst.end()) return std::nullopt;\n    return *it;", "    long min\
    \ = *std::min_element(lst.begin(), lst.end());\n    long max = *std::max_element(lst.begin(),\
    \ lst.end());\n    if (min == max) {\n        return std::nullopt;\n    }\n  \
    \  if (min > max) {\n        std::swap(min, max);\n    }\n    for (long i = min;\
    \ i <= max; i++) {\n        if (lst.find(i) != lst.end()) {\n            return\
    \ i;\n        }\n    }\n    return std::nullopt;"]
stop_tokens:
- "\n}"
