language: cpp
name: HumanEval_99_closest_integer
results:
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n\
    \    long mid = 0;\n    long diff = 0;\n    long closest_integer = std::numeric_limits<long>::max();\n\
    \    long midpoint = 0;\n    long midpoint_diff = 0;\n    long midpoint_closest\
    \ = 0;\n    long midpoint_closest_diff = 0;\n    long midpoint_closest_integer\
    \ = 0;\n    long midpoint_closest_integer_diff = 0;\n    long midpoint_closest_integer_diff2\
    \ = 0;\n    long midpoint_closest_integer_diff3 = 0;\n    long midpoint_closest_integer_diff4\
    \ = 0;\n    long midpoint_closest_integer_diff5 = 0;\n    long midpoint_closest_integer_diff6\
    \ = 0;\n    long midpoint_closest_integer_diff7 = 0;\n    long midpoint_closest_integer_diff8\
    \ = 0;\n    long midpoint_closest_integer_diff9 = 0;\n    long midpoint_closest_integer_diff10\
    \ = 0;\n    long midpoint_closest_integer_diff11 = 0;\n    long midpoint_closest_integer_diff12\
    \ = 0;\n    long midpoint_closest_integer_diff13 = 0;\n    long midpoint_closest_integer_diff14\
    \ = 0;\n    long midpoint_closest_integer_diff15 = 0;\n    long midpoint_closest_integer_diff16\
    \ = 0;\n    long midpoint_closest_integer_diff17 = 0;\n    long midpoint_closest_integer_diff18\
    \ = 0;\n    long midpoint_closest_integer_diff19 = 0;\n    long midpoint_closest_integer_diff20\
    \ = 0;\n    long midpoint_closest_integer_diff21 = 0;\n    long midpoint_closest_integer_diff22\
    \ = 0;\n    long midpoint_closest_integer_diff23 = 0;\n    long midpoint_closest_integer_diff24\
    \ = 0;\n    long midpoint_closest_integer_diff25 = 0;\n    long midpoint_closest_integer_diff26\
    \ = 0;\n    long midpoint_closest_integer_diff27 = 0;\n    long midpoint_closest_integer_diff28\
    \ = 0;\n    long midpoint_closest_integer_diff29 = 0;\n    long midpoint_closest_integer_diff30\
    \ = 0;\n    long midpoint_closest_integer_diff31 = 0;\n    long midpoint_closest_integer_diff32\
    \ = 0;\n    long midpoint_closest_integer_diff33 = 0;\n    long midpoint_closest_integer_diff34\
    \ = 0;\n    long midpoint_closest_integer_diff35 = 0;\n    long midpoint_closest_integer_diff36\
    \ = 0;\n    long midpoint_closest_integer_diff37 = 0;\n    long midpoint_closest_integer_diff38\
    \ = 0;\n    long midpoint_closest_integer_diff39 = 0;\n    long midpoint_closest_integer_diff40\
    \ = 0;\n    long midpoint_closest_integer_diff41 = 0;\n    long midpoint_closest_integer_diff42\
    \ = 0;\n    long midpoint_closest_integer_diff43 = 0;\n    long midpoint_closest_integer_diff44\
    \ = 0;\n    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpfter3rxr: /tmp/tmpfter3rxr.cpp:70: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141604
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, diff = 0;\n    long n = stoi(value);\n    long x = n;\n    long y = n;\n\
    \    long z = n;\n    long a = n;\n    long b = n;\n    long c = n;\n    long\
    \ d = n;\n    long e = n;\n    long f = n;\n    long g = n;\n    long h = n;\n\
    \    long i = n;\n    long j = n;\n    long k = n;\n    long l = n;\n    long\
    \ m = n;\n    long n = n;\n    long o = n;\n    long p = n;\n    long q = n;\n\
    \    long r = n;\n    long s = n;\n    long t = n;\n    long u = n;\n    long\
    \ v = n;\n    long w = n;\n    long x = n;\n    long y = n;\n    long z = n;\n\
    \    long a = n;\n    long b = n;\n    long c = n;\n    long d = n;\n    long\
    \ e = n;\n    long f = n;\n    long g = n;\n    long h = n;\n    long i = n;\n\
    \    long j = n;\n    long k = n;\n    long l = n;\n    long m = n;\n    long\
    \ n = n;\n    long o = n;\n    long p = n;\n    long q = n;\n    long r = n;\n\
    \    long s = n;\n    long t = n;\n    long u = n;\n    long v = n;\n    long\
    \ w = n;\n    long x = n;\n    long y = n;\n    long z = n;\n    long a = n;\n\
    \    long b = n;\n    long c = n;\n    long d = n;\n    long e = n;\n    long\
    \ f = n;\n    long g = n;\n    long h = n;\n    long i = n;\n    long j = n;\n\
    \    long k = n;\n    long l = n;\n    long m = n;\n    long n = n;\n    long\
    \ o = n;\n    long p = n;\n    long q = n;\n    long r = n;\n    long s = n;\n\
    \    long t = n;\n    long u = n;\n    long v = n;\n    long w = n;\n    long\
    \ x = n;\n    long y = n;\n    long z = n;\n    long a = n;\n    long b = n;\n\
    \    long c = n;\n    long d = n;\n    long e = n;\n    long f = n;\n    long\
    \ g = n;\n    long h = n;\n    long i = n;\n    long j = n;\n    long k = n;\n\
    \    long l = n;\n    long m = n;\n    long n = n;\n    long o = n;\n    long\
    \ p = n;\n    long q = n;\n    long \n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpapecxz6x.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpapecxz6x.cpp:32:10: error: redeclaration of \u2018long int n\u2019\n\
    \   32 |     long n = n;\n      |          ^\n/tmp/tmpapecxz6x.cpp:15:10: note:\
    \ \u2018long int n\u2019 previously declared here\n   15 |     long n = stoi(value);\n\
    \      |          ^\n/tmp/tmpapecxz6x.cpp:42:10: error: redeclaration of \u2018\
    long int x\u2019\n   42 |     long x = n;\n      |          ^\n/tmp/tmpapecxz6x.cpp:16:10:\
    \ note: \u2018long int x\u2019 previously declared here\n   16 |     long x =\
    \ n;\n      |          ^\n/tmp/tmpapecxz6x.cpp:43:10: error: redeclaration of\
    \ \u2018long int y\u2019\n   43 |     long y = n;\n      |          ^\n/tmp/tmpapecxz6x.cpp:17:10:\
    \ note: \u2018long int y\u2019 previously declared here\n   17 |     long y =\
    \ n;\n      |          ^\n/tmp/tmpapecxz6x.cpp:44:10: error: redeclaration of\
    \ \u2018long int z\u2019\n   44 |     long z = n;\n      |          ^\n/tmp/tmpapecxz6x.cpp:18:10:\
    \ note: \u2018long int z\u2019 previously declared here\n   18 |     long z =\
    \ n;\n      |          ^\n/tmp/tmpapecxz6x.cpp:45:10: error: redeclaration of\
    \ \u2018long int a\u2019\n   45 |     long a = n;\n      |          ^\n/tmp/tmpapecxz6x.cpp:19:10:\
    \ note: \u2018long int a\u2019 previously declared here\n   19 |     long a =\
    \ n;\n      |          ^\n/tmp/tmpapecxz6x.cpp:46:10: error: redeclaration of\
    \ \u2018long int b\u2019\n   46 |     long b = n;\n      |          ^\n/tmp/tmpapecxz6x.cpp:20:10:\
    \ note: \u2018long int b\u2019 previously declared here\n   20 |     long b =\
    \ n;\n      |          ^\n/tmp/tmpapecxz6x.cpp:47:10: error: redeclaration of\
    \ \u2018long int c\u2019\n   47 |     long c = n;\n      |          ^\n/tmp/tmpapecxz6x.cpp:21:10:\
    \ note: \u2018long int c\u2019 previously declared here\n   21 |     long c =\
    \ n;\n      |          ^\n/tmp/tmpapecxz6x.cpp:48:10: error: redeclaration of\
    \ \u2018long int d\u2019\n   48 |     long d = n;\n      |          ^\n/tmp/tmpapecxz6x.cpp:22:10:\
    \ note: \u2018long int d\u2019 previously declared here\n   22 |     long d =\
    \ n;\n      |          ^\n/tmp/tmpapecxz6x.cpp:49:10: error: redeclaration of\
    \ \u2018long int e\u2019\n   49 |     long e = n;\n      |          ^"
  stdout: ''
  timestamp: 1660141604
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ long int l=atoll(value.c_str());\n    long long int r=atoll(value.c_str());\n\
    \    long long int d=l-r+1;\n    long long int m=l+r+1;\n    if(d<0){\n      \
    \  m=m-1;\n        d=d-1;\n    }\n    long long int k=l+r+d;\n    if(k<0){\n \
    \       m=m-1;\n        k=k-1;\n    }\n    long long int l1=l+d;\n    long long\
    \ int l2=l+d;\n    if(l1>l2){\n        l1=l1-k;\n        l2=l2-k;\n    }\n   \
    \ if(l1>l2){\n        l1=l1-k;\n        l2=l2-k;\n    }\n    if(l1>l2){\n    \
    \    l1=l1-k;\n        l2=l2-k;\n    }\n    if(l1>l2){\n        l1=l1-k;\n   \
    \     l2=l2-k;\n    }\n    if(l1>l2){\n        l1=l1-k;\n        l2=l2-k;\n  \
    \  }\n    if(l1>l2){\n        l1=l1-k;\n        l2=l2-k;\n    }\n    if(l1>l2){\n\
    \        l1=l1-k;\n        l2=l2-k;\n    }\n    if(l1>l2){\n        l1=l1-k;\n\
    \        l2=l2-k;\n    }\n    if(l1>l2){\n        l1=l1-k;\n        l2=l2-k;\n\
    \    }\n    if(l1>l2){\n        l1=l1-k;\n        l2=l2-k;\n    }\n    if(l1>l2){\n\
    \        l1=l1-k;\n        l2=l2-k;\n    }\n    if(l1>l2){\n        l1=l1-k;\n\
    \        l2=l2-k;\n    }\n    if(l1>l2){\n        l1=l1-k;\n        l2=l2-k;\n\
    \    }\n    if(l1>l2){\n        l1=l1-k;\n        l2=l2-k;\n    }\n    if(l1>l2){\n\
    \        l1=l1-k;\n        l2=l2-k;\n    }\n    if(l1>l2){\n        l1=l1-k;\n\
    \        l2=l2-k;\n    }\n    if(l1>l2){\n        l1=l1-k;\n        l2=l2-k;\n\
    \    }\n    if(l1>l2){\n        l1=l1-k;\n        l2=l2-k;\n    }\n    if(l1>l2){\n\
    \        l1=l1-k;\n        l2=l2-k;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbh238r7r.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpbh238r7r.cpp:105:12: error: a function-definition is not allowed here\
    \ before \u2018{\u2019 token\n  105 | int main() {\n      |            ^\n/tmp/tmpbh238r7r.cpp:112:1:\
    \ error: expected \u2018}\u2019 at end of input\n  112 | }\n      | ^\n/tmp/tmpbh238r7r.cpp:12:41:\
    \ note: to match this \u2018{\u2019\n   12 | long closest_integer(std::string\
    \ value) {\n      |                                         ^\n/tmp/tmpbh238r7r.cpp:112:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n\
    \  112 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num;\n    long long\
    \ int min;\n    long long int max;\n    long long int mid;\n    long long int\
    \ diff;\n    long long int diff2;\n    long long int diff3;\n    long long int\
    \ diff4;\n    long long int diff5;\n    long long int diff6;\n    long long int\
    \ diff7;\n    long long int diff8;\n    long long int diff9;\n    long long int\
    \ diff10;\n    long long int diff11;\n    long long int diff12;\n    long long\
    \ int diff13;\n    long long int diff14;\n    long long int diff15;\n    long\
    \ long int diff16;\n    long long int diff17;\n    long long int diff18;\n   \
    \ long long int diff19;\n    long long int diff20;\n    long long int diff21;\n\
    \    long long int diff22;\n    long long int diff23;\n    long long int diff24;\n\
    \    long long int diff25;\n    long long int diff26;\n    long long int diff27;\n\
    \    long long int diff28;\n    long long int diff29;\n    long long int diff30;\n\
    \    long long int diff31;\n    long long int diff32;\n    long long int diff33;\n\
    \    long long int diff34;\n    long long int diff35;\n    long long int diff36;\n\
    \    long long int diff37;\n    long long int diff38;\n    long long int diff39;\n\
    \    long long int diff40;\n    long long int diff41;\n    long long int diff42;\n\
    \    long long int diff43;\n    long long int diff44;\n    long long int diff45;\n\
    \    long long int diff46;\n    long long int diff47;\n    long long int diff48;\n\
    \    long long int diff49;\n    long long int diff50;\n    long long int diff51;\n\
    \    long long int diff52;\n    long long int diff53;\n    long long int diff54;\n\
    \    long long int diff55;\n    long long int diff56;\n    long long int diff57;\n\
    \    long long int diff58;\n    long long int diff59;\n    long long int diff60;\n\
    \    long long int diff61;\n    long long int diff62;\n    long long int diff63;\n\
    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpqg_4dw5y: /tmp/tmpqg_4dw5y.cpp:84: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // Write your code here\n  long ans\
    \ = 0;\n  long temp = 0;\n  long diff = 0;\n  long sum = 0;\n  for (int i = 0;\
    \ i < value.size(); i++) {\n    temp = value[i] - '0';\n    diff = temp - sum;\n\
    \    sum = temp + sum;\n    if (diff > 0)\n      ans = temp;\n  }\n  return ans;\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpy9irznw6: /tmp/tmpy9irznw6.cpp:29: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141604
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long temp = 0;\n    long sum = 0;\n    long count = 0;\n    long pow = 0;\n\
    \    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long\
    \ m = 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n\
    \    long r = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n    long\
    \ v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n\
    \    long A = 0;\n    long B = 0;\n    long C = 0;\n    long D = 0;\n    long\
    \ E = 0;\n    long F = 0;\n    long G = 0;\n    long H = 0;\n    long I = 0;\n\
    \    long J = 0;\n    long K = 0;\n    long L = 0;\n    long M = 0;\n    long\
    \ N = 0;\n    long O = 0;\n    long P = 0;\n    long Q = 0;\n    long R = 0;\n\
    \    long S = 0;\n    long T = 0;\n    long U = 0;\n    long V = 0;\n    long\
    \ W = 0;\n    long X = 0;\n    long Y = 0;\n    long Z = 0;\n    long a = 0;\n\
    \    long b = 0;\n    long c = 0;\n    long d = 0;\n    long e = 0;\n    long\
    \ f = 0;\n    long g = 0;\n    long h = 0;\n    long i = 0;\n    long j = 0;\n\
    \    long k = 0;\n    long l = 0;\n    long m = 0;\n    long n = 0;\n    long\
    \ o = 0;\n    long p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n\
    \    long t = 0;\n    long u = 0;\n    long v = 0;\n    long w = 0;\n    long\
    \ x = 0;\n    long y = 0;\n    long z = 0;\n    long A = 0;\n    long B = 0;\n\
    \    long C = 0;\n    long D = 0;\n    long E = 0;\n    long F = 0;\n    long\
    \ G = 0;\n    long H = 0;\n    long I = 0;\n    long J = 0;\n    long K = 0;\n\
    \    long L = 0;\n    long M = 0;\n    long N = 0;\n    long O = 0;\n    long\
    \ P = 0;\n    long Q = 0;\n    long R = 0;\n    long S = 0;\n    long T = 0;\n\
    \    long U = 0;\n    long V = 0;\n    long W = 0;\n    long X = 0;\n    long\
    \ Y = 0;\n    long Z = 0;\n    long a = 0;\n    long b = 0;\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuxyknp9k.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpuxyknp9k.cpp:71:10: error: redeclaration of \u2018long int i\u2019\n\
    \   71 |     long i = 0;\n      |          ^\n/tmp/tmpuxyknp9k.cpp:19:10: note:\
    \ \u2018long int i\u2019 previously declared here\n   19 |     long i = 0;\n \
    \     |          ^\n/tmp/tmpuxyknp9k.cpp:72:10: error: redeclaration of \u2018\
    long int j\u2019\n   72 |     long j = 0;\n      |          ^\n/tmp/tmpuxyknp9k.cpp:20:10:\
    \ note: \u2018long int j\u2019 previously declared here\n   20 |     long j =\
    \ 0;\n      |          ^\n/tmp/tmpuxyknp9k.cpp:73:10: error: redeclaration of\
    \ \u2018long int k\u2019\n   73 |     long k = 0;\n      |          ^\n/tmp/tmpuxyknp9k.cpp:21:10:\
    \ note: \u2018long int k\u2019 previously declared here\n   21 |     long k =\
    \ 0;\n      |          ^\n/tmp/tmpuxyknp9k.cpp:74:10: error: redeclaration of\
    \ \u2018long int l\u2019\n   74 |     long l = 0;\n      |          ^\n/tmp/tmpuxyknp9k.cpp:22:10:\
    \ note: \u2018long int l\u2019 previously declared here\n   22 |     long l =\
    \ 0;\n      |          ^\n/tmp/tmpuxyknp9k.cpp:75:10: error: redeclaration of\
    \ \u2018long int m\u2019\n   75 |     long m = 0;\n      |          ^\n/tmp/tmpuxyknp9k.cpp:23:10:\
    \ note: \u2018long int m\u2019 previously declared here\n   23 |     long m =\
    \ 0;\n      |          ^\n/tmp/tmpuxyknp9k.cpp:76:10: error: redeclaration of\
    \ \u2018long int n\u2019\n   76 |     long n = 0;\n      |          ^\n/tmp/tmpuxyknp9k.cpp:24:10:\
    \ note: \u2018long int n\u2019 previously declared here\n   24 |     long n =\
    \ 0;\n      |          ^\n/tmp/tmpuxyknp9k.cpp:77:10: error: redeclaration of\
    \ \u2018long int o\u2019\n   77 |     long o = 0;\n      |          ^\n/tmp/tmpuxyknp9k.cpp:25:10:\
    \ note: \u2018long int o\u2019 previously declared here\n   25 |     long o =\
    \ 0;\n      |          ^\n/tmp/tmpuxyknp9k.cpp:78:10: error: redeclaration of\
    \ \u2018long int p\u2019\n   78 |     long p = 0;\n      |          ^\n/tmp/tmpuxyknp9k.cpp:26:10:\
    \ note: \u2018long int p\u2019 previously declared here\n   26 |     long p =\
    \ 0;\n      |          ^\n/tmp/tmpuxyknp9k.cpp:79:10: error: redeclaration of\
    \ \u2018long int q\u2019\n   79 |     long q = 0;\n      |          ^\n/tmp/tmpu"
  stdout: ''
  timestamp: 1660141604
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // Your code here\n  long ans = 0;\n\
    \  long x = stoi(value);\n  long y = stoi(value);\n  long z = stoi(value);\n \
    \ long d = abs(x - y);\n  long e = abs(x - z);\n  long f = abs(y - z);\n  long\
    \ g = abs(e - f);\n  long h = abs(e - g);\n  long i = abs(f - g);\n  long j =\
    \ abs(f - h);\n  long k = abs(g - h);\n  long l = abs(g - i);\n  long m = abs(h\
    \ - i);\n  long n = abs(h - j);\n  long o = abs(i - j);\n  long p = abs(i - k);\n\
    \  long q = abs(j - k);\n  long r = abs(j - l);\n  long s = abs(k - l);\n  long\
    \ t = abs(k - m);\n  long u = abs(l - m);\n  long v = abs(l - n);\n  long w =\
    \ abs(m - n);\n  long x = abs(m - o);\n  long y = abs(n - o);\n  long z = abs(o\
    \ - p);\n  long a = abs(p - q);\n  long b = abs(q - r);\n  long c = abs(r - s);\n\
    \  long d = abs(s - t);\n  long e = abs(t - u);\n  long f = abs(t - v);\n  long\
    \ g = abs(u - v);\n  long h = abs(u - w);\n  long i = abs(v - w);\n  long j =\
    \ abs(v - x);\n  long k = abs(w - x);\n  long l = abs(w - y);\n  long m = abs(x\
    \ - y);\n  long n = abs(x - z);\n  long o = abs(y - z);\n  long p = abs(y - a);\n\
    \  long q = abs(z - a);\n  long r = abs(z - b);\n  long s = abs(a - b);\n  long\
    \ t = abs(a - c);\n  long u = abs(b - c);\n  long v = abs(b - d);\n  long w =\
    \ abs(c - d);\n  long x = abs(c - e);\n  long y = abs(d - e);\n  long z = abs(d\
    \ - f);\n  long a = abs(e - f);\n  long b = abs(e - g);\n  long c = abs(f - g);\n\
    \  long d = abs(f - h);\n  long e = abs(f - i);\n  long f = abs(g - i);\n  long\
    \ g = abs(g - j);\n  long h = abs(g - k);\n  long i = abs(g - l);\n  long j =\
    \ abs(h - l);\n  long k = abs(h - m);\n\n}\nint main() {\n    auto candidate =\
    \ closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp95ha6wx9.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp95ha6wx9.cpp:38:8: error: redeclaration of \u2018long int x\u2019\n\
    \   38 |   long x = abs(m - o);\n      |        ^\n/tmp/tmp95ha6wx9.cpp:15:8:\
    \ note: \u2018long int x\u2019 previously declared here\n   15 |   long x = stoi(value);\n\
    \      |        ^\n/tmp/tmp95ha6wx9.cpp:39:8: error: redeclaration of \u2018long\
    \ int y\u2019\n   39 |   long y = abs(n - o);\n      |        ^\n/tmp/tmp95ha6wx9.cpp:16:8:\
    \ note: \u2018long int y\u2019 previously declared here\n   16 |   long y = stoi(value);\n\
    \      |        ^\n/tmp/tmp95ha6wx9.cpp:40:8: error: redeclaration of \u2018long\
    \ int z\u2019\n   40 |   long z = abs(o - p);\n      |        ^\n/tmp/tmp95ha6wx9.cpp:17:8:\
    \ note: \u2018long int z\u2019 previously declared here\n   17 |   long z = stoi(value);\n\
    \      |        ^\n/tmp/tmp95ha6wx9.cpp:44:8: error: redeclaration of \u2018long\
    \ int d\u2019\n   44 |   long d = abs(s - t);\n      |        ^\n/tmp/tmp95ha6wx9.cpp:18:8:\
    \ note: \u2018long int d\u2019 previously declared here\n   18 |   long d = abs(x\
    \ - y);\n      |        ^\n/tmp/tmp95ha6wx9.cpp:45:8: error: redeclaration of\
    \ \u2018long int e\u2019\n   45 |   long e = abs(t - u);\n      |        ^\n/tmp/tmp95ha6wx9.cpp:19:8:\
    \ note: \u2018long int e\u2019 previously declared here\n   19 |   long e = abs(x\
    \ - z);\n      |        ^\n/tmp/tmp95ha6wx9.cpp:46:8: error: redeclaration of\
    \ \u2018long int f\u2019\n   46 |   long f = abs(t - v);\n      |        ^\n/tmp/tmp95ha6wx9.cpp:20:8:\
    \ note: \u2018long int f\u2019 previously declared here\n   20 |   long f = abs(y\
    \ - z);\n      |        ^\n/tmp/tmp95ha6wx9.cpp:47:8: error: redeclaration of\
    \ \u2018long int g\u2019\n   47 |   long g = abs(u - v);\n      |        ^\n/tmp/tmp95ha6wx9.cpp:21:8:\
    \ note: \u2018long int g\u2019 previously declared here\n   21 |   long g = abs(e\
    \ - f);\n      |        ^\n/tmp/tmp95ha6wx9.cpp:48:8: error: redeclaration of\
    \ \u2018long int h\u2019\n   48 |   long h = abs(u - w);\n      |        ^\n/tmp/tmp95ha6wx9.cpp:22:8:\
    \ note: \u2018long int h\u2019 previously declared here\n   22 |   long h = abs(e\
    \ - g);\n      |        ^\n/tmp/tmp95ha6wx9.cpp:49:8: error: redeclaration of\
    \ \u2018"
  stdout: ''
  timestamp: 1660141604
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int ans = 0, diff = 0;\n\
    \    long long int first = 0, second = 0, third = 0;\n    long long int fourth\
    \ = 0, fifth = 0, sixth = 0, seventh = 0, eighth = 0;\n    long long int n1 =\
    \ 0, n2 = 0, n3 = 0, n4 = 0, n5 = 0;\n    long long int n6 = 0, n7 = 0, n8 = 0;\n\
    \    long long int n9 = 0, n10 = 0;\n    long long int n11 = 0, n12 = 0;\n   \
    \ long long int n13 = 0, n14 = 0, n15 = 0;\n    long long int n16 = 0, n17 = 0,\
    \ n18 = 0;\n    long long int n19 = 0, n20 = 0;\n    long long int n21 = 0, n22\
    \ = 0, n23 = 0, n24 = 0;\n    long long int n25 = 0, n26 = 0, n27 = 0, n28 = 0;\n\
    \    long long int n29 = 0, n30 = 0;\n    long long int n31 = 0, n32 = 0, n33\
    \ = 0, n34 = 0;\n    long long int n35 = 0, n36 = 0, n37 = 0, n38 = 0;\n    long\
    \ long int n39 = 0, n40 = 0;\n    long long int n41 = 0, n42 = 0, n43 = 0, n44\
    \ = 0;\n    long long int n45 = 0, n46 = 0, n47 = 0, n48 = 0;\n    long long int\
    \ n49 = 0, n50 = 0;\n    long long int n51 = 0, n52 = 0, n53 = 0, n54 = 0;\n \
    \   long long int n55 = 0, n56 = 0, n57 = 0, n58 = 0;\n    long long int n59 =\
    \ 0, n60 = 0;\n    long long int n61 = 0, n62 = 0, n63 = 0, n64 = 0;\n    long\
    \ long int n65 = 0, n66 = 0, n67 = 0, n68 = 0;\n    long long int n69 = 0, n70\
    \ = 0;\n    long long int n71 = 0, n72 = 0, n73 = 0, n74 = 0;\n    long long int\
    \ n75 = 0, n76 = 0, n77 = 0, n78 = 0;\n    long long int n79 = 0, n80 = 0;\n \
    \   long long int n81 = 0, n82 = 0, n83 = 0, n84 = 0;\n    long long int n85 =\
    \ 0, n86 = 0, n87 = 0, n88 = 0;\n    long long int n89 = 0, n90 = 0;\n    long\
    \ long int n91 = 0, n92 = 0, n93 = 0, n94 = 0;\n    long long int n95 = 0, n96\
    \ = 0, n97 = 0, n98 = 0;\n    long \n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpci1xd7ex.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpci1xd7ex.cpp:47:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   47 | }\n      | ^\n/tmp/tmpci1xd7ex.cpp:47:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int a = stoi(value);\n \
    \   long long int b = stoi(value);\n    long long int c = stoi(value);\n    long\
    \ long int d = stoi(value);\n    long long int e = stoi(value);\n    long long\
    \ int f = stoi(value);\n    long long int g = stoi(value);\n    long long int\
    \ h = stoi(value);\n    long long int i = stoi(value);\n    long long int j =\
    \ stoi(value);\n    long long int k = stoi(value);\n    long long int l = stoi(value);\n\
    \    long long int m = stoi(value);\n    long long int n = stoi(value);\n    long\
    \ long int o = stoi(value);\n    long long int p = stoi(value);\n    long long\
    \ int q = stoi(value);\n    long long int r = stoi(value);\n    long long int\
    \ s = stoi(value);\n    long long int t = stoi(value);\n    long long int u =\
    \ stoi(value);\n    long long int v = stoi(value);\n    long long int w = stoi(value);\n\
    \    long long int x = stoi(value);\n    long long int y = stoi(value);\n    long\
    \ long int z = stoi(value);\n    long long int A = a;\n    long long int B = b;\n\
    \    long long int C = c; \n    long long int D = d; \n    long long int E; \n\
    \    long long int F = f; \n    long long int G; \n    long long int H; \n   \
    \ long long int I; \n    long long int J; \n    long long int K; \n    long long\
    \ int L; \n    long long int M; \n    long long int N; \n    long long int O;\
    \ \n    long long int P; \n    long long int Q; \n    long long int R; \n    long\
    \ long int S; \n    long long int T; \n    long long int U; \n    long long int\
    \ V; \n    long long int W; \n    long long int X; \n    long long int Y; \n \
    \   long long int Z; \n    long long int AA; \n    long long int BB; \n    long\
    \ long int CC; \n    long long int DD; \n    long long int EE; \n    long long\
    \ int FF; \n    long long int GG; \n    long long int HH; \n    long long int\
    \ II; \n    long long int JJ; \n    long long int KK; \n    long long int LL;\
    \ \n    long long int MM; \n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpa__l0lae: /tmp/tmpa__l0lae.cpp:82: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ ans = 0, temp;\n    temp = std::stoll(value);\n    if (temp > ans) {\n     \
    \   ans = temp;\n    }\n    return ans;\n}\nint main() {\n    auto candidate =\
    \ closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpkm8kcxkf: /tmp/tmpkm8kcxkf.cpp:24: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Declare a variable to hold the\
    \ closest integer\n    long closest;\n    // Declare a variable to hold the difference\
    \ between the given number\n    // and the closest integer\n    long difference;\n\
    \    // Declare a variable to hold the difference between the given number\n \
    \   // and the closest integer\n    long difference2;\n    // Declare a variable\
    \ to hold the difference between the given number\n    // and the closest integer\n\
    \    long difference3;\n    // Declare a variable to hold the difference between\
    \ the given number\n    // and the closest integer\n    long difference4;\n  \
    \  // Declare a variable to hold the difference between the given number\n   \
    \ // and the closest integer\n    long difference5;\n    // Declare a variable\
    \ to hold the difference between the given number\n    // and the closest integer\n\
    \    long difference6;\n    // Declare a variable to hold the difference between\
    \ the given number\n    // and the closest integer\n    long difference7;\n  \
    \  // Declare a variable to hold the difference between the given number\n   \
    \ // and the closest integer\n    long difference8;\n    // Declare a variable\
    \ to hold the difference between the given number\n    // and the closest integer\n\
    \    long difference9;\n    // Declare a variable to hold the difference between\
    \ the given number\n    // and the closest integer\n    long difference10;\n \
    \   // Declare a variable to hold the difference between the given number\n  \
    \  // and the closest integer\n    long difference11;\n    // Declare a variable\
    \ to hold the difference between the given number\n    // and the closest integer\n\
    \    long difference12;\n    // Declare a variable to hold the difference between\
    \ the given number\n    // and the closest integer\n    long difference13;\n \
    \   // Declare a variable to hold the difference between the given number\n  \
    \  // and the closest integer\n    long difference14;\n    // Declare a variable\
    \ to hold the difference between the given number\n    // and the closest integer\n\
    \    long difference15;\n    // Declare a variable to hold the difference between\
    \ the given number\n    // and the closest integer\n    long difference16;\n \
    \   // Declare a variable to hold the difference between the given number\n  \
    \  // and the closest integer\n    long difference17;\n    // Declare a variable\
    \ to hold the difference between the given number\n    // and the closest integer\n\
    \    long difference18;\n    // Declare a variable to hold the difference between\
    \ the given number\n    // and the closest integer\n    long difference19;\n \
    \   // Declare a variable to hold the difference between the given number\n  \
    \  // and the closest integer\n    long difference20;\n    // Declare a variable\
    \ to hold the difference between the given number\n    // and the closest integer\n\
    \    long difference21;\n    // Declare a variable to hold the difference \n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp7ywj1owt: /tmp/tmp7ywj1owt.cpp:82: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ ans = 0, diff = 0;\n    long long temp;\n    temp = atof(value.c_str());\n \
    \   diff = temp - ans;\n    if (diff < 0) {\n        diff += temp;\n    }\n  \
    \  ans = temp;\n    diff = diff * -1;\n    if (diff < temp) {\n        diff +=\
    \ temp;\n    }\n    ans = temp;\n    return diff;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpm6dympit: /tmp/tmpm6dympit.cpp:31: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141604
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n\
    \    long mid = 0;\n    long diff = 0;\n    long diff2 = 0;\n    long diff3 =\
    \ 0;\n    long diff4 = 0;\n    long diff5 = 0;\n    long diff6 = 0;\n    long\
    \ diff7 = 0;\n    long diff8 = 0;\n    long diff9 = 0;\n    long diff10 = 0;\n\
    \    long diff11 = 0;\n    long diff12 = 0;\n    long diff13 = 0;\n    long diff14\
    \ = 0;\n    long diff15 = 0;\n    long diff16 = 0;\n    long diff17 = 0;\n   \
    \ long diff18 = 0;\n    long diff19 = 0;\n    long diff20 = 0;\n    long diff21\
    \ = 0;\n    long diff22 = 0;\n    long diff23 = 0;\n    long diff24 = 0;\n   \
    \ long diff25 = 0;\n    long diff26 = 0;\n    long diff27 = 0;\n    long diff28\
    \ = 0;\n    long diff29 = 0;\n    long diff30 = 0;\n    long diff31 = 0;\n   \
    \ long diff32 = 0;\n    long diff33 = 0;\n    long diff34 = 0;\n    long diff35\
    \ = 0;\n    long diff36 = 0;\n    long diff37 = 0;\n    long diff38 = 0;\n   \
    \ long diff39 = 0;\n    long diff40 = 0;\n    long diff41 = 0;\n    long diff42\
    \ = 0;\n    long diff43 = 0;\n    long diff44 = 0;\n    long diff45 = 0;\n   \
    \ long diff46 = 0;\n    long diff47 = 0;\n    long diff48 = 0;\n    long diff49\
    \ = 0;\n    long diff50 = 0;\n    long diff51 = 0;\n    long diff52 = 0;\n   \
    \ long diff53 = 0;\n    long diff54 = 0;\n    long diff55 = 0;\n    long diff56\
    \ = 0;\n    long diff57 = 0;\n    long diff58 = 0;\n    long diff59 = 0;\n   \
    \ long diff60 = 0;\n    long diff61 = 0;\n    long diff62 = 0;\n    long diff63\
    \ = 0;\n    long diff64 = 0;\n    long diff65 = 0;\n    long diff66 = 0;\n   \
    \ long diff67 = 0;\n    long diff68 = 0;\n    long diff69 = 0;\n    long diff70\
    \ = 0;\n    long diff71 = 0;\n    long diff72 = 0;\n    long diff73 = 0;\n   \
    \ long diff74 = 0;\n    long diff75 = 0;\n    long diff76 = 0;\n    long diff77\
    \ = 0;\n    long diff78 = 0;\n    long diff79 = 0;\n    long diff80 = 0;\n   \
    \ long diff81 = 0;\n    long diff82 = 0;\n    long diff83\n}\nint main() {\n \
    \   auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa2otwikc.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpa2otwikc.cpp:98:1: error: expected initializer before \u2018}\u2019\
    \ token\n   98 | }\n      | ^\n/tmp/tmpa2otwikc.cpp:98:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141604
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long a = std::stoi(value);\n\
    \    long b = std::stoi(value);\n    long c = std::stoi(value);\n    long d =\
    \ std::stoi(value);\n    long e = std::stoi(value);\n    long f = std::stoi(value);\n\
    \    long g = std::stoi(value);\n    long h = std::stoi(value);\n    long i =\
    \ std::stoi(value);\n    long j = std::stoi(value);\n    long k = std::stoi(value);\n\
    \    long l = std::stoi(value);\n    long m = std::stoi(value);\n    long n =\
    \ std::stoi(value);\n    long o = std::stoi(value);\n    long p = std::stoi(value);\n\
    \    long q = std::stoi(value);\n    long r = std::stoi(value);\n    long s =\
    \ std::stoi(value);\n    long t = std::stoi(value);\n    long u = std::stoi(value);\n\
    \    long v = std::stoi(value);\n    long w = std::stoi(value);\n    long x =\
    \ std::stoi(value);\n    long y = std::stoi(value);\n    long z = std::stoi(value);\n\
    \    long a = std::stoi(value);\n    long b = std::stoi(value);\n    long c =\
    \ std::stoi(value);\n    long d = std::stoi(value);\n    long e = std::stoi(value);\n\
    \    long f = std::stoi(value);\n    long g = std::stoi(value);\n    long h =\
    \ std::stoi(value);\n    long i = std::stoi(value);\n    long j = std::stoi(value);\n\
    \    long k = std::stoi(value);\n    long l = std::stoi(value);\n    long m =\
    \ std::stoi(value);\n    long n = std::stoi(value);\n    long o = std::stoi(value);\n\
    \    long p = std::stoi(value);\n    long q = std::stoi(value);\n    long r =\
    \ std::stoi(value);\n    long s = std::stoi(value);\n    long t = std::stoi(value);\n\
    \    long u = std::stoi(value);\n    long v = std::stoi(value);\n    long w =\
    \ std::stoi(value);\n    long x = std::stoi(value);\n    long y = std::stoi(value);\n\
    \    long z = std::stoi(value);\n    long a = std::stoi(value);\n    long b =\
    \ std::stoi(value);\n    long c = std::stoi(value);\n    long d = std::stoi(value);\n\
    \    long e = std::stoi(value);\n    long f = std::stoi(value);\n    long g =\
    \ std::stoi(value);\n    long h = std::stoi(value);\n    long i = std::stoi(value);\n\
    \    long j = std::stoi(value);\n    long k = std::stoi(value);\n    long l =\
    \ \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_bl4luxc.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp_bl4luxc.cpp:40:10: error: redeclaration of \u2018long int a\u2019\n\
    \   40 |     long a = std::stoi(value);\n      |          ^\n/tmp/tmp_bl4luxc.cpp:14:10:\
    \ note: \u2018long int a\u2019 previously declared here\n   14 |     long a =\
    \ std::stoi(value);\n      |          ^\n/tmp/tmp_bl4luxc.cpp:41:10: error: redeclaration\
    \ of \u2018long int b\u2019\n   41 |     long b = std::stoi(value);\n      | \
    \         ^\n/tmp/tmp_bl4luxc.cpp:15:10: note: \u2018long int b\u2019 previously\
    \ declared here\n   15 |     long b = std::stoi(value);\n      |          ^\n\
    /tmp/tmp_bl4luxc.cpp:42:10: error: redeclaration of \u2018long int c\u2019\n \
    \  42 |     long c = std::stoi(value);\n      |          ^\n/tmp/tmp_bl4luxc.cpp:16:10:\
    \ note: \u2018long int c\u2019 previously declared here\n   16 |     long c =\
    \ std::stoi(value);\n      |          ^\n/tmp/tmp_bl4luxc.cpp:43:10: error: redeclaration\
    \ of \u2018long int d\u2019\n   43 |     long d = std::stoi(value);\n      | \
    \         ^\n/tmp/tmp_bl4luxc.cpp:17:10: note: \u2018long int d\u2019 previously\
    \ declared here\n   17 |     long d = std::stoi(value);\n      |          ^\n\
    /tmp/tmp_bl4luxc.cpp:44:10: error: redeclaration of \u2018long int e\u2019\n \
    \  44 |     long e = std::stoi(value);\n      |          ^\n/tmp/tmp_bl4luxc.cpp:18:10:\
    \ note: \u2018long int e\u2019 previously declared here\n   18 |     long e =\
    \ std::stoi(value);\n      |          ^\n/tmp/tmp_bl4luxc.cpp:45:10: error: redeclaration\
    \ of \u2018long int f\u2019\n   45 |     long f = std::stoi(value);\n      | \
    \         ^\n/tmp/tmp_bl4luxc.cpp:19:10: note: \u2018long int f\u2019 previously\
    \ declared here\n   19 |     long f = std::stoi(value);\n      |          ^\n\
    /tmp/tmp_bl4luxc.cpp:46:10: error: redeclaration of \u2018long int g\u2019\n \
    \  46 |     long g = std::stoi(value);\n      |          ^\n/tmp/tmp_bl4luxc.cpp:20:10:\
    \ note: \u2018long int g\u2019 previously declared here\n   20 |     long g =\
    \ std::stoi(value);\n      |          ^\n/tmp/tmp_bl4luxc.cpp:47:10: error: redeclaration\
    \ of \u2018long int h\u2019\n   47 |     long h = std::stoi(value);\n      | \
    \         ^\n/tmp/tmp_bl4lux"
  stdout: ''
  timestamp: 1660141604
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int closest = 0;\n    long\
    \ long int difference = 0;\n    long long int difference2 = 0;\n    long long\
    \ int difference3 = 0;\n    long long int difference4 = 0;\n    long long int\
    \ difference5 = 0;\n    long long int difference6 = 0;\n    long long int difference7\
    \ = 0;\n    long long int difference8 = 0;\n    long long int difference9 = 0;\n\
    \    long long int difference10 = 0;\n    long long int difference11 = 0;\n  \
    \  long long int difference12 = 0;\n    long long int difference13 = 0;\n    long\
    \ long int difference14 = 0;\n    long long int difference15 = 0;\n    long long\
    \ int difference16 = 0;\n    long long int difference17 = 0;\n    long long int\
    \ difference18 = 0;\n    long long int difference19 = 0;\n    long long int difference20\
    \ = 0;\n    long long int difference21 = 0;\n    long long int difference22 =\
    \ 0;\n    long long int difference23 = 0;\n    long long int difference24 = 0;\n\
    \    long long int difference25 = 0;\n    long long int difference26 = 0;\n  \
    \  long long int difference27 = 0;\n    long long int difference28 = 0;\n    long\
    \ long int difference29 = 0;\n    long long int difference30 = 0;\n    long long\
    \ int difference31 = 0;\n    long long int difference32 = 0;\n    long long int\
    \ difference33 = 0;\n    long long int difference34 = 0;\n    long long int difference35\
    \ = 0;\n    long long int difference36 = 0;\n    long long int difference37 =\
    \ 0;\n    long long int difference38 = 0;\n    long long int difference39 = 0;\n\
    \    long long int difference40 = 0;\n    long long int difference41 = 0;\n  \
    \  long long int difference42 = 0;\n    long long int difference43 = 0;\n    long\
    \ long int difference44 = 0;\n    long long int difference45 = 0;\n    long long\
    \ int difference46 = 0;\n    long long int difference47 = 0;\n    long long int\
    \ difference48 = 0;\n    long long int difference49 = 0;\n    long long int difference50\
    \ = 0;\n    long long int difference51 = 0;\n    long long int difference52 =\
    \ 0;\n    long long int difference53 = 0;\n    long long int difference54 = 0;\n\
    \    long long int difference55 = 0;\n    long long int difference56 = 0;\n  \
    \  long long int difference57 = 0;\n    long long int difference58 = 0;\n    long\
    \ long int difference59 = 0;\n    long long int difference60 = 0;\n    long long\
    \ int difference61 = 0;\n    long long int difference62 = 0;\n    long long int\
    \ difference63 = 0;\n    long long int difference64\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp0butxnmp.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp0butxnmp.cpp:78:1: error: expected initializer before \u2018}\u2019\
    \ token\n   78 | }\n      | ^\n/tmp/tmp0butxnmp.cpp:78:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141604
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n\
    \    long mid = 0;\n    long diff = std::numeric_limits<long>::max();\n    long\
    \ closest = 0;\n    long temp = 0;\n    long count = 0;\n    long index = 0;\n\
    \    long sum = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 =\
    \ 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long\
    \ temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n\
    \    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15\
    \ = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n   \
    \ long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22\
    \ = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n   \
    \ long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29\
    \ = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n   \
    \ long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36\
    \ = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n   \
    \ long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43\
    \ = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n   \
    \ long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50\
    \ = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n   \
    \ long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57\
    \ = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n   \
    \ long temp61 = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64\
    \ = 0;\n    long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n   \
    \ long temp68 = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71\
    \ = 0;\n    long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n   \
    \ long temp75 = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpz8e__ito.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpz8e__ito.cpp:98:1: error: expected initializer before \u2018}\u2019\
    \ token\n   98 | }\n      | ^\n/tmp/tmpz8e__ito.cpp:98:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n\
    \    long mid = 0;\n    long diff = std::numeric_limits<long>::max();\n    long\
    \ diff1 = std::numeric_limits<long>::max();\n    long diff2 = std::numeric_limits<long>::max();\n\
    \    long diff3 = std::numeric_limits<long>::max();\n    long diff4 = std::numeric_limits<long>::max();\n\
    \    long diff5 = std::numeric_limits<long>::max();\n    long diff6 = std::numeric_limits<long>::max();\n\
    \    long diff7 = std::numeric_limits<long>::max();\n    long diff8 = std::numeric_limits<long>::max();\n\
    \    long diff9 = std::numeric_limits<long>::max();\n    long diff10 = std::numeric_limits<long>::max();\n\
    \    long diff11 = std::numeric_limits<long>::max();\n    long diff12 = std::numeric_limits<long>::max();\n\
    \    long diff13 = std::numeric_limits<long>::max();\n    long diff14 = std::numeric_limits<long>::max();\n\
    \    long diff15 = std::numeric_limits<long>::max();\n    long diff16 = std::numeric_limits<long>::max();\n\
    \    long diff17 = std::numeric_limits<long>::max();\n    long diff18 = std::numeric_limits<long>::max();\n\
    \    long diff19 = std::numeric_limits<long>::max();\n    long diff20 = std::numeric_limits<long>::max();\n\
    \    long diff21 = std::numeric_limits<long>::max();\n    long diff22 = std::numeric_limits<long>::max();\n\
    \    long diff23 = std::numeric_limits<long>::max();\n    long diff24 = std::numeric_limits<long>::max();\n\
    \    long diff25 = std::numeric_limits<long>::max();\n    long diff26 = std::numeric_limits<long>::max();\n\
    \    long diff27 = std::numeric_limits<long>::max();\n    long diff28 = std::numeric_limits<long>::max();\n\
    \    long diff29 = std::numeric_limits<long>::max();\n    long diff30 = std::numeric_limits<long>::max();\n\
    \    long diff31 = std::numeric_limits<long>::max();\n    long diff32 = std::numeric_limits<long>::max();\n\
    \    long diff33 = std::numeric_limits<long>::max();\n    long diff34 = std::numeric_limits<long>::max();\n\
    \    long diff35 = std::numeric_limits<long>::max();\n    \n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp1lr7l1uw: /tmp/tmp1lr7l1uw.cpp:55: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141604
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int closest;\n    long long\
    \ int difference;\n    long long int temp;\n    long long int temp2;\n    long\
    \ long int temp3;\n    long long int temp4;\n    long long int temp5;\n    long\
    \ long int temp6;\n    long long int temp7;\n    long long int temp8;\n    long\
    \ long int temp9;\n    long long int temp10;\n    long long int temp11;\n    long\
    \ long int temp12;\n    long long int temp13;\n    long long int temp14;\n   \
    \ long long int temp15;\n    long long int temp16;\n    long long int temp17;\n\
    \    long long int temp18;\n    long long int temp19;\n    long long int temp20;\n\
    \    long long int temp21;\n    long long int temp22;\n    long long int temp23;\n\
    \    long long int temp24;\n    long long int temp25;\n    long long int temp26;\n\
    \    long long int temp27;\n    long long int temp28;\n    long long int temp29;\n\
    \    long long int temp30;\n    long long int temp31;\n    long long int temp32;\n\
    \    long long int temp33;\n    long long int temp34;\n    long long int temp35;\n\
    \    long long int temp36;\n    long long int temp37;\n    long long int temp38;\n\
    \    long long int temp39;\n    long long int temp40;\n    long long int temp41;\n\
    \    long long int temp42;\n    long long int temp43;\n    long long int temp44;\n\
    \    long long int temp45;\n    long long int temp46;\n    long long int temp47;\n\
    \    long long int temp48;\n    long long int temp49;\n    long long int temp50;\n\
    \    long long int temp51;\n    long long int temp52;\n    long long int temp53;\n\
    \    long long int temp54;\n    long long int temp55;\n    long long int temp56;\n\
    \    long long int temp57;\n    long long int temp58;\n    long long int temp59;\n\
    \    long long int temp60;\n    long long int temp61;\n    long long int temp62;\n\
    \    long long int temp63;\n    long long int temp64;\n    long long int temp65\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpo8omhn36.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpo8omhn36.cpp:80:1: error: expected initializer before \u2018}\u2019\
    \ token\n   80 | }\n      | ^\n/tmp/tmpo8omhn36.cpp:80:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long diff = 0;\n    long sum = 0;\n    long i = 0;\n    long j = 0;\n\
    \    long k = 0;\n    long l = 0;\n    long m = 0;\n    long n = 0;\n    long\
    \ o = 0;\n    long p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n\
    \    long t = 0;\n    long u = 0;\n    long v = 0;\n    long w = 0;\n    long\
    \ x = 0;\n    long y = 0;\n    long z = 0;\n    long A = 0;\n    long B = 0;\n\
    \    long C = 0;\n    long D = 0;\n    long E = 0;\n    long F = 0;\n    long\
    \ G = 0;\n    long H = 0;\n    long I = 0;\n    long J = 0;\n    long K = 0;\n\
    \    long L = 0;\n    long M = 0;\n    long N = 0;\n    long O = 0;\n    long\
    \ P = 0;\n    long Q = 0;\n    long R = 0;\n    long S = 0;\n    long T = 0;\n\
    \    long U = 0;\n    long V = 0;\n    long W = 0;\n    long X = 0;\n    long\
    \ Y = 0;\n    long Z = 0;\n    long AA = 0;\n    long AB = 0;\n    long AC = 0;\n\
    \    long AD = 0;\n    long AE = 0;\n    long AF = 0;\n    long AG = 0;\n    long\
    \ AH = 0;\n    long AI = 0;\n    long AJ = 0;\n    long AK = 0;\n    long AL =\
    \ 0;\n    long AM = 0;\n    long AN = 0;\n    long AO = 0;\n    long AP = 0;\n\
    \    long AQ = 0;\n    long AR = 0;\n    long AS = 0;\n    long AT = 0;\n    long\
    \ AU = 0;\n    long AV = 0;\n    long AW = 0;\n    long AX = 0;\n    long AY =\
    \ 0;\n    long AZ = 0;\n    long BA = 0;\n    long BB = 0;\n    long BC = 0;\n\
    \    long BD = 0;\n    long BE = 0;\n    long BF = 0;\n    long BG = 0;\n    long\
    \ BH = 0;\n    long BI = 0;\n    long BJ = 0;\n    long BK = 0;\n    long BL =\
    \ 0;\n    long BM = 0;\n    long BN = 0;\n    long BO = 0;\n    long BP = 0;\n\
    \    long BQ = 0;\n    long BR = 0;\n    long BS = 0;\n    long BT = 0;\n    long\
    \ BU = 0;\n    long BV = 0;\n    long BW = 0;\n    long BX = 0;\n    long BY =\
    \ 0;\n    long BZ = 0;\n    long CA = 0;\n    \n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpksm7nqow: /tmp/tmpksm7nqow.cpp:118: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num;\n    long long\
    \ int min;\n    long long int max;\n    long long int mid;\n    long long int\
    \ diff;\n    long long int diff2;\n    long long int diff3;\n    long long int\
    \ diff4;\n    long long int diff5;\n    long long int diff6;\n    long long int\
    \ diff7;\n    long long int diff8;\n    long long int diff9;\n    long long int\
    \ diff10;\n    long long int diff11;\n    long long int diff12;\n    long long\
    \ int diff13;\n    long long int diff14;\n    long long int diff15;\n    long\
    \ long int diff16;\n    long long int diff17;\n    long long int diff18;\n   \
    \ long long int diff19;\n    long long int diff20;\n    long long int diff21;\n\
    \    long long int diff22;\n    long long int diff23;\n    long long int diff24;\n\
    \    long long int diff25;\n    long long int diff26;\n    long long int diff27;\n\
    \    long long int diff28;\n    long long int diff29;\n    long long int diff30;\n\
    \    long long int diff31;\n    long long int diff32;\n    long long int diff33;\n\
    \    long long int diff34;\n    long long int diff35;\n    long long int diff36;\n\
    \    long long int diff37;\n    long long int diff38;\n    long long int diff39;\n\
    \    long long int diff40;\n    long long int diff41;\n    long long int diff42;\n\
    \    long long int diff43;\n    long long int diff44;\n    long long int diff45;\n\
    \    long long int diff46;\n    long long int diff47;\n    long long int diff48;\n\
    \    long long int diff49;\n    long long int diff50;\n    long long int diff51;\n\
    \    long long int diff52;\n    long long int diff53;\n    long long int diff54;\n\
    \    long long int diff55;\n    long long int diff56;\n    long long int diff57;\n\
    \    long long int diff58;\n    long long int diff59;\n    long long int diff60;\n\
    \    long long int diff61;\n    long long int diff62;\n    long long int diff63;\n\
    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpqg_4dw5y: /tmp/tmpqg_4dw5y.cpp:84: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141604
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long temp = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n\
    \    long l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n    long\
    \ p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n\
    \    long u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n    long\
    \ y = 0;\n    long z = 0;\n    long A = 0;\n    long B = 0;\n    long C = 0;\n\
    \    long D = 0;\n    long E = 0;\n    long F = 0;\n    long G = 0;\n    long\
    \ H = 0;\n    long I = 0;\n    long J = 0;\n    long K = 0;\n    long L = 0;\n\
    \    long M = 0;\n    long N = 0;\n    long O = 0;\n    long P = 0;\n    long\
    \ Q = 0;\n    long R = 0;\n    long S = 0;\n    long T = 0;\n    long U = 0;\n\
    \    long V = 0;\n    long W = 0;\n    long X = 0;\n    long Y = 0;\n    long\
    \ Z = 0;\n    long aa = 0;\n    long bb = 0;\n    long cc = 0;\n    long dd =\
    \ 0;\n    long ee = 0;\n    long ff = 0;\n    long gg = 0;\n    long hh = 0;\n\
    \    long ii = 0;\n    long jj = 0;\n    long kk = 0;\n    long ll = 0;\n    long\
    \ mm = 0;\n    long nn = 0;\n    long oo = 0;\n    long pp = 0;\n    long qq =\
    \ 0;\n    long rr = 0;\n    long ss = 0;\n    long tt = 0;\n    long uu = 0;\n\
    \    long vv = 0;\n    long ww = 0;\n    long xx = 0;\n    long yy = 0;\n    long\
    \ zz = 0;\n    long Aa = 0;\n    long Bb = 0;\n    long Cc = 0;\n    long Dd =\
    \ 0;\n    long Ee = 0;\n    long Ff = 0;\n    long Gg = 0;\n    long Hh = 0;\n\
    \    long Ii = 0;\n    long Jj = 0;\n    long Kk = 0;\n    long Ll = 0;\n    long\
    \ Mm = 0;\n    long Nn = 0;\n    long Oo = 0;\n    long Pp = 0;\n    long Qq =\
    \ 0;\n    long Rr = 0;\n    long Ss = 0;\n    long Tt = 0;\n    long Uu = 0;\n\
    \    long Vv = 0;\n    long Ww = 0;\n    long Xx = 0;\n    long Yy = 0;\n    long\
    \ Z\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzrioc3sy.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpzrioc3sy.cpp:112:1: error: expected initializer before \u2018}\u2019\
    \ token\n  112 | }\n      | ^\n/tmp/tmpzrioc3sy.cpp:112:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, diff = 0;\n    long long temp;\n    temp = atof(value.c_str());\n    diff\
    \ = temp - ans;\n    ans = temp;\n    if (diff < 0) {\n        diff *= -1;\n \
    \   }\n    diff = diff * -1;\n    if (diff > 100) {\n        diff = diff / 100;\n\
    \        ans = ans / 100;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpa1g8fg7p: /tmp/tmpa1g8fg7p.cpp:32: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141605
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n \
    \   long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8\
    \ = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long\
    \ temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n\
    \    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19\
    \ = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n   \
    \ long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26\
    \ = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n   \
    \ long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33\
    \ = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n   \
    \ long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40\
    \ = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n   \
    \ long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47\
    \ = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n   \
    \ long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54\
    \ = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n   \
    \ long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61\
    \ = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n   \
    \ long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68\
    \ = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n   \
    \ long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75\
    \ = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n   \
    \ long temp79 = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82\
    \ = 0;\n    long temp83 = 0;\n    long temp84 = 0;\n    long temp85 = 0;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp8wv4j_et: /tmp/tmp8wv4j_et.cpp:102: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141605
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp = 0;\n    long long temp2 = 0;\n    long long temp3 = 0;\n    long\
    \ long temp4 = 0;\n    long long temp5 = 0;\n    long long temp6 = 0;\n    long\
    \ long temp7 = 0;\n    long long temp8 = 0;\n    long long temp9 = 0;\n    long\
    \ long temp10 = 0;\n    long long temp11 = 0;\n    long long temp12 = 0;\n   \
    \ long long temp13 = 0;\n    long long temp14 = 0;\n    long long temp15 = 0;\n\
    \    long long temp16 = 0;\n    long long temp17 = 0;\n    long long temp18 =\
    \ 0;\n    long long temp19 = 0;\n    long long temp20 = 0;\n    long long temp21\
    \ = 0;\n    long long temp22 = 0;\n    long long temp23 = 0;\n    long long temp24\
    \ = 0;\n    long long temp25 = 0;\n    long long temp26 = 0;\n    long long temp27\
    \ = 0;\n    long long temp28 = 0;\n    long long temp29 = 0;\n    long long temp30\
    \ = 0;\n    long long temp31 = 0;\n    long long temp32 = 0;\n    long long temp33\
    \ = 0;\n    long long temp34 = 0;\n    long long temp35 = 0;\n    long long temp36\
    \ = 0;\n    long long temp37 = 0;\n    long long temp38 = 0;\n    long long temp39\
    \ = 0;\n    long long temp40 = 0;\n    long long temp41 = 0;\n    long long temp42\
    \ = 0;\n    long long temp43 = 0;\n    long long temp44 = 0;\n    long long temp45\
    \ = 0;\n    long long temp46 = 0;\n    long long temp47 = 0;\n    long long temp48\
    \ = 0;\n    long long temp49 = 0;\n    long long temp50 = 0;\n    long long temp51\
    \ = 0;\n    long long temp52 = 0;\n    long long temp53 = 0;\n    long long temp54\
    \ = 0;\n    long long temp55 = 0;\n    long long temp56 = 0;\n    long long temp57\
    \ = 0;\n    long long temp58 = 0;\n    long long temp59 = 0;\n    long long temp60\
    \ = 0;\n    long long temp61 = 0;\n    long long temp62 = 0;\n    long long temp63\
    \ = 0;\n    long long temp64 = 0;\n    long long temp65 = 0;\n    long long temp66\
    \ = 0;\n    long long temp67 = 0;\n    long long temp68 = 0;\n    long long temp69\
    \ = 0;\n    long long temp70 = 0;\n    long long temp71 = 0;\n    long long temp72\
    \ = 0;\n    long long temp73\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjgxgzpwg.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpjgxgzpwg.cpp:87:1: error: expected initializer before \u2018}\u2019\
    \ token\n   87 | }\n      | ^\n/tmp/tmpjgxgzpwg.cpp:87:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n\
    \    long diff = std::abs(std::stod(value));\n    long mid = diff / 2;\n    long\
    \ diff2 = diff - mid;\n    long mid2 = mid - mid;\n    long mid3 = mid + mid;\n\
    \    long mid4 = mid + mid2;\n    long mid5 = mid + mid3;\n    long mid6 = mid\
    \ + mid4;\n    long mid7 = mid + mid5;\n    long mid8 = mid + mid6;\n    long\
    \ mid9 = mid + mid7;\n    long mid10 = mid + mid8;\n    long mid11 = mid + mid9;\n\
    \    long mid12 = mid + mid10;\n    long mid13 = mid + mid11;\n    long mid14\
    \ = mid + mid12;\n    long mid15 = mid + mid13;\n    long mid16 = mid + mid14;\n\
    \    long mid17 = mid + mid15;\n    long mid18 = mid + mid16;\n    long mid19\
    \ = mid + mid17;\n    long mid20 = mid + mid18;\n    long mid21 = mid + mid19;\n\
    \    long mid22 = mid + mid20;\n    long mid23 = mid + mid21;\n    long mid24\
    \ = mid + mid22;\n    long mid25 = mid + mid23;\n    long mid26 = mid + mid24;\n\
    \    long mid27 = mid + mid25;\n    long mid28 = mid + mid26;\n    long mid29\
    \ = mid + mid27;\n    long mid30 = mid + mid28;\n    long mid31 = mid + mid29;\n\
    \    long mid32 = mid + mid30;\n    long mid33 = mid + mid31;\n    long mid34\
    \ = mid + mid32;\n    long mid35 = mid + mid33;\n    long mid36 = mid + mid34;\n\
    \    long mid37 = mid + mid35;\n    long mid38 = mid + mid36;\n    long mid39\
    \ = mid + mid37;\n    long mid40 = mid + mid38;\n    long mid41 = mid + mid39;\n\
    \    long mid42 = mid + mid40;\n    long mid43 = mid + mid41;\n    long mid44\
    \ = mid + mid42;\n    long mid45 = mid + mid43;\n    long mid46 = mid + mid44;\n\
    \    long mid47 = mid + mid45;\n    long mid48 = mid + mid46;\n    long mid49\
    \ = mid + mid47;\n    \n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpml5h8a_h: /tmp/tmpml5h8a_h.cpp:69: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp;\n    temp = atof(value.c_str());\n    diff = temp - ans;\n    if\
    \ (diff < 0) {\n        diff += temp;\n    }\n    ans = diff;\n    while (diff\
    \ >= temp) {\n        diff -= temp;\n        ans++;\n    }\n    return ans;\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpgv3vfgoy: /tmp/tmpgv3vfgoy.cpp:29: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141605
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long long int\
    \ sum = 0;\n    long long int min = std::numeric_limits<long long int>::max();\n\
    \    long long int max = std::numeric_limits<long long int>::min();\n    long\
    \ long int mid = 0;\n    long long int count = 0;\n    long long int diff = 0;\n\
    \    long long int sum1 = 0;\n    long long int sum2 = 0;\n    long long int sum3\
    \ = 0;\n    long long int sum4 = 0;\n    long long int sum5 = 0;\n    long long\
    \ int sum6 = 0;\n    long long int sum7 = 0;\n    long long int sum8 = 0;\n  \
    \  long long int sum9 = 0;\n    long long int sum10 = 0;\n    long long int sum11\
    \ = 0;\n    long long int sum12 = 0;\n    long long int sum13 = 0;\n    long long\
    \ int sum14 = 0;\n    long long int sum15 = 0;\n    long long int sum16 = 0;\n\
    \    long long int sum17 = 0;\n    long long int sum18 = 0;\n    long long int\
    \ sum19 = 0;\n    long long int sum20 = 0;\n    long long int sum21 = 0;\n   \
    \ long long int sum22 = 0;\n    long long int sum23 = 0;\n    long long int sum24\
    \ = 0;\n    long long int sum25 = 0;\n    long long int sum26 = 0;\n    long long\
    \ int sum27 = 0;\n    long long int sum28 = 0;\n    long long int sum29 = 0;\n\
    \    long long int sum30 = 0;\n    long long int sum31 = 0;\n    long long int\
    \ sum32 = 0;\n    long long int sum33 = 0;\n    long long int sum34 = 0;\n   \
    \ long long int sum35 = 0;\n    long long int sum36 = 0;\n    long long int sum37\
    \ = 0;\n    long long int sum38 = 0;\n    long long int sum39 = 0;\n    long long\
    \ int sum40 = 0;\n    long long int sum41 = 0;\n    long long int sum42 = 0;\n\
    \    long long int sum43 = 0;\n    long long int sum44 = 0;\n    long long int\
    \ sum45 = 0;\n    long long int sum46 = 0;\n    long long int sum47 = 0;\n   \
    \ long long int sum48 = 0;\n    long long int sum49 = 0;\n    long long int sum50\
    \ = 0;\n    long long int sum51 = 0;\n    long long int sum52 = 0;\n    long long\
    \ int sum53 = 0;\n    long long int sum54 = 0;\n    long long int sum55 = 0;\n\
    \    long long int sum56 = 0;\n    long long int sum\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnop5diw7.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpnop5diw7.cpp:77:1: error: expected initializer before \u2018}\u2019\
    \ token\n   77 | }\n      | ^\n/tmp/tmpnop5diw7.cpp:77:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141604
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int first = 0;\n    long\
    \ long int second = 0;\n    long long int third = 0;\n    long long int fourth\
    \ = 0;\n    long long int fifth = 0;\n    long long int sixth = 0;\n    long long\
    \ int seventh = 0;\n    long long int eighth = 0;\n    long long int ninth = 0;\n\
    \    long long int tenth = 0;\n    long long int eleventh = 0;\n    long long\
    \ int twelfth = 0;\n    long long int thirteenth = 0;\n    long long int fourteenth\
    \ = 0;\n    long long int fifteenth = 0;\n    long long int sixteenth = 0;\n \
    \   long long int seventeenth = 0;\n    long long int eighteenth = 0;\n    long\
    \ long int nineteenth = 0;\n    long long int twentieth = 0;\n    long long int\
    \ twentyfirst = 0;\n    long long int twentysecond = 0;\n    long long int twentythird\
    \ = 0;\n    long long int twentyfourth = 0;\n    long long int twentyfifth = 0;\n\
    \    long long int twentysixth = 0;\n    long long int twentyseventh = 0;\n  \
    \  long long int twentyeighth = 0;\n    long long int twentyninth = 0;\n    long\
    \ long int thirtieth = 0;\n    long long int thirtyfirst = 0;\n    long long int\
    \ thirtysecond = 0;\n    long long int thirtythird = 0;\n    long long int thirtyfourth\
    \ = 0;\n    long long int thirtyfifth = 0;\n    long long int thirtysixth = 0;\n\
    \    long long int thirtyseventh = 0;\n    long long int thirtyeighth = 0;\n \
    \   long long int thirtyninth = 0;\n    long long int fortieth = 0;\n    long\
    \ long int fortyfirst = 0;\n    long long int fortysecond = 0;\n    long long\
    \ int fortythird = 0;\n    long long int fortyfourth = 0;\n    long long int fortyfifth\
    \ = 0;\n    long long int fortysixth = 0;\n    long long int fortyseventh = 0;\n\
    \    long long int fortyeighth = 0;\n    long long int fortyninth = 0;\n    long\
    \ long int fiftieth = 0;\n    long long int fiftyfirst = 0;\n    long long int\
    \ fiftysecond = 0;\n    long long int fiftythird = 0;\n    long \n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppghc0uwb.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmppghc0uwb.cpp:67:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   67 | }\n      | ^\n/tmp/tmppghc0uwb.cpp:67:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141603
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value);\n\
    \    while (lower < upper) {\n        long mid = (lower + upper) / 2;\n      \
    \  if (mid * mid > value) {\n            upper = mid;\n        } else {\n    \
    \        lower = mid;\n        }\n    }\n    return lower;\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpx0hjkeqt.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpx0hjkeqt.cpp:16:23: error: no match for \u2018operator>\u2019 (operand\
    \ types are \u2018long int\u2019 and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   16 |         if (mid * mid > value) {\n      |             ~~~~~~~~~ ^\
    \ ~~~~~\n      |                 |       |\n      |                 |       std::string\
    \ {aka std::__cxx11::basic_string<char>}\n      |                 long int\nIn\
    \ file included from /usr/include/c++/9/regex:62,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpx0hjkeqt.cpp:2:\n/usr/include/c++/9/bits/regex.h:1081:5:\
    \ note: candidate: \u2018template<class _BiIter> bool std::__cxx11::operator>(const\
    \ std::__cxx11::sub_match<_BiIter>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\
    \n 1081 |     operator>(const sub_match<_BiIter>& __lhs, const sub_match<_BiIter>&\
    \ __rhs)\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/regex.h:1081:5: note:\
    \   template argument deduction/substitution failed:\n/tmp/tmpx0hjkeqt.cpp:16:25:\
    \ note:   mismatched types \u2018const std::__cxx11::sub_match<_BiIter>\u2019\
    \ and \u2018long int\u2019\n   16 |         if (mid * mid > value) {\n      |\
    \                         ^~~~~\nIn file included from /usr/include/c++/9/regex:62,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:110,\n\
    \                 from /tmp/tmpx0hjkeqt.cpp:2:\n/usr/include/c++/9/bits/regex.h:1136:5:\
    \ note: candidate: \u2018template<class _Bi_iter, class _Ch_traits, class _Ch_alloc>\
    \ bool std::__cxx11::operator>(std::__cxx11::__sub_match_string<_Bi_iter, _Ch_traits,\
    \ _Ch_alloc>&, const std::__cxx11::sub_match<_BiIter>&)\u2019\n 1136 |     operator>(const\
    \ __sub_match_string<_Bi_iter, _Ch_traits, _Ch_alloc>& __lhs,\n      |     ^~~~~~~~\n\
    /usr/include/c++/9/bits/regex.h:1136:5: note:   template argument deduction/substitution\
    \ failed:\n/tmp/tmpx0hjkeqt.cpp:16:25: note:   mismatched types \u2018std::__cxx11::__sub_match_string<_Bi_iter,\
    \ _Ch_traits, _Ch_alloc>\u2019 and \u2018long int\u2019\n   16 |        "
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, diff = 0, sign = 1, i = 0;\n    while(i < value.size()) {\n        long val\
    \ = std::stoll(value.substr(i, 1));\n        diff = val - ans;\n        if(diff\
    \ > 0) sign = -1;\n        else if(diff < 0) sign = 1;\n        ans = val + sign\
    \ * diff;\n        i++;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpnops29z4: /tmp/tmpnops29z4.cpp:27: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ ans = 0, diff = 0;\n    long long temp;\n    temp = std::stoll(value);\n   \
    \ diff = temp - ans;\n    if (diff < 0) {\n        diff = diff * -1;\n    }\n\
    \    if (diff > 100) {\n        diff = diff / 100;\n    }\n    ans = temp + diff;\n\
    \    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n   \
    \ assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpvsfqdm6d: /tmp/tmpvsfqdm6d.cpp:29: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141605
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int l1 = 0, l2 = 0, l3 =\
    \ 0, l4 = 0;\n    long long int l5 = 0, l6 = 0, l7 = 0;\n    long long int l8\
    \ = 0, l9 = 0, l10 = 0;\n    long long int l11 = 0, l12 = 0, l13 = 0, l14 = 0;\n\
    \    long long int l15 = 0, l16 = 0, l17 = 0, l18 = 0;\n    long long int l19\
    \ = 0, l20 = 0, l21 = 0, l22 = 0;\n    long long int l23 = 0, l24 = 0, l25 = 0,\
    \ l26 = 0;\n    long long int l27 = 0, l28 = 0, l29 = 0, l30 = 0;\n    long long\
    \ int l31 = 0, l32 = 0, l33 = 0, l34 = 0;\n    long long int l35 = 0, l36 = 0,\
    \ l37 = 0, l38 = 0;\n    long long int l39 = 0, l40 = 0, l41 = 0, l42 = 0;\n \
    \   long long int l43 = 0, l44 = 0, l45 = 0, l46 = 0;\n    long long int l47 =\
    \ 0, l48 = 0, l49 = 0, l50 = 0;\n    long long int l51 = 0, l52 = 0, l53 = 0,\
    \ l54 = 0;\n    long long int l55 = 0, l56 = 0, l57 = 0, l58 = 0;\n    long long\
    \ int l59 = 0, l60 = 0, l61 = 0, l62 = 0;\n    long long int l63 = 0, l64 = 0,\
    \ l65 = 0, l66 = 0;\n    long long int l67 = 0, l68 = 0, l69 = 0, l70 = 0;\n \
    \   long long int l71 = 0, l72 = 0, l73 = 0, l74 = 0;\n    long long int l75 =\
    \ 0, l76 = 0, l77 = 0, l78 = 0;\n    long long int l79 = 0, l80 = 0, l81 = 0,\
    \ l82 = 0;\n    long long int l83 = 0, l84 = 0, l85 = 0, l86 = 0;\n    long long\
    \ int l87 = 0, l88 = 0, l89 = 0, l90 = 0;\n    long long int l91 = 0, l92 = 0,\
    \ l93 = 0, l94 = 0;\n    long long int l95 = 0, l96 = 0, l97 = 0, l98 = 0;\n \
    \   long long int l99 = 0, l100 = 0, l101 = 0, l102 = 0;\n    long long int l103\
    \ = 0, l104 = 0, l105 = 0, l106 = 0;\n    long long int l107 = 0, l108 = 0, l109\
    \ = 0, l110 = 0;\n    long long int l111 = 0, l112 = 0, l113 = 0, l114 = 0;\n\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpes871r6x: /tmp/tmpes871r6x.cpp:46: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long first = 0;\n\
    \    long second = 0;\n    long third = 0;\n    long fourth = 0;\n    long fifth\
    \ = 0;\n    long sixth = 0;\n    long seventh = 0;\n    long eighth = 0;\n   \
    \ long ninth = 0;\n    long tenth = 0;\n    long eleventh = 0;\n    long twelfth\
    \ = 0;\n    long thirteenth = 0;\n    long fourteenth = 0;\n    long fifteenth\
    \ = 0;\n    long sixteenth = 0;\n    long seventeenth = 0;\n    long eighteenth\
    \ = 0;\n    long nineteenth = 0;\n    long twentieth = 0;\n    long twentyfirst\
    \ = 0;\n    long twentysecond = 0;\n    long twentythird = 0;\n    long twentyfourth\
    \ = 0;\n    long twentyfifth = 0;\n    long twentysixth = 0;\n    long twentyseventh\
    \ = 0;\n    long twentyeighth = 0;\n    long twentyninth = 0;\n    long thirtieth\
    \ = 0;\n    long thirtyfirst = 0;\n    long thirtysecond = 0;\n    long thirtythird\
    \ = 0;\n    long thirtyfourth = 0;\n    long thirtyfifth = 0;\n    long thirtysixth\
    \ = 0;\n    long thirtyseventh = 0;\n    long thirtyeighth = 0;\n    long thirtyninth\
    \ = 0;\n    long fourtieth = 0;\n    long fourtyfirst = 0;\n    long fourtysecond\
    \ = 0;\n    long fourtythird = 0;\n    long fourtyfourth = 0;\n    long fourtyfifth\
    \ = 0;\n    long fourtysixth = 0;\n    long fourtyseventh = 0;\n    long fourtyeighth\
    \ = 0;\n    long fourtyninth = 0;\n    long fiftieth = 0;\n    long fiftyfirst\
    \ = 0;\n    long fiftysecond = 0;\n    long fiftythird = 0;\n    long fiftyfourth\
    \ = 0;\n    long fiftyfifth = 0;\n    long fiftysixth = 0;\n    long fiftyseventh\
    \ = 0;\n    long fiftyeighth = 0;\n    long fiftyninth = 0;\n    long sixtieth\
    \ = 0;\n    long sixtyfirst = 0;\n    long sixtysecond = 0;\n    long sixtythird\
    \ = 0;\n    long sixtyfourth = 0;\n    long sixtyfifth = 0;\n    long sixtysixth\
    \ = 0;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmph5c0ps_l: /tmp/tmph5c0ps_l.cpp:83: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int l1 = 0, l2 = 0, l3 =\
    \ 0, l4 = 0;\n    long long int l5 = 0, l6 = 0, l7 = 0;\n    long long int l8\
    \ = 0, l9 = 0;\n    long long int l10 = 0;\n    long long int l11 = 0;\n    long\
    \ long int l12 = 0;\n    long long int l13 = 0;\n    long long int l14 = 0;\n\
    \    long long int l15 = 0;\n    long long int l16 = 0;\n    long long int l17\
    \ = 0;\n    long long int l18 = 0;\n    long long int l19 = 0;\n    long long\
    \ int l20 = 0;\n    long long int l21 = 0;\n    long long int l22 = 0;\n    long\
    \ long int l23 = 0;\n    long long int l24 = 0;\n    long long int l25 = 0;\n\
    \    long long int l26 = 0;\n    long long int l27 = 0;\n    long long int l28\
    \ = 0;\n    long long int l29 = 0;\n    long long int l30 = 0;\n    long long\
    \ int l31 = 0;\n    long long int l32 = 0;\n    long long int l33 = 0;\n    long\
    \ long int l34 = 0;\n    long long int l35 = 0;\n    long long int l36 = 0;\n\
    \    long long int l37 = 0;\n    long long int l38 = 0;\n    long long int l39\
    \ = 0;\n    long long int l40 = 0;\n    long long int l41 = 0;\n    long long\
    \ int l42 = 0;\n    long long int l43 = 0;\n    long long int l44 = 0;\n    long\
    \ long int l45 = 0;\n    long long int l46 = 0;\n    long long int l47 = 0;\n\
    \    long long int l48 = 0;\n    long long int l49 = 0;\n    long long int l50\
    \ = 0;\n    long long int l51 = 0;\n    long long int l52 = 0;\n    long long\
    \ int l53 = 0;\n    long long int l54 = 0;\n    long long int l55 = 0;\n    long\
    \ long int l56 = 0;\n    long long int l57 = 0;\n    long long int l58 = 0;\n\
    \    long long int l59 = 0;\n    long long int l60 = 0;\n    long long int l61\
    \ = 0;\n    long long int l62 = 0;\n    long long int l63 = 0;\n    long long\
    \ int l64 = 0;\n    long long int l65 = 0;\n    long long int l66 = 0;\n    long\
    \ long int l67 = 0;\n    long long int l68 = 0;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpshy_mzpq: /tmp/tmpshy_mzpq.cpp:78: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141605
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long temp = 0;\n\
    \    long diff = 0;\n    long sum = 0;\n    long count = 0;\n    long pos = 0;\n\
    \    long neg = 0;\n    long max = 0;\n    long min = 0;\n    long mid = 0;\n\
    \    long mid2 = 0;\n    long mid3 = 0;\n    long mid4 = 0;\n    long mid5 = 0;\n\
    \    long mid6 = 0;\n    long mid7 = 0;\n    long mid8 = 0;\n    long mid9 = 0;\n\
    \    long mid10 = 0;\n    long mid11 = 0;\n    long mid12 = 0;\n    long mid13\
    \ = 0;\n    long mid14 = 0;\n    long mid15 = 0;\n    long mid16 = 0;\n    long\
    \ mid17 = 0;\n    long mid18 = 0;\n    long mid19 = 0;\n    long mid20 = 0;\n\
    \    long mid21 = 0;\n    long mid22 = 0;\n    long mid23 = 0;\n    long mid24\
    \ = 0;\n    long mid25 = 0;\n    long mid26 = 0;\n    long mid27 = 0;\n    long\
    \ mid28 = 0;\n    long mid29 = 0;\n    long mid30 = 0;\n    long mid31 = 0;\n\
    \    long mid32 = 0;\n    long mid33 = 0;\n    long mid34 = 0;\n    long mid35\
    \ = 0;\n    long mid36 = 0;\n    long mid37 = 0;\n    long mid38 = 0;\n    long\
    \ mid39 = 0;\n    long mid40 = 0;\n    long mid41 = 0;\n    long mid42 = 0;\n\
    \    long mid43 = 0;\n    long mid44 = 0;\n    long mid45 = 0;\n    long mid46\
    \ = 0;\n    long mid47 = 0;\n    long mid48 = 0;\n    long mid49 = 0;\n    long\
    \ mid50 = 0;\n    long mid51 = 0;\n    long mid52 = 0;\n    long mid53 = 0;\n\
    \    long mid54 = 0;\n    long mid55 = 0;\n    long mid56 = 0;\n    long mid57\
    \ = 0;\n    long mid58 = 0;\n    long mid59 = 0;\n    long mid60 = 0;\n    long\
    \ mid61 = 0;\n    long mid62 = 0;\n    long mid63 = 0;\n    long mid64 = 0;\n\
    \    long mid65 = 0;\n    long mid66 = 0;\n    long mid67 = 0;\n    long mid68\
    \ = 0;\n    long mid69 = 0;\n    long mid70 = 0;\n    long mid71 = 0;\n    long\
    \ mid72 = 0;\n    long mid73 = 0;\n    long mid74 = 0;\n    long mid75 = 0;\n\
    \    long mid76 = 0;\n    long mid77 = 0;\n    long mid78 = 0;\n    long mid79\
    \ = 0;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp4uhi2v71: /tmp/tmp4uhi2v71.cpp:104: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141604
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ ans = 0, diff = 0;\n    long n = stoi(value);\n    long diff = abs(n - ans);\n\
    \    long mid = diff / 2;\n    long low = ans - mid;\n    long high = ans + mid;\n\
    \    if (low < n) {\n        ans = low;\n    } else if (high > n) {\n        ans\
    \ = high;\n    } else {\n        ans = n;\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4my8jsvw.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp4my8jsvw.cpp:16:10: error: redeclaration of \u2018long int diff\u2019\
    \n   16 |     long diff = abs(n - ans);\n      |          ^~~~\n/tmp/tmp4my8jsvw.cpp:14:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   14 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n"
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = std::stoll(value);\n  \
    \  if (ans == std::numeric_limits<long>::max()) {\n        std::cerr << \"The\
    \ given value \" << value << \" cannot be converted to long.\" << std::endl;\n\
    \        exit(-1);\n    }\n    long diff = ans - std::stoll(value.substr(0, value.size()\
    \ - 1));\n    if (diff > 0)\n        ++diff;\n    return std::min(ans, std::max(ans,\
    \ diff));\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp_ahgx4xe: /tmp/tmp_ahgx4xe.cpp:26: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ ans = 0;\n    long diff = 0;\n    long sum = 0;\n    long num = 0;\n    long\
    \ i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m = 0;\n\
    \    long n = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n    long\
    \ r = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n\
    \    long w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long\
    \ A = 0;\n    long B = 0;\n    long C = 0;\n    long D = 0;\n    long E = 0;\n\
    \    long F = 0;\n    long G = 0;\n    long H = 0;\n    long I = 0;\n    long\
    \ J = 0;\n    long K = 0;\n    long L = 0;\n    long M = 0;\n    long N = 0;\n\
    \    long O = 0;\n    long P = 0;\n    long Q = 0;\n    long R = 0;\n    long\
    \ S = 0;\n    long T = 0;\n    long U = 0;\n    long V = 0;\n    long W = 0;\n\
    \    long X = 0;\n    long Y = 0;\n    long Z = 0;\n    long aa = 0;\n    long\
    \ bb = 0;\n    long cc = 0;\n    long dd = 0;\n    long ee = 0;\n    long ff =\
    \ 0;\n    long gg = 0;\n    long hh = 0;\n    long ii = 0;\n    long jj = 0;\n\
    \    long kk = 0;\n    long ll = 0;\n    long mm = 0;\n    long nn = 0;\n    long\
    \ oo = 0;\n    long pp = 0;\n    long qq = 0;\n    long rr = 0;\n    long ss =\
    \ 0;\n    long tt = 0;\n    long uu = 0;\n    long vv = 0;\n    long ww = 0;\n\
    \    long xx = 0;\n    long yy = 0;\n    long zz = 0;\n    long Aa = 0;\n    long\
    \ Bb = 0;\n    long Cc = 0;\n    long Dd = 0;\n    long Ee = 0;\n    long Ff =\
    \ 0;\n    long Gg = 0;\n    long Hh = 0;\n    long Ii = 0;\n    long Jj = 0;\n\
    \    long Kk = 0;\n    long Ll = 0;\n    long Mm = 0;\n    long Nn = 0;\n    long\
    \ Oo = 0;\n    long Pp = 0;\n    long Qq = 0;\n    long Rr = 0;\n    long Ss =\
    \ 0;\n    long Tt = 0;\n    long Uu = 0;\n    long Vv = 0;\n    long Ww = 0;\n\
    \    long Xx = 0;\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp4_2ydzom: /tmp/tmp4_2ydzom.cpp:115: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141604
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long diff = 0;\n    long temp = 0;\n    long count = 0;\n    long sum\
    \ = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n \
    \   long m = 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n    long q\
    \ = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n \
    \   long v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n    long z\
    \ = 0;\n    long A = 0;\n    long B = 0;\n    long C = 0;\n    long D = 0;\n \
    \   long E = 0;\n    long F = 0;\n    long G = 0;\n    long H = 0;\n    long I\
    \ = 0;\n    long J = 0;\n    long K = 0;\n    long L = 0;\n    long M = 0;\n \
    \   long N = 0;\n    long O = 0;\n    long P = 0;\n    long Q = 0;\n    long R\
    \ = 0;\n    long S = 0;\n    long T = 0;\n    long U = 0;\n    long V = 0;\n \
    \   long W = 0;\n    long X = 0;\n    long Y = 0;\n    long Z = 0;\n    long a\
    \ = 0;\n    long b = 0;\n    long c = 0;\n    long d = 0;\n    long e = 0;\n \
    \   long f = 0;\n    long g = 0;\n    long h = 0;\n    long i = 0;\n    long j\
    \ = 0;\n    long k = 0;\n    long l = 0;\n    long m = 0;\n    long n = 0;\n \
    \   long o = 0;\n    long p = 0;\n    long q = 0;\n    long r = 0;\n    long s\
    \ = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n    long w = 0;\n \
    \   long x = 0;\n    long y = 0;\n    long z = 0;\n    long A = 0;\n    long B\
    \ = 0;\n    long C = 0;\n    long D = 0;\n    long E = 0;\n    long F = 0;\n \
    \   long G = 0;\n    long H = 0;\n    long I = 0;\n    long J = 0;\n    long K\
    \ = 0;\n    long L = 0;\n    long M = 0;\n    long N = 0;\n    long O = 0;\n \
    \   long P = 0;\n    long Q = 0;\n    long R = 0;\n    long S = 0;\n    long T\
    \ = 0;\n    long U = 0;\n    long V = 0;\n    long W = 0;\n    long X = 0;\n \
    \   long Y = 0;\n    long Z = 0;\n    long a = 0;\n    long b = 0;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1v97wzu7.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp1v97wzu7.cpp:71:10: error: redeclaration of \u2018long int i\u2019\n\
    \   71 |     long i = 0;\n      |          ^\n/tmp/tmp1v97wzu7.cpp:19:10: note:\
    \ \u2018long int i\u2019 previously declared here\n   19 |     long i = 0;\n \
    \     |          ^\n/tmp/tmp1v97wzu7.cpp:72:10: error: redeclaration of \u2018\
    long int j\u2019\n   72 |     long j = 0;\n      |          ^\n/tmp/tmp1v97wzu7.cpp:20:10:\
    \ note: \u2018long int j\u2019 previously declared here\n   20 |     long j =\
    \ 0;\n      |          ^\n/tmp/tmp1v97wzu7.cpp:73:10: error: redeclaration of\
    \ \u2018long int k\u2019\n   73 |     long k = 0;\n      |          ^\n/tmp/tmp1v97wzu7.cpp:21:10:\
    \ note: \u2018long int k\u2019 previously declared here\n   21 |     long k =\
    \ 0;\n      |          ^\n/tmp/tmp1v97wzu7.cpp:74:10: error: redeclaration of\
    \ \u2018long int l\u2019\n   74 |     long l = 0;\n      |          ^\n/tmp/tmp1v97wzu7.cpp:22:10:\
    \ note: \u2018long int l\u2019 previously declared here\n   22 |     long l =\
    \ 0;\n      |          ^\n/tmp/tmp1v97wzu7.cpp:75:10: error: redeclaration of\
    \ \u2018long int m\u2019\n   75 |     long m = 0;\n      |          ^\n/tmp/tmp1v97wzu7.cpp:23:10:\
    \ note: \u2018long int m\u2019 previously declared here\n   23 |     long m =\
    \ 0;\n      |          ^\n/tmp/tmp1v97wzu7.cpp:76:10: error: redeclaration of\
    \ \u2018long int n\u2019\n   76 |     long n = 0;\n      |          ^\n/tmp/tmp1v97wzu7.cpp:24:10:\
    \ note: \u2018long int n\u2019 previously declared here\n   24 |     long n =\
    \ 0;\n      |          ^\n/tmp/tmp1v97wzu7.cpp:77:10: error: redeclaration of\
    \ \u2018long int o\u2019\n   77 |     long o = 0;\n      |          ^\n/tmp/tmp1v97wzu7.cpp:25:10:\
    \ note: \u2018long int o\u2019 previously declared here\n   25 |     long o =\
    \ 0;\n      |          ^\n/tmp/tmp1v97wzu7.cpp:78:10: error: redeclaration of\
    \ \u2018long int p\u2019\n   78 |     long p = 0;\n      |          ^\n/tmp/tmp1v97wzu7.cpp:26:10:\
    \ note: \u2018long int p\u2019 previously declared here\n   26 |     long p =\
    \ 0;\n      |          ^\n/tmp/tmp1v97wzu7.cpp:79:10: error: redeclaration of\
    \ \u2018long int q\u2019\n   79 |     long q = 0;\n      |          ^\n/tmp/tmp1"
  stdout: ''
  timestamp: 1660141604
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Declare a variable to store the\
    \ integer closest to the given number\n    long closest_integer = -1;\n    //\
    \ Declare a variable to store the difference between the given number\n    //\
    \ and the closest integer\n    long difference = std::abs(std::stod(value));\n\
    \    // Declare a variable to store the current integer closest to the given number\n\
    \    long current_integer = std::stod(value);\n    // Declare a variable to store\
    \ the current difference between the given number\n    // and the closest integer\n\
    \    long current_difference = std::abs(std::stod(value));\n    // Declare a variable\
    \ to store the current integer closest to the given number\n    long current_integer_2\
    \ = std::stod(value);\n    // Declare a variable to store the current difference\
    \ between the given number\n    // and the closest integer\n    long current_difference_2\
    \ = std::abs(std::stod(value));\n    // Declare a variable to store the current\
    \ integer closest to the given number\n    long current_integer_3 = std::stod(value);\n\
    \    // Declare a variable to store the current difference between the given number\n\
    \    // and the closest integer\n    long current_difference_3 = std::abs(std::stod(value));\n\
    \    // Declare a variable to store the current integer closest to the given number\n\
    \    long current_integer_4 = std::stod(value);\n    // Declare a variable to\
    \ store the current difference between the given number\n    // and the closest\
    \ integer\n    long current_difference_4 = std::abs(std::stod(value));\n    //\
    \ Declare a variable to store the current integer closest to the given number\n\
    \    long current_integer_5 = std::stod(value);\n    // Declare a variable to\
    \ store the current difference between the given number\n    // and the closest\
    \ integer\n    long current_difference_5 = std::abs(std::stod(value));\n    //\
    \ Declare a variable to store the current integer closest to the given number\n\
    \    long current_integer_6 = std::stod(value);\n    // Declare a variable to\
    \ store the current difference between the given number\n    // and the closest\
    \ integer\n    long current_difference_6 = std::abs(std::stod(value));\n    //\
    \ Declare a variable to store the current integer closest to the given number\n\
    \    long current_integer_7 = std::stod(value);\n    // Declare a variable to\
    \ store the current difference between the given number\n    // and the closest\
    \ integer\n    long current_difference_7 = std::abs(std::stod(value));\n    //\
    \ Declare a variable to store the current integer closest to the given number\n\
    \    long current_integer_8 = std::stod(value);\n    // Declare a variable to\
    \ store the current difference between the given number\n    // and the closest\
    \ integer\n    long current_difference_8 = std::abs(std::stod(value));\n    //\
    \ Declare a variable to store the current integer closest to the given number\n\
    \    long \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpz9wzs894.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpz9wzs894.cpp:60:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   60 | }\n      | ^\n/tmp/tmpz9wzs894.cpp:60:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num;\n    long long\
    \ int min;\n    long long int max;\n    long long int mid;\n    long long int\
    \ diff;\n    long long int diff2;\n    long long int diff3;\n    long long int\
    \ diff4;\n    long long int diff5;\n    long long int diff6;\n    long long int\
    \ diff7;\n    long long int diff8;\n    long long int diff9;\n    long long int\
    \ diff10;\n    long long int diff11;\n    long long int diff12;\n    long long\
    \ int diff13;\n    long long int diff14;\n    long long int diff15;\n    long\
    \ long int diff16;\n    long long int diff17;\n    long long int diff18;\n   \
    \ long long int diff19;\n    long long int diff20;\n    long long int diff21;\n\
    \    long long int diff22;\n    long long int diff23;\n    long long int diff24;\n\
    \    long long int diff25;\n    long long int diff26;\n    long long int diff27;\n\
    \    long long int diff28;\n    long long int diff29;\n    long long int diff30;\n\
    \    long long int diff31;\n    long long int diff32;\n    long long int diff33;\n\
    \    long long int diff34;\n    long long int diff35;\n    long long int diff36;\n\
    \    long long int diff37;\n    long long int diff38;\n    long long int diff39;\n\
    \    long long int diff40;\n    long long int diff41;\n    long long int diff42;\n\
    \    long long int diff43;\n    long long int diff44;\n    long long int diff45;\n\
    \    long long int diff46;\n    long long int diff47;\n    long long int diff48;\n\
    \    long long int diff49;\n    long long int diff50;\n    long long int diff51;\n\
    \    long long int diff52;\n    long long int diff53;\n    long long int diff54;\n\
    \    long long int diff55;\n    long long int diff56;\n    long long int diff57;\n\
    \    long long int diff58;\n    long long int diff59;\n    long long int diff60;\n\
    \    long long int diff61;\n    long long int diff62;\n    long long int diff63;\n\
    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpqg_4dw5y: /tmp/tmpqg_4dw5y.cpp:84: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141604
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n\
    \    long mid = 0;\n    long diff = 0;\n    long closest;\n    long diff2;\n \
    \   long mid2;\n    long mid3;\n    long mid4;\n    long mid5;\n    long mid6;\n\
    \    long mid7;\n    long mid8;\n    long mid9;\n    long mid10;\n    long mid11;\n\
    \    long mid12;\n    long mid13;\n    long mid14;\n    long mid15;\n    long\
    \ mid16;\n    long mid17;\n    long mid18;\n    long mid19;\n    long mid20;\n\
    \    long mid21;\n    long mid22;\n    long mid23;\n    long mid24;\n    long\
    \ mid25;\n    long mid26;\n    long mid27;\n    long mid28;\n    long mid29;\n\
    \    long mid30;\n    long mid31;\n    long mid32;\n    long mid33;\n    long\
    \ mid34;\n    long mid35;\n    long mid36;\n    long mid37;\n    long mid38;\n\
    \    long mid39;\n    long mid40;\n    long mid41;\n    long mid42;\n    long\
    \ mid43;\n    long mid44;\n    long mid45;\n    long mid46;\n    long mid47;\n\
    \    long mid48;\n    long mid49;\n    long mid50;\n    long mid51;\n    long\
    \ mid52;\n    long mid53;\n    long mid54;\n    long mid55;\n    long mid56;\n\
    \    long mid57;\n    long mid58;\n    long mid59;\n    long mid60;\n    long\
    \ mid61;\n    long mid62;\n    long mid63;\n    long mid64;\n    long mid65;\n\
    \    long mid66;\n    long mid67;\n    long mid68;\n    long mid69;\n    long\
    \ mid70;\n    long mid71;\n    long mid72;\n    long mid73;\n    long mid74;\n\
    \    long mid75;\n    long mid76;\n    long mid77;\n    long mid78;\n    long\
    \ mid79;\n    long mid80;\n    long mid81;\n    long mid82;\n    long mid83;\n\
    \    long mid\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpidpc82w6.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpidpc82w6.cpp:101:1: error: expected initializer before \u2018}\u2019\
    \ token\n  101 | }\n      | ^\n/tmp/tmpidpc82w6.cpp:101:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141604
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int ans = 0;\n    long long\
    \ int first = 0;\n    long long int second = 0;\n    long long int third = 0;\n\
    \    long long int fourth = 0;\n    long long int fifth = 0;\n    long long int\
    \ sixth = 0;\n    long long int seventh = 0;\n    long long int eighth = 0;\n\
    \    long long int ninth = 0;\n    long long int tenth = 0;\n    long long int\
    \ eleventh = 0;\n    long long int twelfth = 0;\n    long long int thirteenth\
    \ = 0;\n    long long int fourteenth = 0;\n    long long int fifteenth = 0;\n\
    \    long long int sixteenth = 0;\n    long long int seventeenth = 0;\n    long\
    \ long int eighteenth = 0;\n    long long int nineteenth = 0;\n    long long int\
    \ twentieth = 0;\n    long long int twentyfirst = 0;\n    long long int twentysecond\
    \ = 0;\n    long long int twentythird = 0;\n    long long int twentyfourth = 0;\n\
    \    long long int twentyfifth = 0;\n    long long int twentysixth = 0;\n    long\
    \ long int twentyseventh = 0;\n    long long int twentyeighth = 0;\n    long long\
    \ int twentyninth = 0;\n    long long int thirtieth = 0;\n    long long int thirtyfirst\
    \ = 0;\n    long long int thirtysecond = 0;\n    long long int thirtythird = 0;\n\
    \    long long int thirtyfourth = 0;\n    long long int thirtyfifth = 0;\n   \
    \ long long int thirtysixth = 0;\n    long long int thirtyseventh = 0;\n    long\
    \ long int thirtyeighth = 0;\n    long long int thirtyninth = 0;\n    long long\
    \ int fortieth = 0;\n    long long int fortyfirst = 0;\n    long long int fortysecond\
    \ = 0;\n    long long int fortythird = 0;\n    long long int fortyfourth = 0;\n\
    \    long long int fortyfifth = 0;\n    long long int fortysixth = 0;\n    long\
    \ long int fortyseventh = 0;\n    long long int fortyeighth = 0;\n    long long\
    \ int fortyninth = 0;\n    long long int fiftieth = 0;\n    long long int fiftyfirst\
    \ = 0;\n    long long int fiftysecond = 0;\n    long long int fif\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqt2ppcfs.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpqt2ppcfs.cpp:67:1: error: expected initializer before \u2018}\u2019\
    \ token\n   67 | }\n      | ^\n/tmp/tmpqt2ppcfs.cpp:67:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, diff = 0, i = 0;\n    while(i < value.size()) {\n        long cur = stoi(value.substr(i,\
    \ 1));\n        if(cur > ans) {\n            diff = cur - ans;\n            ans\
    \ = cur;\n        }\n        i++;\n    }\n    return ans + diff;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpmt69r_0b: /tmp/tmpmt69r_0b.cpp:27: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, sign = 1;\n    long val = std::stoll(value);\n    if (val < 0) {\n      \
    \  sign = -1;\n        val = -val;\n    }\n    while (val > 0) {\n        ans\
    \ += val / 10;\n        val %= 10;\n    }\n    ans *= sign;\n    return ans;\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpo1ry9x61: /tmp/tmpo1ry9x61.cpp:29: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num;\n    long long\
    \ int min;\n    long long int max;\n    long long int mid;\n    long long int\
    \ diff;\n    long long int diff2;\n    long long int diff3;\n    long long int\
    \ diff4;\n    long long int diff5;\n    long long int diff6;\n    long long int\
    \ diff7;\n    long long int diff8;\n    long long int diff9;\n    long long int\
    \ diff10;\n    long long int diff11;\n    long long int diff12;\n    long long\
    \ int diff13;\n    long long int diff14;\n    long long int diff15;\n    long\
    \ long int diff16;\n    long long int diff17;\n    long long int diff18;\n   \
    \ long long int diff19;\n    long long int diff20;\n    long long int diff21;\n\
    \    long long int diff22;\n    long long int diff23;\n    long long int diff24;\n\
    \    long long int diff25;\n    long long int diff26;\n    long long int diff27;\n\
    \    long long int diff28;\n    long long int diff29;\n    long long int diff30;\n\
    \    long long int diff31;\n    long long int diff32;\n    long long int diff33;\n\
    \    long long int diff34;\n    long long int diff35;\n    long long int diff36;\n\
    \    long long int diff37;\n    long long int diff38;\n    long long int diff39;\n\
    \    long long int diff40;\n    long long int diff41;\n    long long int diff42;\n\
    \    long long int diff43;\n    long long int diff44;\n    long long int diff45;\n\
    \    long long int diff46;\n    long long int diff47;\n    long long int diff48;\n\
    \    long long int diff49;\n    long long int diff50;\n    long long int diff51;\n\
    \    long long int diff52;\n    long long int diff53;\n    long long int diff54;\n\
    \    long long int diff55;\n    long long int diff56;\n    long long int diff57;\n\
    \    long long int diff58;\n    long long int diff59;\n    long long int diff60;\n\
    \    long long int diff61;\n    long long int diff62;\n    long long int diff63;\n\
    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpqg_4dw5y: /tmp/tmpqg_4dw5y.cpp:84: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp;\n    temp = std::stoll(value);\n    diff = temp - ans;\n    if (diff\
    \ < 0) {\n        diff += 1;\n    }\n    ans = temp;\n    while (diff >= 1) {\n\
    \        diff /= 10;\n        ans *= 10;\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpfhoakczw: /tmp/tmpfhoakczw.cpp:29: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141604
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int closest;\n    long long\
    \ int difference;\n    long long int difference2;\n    long long int difference3;\n\
    \    long long int difference4;\n    long long int difference5;\n    long long\
    \ int difference6;\n    long long int difference7;\n    long long int difference8;\n\
    \    long long int difference9;\n    long long int difference10;\n    long long\
    \ int difference11;\n    long long int difference12;\n    long long int difference13;\n\
    \    long long int difference14;\n    long long int difference15;\n    long long\
    \ int difference16;\n    long long int difference17;\n    long long int difference18;\n\
    \    long long int difference19;\n    long long int difference20;\n    long long\
    \ int difference21;\n    long long int difference22;\n    long long int difference23;\n\
    \    long long int difference24;\n    long long int difference25;\n    long long\
    \ int difference26;\n    long long int difference27;\n    long long int difference28;\n\
    \    long long int difference29;\n    long long int difference30;\n    long long\
    \ int difference31;\n    long long int difference32;\n    long long int difference33;\n\
    \    long long int difference34;\n    long long int difference35;\n    long long\
    \ int difference36;\n    long long int difference37;\n    long long int difference38;\n\
    \    long long int difference39;\n    long long int difference40;\n    long long\
    \ int difference41;\n    long long int difference42;\n    long long int difference43;\n\
    \    long long int difference44;\n    long long int difference45;\n    long long\
    \ int difference46;\n    long long int difference47;\n    long long int difference48;\n\
    \    long long int difference49;\n    long long int difference50;\n    long long\
    \ int difference51;\n    long long int difference52;\n    long long int difference53;\n\
    \    long long int difference54;\n    long long int difference55;\n    long long\
    \ int difference56;\n    long long int difference57;\n    long long int difference58;\n\
    \    long long int difference59;\n    long long int difference60;\n    long long\
    \ int difference61;\n    long long int difference62;\n    long long int difference63;\n\
    \    long long int difference64;\n    long long int difference65;\n    long long\
    \ int difference\n}\nint main() {\n    auto candidate = closest_integer;\n   \
    \ assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsovb1crd.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpsovb1crd.cpp:80:1: error: expected initializer before \u2018}\u2019\
    \ token\n   80 | }\n      | ^\n/tmp/tmpsovb1crd.cpp:80:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141603
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // Your code here\n  long ans = 0, diff\
    \ = 0;\n  long long int temp;\n  long long int temp2;\n  long long int temp3;\n\
    \  long long int temp4;\n  long long int temp5;\n  long long int temp6;\n  long\
    \ long int temp7;\n  long long int temp8;\n  long long int temp9;\n  long long\
    \ int temp10;\n  long long int temp11;\n  long long int temp12;\n  long long int\
    \ temp13;\n  long long int temp14;\n  long long int temp15;\n  long long int temp16;\n\
    \  long long int temp17;\n  long long int temp18;\n  long long int temp19;\n \
    \ long long int temp20;\n  long long int temp21;\n  long long int temp22;\n  long\
    \ long int temp23;\n  long long int temp24;\n  long long int temp25;\n  long long\
    \ int temp26;\n  long long int temp27;\n  long long int temp28;\n  long long int\
    \ temp29;\n  long long int temp30;\n  long long int temp31;\n  long long int temp32;\n\
    \  long long int temp33;\n  long long int temp34;\n  long long int temp35;\n \
    \ long long int temp36;\n  long long int temp37;\n  long long int temp38;\n  long\
    \ long int temp39;\n  long long int temp40;\n  long long int temp41;\n  long long\
    \ int temp42;\n  long long int temp43;\n  long long int temp44;\n  long long int\
    \ temp45;\n  long long int temp46;\n  long long int temp47;\n  long long int temp48;\n\
    \  long long int temp49;\n  long long int temp50;\n  long long int temp51;\n \
    \ long long int temp52;\n  long long int temp53;\n  long long int temp54;\n  long\
    \ long int temp55;\n  long long int temp56;\n  long long int temp57;\n  long long\
    \ int temp58;\n  long long int temp59;\n  long long int temp60;\n  long long int\
    \ temp61;\n  long long int temp62;\n  long long int temp63;\n  long long int temp64;\n\
    \  long long int temp65;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpwko4taxi: /tmp/tmpwko4taxi.cpp:83: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141605
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, power = 1;\n    long diff = abs(atoi(value.c_str()));\n    long mid = diff\
    \ / 2;\n    long left = atoi(value.substr(0, value.size() - 1).c_str());\n   \
    \ long right = atoi(value.substr(value.size() - 1).c_str());\n    while (diff\
    \ > 1) {\n        mid = diff / 2;\n        diff = abs(atoi(value.substr(0, value.size()\
    \ - 1).c_str()));\n        mid = diff / 2;\n        power = power * 10;\n    }\n\
    \    power = power * 10;\n    while (diff > 1) {\n        mid = diff / 2;\n  \
    \      diff = abs(atoi(value.substr(0, value.size() - 1).c_str()));\n        mid\
    \ = diff / 2;\n        power = power * 10;\n    }\n    power = power * 10;\n \
    \   while (diff > 1) {\n        mid = diff / 2;\n        diff = abs(atoi(value.substr(0,\
    \ value.size() - 1).c_str()));\n        mid = diff / 2;\n        power = power\
    \ * 10;\n    }\n    power = power * 10;\n    while (diff > 1) {\n        mid =\
    \ diff / 2;\n        diff = abs(atoi(value.substr(0, value.size() - 1).c_str()));\n\
    \        mid = diff / 2;\n        power = power * 10;\n    }\n    power = power\
    \ * 10;\n    while (diff > 1) {\n        mid = diff / 2;\n        diff = abs(atoi(value.substr(0,\
    \ value.size() - 1).c_str()));\n        mid = diff / 2;\n        power = power\
    \ * 10;\n    }\n    power = power * 10;\n    while (diff > 1) {\n        mid =\
    \ diff / 2;\n        diff = abs(atoi(value.substr(0, value.size() - 1).c_str()));\n\
    \        mid = diff / 2;\n        power = power * 10;\n    }\n    power = power\
    \ * 10;\n    while (diff > 1) {\n        mid = diff / 2;\n        diff = abs(atoi(value.substr(0,\
    \ value.size() - 1).c_str()));\n        mid = diff / 2;\n        power = power\
    \ * 10;\n    }\n    power = power * 10;\n    while (diff > 1) {\n        mid =\
    \ diff / 2;\n        diff = abs(atoi(value.substr(0, value.size() - 1).c_str()));\n\
    \        mid = diff / 2;\n        power = power * 10;\n    }\n    power = power\
    \ * 10;\n    while (diff > 1) {\n        mid = diff / 2;\n        diff = abs(atoi(value.substr(0,\
    \ value.size() - 1).c_str()));\n        mid = diff / 2;\n        power = power\
    \ * \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp4ysxv6gm.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp4ysxv6gm.cpp:80:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   80 | }\n      | ^\n/tmp/tmp4ysxv6gm.cpp:81:12: error: a function-definition\
    \ is not allowed here before \u2018{\u2019 token\n   81 | int main() {\n     \
    \ |            ^\n/tmp/tmp4ysxv6gm.cpp:88:1: error: expected \u2018}\u2019 at\
    \ end of input\n   88 | }\n      | ^\n/tmp/tmp4ysxv6gm.cpp:12:41: note: to match\
    \ this \u2018{\u2019\n   12 | long closest_integer(std::string value) {\n    \
    \  |                                         ^\n/tmp/tmp4ysxv6gm.cpp:88:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n   88 |\
    \ }\n      | ^\n"
  stdout: ''
  timestamp: 1660141606
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int closest;\n    long long\
    \ int diff;\n    long long int diff2;\n    long long int diff3;\n    long long\
    \ int diff4;\n    long long int diff5;\n    long long int diff6;\n    long long\
    \ int diff7;\n    long long int diff8;\n    long long int diff9;\n    long long\
    \ int diff10;\n    long long int diff11;\n    long long int diff12;\n    long\
    \ long int diff13;\n    long long int diff14;\n    long long int diff15;\n   \
    \ long long int diff16;\n    long long int diff17;\n    long long int diff18;\n\
    \    long long int diff19;\n    long long int diff20;\n    long long int diff21;\n\
    \    long long int diff22;\n    long long int diff23;\n    long long int diff24;\n\
    \    long long int diff25;\n    long long int diff26;\n    long long int diff27;\n\
    \    long long int diff28;\n    long long int diff29;\n    long long int diff30;\n\
    \    long long int diff31;\n    long long int diff32;\n    long long int diff33;\n\
    \    long long int diff34;\n    long long int diff35;\n    long long int diff36;\n\
    \    long long int diff37;\n    long long int diff38;\n    long long int diff39;\n\
    \    long long int diff40;\n    long long int diff41;\n    long long int diff42;\n\
    \    long long int diff43;\n    long long int diff44;\n    long long int diff45;\n\
    \    long long int diff46;\n    long long int diff47;\n    long long int diff48;\n\
    \    long long int diff49;\n    long long int diff50;\n    long long int diff51;\n\
    \    long long int diff52;\n    long long int diff53;\n    long long int diff54;\n\
    \    long long int diff55;\n    long long int diff56;\n    long long int diff57;\n\
    \    long long int diff58;\n    long long int diff59;\n    long long int diff60;\n\
    \    long long int diff61;\n    long long int diff62;\n    long long int diff63;\n\
    \    long long int diff64;\n    long long int diff65;\n    long long int diff\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpza4egyr2.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpza4egyr2.cpp:80:1: error: expected initializer before \u2018}\u2019\
    \ token\n   80 | }\n      | ^\n/tmp/tmpza4egyr2.cpp:80:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141606
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ ans = 0;\n    long sum = 0;\n    long temp = 0;\n    long count = 0;\n    long\
    \ i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m = 0;\n\
    \    long n = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n    long\
    \ r = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n\
    \    long w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long\
    \ A = 0;\n    long B = 0;\n    long C = 0;\n    long D = 0;\n    long E = 0;\n\
    \    long F = 0;\n    long G = 0;\n    long H = 0;\n    long I = 0;\n    long\
    \ J = 0;\n    long K = 0;\n    long L = 0;\n    long M = 0;\n    long N = 0;\n\
    \    long O = 0;\n    long P = 0;\n    long Q = 0;\n    long R = 0;\n    long\
    \ S = 0;\n    long T = 0;\n    long U = 0;\n    long V = 0;\n    long W = 0;\n\
    \    long X = 0;\n    long Y = 0;\n    long Z = 0;\n    long a = 0;\n    long\
    \ b = 0;\n    long c = 0;\n    long d = 0;\n    long e = 0;\n    long f = 0;\n\
    \    long g = 0;\n    long h = 0;\n    long i = 0;\n    long j = 0;\n    long\
    \ k = 0;\n    long l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n\
    \    long p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n    long\
    \ t = 0;\n    long u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n\
    \    long y = 0;\n    long z = 0;\n    long A = 0;\n    long B = 0;\n    long\
    \ C = 0;\n    long D = 0;\n    long E = 0;\n    long F = 0;\n    long G = 0;\n\
    \    long H = 0;\n    long I = 0;\n    long J = 0;\n    long K = 0;\n    long\
    \ L = 0;\n    long M = 0;\n    long N = 0;\n    long O = 0;\n    long P = 0;\n\
    \    long Q = 0;\n    long R = 0;\n    long S = 0;\n    long T = 0;\n    long\
    \ U = 0;\n    long V = 0;\n    long W = 0;\n    long X = 0;\n    long Y = 0;\n\
    \    long Z = 0;\n    long a = 0;\n    long b = 0;\n    long c = 0;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8x29hw2q.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp8x29hw2q.cpp:70:10: error: redeclaration of \u2018long int i\u2019\n\
    \   70 |     long i = 0;\n      |          ^\n/tmp/tmp8x29hw2q.cpp:18:10: note:\
    \ \u2018long int i\u2019 previously declared here\n   18 |     long i = 0;\n \
    \     |          ^\n/tmp/tmp8x29hw2q.cpp:71:10: error: redeclaration of \u2018\
    long int j\u2019\n   71 |     long j = 0;\n      |          ^\n/tmp/tmp8x29hw2q.cpp:19:10:\
    \ note: \u2018long int j\u2019 previously declared here\n   19 |     long j =\
    \ 0;\n      |          ^\n/tmp/tmp8x29hw2q.cpp:72:10: error: redeclaration of\
    \ \u2018long int k\u2019\n   72 |     long k = 0;\n      |          ^\n/tmp/tmp8x29hw2q.cpp:20:10:\
    \ note: \u2018long int k\u2019 previously declared here\n   20 |     long k =\
    \ 0;\n      |          ^\n/tmp/tmp8x29hw2q.cpp:73:10: error: redeclaration of\
    \ \u2018long int l\u2019\n   73 |     long l = 0;\n      |          ^\n/tmp/tmp8x29hw2q.cpp:21:10:\
    \ note: \u2018long int l\u2019 previously declared here\n   21 |     long l =\
    \ 0;\n      |          ^\n/tmp/tmp8x29hw2q.cpp:74:10: error: redeclaration of\
    \ \u2018long int m\u2019\n   74 |     long m = 0;\n      |          ^\n/tmp/tmp8x29hw2q.cpp:22:10:\
    \ note: \u2018long int m\u2019 previously declared here\n   22 |     long m =\
    \ 0;\n      |          ^\n/tmp/tmp8x29hw2q.cpp:75:10: error: redeclaration of\
    \ \u2018long int n\u2019\n   75 |     long n = 0;\n      |          ^\n/tmp/tmp8x29hw2q.cpp:23:10:\
    \ note: \u2018long int n\u2019 previously declared here\n   23 |     long n =\
    \ 0;\n      |          ^\n/tmp/tmp8x29hw2q.cpp:76:10: error: redeclaration of\
    \ \u2018long int o\u2019\n   76 |     long o = 0;\n      |          ^\n/tmp/tmp8x29hw2q.cpp:24:10:\
    \ note: \u2018long int o\u2019 previously declared here\n   24 |     long o =\
    \ 0;\n      |          ^\n/tmp/tmp8x29hw2q.cpp:77:10: error: redeclaration of\
    \ \u2018long int p\u2019\n   77 |     long p = 0;\n      |          ^\n/tmp/tmp8x29hw2q.cpp:25:10:\
    \ note: \u2018long int p\u2019 previously declared here\n   25 |     long p =\
    \ 0;\n      |          ^\n/tmp/tmp8x29hw2q.cpp:78:10: error: redeclaration of\
    \ \u2018long int q\u2019\n   78 |     long q = 0;\n      |          ^\n/tmp/tmp8"
  stdout: ''
  timestamp: 1660141606
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long sum = 0;\n    long count = 0;\n    long temp = 0;\n    long i = 0;\n\
    \    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m = 0;\n    long\
    \ n = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n    long r = 0;\n\
    \    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n    long\
    \ w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long A = 0;\n\
    \    long B = 0;\n    long C = 0;\n    long D = 0;\n    long E = 0;\n    long\
    \ F = 0;\n    long G = 0;\n    long H = 0;\n    long I = 0;\n    long J = 0;\n\
    \    long K = 0;\n    long L = 0;\n    long M = 0;\n    long N = 0;\n    long\
    \ O = 0;\n    long P = 0;\n    long Q = 0;\n    long R = 0;\n    long S = 0;\n\
    \    long T = 0;\n    long U = 0;\n    long V = 0;\n    long W = 0;\n    long\
    \ X = 0;\n    long Y = 0;\n    long Z = 0;\n    long a = 0;\n    long b = 0;\n\
    \    long c = 0;\n    long d = 0;\n    long e = 0;\n    long f = 0;\n    long\
    \ g = 0;\n    long h = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n\
    \    long l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n    long\
    \ p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n\
    \    long u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n    long\
    \ y = 0;\n    long z = 0;\n    long A = 0;\n    long B = 0;\n    long C = 0;\n\
    \    long D = 0;\n    long E = 0;\n    long F = 0;\n    long G = 0;\n    long\
    \ H = 0;\n    long I = 0;\n    long J = 0;\n    long K = 0;\n    long L = 0;\n\
    \    long M = 0;\n    long N = 0;\n    long O = 0;\n    long P = 0;\n    long\
    \ Q = 0;\n    long R = 0;\n    long S = 0;\n    long T = 0;\n    long U = 0;\n\
    \    long V = 0;\n    long W = 0;\n    long X = 0;\n    long Y = 0;\n    long\
    \ Z = 0;\n    long a = 0;\n    long b = 0;\n    long c = 0;\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppc2xd24k.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmppc2xd24k.cpp:70:10: error: redeclaration of \u2018long int i\u2019\n\
    \   70 |     long i = 0;\n      |          ^\n/tmp/tmppc2xd24k.cpp:18:10: note:\
    \ \u2018long int i\u2019 previously declared here\n   18 |     long i = 0;\n \
    \     |          ^\n/tmp/tmppc2xd24k.cpp:71:10: error: redeclaration of \u2018\
    long int j\u2019\n   71 |     long j = 0;\n      |          ^\n/tmp/tmppc2xd24k.cpp:19:10:\
    \ note: \u2018long int j\u2019 previously declared here\n   19 |     long j =\
    \ 0;\n      |          ^\n/tmp/tmppc2xd24k.cpp:72:10: error: redeclaration of\
    \ \u2018long int k\u2019\n   72 |     long k = 0;\n      |          ^\n/tmp/tmppc2xd24k.cpp:20:10:\
    \ note: \u2018long int k\u2019 previously declared here\n   20 |     long k =\
    \ 0;\n      |          ^\n/tmp/tmppc2xd24k.cpp:73:10: error: redeclaration of\
    \ \u2018long int l\u2019\n   73 |     long l = 0;\n      |          ^\n/tmp/tmppc2xd24k.cpp:21:10:\
    \ note: \u2018long int l\u2019 previously declared here\n   21 |     long l =\
    \ 0;\n      |          ^\n/tmp/tmppc2xd24k.cpp:74:10: error: redeclaration of\
    \ \u2018long int m\u2019\n   74 |     long m = 0;\n      |          ^\n/tmp/tmppc2xd24k.cpp:22:10:\
    \ note: \u2018long int m\u2019 previously declared here\n   22 |     long m =\
    \ 0;\n      |          ^\n/tmp/tmppc2xd24k.cpp:75:10: error: redeclaration of\
    \ \u2018long int n\u2019\n   75 |     long n = 0;\n      |          ^\n/tmp/tmppc2xd24k.cpp:23:10:\
    \ note: \u2018long int n\u2019 previously declared here\n   23 |     long n =\
    \ 0;\n      |          ^\n/tmp/tmppc2xd24k.cpp:76:10: error: redeclaration of\
    \ \u2018long int o\u2019\n   76 |     long o = 0;\n      |          ^\n/tmp/tmppc2xd24k.cpp:24:10:\
    \ note: \u2018long int o\u2019 previously declared here\n   24 |     long o =\
    \ 0;\n      |          ^\n/tmp/tmppc2xd24k.cpp:77:10: error: redeclaration of\
    \ \u2018long int p\u2019\n   77 |     long p = 0;\n      |          ^\n/tmp/tmppc2xd24k.cpp:25:10:\
    \ note: \u2018long int p\u2019 previously declared here\n   25 |     long p =\
    \ 0;\n      |          ^\n/tmp/tmppc2xd24k.cpp:78:10: error: redeclaration of\
    \ \u2018long int q\u2019\n   78 |     long q = 0;\n      |          ^\n/tmp/tmpp"
  stdout: ''
  timestamp: 1660141606
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ base = 10;\n    long power = 1;\n    long factor = 1;\n    long temp;\n    long\
    \ digit;\n    long sum = 0;\n    long count = 0;\n    long sum2 = 0;\n    long\
    \ sum3 = 0;\n    long sum4 = 0;\n    long sum5 = 0;\n    long sum6 = 0;\n    long\
    \ sum7 = 0;\n    long sum8 = 0;\n    long sum9 = 0;\n    long sum10 = 0;\n   \
    \ long sum11 = 0;\n    long sum12 = 0;\n    long sum13 = 0;\n    long sum14 =\
    \ 0;\n    long sum15 = 0;\n    long sum16 = 0;\n    long sum17 = 0;\n    long\
    \ sum18 = 0;\n    long sum19 = 0;\n    long sum20 = 0;\n    long sum21 = 0;\n\
    \    long sum22 = 0;\n    long sum23 = 0;\n    long sum24 = 0;\n    long sum25\
    \ = 0;\n    long sum26 = 0;\n    long sum27 = 0;\n    long sum28 = 0;\n    long\
    \ sum29 = 0;\n    long sum30 = 0;\n    long sum31 = 0;\n    long sum32 = 0;\n\
    \    long sum33 = 0;\n    long sum34 = 0;\n    long sum35 = 0;\n    long sum36\
    \ = 0;\n    long sum37 = 0;\n    long sum38 = 0;\n    long sum39 = 0;\n    long\
    \ sum40 = 0;\n    long sum41 = 0;\n    long sum42 = 0;\n    long sum43 = 0;\n\
    \    long sum44 = 0;\n    long sum45 = 0;\n    long sum46 = 0;\n    long sum47\
    \ = 0;\n    long sum48 = 0;\n    long sum49 = 0;\n    long sum50 = 0;\n    long\
    \ sum51 = 0;\n    long sum52 = 0;\n    long sum53 = 0;\n    long sum54 = 0;\n\
    \    long sum55 = 0;\n    long sum56 = 0;\n    long sum57 = 0;\n    long sum58\
    \ = 0;\n    long sum59 = 0;\n    long sum60 = 0;\n    long sum61 = 0;\n    long\
    \ sum62 = 0;\n    long sum63 = 0;\n    long sum64 = 0;\n    long sum65 = 0;\n\
    \    long sum66 = 0;\n    long sum67 = 0;\n    long sum68 = 0;\n    long sum69\
    \ = 0;\n    long sum70 = 0;\n    long sum71 = 0;\n    long sum72 = 0;\n    long\
    \ sum73 = 0;\n    long sum74 = 0;\n    long sum75 = 0;\n    long sum76 = 0;\n\
    \    long sum77 = 0;\n    long sum78 = 0;\n    long sum79 = 0;\n    long sum80\
    \ = 0;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpl8_6u3we: /tmp/tmpl8_6u3we.cpp:103: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141607
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int first = 0;\n    long\
    \ long int second = 0;\n    long long int difference = 0;\n    long long int closest\
    \ = 0;\n    long long int temp = 0;\n    long long int temp2 = 0;\n    long long\
    \ int temp3 = 0;\n    long long int temp4 = 0;\n    long long int temp5 = 0;\n\
    \    long long int temp6 = 0;\n    long long int temp7 = 0;\n    long long int\
    \ temp8 = 0;\n    long long int temp9 = 0;\n    long long int temp10 = 0;\n  \
    \  long long int temp11 = 0;\n    long long int temp12 = 0;\n    long long int\
    \ temp13 = 0;\n    long long int temp14 = 0;\n    long long int temp15 = 0;\n\
    \    long long int temp16 = 0;\n    long long int temp17 = 0;\n    long long int\
    \ temp18 = 0;\n    long long int temp19 = 0;\n    long long int temp20 = 0;\n\
    \    long long int temp21 = 0;\n    long long int temp22 = 0;\n    long long int\
    \ temp23 = 0;\n    long long int temp24 = 0;\n    long long int temp25 = 0;\n\
    \    long long int temp26 = 0;\n    long long int temp27 = 0;\n    long long int\
    \ temp28 = 0;\n    long long int temp29 = 0;\n    long long int temp30 = 0;\n\
    \    long long int temp31 = 0;\n    long long int temp32 = 0;\n    long long int\
    \ temp33 = 0;\n    long long int temp34 = 0;\n    long long int temp35 = 0;\n\
    \    long long int temp36 = 0;\n    long long int temp37 = 0;\n    long long int\
    \ temp38 = 0;\n    long long int temp39 = 0;\n    long long int temp40 = 0;\n\
    \    long long int temp41 = 0;\n    long long int temp42 = 0;\n    long long int\
    \ temp43 = 0;\n    long long int temp44 = 0;\n    long long int temp45 = 0;\n\
    \    long long int temp46 = 0;\n    long long int temp47 = 0;\n    long long int\
    \ temp48 = 0;\n    long long int temp49 = 0;\n    long long int temp50 = 0;\n\
    \    long long int temp51 = 0;\n    long long int temp52 = 0;\n    long long int\
    \ temp53 = 0;\n    long long int temp54 = 0;\n    long long int temp55 = 0;\n\
    \    long long int temp56 = 0;\n    long long int temp57 = 0;\n    long long int\
    \ temp58 = 0;\n    long long int temp59 = 0;\n    long long int temp60 = 0;\n\
    \    long long int temp61 = 0;\n    \n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp8zih0oq5: /tmp/tmp8zih0oq5.cpp:82: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141607
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int a = stoi(value);\n \
    \   long long int b = a;\n    long long int c = a;\n    long long int d = a;\n\
    \    long long int e = a;\n    long long int f = a;\n    long long int g = a;\n\
    \    long long int h = a;\n    long long int i = a;\n    long long int j = a;\n\
    \    long long int k = a;\n    long long int l = a;\n    long long int m = a;\n\
    \    long long int n = a;\n    long long int o = a;\n    long long int p = a;\n\
    \    long long int q = a;\n    long long int r = a;\n    long long int s = a;\n\
    \    long long int t = a;\n    long long int u = a;\n    long long int v = a;\n\
    \    long long int w = a;\n    long long int x = a;\n    long long int y = a;\n\
    \    long long int z = a;\n    long long int a = a;\n    long long int b = a;\n\
    \    long long int c = a;\n    long long int d = a;\n    long long int e = a;\n\
    \    long long int f = a;\n    long long int g = a;\n    long long int h = a;\n\
    \    long long int i = a;\n    long long int j = a;\n    long long int k = a;\n\
    \    long long int l = a;\n    long long int m = a;\n    long long int n = a;\n\
    \    long long int o = a;\n    long long int p = a;\n    long long int q = a;\n\
    \    long long int r = a;\n    long long int s = a;\n    long long int t = a;\n\
    \    long long int u = a;\n    long long int v = a;\n    long long int w = a;\n\
    \    long long int x = a;\n    long long int y = a;\n    long long int z = a;\n\
    \    long long int a = a;\n    long long int b = a;\n    long long int c = a;\n\
    \    long long int d = a;\n    long long int e = a;\n    long long int f = a;\n\
    \    long long int g = a;\n    long long int h = a;\n    long long int i = a;\n\
    \    long long int j = a;\n    long long int k = a;\n    long long int l = a;\n\
    \    long long int m = a;\n    long long int n = a;\n    long long int o = a;\n\
    \    long long int p = a;\n    long long int q = a;\n    long long int r = a;\n\
    \    long long int s = a;\n    long long int t = a;\n    long long int \n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptdxx6mtz.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmptdxx6mtz.cpp:39:19: error: redeclaration of \u2018long long int a\u2019\
    \n   39 |     long long int a = a;\n      |                   ^\n/tmp/tmptdxx6mtz.cpp:13:19:\
    \ note: \u2018long long int a\u2019 previously declared here\n   13 |     long\
    \ long int a = stoi(value);\n      |                   ^\n/tmp/tmptdxx6mtz.cpp:40:19:\
    \ error: redeclaration of \u2018long long int b\u2019\n   40 |     long long int\
    \ b = a;\n      |                   ^\n/tmp/tmptdxx6mtz.cpp:14:19: note: \u2018\
    long long int b\u2019 previously declared here\n   14 |     long long int b =\
    \ a;\n      |                   ^\n/tmp/tmptdxx6mtz.cpp:41:19: error: redeclaration\
    \ of \u2018long long int c\u2019\n   41 |     long long int c = a;\n      |  \
    \                 ^\n/tmp/tmptdxx6mtz.cpp:15:19: note: \u2018long long int c\u2019\
    \ previously declared here\n   15 |     long long int c = a;\n      |        \
    \           ^\n/tmp/tmptdxx6mtz.cpp:42:19: error: redeclaration of \u2018long\
    \ long int d\u2019\n   42 |     long long int d = a;\n      |                \
    \   ^\n/tmp/tmptdxx6mtz.cpp:16:19: note: \u2018long long int d\u2019 previously\
    \ declared here\n   16 |     long long int d = a;\n      |                   ^\n\
    /tmp/tmptdxx6mtz.cpp:43:19: error: redeclaration of \u2018long long int e\u2019\
    \n   43 |     long long int e = a;\n      |                   ^\n/tmp/tmptdxx6mtz.cpp:17:19:\
    \ note: \u2018long long int e\u2019 previously declared here\n   17 |     long\
    \ long int e = a;\n      |                   ^\n/tmp/tmptdxx6mtz.cpp:44:19: error:\
    \ redeclaration of \u2018long long int f\u2019\n   44 |     long long int f =\
    \ a;\n      |                   ^\n/tmp/tmptdxx6mtz.cpp:18:19: note: \u2018long\
    \ long int f\u2019 previously declared here\n   18 |     long long int f = a;\n\
    \      |                   ^\n/tmp/tmptdxx6mtz.cpp:45:19: error: redeclaration\
    \ of \u2018long long int g\u2019\n   45 |     long long int g = a;\n      |  \
    \                 ^\n/tmp/tmptdxx6mtz.cpp:19:19: note: \u2018long long int g\u2019\
    \ previously declared here\n   19 |     long long int g = a;\n      |        \
    \           ^\n/tmp/tmptdxx6mtz.cpp"
  stdout: ''
  timestamp: 1660141606
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n\
    \    long diff = std::abs(atoi(value.c_str()));\n    long mid = 0;\n    long closest\
    \ = 0;\n    long diff2 = diff;\n    while (diff2 > 0) {\n        mid = (lower\
    \ + upper) / 2;\n        diff2 = std::abs(mid - diff);\n        if (mid > diff)\
    \ {\n            upper = mid;\n        } else if (mid < diff) {\n            lower\
    \ = mid;\n        } else {\n            closest = mid;\n        }\n    }\n   \
    \ return closest;\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpnfzjw6z7: /tmp/tmpnfzjw6z7.cpp:34: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141607
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long temp = 0;\n\
    \    long diff = 0;\n    long diff2 = 0;\n    long diff3 = 0;\n    long diff4\
    \ = 0;\n    long diff5 = 0;\n    long diff6 = 0;\n    long diff7 = 0;\n    long\
    \ diff8 = 0;\n    long diff9 = 0;\n    long diff10 = 0;\n    long diff11 = 0;\n\
    \    long diff12 = 0;\n    long diff13 = 0;\n    long diff14 = 0;\n    long diff15\
    \ = 0;\n    long diff16 = 0;\n    long diff17 = 0;\n    long diff18 = 0;\n   \
    \ long diff19 = 0;\n    long diff20 = 0;\n    long diff21 = 0;\n    long diff22\
    \ = 0;\n    long diff23 = 0;\n    long diff24 = 0;\n    long diff25 = 0;\n   \
    \ long diff26 = 0;\n    long diff27 = 0;\n    long diff28 = 0;\n    long diff29\
    \ = 0;\n    long diff30 = 0;\n    long diff31 = 0;\n    long diff32 = 0;\n   \
    \ long diff33 = 0;\n    long diff34 = 0;\n    long diff35 = 0;\n    long diff36\
    \ = 0;\n    long diff37 = 0;\n    long diff38 = 0;\n    long diff39 = 0;\n   \
    \ long diff40 = 0;\n    long diff41 = 0;\n    long diff42 = 0;\n    long diff43\
    \ = 0;\n    long diff44 = 0;\n    long diff45 = 0;\n    long diff46 = 0;\n   \
    \ long diff47 = 0;\n    long diff48 = 0;\n    long diff49 = 0;\n    long diff50\
    \ = 0;\n    long diff51 = 0;\n    long diff52 = 0;\n    long diff53 = 0;\n   \
    \ long diff54 = 0;\n    long diff55 = 0;\n    long diff56 = 0;\n    long diff57\
    \ = 0;\n    long diff58 = 0;\n    long diff59 = 0;\n    long diff60 = 0;\n   \
    \ long diff61 = 0;\n    long diff62 = 0;\n    long diff63 = 0;\n    long diff64\
    \ = 0;\n    long diff65 = 0;\n    long diff66 = 0;\n    long diff67 = 0;\n   \
    \ long diff68 = 0;\n    long diff69 = 0;\n    long diff70 = 0;\n    long diff71\
    \ = 0;\n    long diff72 = 0;\n    long diff73 = 0;\n    long diff74 = 0;\n   \
    \ long diff75 = 0;\n    long diff76 = 0;\n    long diff77 = 0;\n    long diff78\
    \ = 0;\n    long diff79 = 0;\n    long diff80 = 0;\n    long diff81 = 0;\n   \
    \ long diff82 = 0;\n    long diff83 = 0;\n    long diff84 = 0;\n    long diff\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9h3m93dx.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp9h3m93dx.cpp:100:1: error: expected initializer before \u2018}\u2019\
    \ token\n  100 | }\n      | ^\n/tmp/tmp9h3m93dx.cpp:100:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141606
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp = 0;\n    long long temp2 = 0;\n    long long temp3 = 0;\n    long\
    \ long temp4 = 0;\n    long long temp5 = 0;\n    long long temp6 = 0;\n    long\
    \ long temp7 = 0;\n    long long temp8 = 0;\n    long long temp9 = 0;\n    long\
    \ long temp10 = 0;\n    long long temp11 = 0;\n    long long temp12 = 0;\n   \
    \ long long temp13 = 0;\n    long long temp14 = 0;\n    long long temp15 = 0;\n\
    \    long long temp16 = 0;\n    long long temp17 = 0;\n    long long temp18 =\
    \ 0;\n    long long temp19 = 0;\n    long long temp20 = 0;\n    long long temp21\
    \ = 0;\n    long long temp22 = 0;\n    long long temp23 = 0;\n    long long temp24\
    \ = 0;\n    long long temp25 = 0;\n    long long temp26 = 0;\n    long long temp27\
    \ = 0;\n    long long temp28 = 0;\n    long long temp29 = 0;\n    long long temp30\
    \ = 0;\n    long long temp31 = 0;\n    long long temp32 = 0;\n    long long temp33\
    \ = 0;\n    long long temp34 = 0;\n    long long temp35 = 0;\n    long long temp36\
    \ = 0;\n    long long temp37 = 0;\n    long long temp38 = 0;\n    long long temp39\
    \ = 0;\n    long long temp40 = 0;\n    long long temp41 = 0;\n    long long temp42\
    \ = 0;\n    long long temp43 = 0;\n    long long temp44 = 0;\n    long long temp45\
    \ = 0;\n    long long temp46 = 0;\n    long long temp47 = 0;\n    long long temp48\
    \ = 0;\n    long long temp49 = 0;\n    long long temp50 = 0;\n    long long temp51\
    \ = 0;\n    long long temp52 = 0;\n    long long temp53 = 0;\n    long long temp54\
    \ = 0;\n    long long temp55 = 0;\n    long long temp56 = 0;\n    long long temp57\
    \ = 0;\n    long long temp58 = 0;\n    long long temp59 = 0;\n    long long temp60\
    \ = 0;\n    long long temp61 = 0;\n    long long temp62 = 0;\n    long long temp63\
    \ = 0;\n    long long temp64 = 0;\n    long long temp65 = 0;\n    long long temp66\
    \ = 0;\n    long long temp67 = 0;\n    long long temp68 = 0;\n    long long temp69\
    \ = 0;\n    long long temp70 = 0;\n    long long temp71 = 0;\n    long long temp72\
    \ = 0;\n    long long temp73\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjgxgzpwg.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpjgxgzpwg.cpp:87:1: error: expected initializer before \u2018}\u2019\
    \ token\n   87 | }\n      | ^\n/tmp/tmpjgxgzpwg.cpp:87:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141604
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, sign = 1;\n    long temp;\n    long d = value.size();\n    long x = 0, y\
    \ = 0;\n    long ans2 = 0;\n    long ans3 = 0;\n    long ans4 = 0;\n    long ans5\
    \ = 0;\n    long ans6 = 0;\n    long ans7 = 0;\n    long ans8 = 0;\n    long ans9\
    \ = 0;\n    long ans10 = 0;\n    long ans11 = 0;\n    long ans12 = 0;\n    long\
    \ ans13 = 0;\n    long ans14 = 0;\n    long ans15 = 0;\n    long ans16 = 0;\n\
    \    long ans17 = 0;\n    long ans18 = 0;\n    long ans19 = 0;\n    long ans20\
    \ = 0;\n    long ans21 = 0;\n    long ans22 = 0;\n    long ans23 = 0;\n    long\
    \ ans24 = 0;\n    long ans25 = 0;\n    long ans26 = 0;\n    long ans27 = 0;\n\
    \    long ans28 = 0;\n    long ans29 = 0;\n    long ans30 = 0;\n    long ans31\
    \ = 0;\n    long ans32 = 0;\n    long ans33 = 0;\n    long ans34 = 0;\n    long\
    \ ans35 = 0;\n    long ans36 = 0;\n    long ans37 = 0;\n    long ans38 = 0;\n\
    \    long ans39 = 0;\n    long ans40 = 0;\n    long ans41 = 1;\n    long ans42\
    \ = 0;\n    long ans43 = 0;\n    long ans44 = 0;\n    long ans45 = 0;\n    long\
    \ ans46 = 0;\n    long ans47 = 0;\n    long ans48 = 0;\n    long ans49 = 0;\n\
    \    long ans50 = 0;\n    long ans51 = 1;\n    long ans52 = 0;\n    long ans53\
    \ = 0;\n    long ans54 = 0;\n    long ans55 = 0;\n    long ans56 = 0;\n    long\
    \ ans57 = 0;\n    long ans58 = 0;\n    long ans59 = 0;\n    long ans60 = 0;\n\
    \    long ans61 = 1;\n    long ans62 = 0;\n    long ans63 = 0;\n    long ans64\
    \ = 0;\n    long ans65 = 0;\n    long ans66 = 0;\n    long ans67 = 0;\n    long\
    \ ans68 = 0;\n    long ans69 = 0;\n    long ans70 = 0;\n    long ans = 1;\n  \
    \  long temp1;\n    long temp2;\n    long temp3;\n    long temp4;\n    long temp5;\n\
    \    long temp6;\n    long temp7;\n    long temp8;\n    long temp9;\n    long\
    \ temp10;\n    long temp11;\n    long temp12;\n    long \n}\nint main() {\n  \
    \  auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppxgi3d34.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmppxgi3d34.cpp:87:10: error: redeclaration of \u2018long int ans\u2019\
    \n   87 |     long ans = 1;\n      |          ^~~\n/tmp/tmppxgi3d34.cpp:14:10:\
    \ note: \u2018long int ans\u2019 previously declared here\n   14 |     long ans\
    \ = 0, sign = 1;\n      |          ^~~\n/tmp/tmppxgi3d34.cpp:101:1: error: expected\
    \ unqualified-id before \u2018}\u2019 token\n  101 | }\n      | ^\n/tmp/tmppxgi3d34.cpp:101:1:\
    \ warning: no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141606
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, diff = 0;\n    long n = stoi(value);\n    long diff = n - ans;\n    long\
    \ mid = diff / 2;\n    long left = ans - mid;\n    long right = ans + mid;\n \
    \   if (left > right) {\n        ans = left;\n    } else {\n        ans = right;\n\
    \    }\n    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy33gtz17.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpy33gtz17.cpp:16:10: error: redeclaration of \u2018long int diff\u2019\
    \n   16 |     long diff = n - ans;\n      |          ^~~~\n/tmp/tmpy33gtz17.cpp:14:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   14 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n"
  stdout: ''
  timestamp: 1660141606
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ x = std::stoi(value);\n    long y = std::stoi(value);\n    long z = std::stoi(value);\n\
    \    long a = std::stoi(value);\n    long b = std::stoi(value);\n    long c =\
    \ std::stoi(value);\n    long d = std::stoi(value);\n    long e = std::stoi(value);\n\
    \    long f = std::stoi(value);\n    long g = std::stoi(value);\n    long h =\
    \ std::stoi(value);\n    long i = std::stoi(value);\n    long j = std::stoi(value);\n\
    \    long k = std::stoi(value);\n    long l = std::stoi(value);\n    long m =\
    \ std::stoi(value);\n    long n = std::stoi(value);\n    long o = std::stoi(value);\n\
    \    long p = std::stoi(value);\n    long q = std::stoi(value);\n    long r =\
    \ std::stoi(value);\n    long s = std::stoi(value);\n    long t = std::stoi(value);\n\
    \    long u = std::stoi(value);\n    long v = std::stoi(value);\n    long w =\
    \ std::stoi(value);\n    long x = std::stoi(value);\n    long y = std::stoi(value);\n\
    \    long z = std::stoi(value);\n    long a = std::stoi(value);\n    long b =\
    \ std::stoi(value);\n    long c = std::stoi(value);\n    long d = std::stoi(value);\n\
    \    long e = std::stoi(value);\n    long f = std::stoi(value);\n    long g =\
    \ std::stoi(value);\n    long h = std::stoi(value);\n    long i = std::stoi(value);\n\
    \    long j = std::stoi(value);\n    long k = std::stoi(value);\n    long l =\
    \ std::stoi(value);\n    long m = std::stoi(value);\n    long n = std::stoi(value);\n\
    \    long o = std::stoi(value);\n    long p = std::stoi(value);\n    long q =\
    \ std::stoi(value);\n    long r = std::stoi(value);\n    long s = std::stoi(value);\n\
    \    long t = std::stoi(value);\n    long u = std::stoi(value);\n    long v =\
    \ std::stoi(value);\n    long w = std::stoi(value);\n    long x = std::stoi(value);\n\
    \    long y = std::stoi(value);\n    long z = std::stoi(value);\n    long a =\
    \ std::stoi(value);\n    long b = std::stoi(value);\n    long c = std::stoi(value);\n\
    \    long d = std::stoi(value);\n    long e = std::stoi(value);\n    long f =\
    \ std::stoi(value);\n    long g = std::stoi(value);\n    long h = std::stoi(value);\n\
    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpfdrtw5uo.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpfdrtw5uo.cpp:40:10: error: redeclaration of \u2018long int x\u2019\n\
    \   40 |     long x = std::stoi(value);\n      |          ^\n/tmp/tmpfdrtw5uo.cpp:14:10:\
    \ note: \u2018long int x\u2019 previously declared here\n   14 |     long x =\
    \ std::stoi(value);\n      |          ^\n/tmp/tmpfdrtw5uo.cpp:41:10: error: redeclaration\
    \ of \u2018long int y\u2019\n   41 |     long y = std::stoi(value);\n      | \
    \         ^\n/tmp/tmpfdrtw5uo.cpp:15:10: note: \u2018long int y\u2019 previously\
    \ declared here\n   15 |     long y = std::stoi(value);\n      |          ^\n\
    /tmp/tmpfdrtw5uo.cpp:42:10: error: redeclaration of \u2018long int z\u2019\n \
    \  42 |     long z = std::stoi(value);\n      |          ^\n/tmp/tmpfdrtw5uo.cpp:16:10:\
    \ note: \u2018long int z\u2019 previously declared here\n   16 |     long z =\
    \ std::stoi(value);\n      |          ^\n/tmp/tmpfdrtw5uo.cpp:43:10: error: redeclaration\
    \ of \u2018long int a\u2019\n   43 |     long a = std::stoi(value);\n      | \
    \         ^\n/tmp/tmpfdrtw5uo.cpp:17:10: note: \u2018long int a\u2019 previously\
    \ declared here\n   17 |     long a = std::stoi(value);\n      |          ^\n\
    /tmp/tmpfdrtw5uo.cpp:44:10: error: redeclaration of \u2018long int b\u2019\n \
    \  44 |     long b = std::stoi(value);\n      |          ^\n/tmp/tmpfdrtw5uo.cpp:18:10:\
    \ note: \u2018long int b\u2019 previously declared here\n   18 |     long b =\
    \ std::stoi(value);\n      |          ^\n/tmp/tmpfdrtw5uo.cpp:45:10: error: redeclaration\
    \ of \u2018long int c\u2019\n   45 |     long c = std::stoi(value);\n      | \
    \         ^\n/tmp/tmpfdrtw5uo.cpp:19:10: note: \u2018long int c\u2019 previously\
    \ declared here\n   19 |     long c = std::stoi(value);\n      |          ^\n\
    /tmp/tmpfdrtw5uo.cpp:46:10: error: redeclaration of \u2018long int d\u2019\n \
    \  46 |     long d = std::stoi(value);\n      |          ^\n/tmp/tmpfdrtw5uo.cpp:20:10:\
    \ note: \u2018long int d\u2019 previously declared here\n   20 |     long d =\
    \ std::stoi(value);\n      |          ^\n/tmp/tmpfdrtw5uo.cpp:47:10: error: redeclaration\
    \ of \u2018long int e\u2019\n   47 |     long e = std::stoi(value);\n      | \
    \         ^\n/tmp/tmpfdrtw5u"
  stdout: ''
  timestamp: 1660141606
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n\
    \    long mid = 0;\n    long diff = 0;\n    long diff2 = 0;\n    long diff3 =\
    \ 0;\n    long diff4 = 0;\n    long diff5 = 0;\n    long diff6 = 0;\n    long\
    \ diff7 = 0;\n    long diff8 = 0;\n    long diff9 = 0;\n    long diff10 = 0;\n\
    \    long diff11 = 0;\n    long diff12 = 0;\n    long diff13 = 0;\n    long diff14\
    \ = 0;\n    long diff15 = 0;\n    long diff16 = 0;\n    long diff17 = 0;\n   \
    \ long diff18 = 0;\n    long diff19 = 0;\n    long diff20 = 0;\n    long diff21\
    \ = 0;\n    long diff22 = 0;\n    long diff23 = 0;\n    long diff24 = 0;\n   \
    \ long diff25 = 0;\n    long diff26 = 0;\n    long diff27 = 0;\n    long diff28\
    \ = 0;\n    long diff29 = 0;\n    long diff30 = 0;\n    long diff31 = 0;\n   \
    \ long diff32 = 0;\n    long diff33 = 0;\n    long diff34 = 0;\n    long diff35\
    \ = 0;\n    long diff36 = 0;\n    long diff37 = 0;\n    long diff38 = 0;\n   \
    \ long diff39 = 0;\n    long diff40 = 0;\n    long diff41 = 0;\n    long diff42\
    \ = 0;\n    long diff43 = 0;\n    long diff44 = 0;\n    long diff45 = 0;\n   \
    \ long diff46 = 0;\n    long diff47 = 0;\n    long diff48 = 0;\n    long diff49\
    \ = 0;\n    long diff50 = 0;\n    long diff51 = 0;\n    long diff52 = 0;\n   \
    \ long diff53 = 0;\n    long diff54 = 0;\n    long diff55 = 0;\n    long diff56\
    \ = 0;\n    long diff57 = 0;\n    long diff58 = 0;\n    long diff59 = 0;\n   \
    \ long diff60 = 0;\n    long diff61 = 0;\n    long diff62 = 0;\n    long diff63\
    \ = 0;\n    long diff64 = 0;\n    long diff65 = 0;\n    long diff66 = 0;\n   \
    \ long diff67 = 0;\n    long diff68 = 0;\n    long diff69 = 0;\n    long diff70\
    \ = 0;\n    long diff71 = 0;\n    long diff72 = 0;\n    long diff73 = 0;\n   \
    \ long diff74 = 0;\n    long diff75 = 0;\n    long diff76 = 0;\n    long diff77\
    \ = 0;\n    long diff78 = 0;\n    long diff79 = 0;\n    long diff80 = 0;\n   \
    \ long diff81 = 0;\n    long diff82 = 0;\n    long diff83\n}\nint main() {\n \
    \   auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa2otwikc.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpa2otwikc.cpp:98:1: error: expected initializer before \u2018}\u2019\
    \ token\n   98 | }\n      | ^\n/tmp/tmpa2otwikc.cpp:98:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ temp;\n    long long temp2;\n    long long temp3;\n    long long temp4;\n  \
    \  long long temp5;\n    long long temp6;\n    long long temp7;\n    long long\
    \ temp8;\n    long long temp9;\n    long long temp10;\n    long long temp11;\n\
    \    long long temp12;\n    long long temp13;\n    long long temp14;\n    long\
    \ long temp15;\n    long long temp16;\n    long long temp17;\n    long long temp18;\n\
    \    long long temp19;\n    long long temp20;\n    long long temp21;\n    long\
    \ long temp22;\n    long long temp23;\n    long long temp24;\n    long long temp25;\n\
    \    long long temp26;\n    long long temp27;\n    long long temp28;\n    long\
    \ long temp29;\n    long long temp30;\n    long long temp31;\n    long long temp32;\n\
    \    long long temp33;\n    long long temp34;\n    long long temp35;\n    long\
    \ long temp36;\n    long long temp37;\n    long long temp38;\n    long long temp39;\n\
    \    long long temp40;\n    long long temp41;\n    long long temp42;\n    long\
    \ long temp43;\n    long long temp44;\n    long long temp45;\n    long long temp46;\n\
    \    long long temp47;\n    long long temp48;\n    long long temp49;\n    long\
    \ long temp50;\n    long long temp51;\n    long long temp52;\n    long long temp53;\n\
    \    long long temp54;\n    long long temp55;\n    long long temp56;\n    long\
    \ long temp57;\n    long long temp58;\n    long long temp59;\n    long long temp60;\n\
    \    long long temp61;\n    long long temp62;\n    long long temp63;\n    long\
    \ long temp64;\n    long long temp65;\n    long long temp66;\n    long long temp67;\n\
    \    long long temp68;\n    long long temp69;\n    long long temp70;\n    long\
    \ long temp71;\n    long long temp72;\n    long long temp73;\n    long long temp74;\n\
    \    long long temp75;\n\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpsnrymunm: /tmp/tmpsnrymunm.cpp:93: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141607
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long long temp;\n    long long temp2;\n    long long temp3;\n    long\
    \ long temp4;\n    long long temp5;\n    long long temp6;\n    long long temp7;\n\
    \    long long temp8;\n    long long temp9;\n    long long temp10;\n    long long\
    \ temp11;\n    long long temp12;\n    long long temp13;\n    long long temp14;\n\
    \    long long temp15;\n    long long temp16;\n    long long temp17;\n    long\
    \ long temp18;\n    long long temp19;\n    long long temp20;\n    long long temp21;\n\
    \    long long temp22;\n    long long temp23;\n    long long temp24;\n    long\
    \ long temp25;\n    long long temp26;\n    long long temp27;\n    long long temp28;\n\
    \    long long temp29;\n    long long temp30;\n    long long temp31;\n    long\
    \ long temp32;\n    long long temp33;\n    long long temp34;\n    long long temp35;\n\
    \    long long temp36;\n    long long temp37;\n    long long temp38;\n    long\
    \ long temp39;\n    long long temp40;\n    long long temp41;\n    long long temp42;\n\
    \    long long temp43;\n    long long temp44;\n    long long temp45;\n    long\
    \ long temp46;\n    long long temp47;\n    long long temp48;\n    long long temp49;\n\
    \    long long temp50;\n    long long temp51;\n    long long temp52;\n    long\
    \ long temp53;\n    long long temp54;\n    long long temp55;\n    long long temp56;\n\
    \    long long temp57;\n    long long temp58;\n    long long temp59;\n    long\
    \ long temp60;\n    long long temp61;\n    long long temp62;\n    long long temp63;\n\
    \    long long temp64;\n    long long temp65;\n    long long temp66;\n    long\
    \ long temp67;\n    long long temp68;\n    long long temp69;\n    long long temp70;\n\
    \    long long temp71;\n    long long temp72;\n    long long temp73;\n    long\
    \ long temp74;\n    long long temp\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptxz9s5ij.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmptxz9s5ij.cpp:90:1: error: expected initializer before \u2018}\u2019\
    \ token\n   90 | }\n      | ^\n/tmp/tmptxz9s5ij.cpp:90:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141606
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ ans = 0;\n    long diff = abs(atoi(value.c_str()));\n    long mid = diff / 2;\n\
    \    long left = atoi(value.substr(0, value.size()-1).c_str());\n    long right\
    \ = atoi(value.substr(value.size()-1).c_str());\n    long diff = right - left;\n\
    \    long mid2 = diff / 2;\n    long mid3 = diff / 3;\n    long mid4 = diff /\
    \ 4;\n    long mid5 = diff / 5;\n    long mid6 = diff / 6;\n    long mid7 = diff\
    \ / 7;\n    long mid8 = diff / 8;\n    long mid9 = diff / 9;\n    long mid10 =\
    \ diff / 10;\n    long mid11 = diff / 11;\n    long mid12 = diff / 12;\n    long\
    \ mid13 = diff / 13;\n    long mid14 = diff / 14;\n    long mid15 = diff / 15;\n\
    \    long mid16 = diff / 16;\n    long mid17 = diff / 17;\n    long mid18 = diff\
    \ / 18;\n    long mid19 = diff / 19;\n    long mid20 = diff / 20;\n    long mid21\
    \ = diff / 21;\n    long mid22 = diff / 22;\n    long mid23 = diff / 23;\n   \
    \ long mid24 = diff / 24;\n    long mid25 = diff / 25;\n    long mid26 = diff\
    \ / 26;\n    long mid27 = diff / 27;\n    long mid28 = diff / 28;\n    long mid29\
    \ = diff / 29;\n    long mid30 = diff / 30;\n    long mid31 = diff / 31;\n   \
    \ long mid32 = diff / 32;\n    long mid33 = diff / 33;\n    long mid34 = diff\
    \ / 34;\n    long mid35 = diff / 35;\n    long mid36 = diff / 36;\n    long mid37\
    \ = diff / 37;\n    long mid38 = diff / 38;\n    long mid39 = diff / 39;\n   \
    \ long mid40 = diff / 40;\n    long mid41 = diff / 41;\n    long mid42 = diff\
    \ / 42;\n    long mid43 = diff / 43;\n    long mid44 = diff / 44;\n    long mid45\
    \ = diff / 45;\n    long mid46 = diff / 46;\n    long mid47 = diff / 47;\n   \
    \ long mid48 = diff / 48;\n    long mid49 = diff \n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp05072iex.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp05072iex.cpp:19:10: error: redeclaration of \u2018long int diff\u2019\
    \n   19 |     long diff = right - left;\n      |          ^~~~\n/tmp/tmp05072iex.cpp:15:10:\
    \ note: \u2018long int diff\u2019 previously declared here\n   15 |     long diff\
    \ = abs(atoi(value.c_str()));\n      |          ^~~~\n/tmp/tmp05072iex.cpp:68:1:\
    \ error: expected \u2018,\u2019 or \u2018;\u2019 before \u2018}\u2019 token\n\
    \   68 | }\n      | ^\n/tmp/tmp05072iex.cpp:68:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141606
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp;\n    temp = std::stoll(value);\n    diff = temp - ans;\n    ans =\
    \ temp;\n    if (diff < 0) {\n        diff += 1;\n    }\n    return diff;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpb2_uwb96: /tmp/tmpb2_uwb96.cpp:26: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141606
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n\
    \    long mid = 0;\n    long diff = std::numeric_limits<long>::max();\n    for\
    \ (auto c : value) {\n        mid = (lower + upper) / 2;\n        diff = std::abs(mid\
    \ - std::stod(c));\n        if (diff < diff) {\n            lower = mid;\n   \
    \     } else {\n            upper = mid;\n        }\n    }\n    return lower;\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8amd9jrc.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp8amd9jrc.cpp:18:42: error: no matching function for call to \u2018\
    stod(char&)\u2019\n   18 |         diff = std::abs(mid - std::stod(c));\n    \
    \  |                                          ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp8amd9jrc.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6536:3:\
    \ note: candidate: \u2018double std::__cxx11::stod(const string&, std::size_t*)\u2019\
    \n 6536 |   stod(const string& __str, size_t* __idx = 0)\n      |   ^~~~\n/usr/include/c++/9/bits/basic_string.h:6536:22:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ string&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n 6536\
    \ |   stod(const string& __str, size_t* __idx = 0)\n      |        ~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6642:3: note: candidate: \u2018double std::__cxx11::stod(const\
    \ wstring&, std::size_t*)\u2019\n 6642 |   stod(const wstring& __str, size_t*\
    \ __idx = 0)\n      |   ^~~~\n/usr/include/c++/9/bits/basic_string.h:6642:23:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ wstring&\u2019 {aka \u2018const std::__cxx11::basic_string<wchar_t>&\u2019}\n\
    \ 6642 |   stod(const wstring& __str, size_t* __idx = 0)\n      |        ~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1660141606
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp = 0;\n    long long temp2 = 0;\n    long long temp3 = 0;\n    long\
    \ long temp4 = 0;\n    long long temp5 = 0;\n    long long temp6 = 0;\n    long\
    \ long temp7 = 0;\n    long long temp8 = 0;\n    long long temp9 = 0;\n    long\
    \ long temp10 = 0;\n    long long temp11 = 0;\n    long long temp12 = 0;\n   \
    \ long long temp13 = 0;\n    long long temp14 = 0;\n    long long temp15 = 0;\n\
    \    long long temp16 = 0;\n    long long temp17 = 0;\n    long long temp18 =\
    \ 0;\n    long long temp19 = 0;\n    long long temp20 = 0;\n    long long temp21\
    \ = 0;\n    long long temp22 = 0;\n    long long temp23 = 0;\n    long long temp24\
    \ = 0;\n    long long temp25 = 0;\n    long long temp26 = 0;\n    long long temp27\
    \ = 0;\n    long long temp28 = 0;\n    long long temp29 = 0;\n    long long temp30\
    \ = 0;\n    long long temp31 = 0;\n    long long temp32 = 0;\n    long long temp33\
    \ = 0;\n    long long temp34 = 0;\n    long long temp35 = 0;\n    long long temp36\
    \ = 0;\n    long long temp37 = 0;\n    long long temp38 = 0;\n    long long temp39\
    \ = 0;\n    long long temp40 = 0;\n    long long temp41 = 0;\n    long long temp42\
    \ = 0;\n    long long temp43 = 0;\n    long long temp44 = 0;\n    long long temp45\
    \ = 0;\n    long long temp46 = 0;\n    long long temp47 = 0;\n    long long temp48\
    \ = 0;\n    long long temp49 = 0;\n    long long temp50 = 0;\n    long long temp51\
    \ = 0;\n    long long temp52 = 0;\n    long long temp53 = 0;\n    long long temp54\
    \ = 0;\n    long long temp55 = 0;\n    long long temp56 = 0;\n    long long temp57\
    \ = 0;\n    long long temp58 = 0;\n    long long temp59 = 0;\n    long long temp60\
    \ = 0;\n    long long temp61 = 0;\n    long long temp62 = 0;\n    long long temp63\
    \ = 0;\n    long long temp64 = 0;\n    long long temp65 = 0;\n    long long temp66\
    \ = 0;\n    long long temp67 = 0;\n    long long temp68 = 0;\n    long long temp69\
    \ = 0;\n    long long temp70 = 0;\n    long long temp71 = 0;\n    long long temp72\
    \ = 0;\n    long long temp73\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjgxgzpwg.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpjgxgzpwg.cpp:87:1: error: expected initializer before \u2018}\u2019\
    \ token\n   87 | }\n      | ^\n/tmp/tmpjgxgzpwg.cpp:87:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num;\n    long long\
    \ int min;\n    long long int max;\n    long long int mid;\n    long long int\
    \ diff;\n    long long int diff2;\n    long long int diff3;\n    long long int\
    \ diff4;\n    long long int diff5;\n    long long int diff6;\n    long long int\
    \ diff7;\n    long long int diff8;\n    long long int diff9;\n    long long int\
    \ diff10;\n    long long int diff11;\n    long long int diff12;\n    long long\
    \ int diff13;\n    long long int diff14;\n    long long int diff15;\n    long\
    \ long int diff16;\n    long long int diff17;\n    long long int diff18;\n   \
    \ long long int diff19;\n    long long int diff20;\n    long long int diff21;\n\
    \    long long int diff22;\n    long long int diff23;\n    long long int diff24;\n\
    \    long long int diff25;\n    long long int diff26;\n    long long int diff27;\n\
    \    long long int diff28;\n    long long int diff29;\n    long long int diff30;\n\
    \    long long int diff31;\n    long long int diff32;\n    long long int diff33;\n\
    \    long long int diff34;\n    long long int diff35;\n    long long int diff36;\n\
    \    long long int diff37;\n    long long int diff38;\n    long long int diff39;\n\
    \    long long int diff40;\n    long long int diff41;\n    long long int diff42;\n\
    \    long long int diff43;\n    long long int diff44;\n    long long int diff45;\n\
    \    long long int diff46;\n    long long int diff47;\n    long long int diff48;\n\
    \    long long int diff49;\n    long long int diff50;\n    long long int diff51;\n\
    \    long long int diff52;\n    long long int diff53;\n    long long int diff54;\n\
    \    long long int diff55;\n    long long int diff56;\n    long long int diff57;\n\
    \    long long int diff58;\n    long long int diff59;\n    long long int diff60;\n\
    \    long long int diff61;\n    long long int diff62;\n    long long int diff63;\n\
    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpqg_4dw5y: /tmp/tmpqg_4dw5y.cpp:84: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = std::stoi(value);\n   \
    \ long diff = abs(ans - ans);\n    if (diff > 1) {\n        diff = diff - 1;\n\
    \    }\n    return ans + diff;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpcnprot2a: /tmp/tmpcnprot2a.cpp:23: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141607
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4\
    \ = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long\
    \ temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n\
    \    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15\
    \ = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n   \
    \ long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22\
    \ = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n   \
    \ long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29\
    \ = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n   \
    \ long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36\
    \ = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n   \
    \ long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43\
    \ = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n   \
    \ long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50\
    \ = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n   \
    \ long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57\
    \ = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n   \
    \ long temp61 = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64\
    \ = 0;\n    long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n   \
    \ long temp68 = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71\
    \ = 0;\n    long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n   \
    \ long temp75 = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78\
    \ = 0;\n    long temp79 = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n   \
    \ long temp82 = 0;\n    long temp83 = 0;\n    long temp84 = 0;\n    long temp\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxx1h5ume.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpxx1h5ume.cpp:100:1: error: expected initializer before \u2018}\u2019\
    \ token\n  100 | }\n      | ^\n/tmp/tmpxx1h5ume.cpp:100:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141606
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, sign = 1;\n    long temp = stoi(value);\n    long diff = abs(temp - ans);\n\
    \    long temp2 = abs(temp - ans);\n    if (temp2 > diff) {\n        ans = temp;\n\
    \        sign = -1;\n    }\n    return sign * ans;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpxswa9skm: /tmp/tmpxswa9skm.cpp:26: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141607
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int closest_int = 0;\n \
    \   long long int closest_diff = 0;\n    long long int diff = 0;\n    long long\
    \ int i = 0;\n    long long int j = 0;\n    long long int k = 0;\n    long long\
    \ int l = 0;\n    long long int m = 0;\n    long long int n = 0;\n    long long\
    \ int o = 0;\n    long long int p = 0;\n    long long int q = 0;\n    long long\
    \ int r = 0;\n    long long int s = 0;\n    long long int t = 0;\n    long long\
    \ int u = 0;\n    long long int v = 0;\n    long long int w = 0;\n    long long\
    \ int x = 0;\n    long long int y = 0;\n    long long int z = 0;\n    long long\
    \ int A = 0;\n    long long int B = 0;\n    long long int C = 0;\n    long long\
    \ int D = 0;\n    long long int E = 0;\n    long long int F = 0;\n    long long\
    \ int G = 0;\n    long long int H = 0;\n    long long int I = 0;\n    long long\
    \ int J = 0;\n    long long int K = 0;\n    long long int L = 0;\n    long long\
    \ int M = 0;\n    long long int N = 0;\n    long long int O = 0;\n    long long\
    \ int P = 0;\n    long long int Q = 0;\n    long long int R = 0;\n    long long\
    \ int S = 0;\n    long long int T = 0;\n    long long int U = 0;\n    long long\
    \ int V = 0;\n    long long int W = 0;\n    long long int X = 0;\n    long long\
    \ int Y = 0;\n    long long int Z = 0;\n    long long int a = 0;\n    long long\
    \ int b = 0;\n    long long int c = 0;\n    long long int d = 0;\n    long long\
    \ int e = 0;\n    long long int f = 0;\n    long long int g = 0;\n    long long\
    \ int h = 0;\n    long long int i = 0;\n    long long int j = 0;\n    long long\
    \ int k = 0;\n    long long int l = 0;\n    long long int m = 0;\n    long long\
    \ int n = 0;\n    long long int o = 0;\n    long long int p = 0;\n    long long\
    \ int q = 0;\n    long long int r = 0;\n    long long int s = 0;\n    long long\
    \ int t = 0;\n    long long int u = 0;\n    long long int v = 0;\n    long long\
    \ int w = 0;\n    long long int x = 0;\n    long long int y = 0;\n    long long\
    \ int z = 0;\n    long long int A\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyir2jx65.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpyir2jx65.cpp:68:19: error: redeclaration of \u2018long long int i\u2019\
    \n   68 |     long long int i = 0;\n      |                   ^\n/tmp/tmpyir2jx65.cpp:16:19:\
    \ note: \u2018long long int i\u2019 previously declared here\n   16 |     long\
    \ long int i = 0;\n      |                   ^\n/tmp/tmpyir2jx65.cpp:69:19: error:\
    \ redeclaration of \u2018long long int j\u2019\n   69 |     long long int j =\
    \ 0;\n      |                   ^\n/tmp/tmpyir2jx65.cpp:17:19: note: \u2018long\
    \ long int j\u2019 previously declared here\n   17 |     long long int j = 0;\n\
    \      |                   ^\n/tmp/tmpyir2jx65.cpp:70:19: error: redeclaration\
    \ of \u2018long long int k\u2019\n   70 |     long long int k = 0;\n      |  \
    \                 ^\n/tmp/tmpyir2jx65.cpp:18:19: note: \u2018long long int k\u2019\
    \ previously declared here\n   18 |     long long int k = 0;\n      |        \
    \           ^\n/tmp/tmpyir2jx65.cpp:71:19: error: redeclaration of \u2018long\
    \ long int l\u2019\n   71 |     long long int l = 0;\n      |                \
    \   ^\n/tmp/tmpyir2jx65.cpp:19:19: note: \u2018long long int l\u2019 previously\
    \ declared here\n   19 |     long long int l = 0;\n      |                   ^\n\
    /tmp/tmpyir2jx65.cpp:72:19: error: redeclaration of \u2018long long int m\u2019\
    \n   72 |     long long int m = 0;\n      |                   ^\n/tmp/tmpyir2jx65.cpp:20:19:\
    \ note: \u2018long long int m\u2019 previously declared here\n   20 |     long\
    \ long int m = 0;\n      |                   ^\n/tmp/tmpyir2jx65.cpp:73:19: error:\
    \ redeclaration of \u2018long long int n\u2019\n   73 |     long long int n =\
    \ 0;\n      |                   ^\n/tmp/tmpyir2jx65.cpp:21:19: note: \u2018long\
    \ long int n\u2019 previously declared here\n   21 |     long long int n = 0;\n\
    \      |                   ^\n/tmp/tmpyir2jx65.cpp:74:19: error: redeclaration\
    \ of \u2018long long int o\u2019\n   74 |     long long int o = 0;\n      |  \
    \                 ^\n/tmp/tmpyir2jx65.cpp:22:19: note: \u2018long long int o\u2019\
    \ previously declared here\n   22 |     long long int o = 0;\n      |        \
    \           ^\n/tmp/tmpyir2jx65.cpp:75:19: er"
  stdout: ''
  timestamp: 1660141606
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Declare a variable to hold the\
    \ closest integer\n    long closest;\n    // Declare a variable to hold the difference\
    \ between the given number\n    // and the closest integer\n    long diff;\n \
    \   // Declare a variable to hold the difference between the given number\n  \
    \  // and the closest integer\n    long diff2;\n    // Declare a variable to hold\
    \ the difference between the given number\n    // and the closest integer\n  \
    \  long diff3;\n    // Declare a variable to hold the difference between the given\
    \ number\n    // and the closest integer\n    long diff4;\n    // Declare a variable\
    \ to hold the difference between the given number\n    // and the closest integer\n\
    \    long diff5;\n    // Declare a variable to hold the difference between the\
    \ given number\n    // and the closest integer\n    long diff6;\n    // Declare\
    \ a variable to hold the difference between the given number\n    // and the closest\
    \ integer\n    long diff7;\n    // Declare a variable to hold the difference between\
    \ the given number\n    // and the closest integer\n    long diff8;\n    // Declare\
    \ a variable to hold the difference between the given number\n    // and the closest\
    \ integer\n    long diff9;\n    // Declare a variable to hold the difference between\
    \ the given number\n    // and the closest integer\n    long diff10;\n    // Declare\
    \ a variable to hold the difference between the given number\n    // and the closest\
    \ integer\n    long diff11;\n    // Declare a variable to hold the difference\
    \ between the given number\n    // and the closest integer\n    long diff12;\n\
    \    // Declare a variable to hold the difference between the given number\n \
    \   // and the closest integer\n    long diff13;\n    // Declare a variable to\
    \ hold the difference between the given number\n    // and the closest integer\n\
    \    long diff14;\n    // Declare a variable to hold the difference between the\
    \ given number\n    // and the closest integer\n    long diff15;\n    // Declare\
    \ a variable to hold the difference between the given number\n    // and the closest\
    \ integer\n    long diff16;\n    // Declare a variable to hold the difference\
    \ between the given number\n    // and the closest integer\n    long diff17;\n\
    \    // Declare a variable to hold the difference between the given number\n \
    \   // and the closest integer\n    long diff18;\n    // Declare a variable to\
    \ hold the difference between the given number\n    // and the closest integer\n\
    \    long diff19;\n    // Declare a variable to hold the difference between the\
    \ given number\n    // and the closest integer\n    long diff20;\n    // Declare\
    \ a variable to hold the difference between the given number\n    // and the closest\
    \ integer\n    long diff21;\n    // Declare a variable to hold the difference\
    \ \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpbgmqlgho: /tmp/tmpbgmqlgho.cpp:82: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141607
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long num;\n    long temp;\n    long diff2;\n    long diff3;\n    long diff4;\n\
    \    long diff5;\n    long diff6;\n    long diff7;\n    long diff8;\n    long\
    \ diff9;\n    long diff10;\n    long diff11;\n    long diff12;\n    long diff13;\n\
    \    long diff14;\n    long diff15;\n    long diff16;\n    long diff17;\n    long\
    \ diff18;\n    long diff19;\n    long diff20;\n    long diff21;\n    long diff22;\n\
    \    long diff23;\n    long diff24;\n    long diff25;\n    long diff26;\n    long\
    \ diff27;\n    long diff28;\n    long diff29;\n    long diff30;\n    long diff31;\n\
    \    long diff32;\n    long diff33;\n    long diff34;\n    long diff35;\n    long\
    \ diff36;\n    long diff37;\n    long diff38;\n    long diff39;\n    long diff40;\n\
    \    long diff41;\n    long diff42;\n    long diff43;\n    long diff44;\n    long\
    \ diff45;\n    long diff46;\n    long diff47;\n    long diff48;\n    long diff49;\n\
    \    long diff50;\n    long diff51;\n    long diff52;\n    long diff53;\n    long\
    \ diff54;\n    long diff55;\n    long diff56;\n    long diff57;\n    long diff58;\n\
    \    long diff59;\n    long diff60;\n    long diff61;\n    long diff62;\n    long\
    \ diff63;\n    long diff64;\n    long diff65;\n    long diff66;\n    long diff67;\n\
    \    long diff68;\n    long diff69;\n    long diff70;\n    long diff71;\n    long\
    \ diff72;\n    long diff73;\n    long diff74;\n    long diff75;\n    long diff76;\n\
    \    long diff77;\n    long diff78;\n    long diff79;\n    long diff80;\n    long\
    \ diff81;\n    long diff82;\n    long diff83;\n    long diff84;\n    long diff85;\n\
    \    long diff86;\n    \n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp1hvacmj_: /tmp/tmp1hvacmj_.cpp:106: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141607
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value);\n\
    \    if (lower > upper) {\n        long temp = lower;\n        lower = upper;\n\
    \        upper = temp;\n    }\n    long mid = (lower + upper) / 2;\n    long diff\
    \ = upper - lower;\n    long closest_diff = std::abs(mid - value);\n    if (diff\
    \ > closest_diff) {\n        mid = mid - diff;\n        closest_diff = std::abs(mid\
    \ - value);\n    }\n    return mid;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5_ok22k6.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp5_ok22k6.cpp:21:38: error: no match for \u2018operator-\u2019 (operand\
    \ types are \u2018long int\u2019 and \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    })\n   21 |     long closest_diff = std::abs(mid - value);\n      |          \
    \                        ~~~ ^ ~~~~~\n      |                                \
    \  |     |\n      |                                  |     std::string {aka std::__cxx11::basic_string<char>}\n\
    \      |                                  long int\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp5_ok22k6.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:415:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> constexpr\
    \ decltype ((__y.base() - __x.base())) std::operator-(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_IteratorR>&)\u2019\n  415 |     operator-(const\
    \ reverse_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:415:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmp5_ok22k6.cpp:21:40:\
    \ note:   mismatched types \u2018const std::reverse_iterator<_Iterator>\u2019\
    \ and \u2018long int\u2019\n   21 |     long closest_diff = std::abs(mid - value);\n\
    \      |                                        ^~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmp5_ok22k6.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1209:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> constexpr\
    \ decltype ((__x.base() - __y.base())) std::operator-(const std::move_iterator<_IteratorL>&,\
    \ const std::mov"
  stdout: ''
  timestamp: 1660141606
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = std::abs(std::stod(value)\
    \ - std::stod(value));\n    long diff2 = std::abs(std::stod(value) - std::stod(value));\n\
    \    if (diff < diff2) {\n        ans = std::stod(value) + 1;\n    } else {\n\
    \        ans = std::stod(value);\n    }\n    return ans;\n}\nint main() {\n  \
    \  auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpukhbx83i: /tmp/tmpukhbx83i.cpp:26: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141607
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int a = stoi(value);\n \
    \   long long int b = a;\n    long long int c = a;\n    long long int d = a;\n\
    \    long long int e = a;\n    long long int f = a;\n    long long int g = a;\n\
    \    long long int h = a;\n    long long int i = a;\n    long long int j = a;\n\
    \    long long int k = a;\n    long long int l = a;\n    long long int m = a;\n\
    \    long long int n = a;\n    long long int o = a;\n    long long int p = a;\n\
    \    long long int q = a;\n    long long int r = a;\n    long long int s = a;\n\
    \    long long int t = a;\n    long long int u = a;\n    long long int v = a;\n\
    \    long long int w = a;\n    long long int x = a;\n    long long int y = a;\n\
    \    long long int z = a;\n    long long int a = a;\n    long long int b = a;\n\
    \    long long int c = a;\n    long long int d = a;\n    long long int e = a;\n\
    \    long long int f = a;\n    long long int g = a;\n    long long int h = a;\n\
    \    long long int i = a;\n    long long int j = a;\n    long long int k = a;\n\
    \    long long int l = a;\n    long long int m = a;\n    long long int n = a;\n\
    \    long long int o = a;\n    long long int p = a;\n    long long int q = a;\n\
    \    long long int r = a;\n    long long int s = a;\n    long long int t = a;\n\
    \    long long int u = a;\n    long long int v = a;\n    long long int w = a;\n\
    \    long long int x = a;\n    long long int y = a;\n    long long int z = a;\n\
    \    long long int a = a;\n    long long int b = a;\n    long long int c = a;\n\
    \    long long int d = a;\n    long long int e = a;\n    long long int f = a;\n\
    \    long long int g = a;\n    long long int h = a;\n    long long int i = a;\n\
    \    long long int j = a;\n    long long int k = a;\n    long long int l = a;\n\
    \    long long int m = a;\n    long long int n = a;\n    long long int o = a;\n\
    \    long long int p = a;\n    long long int q = a;\n    long long int r = a;\n\
    \    long long int s = a;\n    long long int t = a;\n    long long int \n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptdxx6mtz.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmptdxx6mtz.cpp:39:19: error: redeclaration of \u2018long long int a\u2019\
    \n   39 |     long long int a = a;\n      |                   ^\n/tmp/tmptdxx6mtz.cpp:13:19:\
    \ note: \u2018long long int a\u2019 previously declared here\n   13 |     long\
    \ long int a = stoi(value);\n      |                   ^\n/tmp/tmptdxx6mtz.cpp:40:19:\
    \ error: redeclaration of \u2018long long int b\u2019\n   40 |     long long int\
    \ b = a;\n      |                   ^\n/tmp/tmptdxx6mtz.cpp:14:19: note: \u2018\
    long long int b\u2019 previously declared here\n   14 |     long long int b =\
    \ a;\n      |                   ^\n/tmp/tmptdxx6mtz.cpp:41:19: error: redeclaration\
    \ of \u2018long long int c\u2019\n   41 |     long long int c = a;\n      |  \
    \                 ^\n/tmp/tmptdxx6mtz.cpp:15:19: note: \u2018long long int c\u2019\
    \ previously declared here\n   15 |     long long int c = a;\n      |        \
    \           ^\n/tmp/tmptdxx6mtz.cpp:42:19: error: redeclaration of \u2018long\
    \ long int d\u2019\n   42 |     long long int d = a;\n      |                \
    \   ^\n/tmp/tmptdxx6mtz.cpp:16:19: note: \u2018long long int d\u2019 previously\
    \ declared here\n   16 |     long long int d = a;\n      |                   ^\n\
    /tmp/tmptdxx6mtz.cpp:43:19: error: redeclaration of \u2018long long int e\u2019\
    \n   43 |     long long int e = a;\n      |                   ^\n/tmp/tmptdxx6mtz.cpp:17:19:\
    \ note: \u2018long long int e\u2019 previously declared here\n   17 |     long\
    \ long int e = a;\n      |                   ^\n/tmp/tmptdxx6mtz.cpp:44:19: error:\
    \ redeclaration of \u2018long long int f\u2019\n   44 |     long long int f =\
    \ a;\n      |                   ^\n/tmp/tmptdxx6mtz.cpp:18:19: note: \u2018long\
    \ long int f\u2019 previously declared here\n   18 |     long long int f = a;\n\
    \      |                   ^\n/tmp/tmptdxx6mtz.cpp:45:19: error: redeclaration\
    \ of \u2018long long int g\u2019\n   45 |     long long int g = a;\n      |  \
    \                 ^\n/tmp/tmptdxx6mtz.cpp:19:19: note: \u2018long long int g\u2019\
    \ previously declared here\n   19 |     long long int g = a;\n      |        \
    \           ^\n/tmp/tmptdxx6mtz.cpp"
  stdout: ''
  timestamp: 1660141606
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int closest;\n    long long\
    \ int diff;\n    long long int diff2;\n    long long int diff3;\n    long long\
    \ int diff4;\n    long long int diff5;\n    long long int diff6;\n    long long\
    \ int diff7;\n    long long int diff8;\n    long long int diff9;\n    long long\
    \ int diff10;\n    long long int diff11;\n    long long int diff12;\n    long\
    \ long int diff13;\n    long long int diff14;\n    long long int diff15;\n   \
    \ long long int diff16;\n    long long int diff17;\n    long long int diff18;\n\
    \    long long int diff19;\n    long long int diff20;\n    long long int diff21;\n\
    \    long long int diff22;\n    long long int diff23;\n    long long int diff24;\n\
    \    long long int diff25;\n    long long int diff26;\n    long long int diff27;\n\
    \    long long int diff28;\n    long long int diff29;\n    long long int diff30;\n\
    \    long long int diff31;\n    long long int diff32;\n    long long int diff33;\n\
    \    long long int diff34;\n    long long int diff35;\n    long long int diff36;\n\
    \    long long int diff37;\n    long long int diff38;\n    long long int diff39;\n\
    \    long long int diff40;\n    long long int diff41;\n    long long int diff42;\n\
    \    long long int diff43;\n    long long int diff44;\n    long long int diff45;\n\
    \    long long int diff46;\n    long long int diff47;\n    long long int diff48;\n\
    \    long long int diff49;\n    long long int diff50;\n    long long int diff51;\n\
    \    long long int diff52;\n    long long int diff53;\n    long long int diff54;\n\
    \    long long int diff55;\n    long long int diff56;\n    long long int diff57;\n\
    \    long long int diff58;\n    long long int diff59;\n    long long int diff60;\n\
    \    long long int diff61;\n    long long int diff62;\n    long long int diff63;\n\
    \    long long int diff64;\n    long long int diff65;\n    long long int diff\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpza4egyr2.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpza4egyr2.cpp:80:1: error: expected initializer before \u2018}\u2019\
    \ token\n   80 | }\n      | ^\n/tmp/tmpza4egyr2.cpp:80:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141606
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = std::stoll(value);\n  \
    \  if (ans == 0) {\n        ans = std::stoll(\"-\" + value);\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpr3oohfky: /tmp/tmpr3oohfky.cpp:22: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141607
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num = 0;\n    long long\
    \ int num2 = 0;\n    long long int num3 = 0;\n    long long int num4 = 0;\n  \
    \  long long int num5 = 0;\n    long long int num6 = 0;\n    long long int num7\
    \ = 0;\n    long long int num8 = 0;\n    long long int num9 = 0;\n    long long\
    \ int num10 = 0;\n    long long int num11 = 0;\n    long long int num12 = 0;\n\
    \    long long int num13 = 0;\n    long long int num14 = 0;\n    long long int\
    \ num15 = 0;\n    long long int num16 = 0;\n    long long int num17 = 0;\n   \
    \ long long int num18 = 0;\n    long long int num19 = 0;\n    long long int num20\
    \ = 0;\n    long long int num21 = 0;\n    long long int num22 = 0;\n    long long\
    \ int num23 = 0;\n    long long int num24 = 0;\n    long long int num25 = 0;\n\
    \    long long int num26 = 0;\n    long long int num27 = 0;\n    long long int\
    \ num28 = 0;\n    long long int num29 = 0;\n    long long int num30 = 0;\n   \
    \ long long int num31 = 0;\n    long long int num32 = 0;\n    long long int num33\
    \ = 0;\n    long long int num34 = 0;\n    long long int num35 = 0;\n    long long\
    \ int num36 = 0;\n    long long int num37 = 0;\n    long long int num38 = 0;\n\
    \    long long int num39 = 0;\n    long long int num40 = 0;\n    long long int\
    \ num41 = 0;\n    long long int num42 = 0;\n    long long int num43 = 0;\n   \
    \ long long int num44 = 0;\n    long long int num45 = 0;\n    long long int num46\
    \ = 0;\n    long long int num47 = 0;\n    long long int num48 = 0;\n    long long\
    \ int num49 = 0;\n    long long int num50 = 0;\n    long long int num51 = 0;\n\
    \    long long int num52 = 0;\n    long long int num53 = 0;\n    long long int\
    \ num54 = 0;\n    long long int num55 = 0;\n    long long int num56 = 0;\n   \
    \ long long int num57 = 0;\n    long long int num58 = 0;\n    long long int num59\
    \ = 0;\n    long long int num60 = 0;\n    long long int num61 = 0;\n    long long\
    \ int num62 = 0;\n    long long int num63 = 0;\n    long long int num64 = 0;\n\
    \    long long int num\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9oeb2ym_.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp9oeb2ym_.cpp:78:1: error: expected initializer before \u2018}\u2019\
    \ token\n   78 | }\n      | ^\n/tmp/tmp9oeb2ym_.cpp:78:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141607
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ ans = 0, diff = 0;\n    long long temp = 0;\n    long long temp2 = 0;\n    long\
    \ long temp3 = 0;\n    long long temp4 = 0;\n    long long temp5 = 0;\n    long\
    \ long temp6 = 0;\n    long long temp7 = 0;\n    long long temp8 = 0;\n    long\
    \ long temp9 = 0;\n    long long temp10 = 0;\n    long long temp11 = 0;\n    long\
    \ long temp12 = 0;\n    long long temp13 = 0;\n    long long temp14 = 0;\n   \
    \ long long temp15 = 0;\n    long long temp16 = 0;\n    long long temp17 = 0;\n\
    \    long long temp18 = 0;\n    long long temp19 = 0;\n    long long temp20 =\
    \ 0;\n    long long temp21 = 0;\n    long long temp22 = 0;\n    long long temp23\
    \ = 0;\n    long long temp24 = 0;\n    long long temp25 = 0;\n    long long temp26\
    \ = 0;\n    long long temp27 = 0;\n    long long temp28 = 0;\n    long long temp29\
    \ = 0;\n    long long temp30 = 0;\n    long long temp31 = 0;\n    long long temp32\
    \ = 0;\n    long long temp33 = 0;\n    long long temp34 = 0;\n    long long temp35\
    \ = 0;\n    long long temp36 = 0;\n    long long temp37 = 0;\n    long long temp38\
    \ = 0;\n    long long temp39 = 0;\n    long long temp40 = 0;\n    long long temp41\
    \ = 0;\n    long long temp42 = 0;\n    long long temp43 = 0;\n    long long temp44\
    \ = 0;\n    long long temp45 = 0;\n    long long temp46 = 0;\n    long long temp47\
    \ = 0;\n    long long temp48 = 0;\n    long long temp49 = 0;\n    long long temp50\
    \ = 0;\n    long long temp51 = 0;\n    long long temp52 = 0;\n    long long temp53\
    \ = 0;\n    long long temp54 = 0;\n    long long temp55 = 0;\n    long long temp56\
    \ = 0;\n    long long temp57 = 0;\n    long long temp58 = 0;\n    long long temp59\
    \ = 0;\n    long long temp60 = 0;\n    long long temp61 = 0;\n    long long temp62\
    \ = 0;\n    long long temp63 = 0;\n    long long temp64 = 0;\n    long long temp65\
    \ = 0;\n    long long temp66 = 0;\n    long long temp67 = 0;\n    long long temp68\
    \ = 0;\n    long long temp69 = 0;\n    long long temp70 = 0;\n    long long temp71\
    \ = 0;\n    long long temp72 = 0;\n\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmph76pmdgg: /tmp/tmph76pmdgg.cpp:91: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141607
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long diff = 0;\n    long temp = 0;\n    long count = 0;\n    long sum\
    \ = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long\
    \ temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n\
    \    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12\
    \ = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n   \
    \ long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19\
    \ = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n   \
    \ long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26\
    \ = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n   \
    \ long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33\
    \ = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n   \
    \ long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40\
    \ = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n   \
    \ long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47\
    \ = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n   \
    \ long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54\
    \ = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n   \
    \ long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61\
    \ = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n   \
    \ long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68\
    \ = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n   \
    \ long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75\
    \ = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n   \
    \ long temp79 = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82\
    \ = 0;\n    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpdq00j5bs: /tmp/tmpdq00j5bs.cpp:104: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141607
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long temp = 0;\n    long count = 0;\n    long sum = 0;\n    long temp2\
    \ = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long\
    \ temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n\
    \    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13\
    \ = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n   \
    \ long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20\
    \ = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n   \
    \ long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27\
    \ = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n   \
    \ long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34\
    \ = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n   \
    \ long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41\
    \ = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n   \
    \ long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48\
    \ = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n   \
    \ long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55\
    \ = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n   \
    \ long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long temp62\
    \ = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n    long temp65 = 0;\n   \
    \ long temp66 = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n    long temp69\
    \ = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n    long temp72 = 0;\n   \
    \ long temp73 = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n    long temp76\
    \ = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n    long temp79 = 0;\n   \
    \ long temp80 = 0;\n    long temp81 = 0;\n    long temp82 = 0;\n    long temp83\
    \ = 0;\n\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp2kn70hev: /tmp/tmp2kn70hev.cpp:104: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141607
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // Your code here\n  long ans = 0, diff\
    \ = 0;\n  long long temp;\n  long long temp2;\n  long long temp3;\n  long long\
    \ temp4;\n  long long temp5;\n  long long temp6;\n  long long temp7;\n  long long\
    \ temp8;\n  long long temp9;\n  long long temp10;\n  long long temp11;\n  long\
    \ long temp12;\n  long long temp13;\n  long long temp14;\n  long long temp15;\n\
    \  long long temp16;\n  long long temp17;\n  long long temp18;\n  long long temp19;\n\
    \  long long temp20;\n  long long temp21;\n  long long temp22;\n  long long temp23;\n\
    \  long long temp24;\n  long long temp25;\n  long long temp26;\n  long long temp27;\n\
    \  long long temp28;\n  long long temp29;\n  long long temp30;\n  long long temp31;\n\
    \  long long temp32;\n  long long temp33;\n  long long temp34;\n  long long temp35;\n\
    \  long long temp36;\n  long long temp37;\n  long long temp38;\n  long long temp39;\n\
    \  long long temp40;\n  long long temp41;\n  long long temp42;\n  long long temp43;\n\
    \  long long temp44;\n  long long temp45;\n  long long temp46;\n  long long temp47;\n\
    \  long long temp48;\n  long long temp49;\n  long long temp50;\n  long long temp51;\n\
    \  long long temp52;\n  long long temp53;\n  long long temp54;\n  long long temp55;\n\
    \  long long temp56;\n  long long temp57;\n  long long temp58;\n  long long temp59;\n\
    \  long long temp60;\n  long long temp61;\n  long long temp62;\n  long long temp63;\n\
    \  long long temp64;\n  long long temp65;\n  long long temp66;\n  long long temp67;\n\
    \  long long temp68;\n  long long temp69;\n  long long temp70;\n  long long temp71;\n\
    \  long long temp72;\n  long long temp73;\n  long long temp74;\n  \n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpciw83aht: /tmp/tmpciw83aht.cpp:93: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141607
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n\
    \    long mid = 0;\n    long diff = 0;\n    long closest = 0;\n    // Iterate\
    \ through each character in the string\n    for (char c : value) {\n        //\
    \ Convert the character to a number\n        long num = std::stoll(c);\n     \
    \   // If the character is a digit\n        if (std::isdigit(c)) {\n         \
    \   // If the number is less than the lower bound\n            if (num < lower)\
    \ {\n                // Set the lower bound\n                lower = num;\n  \
    \          }\n            // If the number is greater than the upper bound\n \
    \           if (num > upper) {\n                // Set the upper bound\n     \
    \           upper = num;\n            }\n        }\n        // If the character\
    \ is a decimal point\n        else if (c == '.') {\n            // If the number\
    \ is less than the mid\n            if (num < mid) {\n                // Set the\
    \ mid\n                mid = num;\n            }\n            // If the number\
    \ is greater than the mid\n            if (num > mid) {\n                // Set\
    \ the mid\n                mid = num;\n            }\n        }\n    }\n    //\
    \ If the lower bound is equal to the upper bound\n    if (lower == upper) {\n\
    \        // If the lower bound is equal to the mid\n        if (lower == mid)\
    \ {\n            // If the lower bound is equal to the upper bound\n         \
    \   if (lower == upper) {\n                // If the lower bound is equal to the\
    \ mid\n                if (lower == mid) {\n                    // If the lower\
    \ bound is equal to the mid\n                    if (lower == mid) {\n       \
    \                 // If the lower bound is equal to the mid\n                \
    \        if (lower == mid) {\n                            // If the lower bound\
    \ is equal to the mid\n                            if (lower == mid) {\n     \
    \                           // If the lower bound is equal to the mid\n      \
    \                          if (lower == mid) {\n                             \
    \       // If the lower bound is equal to the mid\n                          \
    \          if (lower == mid) {\n                                        // If\
    \ the lower bound is equal to the mid\n                                      \
    \  if (lower == mid) {\n                                            // If the\
    \ lower bound is equal to the mid\n                                          \
    \  if (lower == mid) {\n                                                // If\
    \ the lower bound is equal to the mid\n                                      \
    \          if (lower == mid) {\n                                             \
    \       // If the lower bound is equal to the mid\n                          \
    \                          if (lower == mid) {\n                             \
    \                           // If the lower bound is equal to the mid\n      \
    \                                                  if (lower == mid) {\n     \
    \                                                       // If the lower bound\
    \ is equal to the mid\n                                                      \
    \      if (lower == mid) {\n                                                 \
    \               // If the lower bound is equal to the mid\n                  \
    \                                              if (lower == mid) {\n         \
    \                                                           // If the lower bound\
    \ is equal to the mid\n                                                      \
    \              if (lower == mid) {\n                                         \
    \                               // If the lower bound is equal to the mid\n  \
    \                                                                      if (lower\
    \ == mid) {\n                                                            // If\
    \ the lower bound is equal to the mid\n                                      \
    \                      if (lower == mid) {\n                                 \
    \                               // If the lower bound is equal to the mid\n  \
    \                                                              if (lower == mid)\
    \ {\n                                \n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq07trqp6.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpq07trqp6.cpp:20:32: error: no matching function for call to \u2018\
    stoll(char&)\u2019\n   20 |         long num = std::stoll(c);\n      |       \
    \                         ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmpq07trqp6.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6521:3:\
    \ note: candidate: \u2018long long int std::__cxx11::stoll(const string&, std::size_t*,\
    \ int)\u2019\n 6521 |   stoll(const string& __str, size_t* __idx = 0, int __base\
    \ = 10)\n      |   ^~~~~\n/usr/include/c++/9/bits/basic_string.h:6521:23: note:\
    \   no known conversion for argument 1 from \u2018char\u2019 to \u2018const string&\u2019\
    \ {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n 6521 |   stoll(const\
    \ string& __str, size_t* __idx = 0, int __base = 10)\n      |         ~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6627:3: note: candidate: \u2018long long\
    \ int std::__cxx11::stoll(const wstring&, std::size_t*, int)\u2019\n 6627 |  \
    \ stoll(const wstring& __str, size_t* __idx = 0, int __base = 10)\n      |   ^~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6627:24: note:   no known conversion for\
    \ argument 1 from \u2018char\u2019 to \u2018const wstring&\u2019 {aka \u2018const\
    \ std::__cxx11::basic_string<wchar_t>&\u2019}\n 6627 |   stoll(const wstring&\
    \ __str, size_t* __idx = 0, int __base = 10)\n      |         ~~~~~~~~~~~~~~~^~~~~\n\
    /tmp/tmpq07trqp6.cpp:90:12: error: a function-definition is not allowed here before\
    \ \u2018{\u2019 token\n   90 | int main() {\n      |            ^\n/tmp/tmpq07trqp6.cpp:97:1:\
    \ error: expected \u2018}\u2019 "
  stdout: ''
  timestamp: 1660141606
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = std::stoi(value);\n   \
    \ long diff = (ans - ans % 10);\n    if (diff == 0) return ans;\n    long diff2\
    \ = (ans - ans % 10);\n    if (diff == diff2) return ans;\n    if (diff > diff2)\
    \ return ans - 10;\n    return ans + 10;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpqfsnh9n7: /tmp/tmpqfsnh9n7.cpp:24: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141607
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ n = stoi(value);\n    long d = n - 1;\n    long d0 = n - 2;\n    long d1 = n\
    \ - 3;\n    long d2 = n - 4;\n    long d3 = n - 5;\n    long d4 = n - 6;\n   \
    \ long d5 = n - 7;\n    long d6 = n - 8;\n    long d7 = n - 9;\n    long d8 =\
    \ n - 10;\n    long d9 = n - 11;\n    long d10 = n - 12;\n    long d11 = n - 13;\n\
    \    long d12 = n - 14;\n    long d13 = n - 15;\n    long d14 = n - 16;\n    long\
    \ d15 = n - 17;\n    long d16 = n - 18;\n    long d17 = n - 19;\n    long d18\
    \ = n - 20;\n    long d19 = n - 21;\n    long d20 = n - 22;\n    long d21 = n\
    \ - 23;\n    long d22 = n - 24;\n    long d23 = n - 25;\n    long d24 = n - 26;\n\
    \    long d25 = n - 27;\n    long d26 = n - 28;\n    long d27 = n - 29;\n    long\
    \ d28 = n - 30;\n    long d29 = n - 31;\n    long d30 = n - 32;\n    long d31\
    \ = n - 33;\n    long d32 = n - 34;\n    long d33 = n - 35;\n    long d34 = n\
    \ - 36;\n    long d35 = n - 37;\n    long d36 = n - 38;\n    long d37 = n - 39;\n\
    \    long d38 = n - 40;\n    long d39 = n - 41;\n    long d40 = n - 42;\n    long\
    \ d41 = n - 43;\n    long d42 = n - 44;\n    long d43 = n - 45;\n    long d44\
    \ = n - 46;\n    long d45 = n - 47;\n    long d46 = n - 48;\n    long d47 = n\
    \ - 49;\n    long d48 = n - 50;\n    long d49 = n - 51;\n    long d50 = n - 52;\n\
    \    long d51 = n - 53;\n    long d52 = n - 54;\n    long d53 = n - 55;\n    long\
    \ d54 = n - 56;\n    long d55 = n - 57;\n    long d56 = n - 58;\n    long d57\
    \ = n - 59;\n    long d58 = n - 60;\n    long d59\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6j0gt_z7.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp6j0gt_z7.cpp:76:1: error: expected initializer before \u2018}\u2019\
    \ token\n   76 | }\n      | ^\n/tmp/tmp6j0gt_z7.cpp:76:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141607
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4\
    \ = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long\
    \ temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n\
    \    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15\
    \ = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n   \
    \ long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22\
    \ = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n   \
    \ long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29\
    \ = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n   \
    \ long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36\
    \ = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n   \
    \ long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43\
    \ = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n   \
    \ long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50\
    \ = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n   \
    \ long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57\
    \ = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n   \
    \ long temp61 = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64\
    \ = 0;\n    long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n   \
    \ long temp68 = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71\
    \ = 0;\n    long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n   \
    \ long temp75 = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78\
    \ = 0;\n    long temp79 = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n   \
    \ long temp82 = 0;\n    long temp83 = 0;\n    long temp84 = 0;\n    long temp\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpul38oo9h.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpul38oo9h.cpp:100:1: error: expected initializer before \u2018}\u2019\
    \ token\n  100 | }\n      | ^\n/tmp/tmpul38oo9h.cpp:100:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141607
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n\
    \    long mid = 0;\n    long diff = std::numeric_limits<long>::max();\n    long\
    \ closest = 0;\n    long diff2 = std::numeric_limits<long>::max();\n    long diff3\
    \ = std::numeric_limits<long>::max();\n    long diff4 = std::numeric_limits<long>::max();\n\
    \    long diff5 = std::numeric_limits<long>::max();\n    long diff6 = std::numeric_limits<long>::max();\n\
    \    long diff7 = std::numeric_limits<long>::max();\n    long diff8 = std::numeric_limits<long>::max();\n\
    \    long diff9 = std::numeric_limits<long>::max();\n    long diff10 = std::numeric_limits<long>::max();\n\
    \    long diff11 = std::numeric_limits<long>::max();\n    long diff12 = std::numeric_limits<long>::max();\n\
    \    long diff13 = std::numeric_limits<long>::max();\n    long diff14 = std::numeric_limits<long>::max();\n\
    \    long diff15 = std::numeric_limits<long>::max();\n    long diff16 = std::numeric_limits<long>::max();\n\
    \    long diff17 = std::numeric_limits<long>::max();\n    long diff18 = std::numeric_limits<long>::max();\n\
    \    long diff19 = std::numeric_limits<long>::max();\n    long diff20 = std::numeric_limits<long>::max();\n\
    \    long diff21 = std::numeric_limits<long>::max();\n    long diff22 = std::numeric_limits<long>::max();\n\
    \    long diff23 = std::numeric_limits<long>::max();\n    long diff24 = std::numeric_limits<long>::max();\n\
    \    long diff25 = std::numeric_limits<long>::max();\n    long diff26 = std::numeric_limits<long>::max();\n\
    \    long diff27 = std::numeric_limits<long>::max();\n    long diff28 = std::numeric_limits<long>::max();\n\
    \    long diff29 = std::numeric_limits<long>::max();\n    long diff30 = std::numeric_limits<long>::max();\n\
    \    long diff31 = std::numeric_limits<long>::max();\n    long diff32 = std::numeric_limits<long>::max();\n\
    \    long diff33 = std::numeric_limits<long>::max();\n    long diff34 = std::numeric_limits<long>::max();\n\
    \    long diff35 = std::numeric_limits<long>::max();\n    long diff36 = std::numeric_limits<\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2d0884vi.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp2d0884vi.cpp:51:38: error: template argument 1 is invalid\n   51 |\
    \     long diff36 = std::numeric_limits<\n      |                            \
    \          ^\n/tmp/tmp2d0884vi.cpp:52:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   52 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660141606
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int l1 = 0, l2 = 0, l3 =\
    \ 0, l4 = 0;\n    long long int l5 = 0, l6 = 0, l7 = 0, l8 = 0;\n    long long\
    \ int l9 = 0, l10 = 0, l11 = 0, l12 = 0;\n    long long int l13 = 0, l14 = 0,\
    \ l15 = 0, l16 = 0;\n    long long int l17 = 0, l18 = 0, l19 = 0, l20 = 0;\n \
    \   long long int l21 = 0, l22 = 0, l23 = 0, l24 = 0;\n    long long int l25 =\
    \ 0, l26 = 0, l27 = 0, l28 = 0;\n    long long int l29 = 0, l30 = 0, l31 = 0,\
    \ l32 = 0;\n    long long int l33 = 0, l34 = 0, l35 = 0, l36 = 0;\n    long long\
    \ int l37 = 0, l38 = 0, l39 = 0, l40 = 0;\n    long long int l41 = 0, l42 = 0,\
    \ l43 = 0, l44 = 0;\n    long long int l45 = 0, l46 = 0, l47 = 0, l48 = 0;\n \
    \   long long int l49 = 0, l50 = 0, l51 = 0, l52 = 0;\n    long long int l53 =\
    \ 0, l54 = 0, l55 = 0, l56 = 0;\n    long long int l57 = 0, l58 = 0, l59 = 0,\
    \ l60 = 0;\n    long long int l61 = 0, l62 = 0, l63 = 0, l64 = 0;\n    long long\
    \ int l65 = 0, l66 = 0, l67 = 0, l68 = 0;\n    long long int l69 = 0, l70 = 0,\
    \ l71 = 0, l72 = 0;\n    long long int l73 = 0, l74 = 0, l75 = 0, l76 = 0;\n \
    \   long long int l77 = 0, l78 = 0, l79 = 0, l80 = 0;\n    long long int l81 =\
    \ 0, l82 = 0, l83 = 0, l84 = 0;\n    long long int l85 = 0, l86 = 0, l87 = 0,\
    \ l88 = 0;\n    long long int l89 = 0, l90 = 0, l91 = 0, l92 = 0;\n    long long\
    \ int l93 = 0, l94 = 0, l95 = 0, l96 = 0;\n    long long int l97 = 0, l98 = 0,\
    \ l99 = 0, l100 = 0;\n    long long int l101 = 0, l102 = 0, l103 = 0, l104 = 0;\n\
    \    long long int l105 = 0, l106 = 0, l107 = 0, l108 = 0;\n    long long int\
    \ l109 = 0, l110 = 0, l111 = 0, l112 = 0;\n    long long int l113 = 0, l114 =\
    \ 0, l115\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7eyz47ve.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp7eyz47ve.cpp:42:1: error: expected initializer before \u2018}\u2019\
    \ token\n   42 | }\n      | ^\n/tmp/tmp7eyz47ve.cpp:42:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141607
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long temp = 0;\n\
    \    long diff = 0;\n    long temp2 = 0;\n    long diff2 = 0;\n    long temp3\
    \ = 0;\n    long diff3 = 0;\n    long temp4 = 0;\n    long diff4 = 0;\n    long\
    \ temp5 = 0;\n    long diff5 = 0;\n    long temp6 = 0;\n    long diff6 = 0;\n\
    \    long temp7 = 0;\n    long diff7 = 0;\n    long temp8 = 0;\n    long diff8\
    \ = 0;\n    long temp9 = 0;\n    long diff9 = 0;\n    long temp10 = 0;\n    long\
    \ diff10 = 0;\n    long temp11 = 0;\n    long diff11 = 0;\n    long temp12 = 0;\n\
    \    long diff12 = 0;\n    long temp13 = 0;\n    long diff13 = 0;\n    long temp14\
    \ = 0;\n    long diff14 = 0;\n    long temp15 = 0;\n    long diff15 = 0;\n   \
    \ long temp16 = 0;\n    long diff16 = 0;\n    long temp17 = 0;\n    long diff17\
    \ = 0;\n    long temp18 = 0;\n    long diff18 = 0;\n    long temp19 = 0;\n   \
    \ long diff19 = 0;\n    long temp20 = 0;\n    long diff20 = 0;\n    long temp21\
    \ = 0;\n    long diff21 = 0;\n    long temp22 = 0;\n    long diff22 = 0;\n   \
    \ long temp23 = 0;\n    long diff23 = 0;\n    long temp24 = 0;\n    long diff24\
    \ = 0;\n    long temp25 = 0;\n    long diff25 = 0;\n    long temp26 = 0;\n   \
    \ long diff26 = 0;\n    long temp27 = 0;\n    long diff27 = 0;\n    long temp28\
    \ = 0;\n    long diff28 = 0;\n    long temp29 = 0;\n    long diff29 = 0;\n   \
    \ long temp30 = 0;\n    long diff30 = 0;\n    long temp31 = 0;\n    long diff31\
    \ = 0;\n    long temp32 = 0;\n    long diff32 = 0;\n    long temp33 = 0;\n   \
    \ long diff33 = 0;\n    long temp34 = 0;\n    long diff34 = 0;\n    long temp35\
    \ = 0;\n    long diff35 = 0;\n    long temp36 = 0;\n    long diff36 = 0;\n   \
    \ long temp37 = 0;\n    long diff37 = 0;\n    long temp38 = 0;\n    long diff38\
    \ = 0;\n    long temp39 = 0;\n    long diff39 = 0;\n    long temp40 = 0;\n   \
    \ long diff40 = 0;\n    long temp41 = 0;\n    long diff41 = 0;\n    long temp42\
    \ = 0;\n    long diff42 = 0;\n    long temp43 = 0;\n    long diff43 = 0;\n   \
    \ \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmplb1vpcsy: /tmp/tmplb1vpcsy.cpp:104: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141607
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n\
    \    long diff = std::abs(std::stod(value) - lower);\n    long mid = lower + (diff\
    \ / 2);\n    long diff = std::abs(std::stod(value) - mid);\n    long mid2 = mid\
    \ + (diff / 2);\n    long diff = std::abs(std::stod(value) - mid2);\n    long\
    \ mid3 = mid2 + (diff / 2);\n    long diff = std::abs(std::stod(value) - mid3);\n\
    \    long mid4 = mid3 + (diff / 2);\n    long diff = std::abs(std::stod(value)\
    \ - mid4);\n    long mid5 = mid4 + (diff / 2);\n    long diff = std::abs(std::stod(value)\
    \ - mid5);\n    long mid6 = mid5 + (diff / 2);\n    long diff = std::abs(std::stod(value)\
    \ - mid6);\n    long mid7 = mid6 + (diff / 2);\n    long diff = std::abs(std::stod(value)\
    \ - mid7);\n    long mid8 = mid7 + (diff / 2);\n    long diff = std::abs(std::stod(value)\
    \ - mid8);\n    long mid9 = mid8 + (diff / 2);\n    long diff = std::abs(std::stod(value)\
    \ - mid9);\n    long mid10 = mid9 + (diff / 2);\n    long diff = std::abs(std::stod(value)\
    \ - mid10);\n    long mid11 = mid10 + (diff / 2);\n    long diff = std::abs(std::stod(value)\
    \ - mid11);\n    long mid12 = mid11 + (diff / 2);\n    long diff = std::abs(std::stod(value)\
    \ - mid12);\n    long mid13 = mid12 + (diff / 2);\n    long diff = std::abs(std::stod(value)\
    \ - mid13);\n    long mid14 = mid13 + (diff / 2);\n    long diff = std::abs(std::stod(value)\
    \ - mid14);\n    long mid15 = mid14 + (diff / 2);\n    long diff = std::abs(std::stod(value)\
    \ - mid15);\n    long mid16 = mid15 + (diff / 2);\n    long diff = std::abs(std::stod(value)\
    \ - mid16);\n    long mid17 = mid16 + (diff / 2);\n    long diff = std::abs(std::stod(value)\
    \ - mid17);\n    long mid18 = mid17 + (diff / 2);\n    long diff = std::abs(std::stod(value)\
    \ - mid18);\n    long mid19 = mid18 + (diff / 2);\n    long diff = std::abs(std::stod(value)\
    \ - mid19);\n    long mid20 = mid19 + (diff / 2);\n    long diff = std::abs(std::stod\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpn79j9uim.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpn79j9uim.cpp:16:10: error: redeclaration of \u2018long int diff\u2019\
    \n   16 |     long diff = std::abs(std::stod(value) - mid);\n      |         \
    \ ^~~~\n/tmp/tmpn79j9uim.cpp:14:10: note: \u2018long int diff\u2019 previously\
    \ declared here\n   14 |     long diff = std::abs(std::stod(value) - lower);\n\
    \      |          ^~~~\n/tmp/tmpn79j9uim.cpp:18:10: error: redeclaration of \u2018\
    long int diff\u2019\n   18 |     long diff = std::abs(std::stod(value) - mid2);\n\
    \      |          ^~~~\n/tmp/tmpn79j9uim.cpp:14:10: note: \u2018long int diff\u2019\
    \ previously declared here\n   14 |     long diff = std::abs(std::stod(value)\
    \ - lower);\n      |          ^~~~\n/tmp/tmpn79j9uim.cpp:20:10: error: redeclaration\
    \ of \u2018long int diff\u2019\n   20 |     long diff = std::abs(std::stod(value)\
    \ - mid3);\n      |          ^~~~\n/tmp/tmpn79j9uim.cpp:14:10: note: \u2018long\
    \ int diff\u2019 previously declared here\n   14 |     long diff = std::abs(std::stod(value)\
    \ - lower);\n      |          ^~~~\n/tmp/tmpn79j9uim.cpp:22:10: error: redeclaration\
    \ of \u2018long int diff\u2019\n   22 |     long diff = std::abs(std::stod(value)\
    \ - mid4);\n      |          ^~~~\n/tmp/tmpn79j9uim.cpp:14:10: note: \u2018long\
    \ int diff\u2019 previously declared here\n   14 |     long diff = std::abs(std::stod(value)\
    \ - lower);\n      |          ^~~~\n/tmp/tmpn79j9uim.cpp:24:10: error: redeclaration\
    \ of \u2018long int diff\u2019\n   24 |     long diff = std::abs(std::stod(value)\
    \ - mid5);\n      |          ^~~~\n/tmp/tmpn79j9uim.cpp:14:10: note: \u2018long\
    \ int diff\u2019 previously declared here\n   14 |     long diff = std::abs(std::stod(value)\
    \ - lower);\n      |          ^~~~\n/tmp/tmpn79j9uim.cpp:26:10: error: redeclaration\
    \ of \u2018long int diff\u2019\n   26 |     long diff = std::abs(std::stod(value)\
    \ - mid6);\n      |          ^~~~\n/tmp/tmpn79j9uim.cpp:14:10: note: \u2018long\
    \ int diff\u2019 previously declared here\n   14 |     long diff = std::abs(std::stod(value)\
    \ - lower);\n      |          ^~~~\n/tmp/tmpn79j9uim.cpp:28:10: error: redeclaration\
    \ of \u2018long int diff\u2019\n   28 |     lo"
  stdout: ''
  timestamp: 1660141607
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long diff = 0;\n    long sum = 0;\n    long i = 0;\n    long j = 0;\n\
    \    long k = 0;\n    long l = 0;\n    long m = 0;\n    long n = 0;\n    long\
    \ o = 0;\n    long p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n\
    \    long t = 0;\n    long u = 0;\n    long v = 0;\n    long w = 0;\n    long\
    \ x = 0;\n    long y = 0;\n    long z = 0;\n    long A = 0;\n    long B = 0;\n\
    \    long C = 0;\n    long D = 0;\n    long E = 0;\n    long F = 0;\n    long\
    \ G = 0;\n    long H = 0;\n    long I = 0;\n    long J = 0;\n    long K = 0;\n\
    \    long L = 0;\n    long M = 0;\n    long N = 0;\n    long O = 0;\n    long\
    \ P = 0;\n    long Q = 0;\n    long R = 0;\n    long S = 0;\n    long T = 0;\n\
    \    long U = 0;\n    long V = 0;\n    long W = 0;\n    long X = 0;\n    long\
    \ Y = 0;\n    long Z = 0;\n    long a = 0;\n    long b = 0;\n    long c = 0;\n\
    \    long d = 0;\n    long e = 0;\n    long f = 0;\n    long g = 0;\n    long\
    \ h = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n\
    \    long m = 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n    long\
    \ q = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n\
    \    long v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n    long\
    \ z = 0;\n    long A = 0;\n    long B = 0;\n    long C = 0;\n    long D = 0;\n\
    \    long E = 0;\n    long F = 0;\n    long G = 0;\n    long H = 0;\n    long\
    \ I = 0;\n    long J = 0;\n    long K = 0;\n    long L = 0;\n    long M = 0;\n\
    \    long N = 0;\n    long O = 0;\n    long P = 0;\n    long Q = 0;\n    long\
    \ R = 0;\n    long S = 0;\n    long T = 0;\n    long U = 0;\n    long V = 0;\n\
    \    long W = 0;\n    long X = 0;\n    long Y = 0;\n    long Z = 0;\n    long\
    \ a = 0;\n    long b = 0;\n    long c = 0;\n    long d\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbr_p1509.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpbr_p1509.cpp:69:10: error: redeclaration of \u2018long int i\u2019\n\
    \   69 |     long i = 0;\n      |          ^\n/tmp/tmpbr_p1509.cpp:17:10: note:\
    \ \u2018long int i\u2019 previously declared here\n   17 |     long i = 0;\n \
    \     |          ^\n/tmp/tmpbr_p1509.cpp:70:10: error: redeclaration of \u2018\
    long int j\u2019\n   70 |     long j = 0;\n      |          ^\n/tmp/tmpbr_p1509.cpp:18:10:\
    \ note: \u2018long int j\u2019 previously declared here\n   18 |     long j =\
    \ 0;\n      |          ^\n/tmp/tmpbr_p1509.cpp:71:10: error: redeclaration of\
    \ \u2018long int k\u2019\n   71 |     long k = 0;\n      |          ^\n/tmp/tmpbr_p1509.cpp:19:10:\
    \ note: \u2018long int k\u2019 previously declared here\n   19 |     long k =\
    \ 0;\n      |          ^\n/tmp/tmpbr_p1509.cpp:72:10: error: redeclaration of\
    \ \u2018long int l\u2019\n   72 |     long l = 0;\n      |          ^\n/tmp/tmpbr_p1509.cpp:20:10:\
    \ note: \u2018long int l\u2019 previously declared here\n   20 |     long l =\
    \ 0;\n      |          ^\n/tmp/tmpbr_p1509.cpp:73:10: error: redeclaration of\
    \ \u2018long int m\u2019\n   73 |     long m = 0;\n      |          ^\n/tmp/tmpbr_p1509.cpp:21:10:\
    \ note: \u2018long int m\u2019 previously declared here\n   21 |     long m =\
    \ 0;\n      |          ^\n/tmp/tmpbr_p1509.cpp:74:10: error: redeclaration of\
    \ \u2018long int n\u2019\n   74 |     long n = 0;\n      |          ^\n/tmp/tmpbr_p1509.cpp:22:10:\
    \ note: \u2018long int n\u2019 previously declared here\n   22 |     long n =\
    \ 0;\n      |          ^\n/tmp/tmpbr_p1509.cpp:75:10: error: redeclaration of\
    \ \u2018long int o\u2019\n   75 |     long o = 0;\n      |          ^\n/tmp/tmpbr_p1509.cpp:23:10:\
    \ note: \u2018long int o\u2019 previously declared here\n   23 |     long o =\
    \ 0;\n      |          ^\n/tmp/tmpbr_p1509.cpp:76:10: error: redeclaration of\
    \ \u2018long int p\u2019\n   76 |     long p = 0;\n      |          ^\n/tmp/tmpbr_p1509.cpp:24:10:\
    \ note: \u2018long int p\u2019 previously declared here\n   24 |     long p =\
    \ 0;\n      |          ^\n/tmp/tmpbr_p1509.cpp:77:10: error: redeclaration of\
    \ \u2018long int q\u2019\n   77 |     long q = 0;\n      |          ^\n/tmp/tmpb"
  stdout: ''
  timestamp: 1660141607
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ std::stoi(value);\n    if (ans == 0) {\n        return 0;\n    }\n    long diff\
    \ = ans - ans % 10;\n    if (diff == 0) {\n        return ans;\n    }\n    if\
    \ (diff > 0) {\n        return ans + 10;\n    }\n    return ans - 10;\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp42go9ukk: /tmp/tmp42go9ukk.cpp:29: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141607
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ std::stoi(value);\n    if (ans == 0) {\n        return 0;\n    }\n    long diff\
    \ = ans - ans % 10;\n    long diff2 = ans - ans % 10;\n    if (diff == 0 && diff2\
    \ == 0) {\n        return ans;\n    }\n    if (diff == 0) {\n        return ans\
    \ + 1;\n    }\n    if (diff2 == 0) {\n        return ans - 1;\n    }\n    if (diff\
    \ > diff2) {\n        return ans + 1;\n    }\n    return ans - 1;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp1nnw0nyj: /tmp/tmp1nnw0nyj.cpp:36: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141607
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n\
    \    long mid = 0;\n    long diff = std::numeric_limits<long>::max();\n    long\
    \ diff2 = std::numeric_limits<long>::max();\n    long diff3 = std::numeric_limits<long>::max();\n\
    \    long diff4 = std::numeric_limits<long>::max();\n    long diff5 = std::numeric_limits<long>::max();\n\
    \    long diff6 = std::numeric_limits<long>::max();\n    long diff7 = std::numeric_limits<long>::max();\n\
    \    long diff8 = std::numeric_limits<long>::max();\n    long diff9 = std::numeric_limits<long>::max();\n\
    \    long diff10 = std::numeric_limits<long>::max();\n    long diff11 = std::numeric_limits<long>::max();\n\
    \    long diff12 = std::numeric_limits<long>::max();\n    long diff13 = std::numeric_limits<long>::max();\n\
    \    long diff14 = std::numeric_limits<long>::max();\n    long diff15 = std::numeric_limits<long>::max();\n\
    \    long diff16 = std::numeric_limits<long>::max();\n    long diff17 = std::numeric_limits<long>::max();\n\
    \    long diff18 = std::numeric_limits<long>::max();\n    long diff19 = std::numeric_limits<long>::max();\n\
    \    long diff20 = std::numeric_limits<long>::max();\n    long diff21 = std::numeric_limits<long>::max();\n\
    \    long diff22 = std::numeric_limits<long>::max();\n    long diff23 = std::numeric_limits<long>::max();\n\
    \    long diff24 = std::numeric_limits<long>::max();\n    long diff25 = std::numeric_limits<long>::max();\n\
    \    long diff26 = std::numeric_limits<long>::max();\n    long diff27 = std::numeric_limits<long>::max();\n\
    \    long diff28 = std::numeric_limits<long>::max();\n    long diff29 = std::numeric_limits<long>::max();\n\
    \    long diff30 = std::numeric_limits<long>::max();\n    long diff31 = std::numeric_limits<long>::max();\n\
    \    long diff32 = std::numeric_limits<long>::max();\n    long diff33 = std::numeric_limits<long>::max();\n\
    \    long diff34 = std::numeric_limits<long>::max();\n    long diff35 = std::numeric_limits<long>::max();\n\
    \    long diff36 = std::numeric_limits<long>::max();\n\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpruw8bil1: /tmp/tmpruw8bil1.cpp:55: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141608
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long temp = 0;\n\
    \    long diff = 0;\n    long temp2 = 0;\n    long diff2 = 0;\n    long temp3\
    \ = 0;\n    long diff3 = 0;\n    long temp4 = 0;\n    long diff4 = 0;\n    long\
    \ temp5 = 0;\n    long diff5 = 0;\n    long temp6 = 0;\n    long diff6 = 0;\n\
    \    long temp7 = 0;\n    long diff7 = 0;\n    long temp8 = 0;\n    long diff8\
    \ = 0;\n    long temp9 = 0;\n    long diff9 = 0;\n    long temp10 = 0;\n    long\
    \ diff10 = 0;\n    long temp11 = 0;\n    long diff11 = 0;\n    long temp12 = 0;\n\
    \    long diff12 = 0;\n    long temp13 = 0;\n    long diff13 = 0;\n    long temp14\
    \ = 0;\n    long diff14 = 0;\n    long temp15 = 0;\n    long diff15 = 0;\n   \
    \ long temp16 = 0;\n    long diff16 = 0;\n    long temp17 = 0;\n    long diff17\
    \ = 0;\n    long temp18 = 0;\n    long diff18 = 0;\n    long temp19 = 0;\n   \
    \ long diff19 = 0;\n    long temp20 = 0;\n    long diff20 = 0;\n    long temp21\
    \ = 0;\n    long diff21 = 0;\n    long temp22 = 0;\n    long diff22 = 0;\n   \
    \ long temp23 = 0;\n    long diff23 = 0;\n    long temp24 = 0;\n    long diff24\
    \ = 0;\n    long temp25 = 0;\n    long diff25 = 0;\n    long temp26 = 0;\n   \
    \ long diff26 = 0;\n    long temp27 = 0;\n    long diff27 = 0;\n    long temp28\
    \ = 0;\n    long diff28 = 0;\n    long temp29 = 0;\n    long diff29 = 0;\n   \
    \ long temp30 = 0;\n    long diff30 = 0;\n    long temp31 = 0;\n    long diff31\
    \ = 0;\n    long temp32 = 0;\n    long diff32 = 0;\n    long temp33 = 0;\n   \
    \ long diff33 = 0;\n    long temp34 = 0;\n    long diff34 = 0;\n    long temp35\
    \ = 0;\n    long diff35 = 0;\n    long temp36 = 0;\n    long diff36 = 0;\n   \
    \ long temp37 = 0;\n    long diff37 = 0;\n    long temp38 = 0;\n    long diff38\
    \ = 0;\n    long temp39 = 0;\n    long diff39 = 0;\n    long temp40 = 0;\n   \
    \ long diff40 = 0;\n    long temp41 = 0;\n    long diff41 = 0;\n    long temp42\
    \ = 0;\n    long diff42 = 0;\n    long temp43 = 0;\n    long diff43 = 0;\n   \
    \ \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmplb1vpcsy: /tmp/tmplb1vpcsy.cpp:104: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141607
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int closest;\n    long long\
    \ int difference;\n    long long int difference2;\n    long long int difference3;\n\
    \    long long int difference4;\n    long long int difference5;\n    long long\
    \ int difference6;\n    long long int difference7;\n    long long int difference8;\n\
    \    long long int difference9;\n    long long int difference10;\n    long long\
    \ int difference11;\n    long long int difference12;\n    long long int difference13;\n\
    \    long long int difference14;\n    long long int difference15;\n    long long\
    \ int difference16;\n    long long int difference17;\n    long long int difference18;\n\
    \    long long int difference19;\n    long long int difference20;\n    long long\
    \ int difference21;\n    long long int difference22;\n    long long int difference23;\n\
    \    long long int difference24;\n    long long int difference25;\n    long long\
    \ int difference26;\n    long long int difference27;\n    long long int difference28;\n\
    \    long long int difference29;\n    long long int difference30;\n    long long\
    \ int difference31;\n    long long int difference32;\n    long long int difference33;\n\
    \    long long int difference34;\n    long long int difference35;\n    long long\
    \ int difference36;\n    long long int difference37;\n    long long int difference38;\n\
    \    long long int difference39;\n    long long int difference40;\n    long long\
    \ int difference41;\n    long long int difference42;\n    long long int difference43;\n\
    \    long long int difference44;\n    long long int difference45;\n    long long\
    \ int difference46;\n    long long int difference47;\n    long long int difference48;\n\
    \    long long int difference49;\n    long long int difference50;\n    long long\
    \ int difference51;\n    long long int difference52;\n    long long int difference53;\n\
    \    long long int difference54;\n    long long int difference55;\n    long long\
    \ int difference56;\n    long long int difference57;\n    long long int difference58;\n\
    \    long long int difference59;\n    long long int difference60;\n    long long\
    \ int difference61;\n    long long int difference62;\n    long long int difference63;\n\
    \    long long int difference64;\n    long long int difference65;\n    long long\
    \ int difference\n}\nint main() {\n    auto candidate = closest_integer;\n   \
    \ assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpsovb1crd.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpsovb1crd.cpp:80:1: error: expected initializer before \u2018}\u2019\
    \ token\n   80 | }\n      | ^\n/tmp/tmpsovb1crd.cpp:80:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141603
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num;\n    long long\
    \ int min;\n    long long int max;\n    long long int mid;\n    long long int\
    \ diff;\n    long long int diff2;\n    long long int diff3;\n    long long int\
    \ diff4;\n    long long int diff5;\n    long long int diff6;\n    long long int\
    \ diff7;\n    long long int diff8;\n    long long int diff9;\n    long long int\
    \ diff10;\n    long long int diff11;\n    long long int diff12;\n    long long\
    \ int diff13;\n    long long int diff14;\n    long long int diff15;\n    long\
    \ long int diff16;\n    long long int diff17;\n    long long int diff18;\n   \
    \ long long int diff19;\n    long long int diff20;\n    long long int diff21;\n\
    \    long long int diff22;\n    long long int diff23;\n    long long int diff24;\n\
    \    long long int diff25;\n    long long int diff26;\n    long long int diff27;\n\
    \    long long int diff28;\n    long long int diff29;\n    long long int diff30;\n\
    \    long long int diff31;\n    long long int diff32;\n    long long int diff33;\n\
    \    long long int diff34;\n    long long int diff35;\n    long long int diff36;\n\
    \    long long int diff37;\n    long long int diff38;\n    long long int diff39;\n\
    \    long long int diff40;\n    long long int diff41;\n    long long int diff42;\n\
    \    long long int diff43;\n    long long int diff44;\n    long long int diff45;\n\
    \    long long int diff46;\n    long long int diff47;\n    long long int diff48;\n\
    \    long long int diff49;\n    long long int diff50;\n    long long int diff51;\n\
    \    long long int diff52;\n    long long int diff53;\n    long long int diff54;\n\
    \    long long int diff55;\n    long long int diff56;\n    long long int diff57;\n\
    \    long long int diff58;\n    long long int diff59;\n    long long int diff60;\n\
    \    long long int diff61;\n    long long int diff62;\n    long long int diff63;\n\
    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpqg_4dw5y: /tmp/tmpqg_4dw5y.cpp:84: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ temp;\n    long power = 1;\n    long power2 = 1;\n    long power3 = 1;\n   \
    \ long power4 = 1;\n    long power5 = 1;\n    long power6 = 1;\n    long power7\
    \ = 1;\n    long power8 = 1;\n    long power9 = 1;\n    long power10 = 1;\n  \
    \  long power11 = 1;\n    long power12 = 1;\n    long power13 = 1;\n    long power14\
    \ = 1;\n    long power15 = 1;\n    long power16 = 1;\n    long power17 = 1;\n\
    \    long power18 = 1;\n    long power19 = 1;\n    long power20 = 1;\n    long\
    \ power21 = 1;\n    long power22 = 1;\n    long power23 = 1;\n    long power24\
    \ = 1;\n    long power25 = 1;\n    long power26 = 1;\n    long power27 = 1;\n\
    \    long power28 = 1;\n    long power29 = 1;\n    long power30 = 1;\n    long\
    \ power31 = 1;\n    long power32 = 1;\n    long power33 = 1;\n    long power34\
    \ = 1;\n    long power35 = 1;\n    long power36 = 1;\n    long power37 = 1;\n\
    \    long power38 = 1;\n    long power39 = 1;\n    long power40 = 1;\n    long\
    \ power41 = 1;\n    long power42 = 1;\n    long power43 = 1;\n    long power44\
    \ = 1;\n    long power45 = 1;\n    long power46 = 1;\n    long power47 = 1;\n\
    \    long power48 = 1;\n    long power49 = 1;\n    long power50 = 1;\n    long\
    \ power51 = 1;\n    long power52 = 1;\n    long power53 = 1;\n    long power54\
    \ = 1;\n    long power55 = 1;\n    long power56 = 1;\n    long power57 = 1;\n\
    \    long power58 = 1;\n    long power59 = 1;\n    long power60 = 1;\n    long\
    \ power61 = 1;\n    long power62 = 1;\n    long power63 = 1;\n    long power64\
    \ = 1;\n    long power65 = 1;\n    long power66 = 1;\n    long power67 = 1;\n\
    \    long power68 = 1;\n    long power69 = 1;\n    long power70 = 1;\n    long\
    \ power71 = 1;\n    long power72 = 1;\n    long power73 = 1;\n    long power74\
    \ = 1;\n    long power75 = 1;\n    long power76 = 1;\n    long power77 = 1;\n\
    \    long power78 = 1;\n    long power79 = 1;\n    long power80 = 1;\n    long\
    \ power81 = 1;\n    long power82 = 1;\n\n}\nint main() {\n    auto candidate =\
    \ closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpjq52or6y: /tmp/tmpjq52or6y.cpp:101: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141608
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int result = 0;\n    long\
    \ long int min = 0;\n    long long int max = 0;\n    long long int mid = 0;\n\
    \    long long int diff = 0;\n    long long int diff2 = 0;\n    long long int\
    \ diff3 = 0;\n    long long int diff4 = 0;\n    long long int diff5 = 0;\n   \
    \ long long int diff6 = 0;\n    long long int diff7 = 0;\n    long long int diff8\
    \ = 0;\n    long long int diff9 = 0;\n    long long int diff10 = 0;\n    long\
    \ long int diff11 = 0;\n    long long int diff12 = 0;\n    long long int diff13\
    \ = 0;\n    long long int diff14 = 0;\n    long long int diff15 = 0;\n    long\
    \ long int diff16 = 0;\n    long long int diff17 = 0;\n    long long int diff18\
    \ = 0;\n    long long int diff19 = 0;\n    long long int diff20 = 0;\n    long\
    \ long int diff21 = 0;\n    long long int diff22 = 0;\n    long long int diff23\
    \ = 0;\n    long long int diff24 = 0;\n    long long int diff25 = 0;\n    long\
    \ long int diff26 = 0;\n    long long int diff27 = 0;\n    long long int diff28\
    \ = 0;\n    long long int diff29 = 0;\n    long long int diff30 = 0;\n    long\
    \ long int diff31 = 0;\n    long long int diff32 = 0;\n    long long int diff33\
    \ = 0;\n    long long int diff34 = 0;\n    long long int diff35 = 0;\n    long\
    \ long int diff36 = 0;\n    long long int diff37 = 0;\n    long long int diff38\
    \ = 0;\n    long long int diff39 = 0;\n    long long int diff40 = 0;\n    long\
    \ long int diff41 = 0;\n    long long int diff42 = 0;\n    long long int diff43\
    \ = 0;\n    long long int diff44 = 0;\n    long long int diff45 = 0;\n    long\
    \ long int diff46 = 0;\n    long long int diff47 = 0;\n    long long int diff48\
    \ = 0;\n    long long int diff49 = 0;\n    long long int diff50 = 0;\n    long\
    \ long int diff51 = 0;\n    long long int diff52 = 0;\n    long long int diff53\
    \ = 0;\n    long long int diff54 = 0;\n    long long int diff55 = 0;\n    long\
    \ long int diff56 = 0;\n    long long int diff57 = 0;\n    long long int diff58\
    \ = 0;\n    long long int diff59 = 0;\n    long long int diff60 = 0;\n    long\
    \ long int diff61 = 0;\n    \n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpmlregh2_: /tmp/tmpmlregh2_.cpp:82: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141608
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ ans = 0, diff = 0;\n    long long temp = 0;\n    long long temp2 = 0;\n    long\
    \ long temp3 = 0;\n    long long temp4 = 0;\n    long long temp5 = 0;\n    long\
    \ long temp6 = 0;\n    long long temp7 = 0;\n    long long temp8 = 0;\n    long\
    \ long temp9 = 0;\n    long long temp10 = 0;\n    long long temp11 = 0;\n    long\
    \ long temp12 = 0;\n    long long temp13 = 0;\n    long long temp14 = 0;\n   \
    \ long long temp15 = 0;\n    long long temp16 = 0;\n    long long temp17 = 0;\n\
    \    long long temp18 = 0;\n    long long temp19 = 0;\n    long long temp20 =\
    \ 0;\n    long long temp21 = 0;\n    long long temp22 = 0;\n    long long temp23\
    \ = 0;\n    long long temp24 = 0;\n    long long temp25 = 0;\n    long long temp26\
    \ = 0;\n    long long temp27 = 0;\n    long long temp28 = 0;\n    long long temp29\
    \ = 0;\n    long long temp30 = 0;\n    long long temp31 = 0;\n    long long temp32\
    \ = 0;\n    long long temp33 = 0;\n    long long temp34 = 0;\n    long long temp35\
    \ = 0;\n    long long temp36 = 0;\n    long long temp37 = 0;\n    long long temp38\
    \ = 0;\n    long long temp39 = 0;\n    long long temp40 = 0;\n    long long temp41\
    \ = 0;\n    long long temp42 = 0;\n    long long temp43 = 0;\n    long long temp44\
    \ = 0;\n    long long temp45 = 0;\n    long long temp46 = 0;\n    long long temp47\
    \ = 0;\n    long long temp48 = 0;\n    long long temp49 = 0;\n    long long temp50\
    \ = 0;\n    long long temp51 = 0;\n    long long temp52 = 0;\n    long long temp53\
    \ = 0;\n    long long temp54 = 0;\n    long long temp55 = 0;\n    long long temp56\
    \ = 0;\n    long long temp57 = 0;\n    long long temp58 = 0;\n    long long temp59\
    \ = 0;\n    long long temp60 = 0;\n    long long temp61 = 0;\n    long long temp62\
    \ = 0;\n    long long temp63 = 0;\n    long long temp64 = 0;\n    long long temp65\
    \ = 0;\n    long long temp66 = 0;\n    long long temp67 = 0;\n    long long temp68\
    \ = 0;\n    long long temp69 = 0;\n    long long temp70 = 0;\n    long long temp71\
    \ = 0;\n    long long temp72 = 0;\n\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmph76pmdgg: /tmp/tmph76pmdgg.cpp:91: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141607
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long temp = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long\
    \ l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n\
    \    long q = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n    long\
    \ u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n\
    \    long z = 0;\n    long A = 0;\n    long B = 0;\n    long C = 0;\n    long\
    \ D = 0;\n    long E = 0;\n    long F = 0;\n    long G = 0;\n    long H = 0;\n\
    \    long I = 0;\n    long J = 0;\n    long K = 0;\n    long L = 0;\n    long\
    \ M = 0;\n    long N = 0;\n    long O = 0;\n    long P = 0;\n    long Q = 0;\n\
    \    long R = 0;\n    long S = 0;\n    long T = 0;\n    long U = 0;\n    long\
    \ V = 0;\n    long W = 0;\n    long X = 0;\n    long Y = 0;\n    long Z = 0;\n\
    \    long aa = 0;\n    long bb = 0;\n    long cc = 0;\n    long dd = 0;\n    long\
    \ ee = 0;\n    long ff = 0;\n    long gg = 0;\n    long hh = 0;\n    long ii =\
    \ 0;\n    long jj = 0;\n    long kk = 0;\n    long ll = 0;\n    long mm = 0;\n\
    \    long nn = 0;\n    long oo = 0;\n    long pp = 0;\n    long qq = 0;\n    long\
    \ rr = 0;\n    long ss = 0;\n    long tt = 0;\n    long uu = 0;\n    long vv =\
    \ 0;\n    long ww = 0;\n    long xx = 0;\n    long yy = 0;\n    long zz = 0;\n\
    \    long Aa = 0;\n    long Bb = 0;\n    long Cc = 0;\n    long Dd = 0;\n    long\
    \ Ee = 0;\n    long Ff = 0;\n    long Gg = 0;\n    long Hh = 0;\n    long Ii =\
    \ 0;\n    long Jj = 0;\n    long Kk = 0;\n    long Ll = 0;\n    long Mm = 0;\n\
    \    long Nn = 0;\n    long Oo = 0;\n    long Pp = 0;\n    long Qq = 0;\n    long\
    \ Rr = 0;\n    long Ss = 0;\n    long Tt = 0;\n    long Uu = 0;\n    long Vv =\
    \ 0;\n    long Ww = 0;\n    long Xx = 0;\n    long Yy = 0;\n    long Z\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxevzbc6_.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpxevzbc6_.cpp:112:1: error: expected initializer before \u2018}\u2019\
    \ token\n  112 | }\n      | ^\n/tmp/tmpxevzbc6_.cpp:112:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141607
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num = std::stoll(value);\n\
    \    long long int diff = num - num % 10;\n    long long int diff2 = num - num\
    \ % 100;\n    long long int diff3 = num - num % 1000;\n    long long int diff4\
    \ = num - num % 10000;\n    long long int diff5 = num - num % 100000;\n    long\
    \ long int diff6 = num - num % 1000000;\n    long long int diff7 = num - num %\
    \ 10000000;\n    long long int diff8 = num - num % 100000000;\n    long long int\
    \ diff9 = num - num % 100000000;\n    long long int diff10 = num - num % 1000000000;\n\
    \    long long int diff11 = num - num % 1000000000;\n    long long int diff12\
    \ = num - num % 10000000000;\n    long long int diff13 = num - num % 10000000000;\n\
    \    long long int diff14 = num - num % 10000000000;\n    long long int diff15\
    \ = num - num % 10000000000;\n    long long int diff16 = num - num % 10000000000;\n\
    \    long long int diff17 = num - num % 10000000000;\n    long long int diff18\
    \ = num - num % 10000000000;\n    long long int diff19 = num - num % 10000000000;\n\
    \    long long int diff20 = num - num % 10000000000;\n    long long int diff21\
    \ = num - num % 10000000000;\n    long long int diff22 = num - num % 10000000000;\n\
    \    long long int diff23 = num - num % 10000000000;\n    long long int diff24\
    \ = num - num % 10000000000;\n    long long int diff25 = num - num % 10000000000;\n\
    \    long long int diff26 = num - num % 10000000000;\n    long long int diff27\
    \ = num - num % 10000000000;\n    long long int diff28 = num - num % 10000000000;\n\
    \    long long int diff29 = num - num % 10000000000;\n    long long int diff30\
    \ = num - num % 10000000000;\n    long long int diff31 = num - num % 10000000000;\n\
    \    long long int diff32 = num - num % 10000000000;\n    long long int diff33\
    \ = num - num % 10000000000;\n    long long int diff34 = num - num % 10000000000;\n\
    \    long long int diff35 = num - num % 10000000000;\n\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp5473_41t: /tmp/tmp5473_41t.cpp:53: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141608
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ ans = 0, diff = 0;\n    long long temp = 0;\n    long long temp2 = 0;\n    long\
    \ long temp3 = 0;\n    long long temp4 = 0;\n    long long temp5 = 0;\n    long\
    \ long temp6 = 0;\n    long long temp7 = 0;\n    long long temp8 = 0;\n    long\
    \ long temp9 = 0;\n    long long temp10 = 0;\n    long long temp11 = 0;\n    long\
    \ long temp12 = 0;\n    long long temp13 = 0;\n    long long temp14 = 0;\n   \
    \ long long temp15 = 0;\n    long long temp16 = 0;\n    long long temp17 = 0;\n\
    \    long long temp18 = 0;\n    long long temp19 = 0;\n    long long temp20 =\
    \ 0;\n    long long temp21 = 0;\n    long long temp22 = 0;\n    long long temp23\
    \ = 0;\n    long long temp24 = 0;\n    long long temp25 = 0;\n    long long temp26\
    \ = 0;\n    long long temp27 = 0;\n    long long temp28 = 0;\n    long long temp29\
    \ = 0;\n    long long temp30 = 0;\n    long long temp31 = 0;\n    long long temp32\
    \ = 0;\n    long long temp33 = 0;\n    long long temp34 = 0;\n    long long temp35\
    \ = 0;\n    long long temp36 = 0;\n    long long temp37 = 0;\n    long long temp38\
    \ = 0;\n    long long temp39 = 0;\n    long long temp40 = 0;\n    long long temp41\
    \ = 0;\n    long long temp42 = 0;\n    long long temp43 = 0;\n    long long temp44\
    \ = 0;\n    long long temp45 = 0;\n    long long temp46 = 0;\n    long long temp47\
    \ = 0;\n    long long temp48 = 0;\n    long long temp49 = 0;\n    long long temp50\
    \ = 0;\n    long long temp51 = 0;\n    long long temp52 = 0;\n    long long temp53\
    \ = 0;\n    long long temp54 = 0;\n    long long temp55 = 0;\n    long long temp56\
    \ = 0;\n    long long temp57 = 0;\n    long long temp58 = 0;\n    long long temp59\
    \ = 0;\n    long long temp60 = 0;\n    long long temp61 = 0;\n    long long temp62\
    \ = 0;\n    long long temp63 = 0;\n    long long temp64 = 0;\n    long long temp65\
    \ = 0;\n    long long temp66 = 0;\n    long long temp67 = 0;\n    long long temp68\
    \ = 0;\n    long long temp69 = 0;\n    long long temp70 = 0;\n    long long temp71\
    \ = 0;\n    long long temp72 = 0;\n\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmph76pmdgg: /tmp/tmph76pmdgg.cpp:91: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141607
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = std::stoi(value);\n   \
    \ long diff = 0;\n    long maxDiff = std::numeric_limits<long>::max();\n    long\
    \ minDiff = std::numeric_limits<long>::min();\n    long mid = 0;\n    long midVal\
    \ = 0;\n    long midDiff = 0;\n    long midMaxDiff = std::numeric_limits<long>::max();\n\
    \    long midMinDiff = std::numeric_limits<long>::min();\n    long midMid = 0;\n\
    \    long midMidVal = 0;\n    long midMidDiff = 0;\n    long midMidMaxDiff = std::numeric_limits<long>::max();\n\
    \    long midMidMinDiff = std::numeric_limits<long>::min();\n    long midMidMid\
    \ = 0;\n    long midMidMidVal = 0;\n    long midMidMidDiff = 0;\n    long midMidMidMaxDiff\
    \ = std::numeric_limits<long>::max();\n    long midMidMidMinDiff = std::numeric_limits<long>::min();\n\
    \    long midMidMidMid = 0;\n    long midMidMidMidVal = 0;\n    long midMidMidMidDiff\
    \ = 0;\n    long midMidMidMidMaxDiff = std::numeric_limits<long>::max();\n   \
    \ long midMidMidMinDiff = std::numeric_limits<long>::min();\n    long midMidMidMidMid\
    \ = 0;\n    long midMidMidMidVal = 0;\n    long midMidMidMidDiff = 0;\n    long\
    \ midMidMidMidMaxDiff = std::numeric_limits<long>::max();\n    long midMidMidMinDiff\
    \ = std::numeric_limits<long>::min();\n    long midMidMidMid = 0;\n    long midMidMidMidVal\
    \ = 0;\n    long midMidMidMidDiff = 0;\n    long midMidMidMidMaxDiff = std::numeric_limits<long>::max();\n\
    \    long midMidMidMinDiff = std::numeric_limits<long>::min();\n    long midMidMidMid\
    \ = 0;\n    long midMidMidMidVal = 0;\n    long midMidMidMidDiff = 0;\n    long\
    \ midMidMidMidMaxDiff = std::numeric_limits<long>::max();\n    long midMidMidMinDiff\
    \ = std::numeric_limits<long>::min();\n    long midMidMidMid = 0;\n    long midMidMidMidVal\
    \ = 0;\n    long midMidMidMidDiff = 0;\n    long midMidMidMidMaxDiff = std::numeric_limits<long>::max();\n\
    \    long midMidMidMinDiff = std::numeric_limits<long>::min();\n    long midMidMidMid\
    \ = 0;\n\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7n61jfwe.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp7n61jfwe.cpp:36:10: error: redeclaration of \u2018long int midMidMidMinDiff\u2019\
    \n   36 |     long midMidMidMinDiff = std::numeric_limits<long>::min();\n    \
    \  |          ^~~~~~~~~~~~~~~~\n/tmp/tmp7n61jfwe.cpp:31:10: note: \u2018long int\
    \ midMidMidMinDiff\u2019 previously declared here\n   31 |     long midMidMidMinDiff\
    \ = std::numeric_limits<long>::min();\n      |          ^~~~~~~~~~~~~~~~\n/tmp/tmp7n61jfwe.cpp:38:10:\
    \ error: redeclaration of \u2018long int midMidMidMidVal\u2019\n   38 |     long\
    \ midMidMidMidVal = 0;\n      |          ^~~~~~~~~~~~~~~\n/tmp/tmp7n61jfwe.cpp:33:10:\
    \ note: \u2018long int midMidMidMidVal\u2019 previously declared here\n   33 |\
    \     long midMidMidMidVal = 0;\n      |          ^~~~~~~~~~~~~~~\n/tmp/tmp7n61jfwe.cpp:39:10:\
    \ error: redeclaration of \u2018long int midMidMidMidDiff\u2019\n   39 |     long\
    \ midMidMidMidDiff = 0;\n      |          ^~~~~~~~~~~~~~~~\n/tmp/tmp7n61jfwe.cpp:34:10:\
    \ note: \u2018long int midMidMidMidDiff\u2019 previously declared here\n   34\
    \ |     long midMidMidMidDiff = 0;\n      |          ^~~~~~~~~~~~~~~~\n/tmp/tmp7n61jfwe.cpp:40:10:\
    \ error: redeclaration of \u2018long int midMidMidMidMaxDiff\u2019\n   40 |  \
    \   long midMidMidMidMaxDiff = std::numeric_limits<long>::max();\n      |    \
    \      ^~~~~~~~~~~~~~~~~~~\n/tmp/tmp7n61jfwe.cpp:35:10: note: \u2018long int midMidMidMidMaxDiff\u2019\
    \ previously declared here\n   35 |     long midMidMidMidMaxDiff = std::numeric_limits<long>::max();\n\
    \      |          ^~~~~~~~~~~~~~~~~~~\n/tmp/tmp7n61jfwe.cpp:41:10: error: redeclaration\
    \ of \u2018long int midMidMidMinDiff\u2019\n   41 |     long midMidMidMinDiff\
    \ = std::numeric_limits<long>::min();\n      |          ^~~~~~~~~~~~~~~~\n/tmp/tmp7n61jfwe.cpp:31:10:\
    \ note: \u2018long int midMidMidMinDiff\u2019 previously declared here\n   31\
    \ |     long midMidMidMinDiff = std::numeric_limits<long>::min();\n      |   \
    \       ^~~~~~~~~~~~~~~~\n/tmp/tmp7n61jfwe.cpp:42:10: error: redeclaration of\
    \ \u2018long int midMidMidMid\u2019\n   42 |     long midMidMidMid = 0;\n    \
    \  |          ^~~~~~~~~~~~\n/tmp/tmp7n61jfwe.cpp:"
  stdout: ''
  timestamp: 1660141608
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int lower = 0, upper = std::numeric_limits<long\
    \ long int>::max();\n    long long int mid = 0;\n    long long int diff = std::numeric_limits<long\
    \ long int>::max();\n    long long int diff2 = std::numeric_limits<long long int>::max();\n\
    \    long long int diff3 = std::numeric_limits<long long int>::max();\n    long\
    \ long int diff4 = std::numeric_limits<long long int>::max();\n    long long int\
    \ diff5 = std::numeric_limits<long long int>::max();\n    long long int diff6\
    \ = std::numeric_limits<long long int>::max();\n    long long int diff7 = std::numeric_limits<long\
    \ long int>::max();\n    long long int diff8 = std::numeric_limits<long long int>::max();\n\
    \    long long int diff9 = std::numeric_limits<long long int>::max();\n    long\
    \ long int diff10 = std::numeric_limits<long long int>::max();\n    long long\
    \ int diff11 = std::numeric_limits<long long int>::max();\n    long long int diff12\
    \ = std::numeric_limits<long long int>::max();\n    long long int diff13 = std::numeric_limits<long\
    \ long int>::max();\n    long long int diff14 = std::numeric_limits<long long\
    \ int>::max();\n    long long int diff15 = std::numeric_limits<long long int>::max();\n\
    \    long long int diff16 = std::numeric_limits<long long int>::max();\n    long\
    \ long int diff17 = std::numeric_limits<long long int>::max();\n    long long\
    \ int diff18 = std::numeric_limits<long long int>::max();\n    long long int diff19\
    \ = std::numeric_limits<long long int>::max();\n    long long int diff20 = std::numeric_limits<long\
    \ long int>::max();\n    long long int diff21 = std::numeric_limits<long long\
    \ int>::max();\n    long long int diff22 = std::numeric_limits<long long int>::max();\n\
    \    long long int diff23 = std::numeric_limits<long long int>::max();\n    long\
    \ long int diff24 = std::numeric_limits<long long int>::max();\n    long long\
    \ int diff25 = std::numeric_limits<long long int>::max();\n    long long int diff26\
    \ = std::numeric_limits<long long int>::max();\n    long long int diff27 = std::numeric_limits<long\
    \ long int>::max();\n    long long int diff28 = std::numeric_limits<long \n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpx9xv198l.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpx9xv198l.cpp:42:48: error: template argument 1 is invalid\n   42 |\
    \     long long int diff28 = std::numeric_limits<long\n      |               \
    \                                 ^~~~\n/tmp/tmpx9xv198l.cpp:43:1: warning: no\
    \ return statement in function returning non-void [-Wreturn-type]\n   43 | }\n\
    \      | ^\n"
  stdout: ''
  timestamp: 1660141608
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ long int x = std::stoll(value);\n    long long int y = std::stoll(value);\n\
    \    long long int z = std::stoll(value);\n    long long int w = std::stoll(value);\n\
    \    long long int v = std::stoll(value);\n    long long int u = std::stoll(value);\n\
    \    long long int t = std::stoll(value);\n    long long int r = std::stoll(value);\n\
    \    long long int q = std::stoll(value);\n    long long int p = std::stoll(value);\n\
    \    long long int m = std::stoll(value);\n    long long int l = std::stoll(value);\n\
    \    long long int k = std::stoll(value);\n    long long int j = std::stoll(value);\n\
    \    long long int i = std::stoll(value);\n    long long int h = std::stoll(value);\n\
    \    long long int g = std::stoll(value);\n    long long int f = std::stoll(value);\n\
    \    long long int e = std::stoll(value);\n    long long int d = std::stoll(value);\n\
    \    long long int c = std::stoll(value);\n    long long int b = std::stoll(value);\n\
    \    long long int a = std::stoll(value);\n    long long int j = std::stoll(value);\n\
    \    long long int i = std::stoll(value);\n    long long int h = std::stoll(value);\n\
    \    long long int g = std::stoll(value);\n    long long int f = std::stoll(value);\n\
    \    long long int e = std::stoll(value);\n    long long int d = std::stoll(value);\n\
    \    long long int c = std::stoll(value);\n    long long int b = std::stoll(value);\n\
    \    long long int a = std::stoll(value);\n    long long int j = std::stoll(value);\n\
    \    long long int i = std::stoll(value);\n    long long int h = std::stoll(value);\n\
    \    long long int g = std::stoll(value);\n    long long int f = std::stoll(value);\n\
    \    long long int e = std::stoll(value);\n    long long int d = std::stoll(value);\n\
    \    long long int c = std::stoll(value);\n    long long int b = std::stoll(value);\n\
    \    long long int a = std::stoll(value);\n    long long int j = std::stoll(value);\n\
    \    long long int i = std::stoll(value);\n    long long int h = std::stoll(value);\n\
    \    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5zgmtfup.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp5zgmtfup.cpp:37:19: error: redeclaration of \u2018long long int j\u2019\
    \n   37 |     long long int j = std::stoll(value);\n      |                  \
    \ ^\n/tmp/tmp5zgmtfup.cpp:27:19: note: \u2018long long int j\u2019 previously\
    \ declared here\n   27 |     long long int j = std::stoll(value);\n      |   \
    \                ^\n/tmp/tmp5zgmtfup.cpp:38:19: error: redeclaration of \u2018\
    long long int i\u2019\n   38 |     long long int i = std::stoll(value);\n    \
    \  |                   ^\n/tmp/tmp5zgmtfup.cpp:28:19: note: \u2018long long int\
    \ i\u2019 previously declared here\n   28 |     long long int i = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmp5zgmtfup.cpp:39:19: error: redeclaration\
    \ of \u2018long long int h\u2019\n   39 |     long long int h = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmp5zgmtfup.cpp:29:19: note: \u2018long long\
    \ int h\u2019 previously declared here\n   29 |     long long int h = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmp5zgmtfup.cpp:40:19: error: redeclaration\
    \ of \u2018long long int g\u2019\n   40 |     long long int g = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmp5zgmtfup.cpp:30:19: note: \u2018long long\
    \ int g\u2019 previously declared here\n   30 |     long long int g = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmp5zgmtfup.cpp:41:19: error: redeclaration\
    \ of \u2018long long int f\u2019\n   41 |     long long int f = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmp5zgmtfup.cpp:31:19: note: \u2018long long\
    \ int f\u2019 previously declared here\n   31 |     long long int f = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmp5zgmtfup.cpp:42:19: error: redeclaration\
    \ of \u2018long long int e\u2019\n   42 |     long long int e = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmp5zgmtfup.cpp:32:19: note: \u2018long long\
    \ int e\u2019 previously declared here\n   32 |     long long int e = std::stoll(value);\n\
    \      |                   ^\n/tmp/tmp5zgmtfup.cpp:43:19: error: redeclaration\
    \ of \u2018long long int d\u2019\n   43 |     long long int d = std::stoll("
  stdout: ''
  timestamp: 1660141608
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ temp = 0;\n    long mod = 1000000007;\n    long power = 1;\n    long temp2 =\
    \ 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long\
    \ temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n\
    \    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13\
    \ = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n   \
    \ long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20\
    \ = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n   \
    \ long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27\
    \ = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n   \
    \ long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34\
    \ = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n   \
    \ long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41\
    \ = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n   \
    \ long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48\
    \ = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n   \
    \ long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55\
    \ = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n   \
    \ long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long temp62\
    \ = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n    long temp65 = 0;\n   \
    \ long temp66 = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n    long temp69\
    \ = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n    long temp72 = 0;\n   \
    \ long temp73 = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n    long temp76\
    \ = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n    long temp79 = 0;\n   \
    \ long temp80 = 0;\n    long temp81 = 0;\n    long temp82 = 0;\n    long temp83\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgjo9jatw.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpgjo9jatw.cpp:99:1: error: expected initializer before \u2018}\u2019\
    \ token\n   99 | }\n      | ^\n/tmp/tmpgjo9jatw.cpp:99:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141608
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long diff = 0;\n    long temp = 0;\n    long i = 0;\n    long j = 0;\n\
    \    long k = 0;\n    long l = 0;\n    long m = 0;\n    long n = 0;\n    long\
    \ o = 0;\n    long p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n\
    \    long t = 0;\n    long u = 0;\n    long v = 0;\n    long w = 0;\n    long\
    \ x = 0;\n    long y = 0;\n    long z = 0;\n    long A = 0;\n    long B = 0;\n\
    \    long C = 0;\n    long D = 0;\n    long E = 0;\n    long F = 0;\n    long\
    \ G = 0;\n    long H = 0;\n    long I = 0;\n    long J = 0;\n    long K = 0;\n\
    \    long L = 0;\n    long M = 0;\n    long N = 0;\n    long O = 0;\n    long\
    \ P = 0;\n    long Q = 0;\n    long R = 0;\n    long S = 0;\n    long T = 0;\n\
    \    long U = 0;\n    long V = 0;\n    long W = 0;\n    long X = 0;\n    long\
    \ Y = 0;\n    long Z = 0;\n    long aa = 0;\n    long bb = 0;\n    long cc = 0;\n\
    \    long dd = 0;\n    long ee = 0;\n    long ff = 0;\n    long gg = 0;\n    long\
    \ hh = 0;\n    long ii = 0;\n    long jj = 0;\n    long kk = 0;\n    long ll =\
    \ 0;\n    long mm = 0;\n    long nn = 0;\n    long oo = 0;\n    long pp = 0;\n\
    \    long qq = 0;\n    long rr = 0;\n    long ss = 0;\n    long tt = 0;\n    long\
    \ uu = 0;\n    long vv = 0;\n    long ww = 0;\n    long xx = 0;\n    long yy =\
    \ 0;\n    long zz = 0;\n    long Aa = 0;\n    long Bb = 0;\n    long Cc = 0;\n\
    \    long Dd = 0;\n    long Ee = 0;\n    long Ff = 0;\n    long Gg = 0;\n    long\
    \ Hh = 0;\n    long Ii = 0;\n    long Jj = 0;\n    long Kk = 0;\n    long Ll =\
    \ 0;\n    long Mm = 0;\n    long Nn = 0;\n    long Oo = 0;\n    long Pp = 0;\n\
    \    long Qq = 0;\n    long Rr = 0;\n    long Ss = 0;\n    long Tt = 0;\n    long\
    \ Uu = 0;\n    long Vv = 0;\n    long Ww = 0;\n    long Xx = 0;\n    long Yy\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9a_gbay4.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp9a_gbay4.cpp:112:1: error: expected initializer before \u2018}\u2019\
    \ token\n  112 | }\n      | ^\n/tmp/tmp9a_gbay4.cpp:112:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141608
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n\
    \    long mid = 0;\n    long diff = std::numeric_limits<long>::max();\n    long\
    \ diff1 = std::numeric_limits<long>::max();\n    long diff2 = std::numeric_limits<long>::max();\n\
    \    long diff3 = std::numeric_limits<long>::max();\n    long diff4 = std::numeric_limits<long>::max();\n\
    \    long diff5 = std::numeric_limits<long>::max();\n    long diff6 = std::numeric_limits<long>::max();\n\
    \    long diff7 = std::numeric_limits<long>::max();\n    long diff8 = std::numeric_limits<long>::max();\n\
    \    long diff9 = std::numeric_limits<long>::max();\n    long diff10 = std::numeric_limits<long>::max();\n\
    \    long diff11 = std::numeric_limits<long>::max();\n    long diff12 = std::numeric_limits<long>::max();\n\
    \    long diff13 = std::numeric_limits<long>::max();\n    long diff14 = std::numeric_limits<long>::max();\n\
    \    long diff15 = std::numeric_limits<long>::max();\n    long diff16 = std::numeric_limits<long>::max();\n\
    \    long diff17 = std::numeric_limits<long>::max();\n    long diff18 = std::numeric_limits<long>::max();\n\
    \    long diff19 = std::numeric_limits<long>::max();\n    long diff20 = std::numeric_limits<long>::max();\n\
    \    long diff21 = std::numeric_limits<long>::max();\n    long diff22 = std::numeric_limits<long>::max();\n\
    \    long diff23 = std::numeric_limits<long>::max();\n    long diff24 = std::numeric_limits<long>::max();\n\
    \    long diff25 = std::numeric_limits<long>::max();\n    long diff26 = std::numeric_limits<long>::max();\n\
    \    long diff27 = std::numeric_limits<long>::max();\n    long diff28 = std::numeric_limits<long>::max();\n\
    \    long diff29 = std::numeric_limits<long>::max();\n    long diff30 = std::numeric_limits<long>::max();\n\
    \    long diff31 = std::numeric_limits<long>::max();\n    long diff32 = std::numeric_limits<long>::max();\n\
    \    long diff33 = std::numeric_limits<long>::max();\n    long diff34 = std::numeric_limits<long>::max();\n\
    \    long diff35 = std::numeric_limits<long>::max();\n    \n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp1lr7l1uw: /tmp/tmp1lr7l1uw.cpp:55: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, diff = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n\
    \    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7\
    \ = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long\
    \ temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n\
    \    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18\
    \ = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n   \
    \ long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25\
    \ = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n   \
    \ long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32\
    \ = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n   \
    \ long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39\
    \ = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n   \
    \ long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46\
    \ = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n   \
    \ long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53\
    \ = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n   \
    \ long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60\
    \ = 0;\n    long temp61 = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n   \
    \ long temp64 = 0;\n    long temp65 = 0;\n    long temp66 = 0;\n    long temp67\
    \ = 0;\n    long temp68 = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n   \
    \ long temp71 = 0;\n    long temp72 = 0;\n    long temp73 = 0;\n    long temp74\
    \ = 0;\n    long temp75 = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n   \
    \ long temp78 = 0;\n    long temp79 = 0;\n    long temp80 = 0;\n    long temp81\
    \ = 0;\n    long temp82 = 0;\n    long temp83 = 0;\n    long temp84 = 0;\n\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpo12f3813: /tmp/tmpo12f3813.cpp:103: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int a = stoi(value);\n \
    \   long long int b = stoi(value);\n    long long int c = stoi(value);\n    long\
    \ long int d = stoi(value);\n    long long int e = stoi(value);\n    long long\
    \ int f = stoi(value);\n    long long int g = stoi(value);\n    long long int\
    \ h = stoi(value);\n    long long int i = stoi(value);\n    long long int j =\
    \ stoi(value);\n    long long int k = stoi(value);\n    long long int l = stoi(value);\n\
    \    long long int m = stoi(value);\n    long long int n = stoi(value);\n    long\
    \ long int o = stoi(value);\n    long long int p = stoi(value);\n    long long\
    \ int q = stoi(value);\n    long long int r = stoi(value);\n    long long int\
    \ s = stoi(value);\n    long long int t = stoi(value);\n    long long int u =\
    \ stoi(value);\n    long long int v = stoi(value);\n    long long int w = stoi(value);\n\
    \    long long int x = stoi(value);\n    long long int y = stoi(value);\n    long\
    \ long int z = stoi(value);\n    long long int A = a;\n    long long int B = b;\n\
    \    long long int C = c; \n    long long int D = d; \n    long long int E; \n\
    \    long long int F = f; \n    long long int G; \n    long long int H; \n   \
    \ long long int I; \n    long long int J; \n    long long int K; \n    long long\
    \ int L; \n    long long int M; \n    long long int N; \n    long long int O;\
    \ \n    long long int P; \n    long long int Q; \n    long long int R; \n    long\
    \ long int S; \n    long long int T; \n    long long int U; \n    long long int\
    \ V; \n    long long int W; \n    long long int X; \n    long long int Y; \n \
    \   long long int Z; \n    long long int AA = A; \n    long long int BB = B; \n\
    \    long long int CC = C; \n    long long int DD = D; \n    long long int EE;\
    \ \n    long long int FF; \n    long long int GG; \n    long long int HH; \n \
    \   long long int II; \n    long long int JJ; \n    long long int KK; \n    long\
    \ long int LL\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9caup_pb.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp9caup_pb.cpp:77:1: error: expected initializer before \u2018}\u2019\
    \ token\n   77 | }\n      | ^\n/tmp/tmp9caup_pb.cpp:77:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141608
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, sign = 1;\n    long\
    \ long temp = 0;\n    long long temp2 = 0;\n    long long temp3 = 0;\n    long\
    \ long temp4 = 0;\n    long long temp5 = 0;\n    long long temp6 = 0;\n    long\
    \ long temp7 = 0;\n    long long temp8 = 0;\n    long long temp9 = 0;\n    long\
    \ long temp10 = 0;\n    long long temp11 = 0;\n    long long temp12 = 0;\n   \
    \ long long temp13 = 0;\n    long long temp14 = 0;\n    long long temp15 = 0;\n\
    \    long long temp16 = 0;\n    long long temp17 = 0;\n    long long temp18 =\
    \ 0;\n    long long temp19 = 0;\n    long long temp20 = 0;\n    long long temp21\
    \ = 0;\n    long long temp22 = 0;\n    long long temp23 = 0;\n    long long temp24\
    \ = 0;\n    long long temp25 = 0;\n    long long temp26 = 0;\n    long long temp27\
    \ = 0;\n    long long temp28 = 0;\n    long long temp29 = 0;\n    long long temp30\
    \ = 0;\n    long long temp31 = 0;\n    long long temp32 = 0;\n    long long temp33\
    \ = 0;\n    long long temp34 = 0;\n    long long temp35 = 0;\n    long long temp36\
    \ = 0;\n    long long temp37 = 0;\n    long long temp38 = 0;\n    long long temp39\
    \ = 0;\n    long long temp40 = 0;\n    long long temp41 = 0;\n    long long temp42\
    \ = 0;\n    long long temp43 = 0;\n    long long temp44 = 0;\n    long long temp45\
    \ = 0;\n    long long temp46 = 0;\n    long long temp47 = 0;\n    long long temp48\
    \ = 0;\n    long long temp49 = 0;\n    long long temp50 = 0;\n    long long temp51\
    \ = 0;\n    long long temp52 = 0;\n    long long temp53 = 0;\n    long long temp54\
    \ = 0;\n    long long temp55 = 0;\n    long long temp56 = 0;\n    long long temp57\
    \ = 0;\n    long long temp58 = 0;\n    long long temp59 = 0;\n    long long temp60\
    \ = 0;\n    long long temp61 = 0;\n    long long temp62 = 0;\n    long long temp63\
    \ = 0;\n    long long temp64 = 0;\n    long long temp65 = 0;\n    long long temp66\
    \ = 0;\n    long long temp67 = 0;\n    long long temp68 = 0;\n    long long temp69\
    \ = 0;\n    long long temp70 = 0;\n    long long temp71 = 0;\n    long long temp72\
    \ = 0;\n    long long temp73\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpnmfcxop5.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpnmfcxop5.cpp:87:1: error: expected initializer before \u2018}\u2019\
    \ token\n   87 | }\n      | ^\n/tmp/tmpnmfcxop5.cpp:87:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141608
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num;\n    long long\
    \ int closest;\n    num = stoll(value);\n    closest = (num > 0) ? num : -num;\n\
    \    return closest;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpi7w1zz4s: /tmp/tmpi7w1zz4s.cpp:22: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141609
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ ans = 0, temp = 0;\n    long long temp2 = 0;\n    long long temp3 = 0;\n   \
    \ long long temp4 = 0;\n    long long temp5 = 0;\n    long long temp6 = 0;\n \
    \   long long temp7 = 0;\n    long long temp8 = 0;\n    long long temp9 = 0;\n\
    \    long long temp10 = 0;\n    long long temp11 = 0;\n    long long temp12 =\
    \ 0;\n    long long temp13 = 0;\n    long long temp14 = 0;\n    long long temp15\
    \ = 0;\n    long long temp16 = 0;\n    long long temp17 = 0;\n    long long temp18\
    \ = 0;\n    long long temp19 = 0;\n    long long temp20 = 0;\n    long long temp21\
    \ = 0;\n    long long temp22 = 0;\n    long long temp23 = 0;\n    long long temp24\
    \ = 0;\n    long long temp25 = 0;\n    long long temp26 = 0;\n    long long temp27\
    \ = 0;\n    long long temp28 = 0;\n    long long temp29 = 0;\n    long long temp30\
    \ = 0;\n    long long temp31 = 0;\n    long long temp32 = 0;\n    long long temp33\
    \ = 0;\n    long long temp34 = 0;\n    long long temp35 = 0;\n    long long temp36\
    \ = 0;\n    long long temp37 = 0;\n    long long temp38 = 0;\n    long long temp39\
    \ = 0;\n    long long temp40 = 0;\n    long long temp41 = 0;\n    long long temp42\
    \ = 0;\n    long long temp43 = 0;\n    long long temp44 = 0;\n    long long temp45\
    \ = 0;\n    long long temp46 = 0;\n    long long temp47 = 0;\n    long long temp48\
    \ = 0;\n    long long temp49 = 0;\n    long long temp50 = 0;\n    long long temp51\
    \ = 0;\n    long long temp52 = 0;\n    long long temp53 = 0;\n    long long temp54\
    \ = 0;\n    long long temp55 = 0;\n    long long temp56 = 0;\n    long long temp57\
    \ = 0;\n    long long temp58 = 0;\n    long long temp59 = 0;\n    long long temp60\
    \ = 0;\n    long long temp61 = 0;\n    long long temp62 = 0;\n    long long temp63\
    \ = 0;\n    long long temp64 = 0;\n    long long temp65 = 0;\n    long long temp66\
    \ = 0;\n    long long temp67 = 0;\n    long long temp68 = 0;\n    long long temp69\
    \ = 0;\n    long long temp70 = 0;\n    long long temp71 = 0;\n    long long temp72\
    \ = 0;\n    long long temp73 = 0;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp5352alew: /tmp/tmp5352alew.cpp:90: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp = 0;\n    long long temp2 = 0;\n    long long temp3 = 0;\n    long\
    \ long temp4 = 0;\n    long long temp5 = 0;\n    long long temp6 = 0;\n    long\
    \ long temp7 = 0;\n    long long temp8 = 0;\n    long long temp9 = 0;\n    long\
    \ long temp10 = 0;\n    long long temp11 = 0;\n    long long temp12 = 0;\n   \
    \ long long temp13 = 0;\n    long long temp14 = 0;\n    long long temp15 = 0;\n\
    \    long long temp16 = 0;\n    long long temp17 = 0;\n    long long temp18 =\
    \ 0;\n    long long temp19 = 0;\n    long long temp20 = 0;\n    long long temp21\
    \ = 0;\n    long long temp22 = 0;\n    long long temp23 = 0;\n    long long temp24\
    \ = 0;\n    long long temp25 = 0;\n    long long temp26 = 0;\n    long long temp27\
    \ = 0;\n    long long temp28 = 0;\n    long long temp29 = 0;\n    long long temp30\
    \ = 0;\n    long long temp31 = 0;\n    long long temp32 = 0;\n    long long temp33\
    \ = 0;\n    long long temp34 = 0;\n    long long temp35 = 0;\n    long long temp36\
    \ = 0;\n    long long temp37 = 0;\n    long long temp38 = 0;\n    long long temp39\
    \ = 0;\n    long long temp40 = 0;\n    long long temp41 = 0;\n    long long temp42\
    \ = 0;\n    long long temp43 = 0;\n    long long temp44 = 0;\n    long long temp45\
    \ = 0;\n    long long temp46 = 0;\n    long long temp47 = 0;\n    long long temp48\
    \ = 0;\n    long long temp49 = 0;\n    long long temp50 = 0;\n    long long temp51\
    \ = 0;\n    long long temp52 = 0;\n    long long temp53 = 0;\n    long long temp54\
    \ = 0;\n    long long temp55 = 0;\n    long long temp56 = 0;\n    long long temp57\
    \ = 0;\n    long long temp58 = 0;\n    long long temp59 = 0;\n    long long temp60\
    \ = 0;\n    long long temp61 = 0;\n    long long temp62 = 0;\n    long long temp63\
    \ = 0;\n    long long temp64 = 0;\n    long long temp65 = 0;\n    long long temp66\
    \ = 0;\n    long long temp67 = 0;\n    long long temp68 = 0;\n    long long temp69\
    \ = 0;\n    long long temp70 = 0;\n    long long temp71 = 0;\n    long long temp72\
    \ = 0;\n    long long temp73\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjgxgzpwg.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpjgxgzpwg.cpp:87:1: error: expected initializer before \u2018}\u2019\
    \ token\n   87 | }\n      | ^\n/tmp/tmpjgxgzpwg.cpp:87:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141604
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ ans = 0;\n    long min = std::numeric_limits<long>::max();\n    long max = std::numeric_limits<long>::min();\n\
    \    long mid = 0;\n    long temp = 0;\n    long count = 0;\n    long sum = 0;\n\
    \    long x = 0;\n    long y = 0;\n    long z = 0;\n    long count = 0;\n    long\
    \ sum = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long count\
    \ = 0;\n    long sum = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n\
    \    long count = 0;\n    long sum = 0;\n    long x = 0;\n    long y = 0;\n  \
    \  long z = 0;\n    long count = 0;\n    long sum = 0;\n    long x = 0;\n    long\
    \ y = 0;\n    long z = 0;\n    long count = 0;\n    long sum = 0;\n    long x\
    \ = 0;\n    long y = 0;\n    long z = 0;\n    long count = 0;\n    long sum =\
    \ 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long count = 0;\n\
    \    long sum = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long\
    \ count = 0;\n    long sum = 0;\n    long x = 0;\n    long y = 0;\n    long z\
    \ = 0;\n    long count = 0;\n    long sum = 0;\n    long x = 0;\n    long y =\
    \ 0;\n    long z = 0;\n    long count = 0;\n    long sum = 0;\n    long x = 0;\n\
    \    long y = 0;\n    long z = 0;\n    long count = 0;\n    long sum = 0;\n  \
    \  long x = 0;\n    long y = 0;\n    long z = 0;\n    long count = 0;\n    long\
    \ sum = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long count\
    \ = 0;\n    long sum = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n\
    \    long count = 0;\n    long sum = 0;\n    long x = 0;\n    long y = 0;\n  \
    \  long z = 0;\n    long count = 0;\n    long sum = 0;\n    long x = 0;\n    long\
    \ y = 0;\n    long z = 0;\n    long count = 0;\n    long sum = 0;\n    long x\
    \ = 0;\n    long y = 0;\n    long z = 0;\n    long count = 0;\n    long sum =\
    \ 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long count = 0;\n\
    \    long sum = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long\
    \ count = 0;\n    long sum = 0;\n    long x\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpirm3ax7a.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpirm3ax7a.cpp:24:10: error: redeclaration of \u2018long int count\u2019\
    \n   24 |     long count = 0;\n      |          ^~~~~\n/tmp/tmpirm3ax7a.cpp:19:10:\
    \ note: \u2018long int count\u2019 previously declared here\n   19 |     long\
    \ count = 0;\n      |          ^~~~~\n/tmp/tmpirm3ax7a.cpp:25:10: error: redeclaration\
    \ of \u2018long int sum\u2019\n   25 |     long sum = 0;\n      |          ^~~\n\
    /tmp/tmpirm3ax7a.cpp:20:10: note: \u2018long int sum\u2019 previously declared\
    \ here\n   20 |     long sum = 0;\n      |          ^~~\n/tmp/tmpirm3ax7a.cpp:26:10:\
    \ error: redeclaration of \u2018long int x\u2019\n   26 |     long x = 0;\n  \
    \    |          ^\n/tmp/tmpirm3ax7a.cpp:21:10: note: \u2018long int x\u2019 previously\
    \ declared here\n   21 |     long x = 0;\n      |          ^\n/tmp/tmpirm3ax7a.cpp:27:10:\
    \ error: redeclaration of \u2018long int y\u2019\n   27 |     long y = 0;\n  \
    \    |          ^\n/tmp/tmpirm3ax7a.cpp:22:10: note: \u2018long int y\u2019 previously\
    \ declared here\n   22 |     long y = 0;\n      |          ^\n/tmp/tmpirm3ax7a.cpp:28:10:\
    \ error: redeclaration of \u2018long int z\u2019\n   28 |     long z = 0;\n  \
    \    |          ^\n/tmp/tmpirm3ax7a.cpp:23:10: note: \u2018long int z\u2019 previously\
    \ declared here\n   23 |     long z = 0;\n      |          ^\n/tmp/tmpirm3ax7a.cpp:29:10:\
    \ error: redeclaration of \u2018long int count\u2019\n   29 |     long count =\
    \ 0;\n      |          ^~~~~\n/tmp/tmpirm3ax7a.cpp:19:10: note: \u2018long int\
    \ count\u2019 previously declared here\n   19 |     long count = 0;\n      | \
    \         ^~~~~\n/tmp/tmpirm3ax7a.cpp:30:10: error: redeclaration of \u2018long\
    \ int sum\u2019\n   30 |     long sum = 0;\n      |          ^~~\n/tmp/tmpirm3ax7a.cpp:20:10:\
    \ note: \u2018long int sum\u2019 previously declared here\n   20 |     long sum\
    \ = 0;\n      |          ^~~\n/tmp/tmpirm3ax7a.cpp:31:10: error: redeclaration\
    \ of \u2018long int x\u2019\n   31 |     long x = 0;\n      |          ^\n/tmp/tmpirm3ax7a.cpp:21:10:\
    \ note: \u2018long int x\u2019 previously declared here\n   21 |     long x =\
    \ 0;\n      |          ^\n/tmp/tmpirm3ax7a.cpp:32:10: error: redeclaration "
  stdout: ''
  timestamp: 1660141608
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, sign = 1;\n    // Convert\
    \ the string to a number using strtol to ensure it can be\n    // converted to\
    \ a long integer.\n    char* endptr;\n    long num = strtol(value.c_str(), &endptr,\
    \ 10);\n    // If the conversion failed, return 0.\n    if (endptr == value.c_str()\
    \ + value.size()) {\n        return 0;\n    }\n    // If the number is negative,\
    \ flip it so that it becomes positive.\n    if (*endptr == '-') {\n        sign\
    \ = -1;\n        ++endptr;\n    }\n    // If the number is zero, return it.\n\
    \    if (*endptr == '0') {\n        return sign * num;\n    }\n    // If the number\
    \ is positive, add it to the current answer.\n    if (*endptr == '.') {\n    \
    \    ans += sign * num;\n    }\n    // If the number is negative, subtract it\
    \ from the current answer.\n    if (*endptr == '-') {\n        ans -= sign * num;\n\
    \    }\n    // If the number is equidistant from two integers, round it away from\n\
    \    // zero.\n    if (abs(num - ans) < abs(num - ans - 1)) {\n        ans = sign\
    \ * num;\n    }\n    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp7bkcdm62: /tmp/tmp7bkcdm62.cpp:48: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Declare a variable that holds the\
    \ closest integer\n    long closest_integer = 0;\n    // Declare a variable that\
    \ holds the difference between the given number\n    // and the closest integer\n\
    \    long difference = 0;\n    // Declare a variable that holds the absolute difference\
    \ between the given\n    // number and the closest integer\n    long absolute_difference\
    \ = 0;\n    // Declare a variable that holds the absolute difference between the\
    \ given\n    // number and the closest integer\n    long absolute_difference_negative\
    \ = 0;\n    // Declare a variable that holds the absolute difference between the\
    \ given\n    // number and the closest integer\n    long absolute_difference_positive\
    \ = 0;\n    // Declare a variable that holds the absolute difference between the\
    \ given\n    // number and the closest integer\n    long absolute_difference_zero\
    \ = 0;\n    // Declare a variable that holds the absolute difference between the\
    \ given\n    // number and the closest integer\n    long absolute_difference_negative\
    \ = 0;\n    // Declare a variable that holds the absolute difference between the\
    \ given\n    // number and the closest integer\n    long absolute_difference_positive\
    \ = 0;\n    // Declare a variable that holds the absolute difference between the\
    \ given\n    // number and the closest integer\n    long absolute_difference_zero\
    \ = 0;\n    // Declare a variable that holds the absolute difference between the\
    \ given\n    // number and the closest integer\n    long absolute_difference_negative\
    \ = 0;\n    // Declare a variable that holds the absolute difference between the\
    \ given\n    // number and the closest integer\n    long absolute_difference_positive\
    \ = 0;\n    // Declare a variable that holds the absolute difference between the\
    \ given\n    // number and the closest integer\n    long absolute_difference_zero\
    \ = 0;\n    // Declare a variable that holds the absolute difference between the\
    \ given\n    // number and the closest integer\n    long absolute_difference_negative\
    \ = 0;\n    // Declare a variable that holds the absolute difference between the\
    \ given\n    // number and the closest integer\n    long absolute_difference_positive\
    \ = 0;\n    // Declare a variable that holds the absolute difference between the\
    \ given\n    // number and the closest integer\n    long absolute_difference_zero\
    \ = 0;\n    // Declare a variable that holds the absolute difference between the\
    \ given\n    // number and the closest integer\n    long absolute_difference_negative\
    \ = 0;\n    // Declare a variable that holds the absolute difference between the\
    \ given\n    // number and the closest integer\n    long absolute_difference_positive\
    \ = 0;\n    // Declare a variable that holds the absolute difference between the\
    \ given\n    // number and the closest integer\n    long absolute_difference_zero\
    \ = 0;\n    // Declare a variable that holds the absolute difference between the\
    \ given\n    // number and the closest integer\n    long absolute_difference_negative\
    \ = 0;\n    // Declare a variable that holds the absolute difference between the\
    \ given\n    // number \n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptrhvrl9h.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmptrhvrl9h.cpp:32:10: error: redeclaration of \u2018long int absolute_difference_negative\u2019\
    \n   32 |     long absolute_difference_negative = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmptrhvrl9h.cpp:23:10: note: \u2018long int absolute_difference_negative\u2019\
    \ previously declared here\n   23 |     long absolute_difference_negative = 0;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmptrhvrl9h.cpp:35:10: error:\
    \ redeclaration of \u2018long int absolute_difference_positive\u2019\n   35 |\
    \     long absolute_difference_positive = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmptrhvrl9h.cpp:26:10: note: \u2018long int absolute_difference_positive\u2019\
    \ previously declared here\n   26 |     long absolute_difference_positive = 0;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmptrhvrl9h.cpp:38:10: error:\
    \ redeclaration of \u2018long int absolute_difference_zero\u2019\n   38 |    \
    \ long absolute_difference_zero = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmptrhvrl9h.cpp:29:10: note: \u2018long int absolute_difference_zero\u2019\
    \ previously declared here\n   29 |     long absolute_difference_zero = 0;\n \
    \     |          ^~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmptrhvrl9h.cpp:41:10: error:\
    \ redeclaration of \u2018long int absolute_difference_negative\u2019\n   41 |\
    \     long absolute_difference_negative = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmptrhvrl9h.cpp:23:10: note: \u2018long int absolute_difference_negative\u2019\
    \ previously declared here\n   23 |     long absolute_difference_negative = 0;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmptrhvrl9h.cpp:44:10: error:\
    \ redeclaration of \u2018long int absolute_difference_positive\u2019\n   44 |\
    \     long absolute_difference_positive = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmptrhvrl9h.cpp:26:10: note: \u2018long int absolute_difference_positive\u2019\
    \ previously declared here\n   26 |     long absolute_difference_positive = 0;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~\n/tmp/tmptrhvrl9h.cpp:47:10: "
  stdout: ''
  timestamp: 1660141608
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long d = std::stoll(value);\n    long a = std::stoll(\"0\");\n    long\
    \ b = std::stoll(\"9\");\n    long c = std::stoll(\"10\");\n    long d = std::stoll(\"\
    0\");\n    long e = std::stoll(\"0\");\n    long f = std::stoll(\"0\");\n    long\
    \ g = std::stoll(\"0\");\n    long h = std::stoll(\"0\");\n    long i = std::stoll(\"\
    0\");\n    long j = std::stoll(\"0\");\n    long k = std::stoll(\"0\");\n    long\
    \ l = std::stoll(\"0\");\n    long m = std::stoll(\"0\");\n    long n = std::stoll(\"\
    0\");\n    long o = std::stoll(\"0\");\n    long p = std::stoll(\"0\");\n    long\
    \ q = std::stoll(\"0\");\n    long r = std::stoll(\"0\");\n    long s = std::stoll(\"\
    0\");\n    long t = std::stoll(\"0\");\n    long u = std::stoll(\"0\");\n    long\
    \ v = std::stoll(\"0\");\n    long w = std::stoll(\"0\");\n    long x = std::stoll(\"\
    0\");\n    long y = std::stoll(\"0\");\n    long z = std::stoll(\"0\");\n    long\
    \ a = std::stoll(\"0\");\n    long b = std::stoll(\"0\");\n    long c = std::stoll(\"\
    0\");\n    long d = std::stoll(\"0\");\n    long e = std::stoll(\"0\");\n    long\
    \ f = std::stoll(\"0\");\n    long g = std::stoll(\"0\");\n    long h = std::stoll(\"\
    0\");\n    long i = std::stoll(\"0\");\n    long j = std::stoll(\"0\");\n    long\
    \ k = std::stoll(\"0\");\n    long l = std::stoll(\"0\");\n    long m = std::stoll(\"\
    0\");\n    long n = std::stoll(\"0\");\n    long o = std::stoll(\"0\");\n    long\
    \ p = std::stoll(\"0\");\n    long q = std::stoll(\"0\");\n    long r = std::stoll(\"\
    0\");\n    long s = std::stoll(\"0\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq1z8kbv4.cpp:60:25: warning: missing terminating \" character\n\
    \   60 |     long s = std::stoll(\"0\n      |                         ^\n/tmp/tmpq1z8kbv4.cpp:60:25:\
    \ error: missing terminating \" character\n   60 |     long s = std::stoll(\"\
    0\n      |                         ^~\n/tmp/tmpq1z8kbv4.cpp: In function \u2018\
    long int closest_integer(std::string)\u2019:\n/tmp/tmpq1z8kbv4.cpp:19:10: error:\
    \ redeclaration of \u2018long int d\u2019\n   19 |     long d = std::stoll(\"\
    0\");\n      |          ^\n/tmp/tmpq1z8kbv4.cpp:15:10: note: \u2018long int d\u2019\
    \ previously declared here\n   15 |     long d = std::stoll(value);\n      | \
    \         ^\n/tmp/tmpq1z8kbv4.cpp:42:10: error: redeclaration of \u2018long int\
    \ a\u2019\n   42 |     long a = std::stoll(\"0\");\n      |          ^\n/tmp/tmpq1z8kbv4.cpp:16:10:\
    \ note: \u2018long int a\u2019 previously declared here\n   16 |     long a =\
    \ std::stoll(\"0\");\n      |          ^\n/tmp/tmpq1z8kbv4.cpp:43:10: error: redeclaration\
    \ of \u2018long int b\u2019\n   43 |     long b = std::stoll(\"0\");\n      |\
    \          ^\n/tmp/tmpq1z8kbv4.cpp:17:10: note: \u2018long int b\u2019 previously\
    \ declared here\n   17 |     long b = std::stoll(\"9\");\n      |          ^\n\
    /tmp/tmpq1z8kbv4.cpp:44:10: error: redeclaration of \u2018long int c\u2019\n \
    \  44 |     long c = std::stoll(\"0\");\n      |          ^\n/tmp/tmpq1z8kbv4.cpp:18:10:\
    \ note: \u2018long int c\u2019 previously declared here\n   18 |     long c =\
    \ std::stoll(\"10\");\n      |          ^\n/tmp/tmpq1z8kbv4.cpp:45:10: error:\
    \ redeclaration of \u2018long int d\u2019\n   45 |     long d = std::stoll(\"\
    0\");\n      |          ^\n/tmp/tmpq1z8kbv4.cpp:15:10: note: \u2018long int d\u2019\
    \ previously declared here\n   15 |     long d = std::stoll(value);\n      | \
    \         ^\n/tmp/tmpq1z8kbv4.cpp:46:10: error: redeclaration of \u2018long int\
    \ e\u2019\n   46 |     long e = std::stoll(\"0\");\n      |          ^\n/tmp/tmpq1z8kbv4.cpp:20:10:\
    \ note: \u2018long int e\u2019 previously declared here\n   20 |     long e =\
    \ std::stoll(\"0\");\n      |          ^\n/tmp/tmpq1z8kbv4.cpp:47:10: error: redeclaration\
    \ of \u2018long int f\u2019\n   47 |     long f = std::stoll(\"0\");\n      |\
    \          ^\n/tmp/tmpq"
  stdout: ''
  timestamp: 1660141609
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long temp = 0;\n    long sum = 0;\n    long count = 0;\n    long temp2 =\
    \ 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long\
    \ temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n\
    \    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13\
    \ = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n   \
    \ long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20\
    \ = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n   \
    \ long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27\
    \ = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n   \
    \ long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34\
    \ = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n   \
    \ long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41\
    \ = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n   \
    \ long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48\
    \ = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n   \
    \ long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55\
    \ = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n   \
    \ long temp59 = 0;\n    long temp60 = 0;\n    long temp61 = 0;\n    long temp62\
    \ = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n    long temp65 = 0;\n   \
    \ long temp66 = 0;\n    long temp67 = 0;\n    long temp68 = 0;\n    long temp69\
    \ = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n    long temp72 = 0;\n   \
    \ long temp73 = 0;\n    long temp74 = 0;\n    long temp75 = 0;\n    long temp76\
    \ = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n    long temp79 = 0;\n   \
    \ long temp80 = 0;\n    long temp81 = 0;\n    long temp82 = 0;\n    long temp83\
    \ = 0;\n\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpyf5093ow: /tmp/tmpyf5093ow.cpp:104: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141609
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = std::stoll(value);\n  \
    \  if (ans < 0) {\n        ans = -ans;\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpey16nsa7: /tmp/tmpey16nsa7.cpp:22: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int x = 0;\n    long long\
    \ int y = 0;\n    long long int z = 0;\n    long long int count = 0;\n    long\
    \ long int max = 0;\n    long long int min = 0;\n    long long int mid = 0;\n\
    \    long long int xcount = 0;\n    long long int ycount = 0;\n    long long int\
    \ zcount = 0;\n    long long int xmin = 0;\n    long long int ymin = 0;\n    long\
    \ long int zmin = 0;\n    long long int xmid = 0;\n    long long int ymid = 0;\n\
    \    long long int zmid = 0;\n    long long int xmax = 0;\n    long long int ymax\
    \ = 0;\n    long long int zmax = 0;\n    long long int xmin1 = 0;\n    long long\
    \ int ymin1 = 0;\n    long long int zmin1 = 0;\n    long long int xmid1 = 0;\n\
    \    long long int ymid1 = 0;\n    long long int zmid1 = 0;\n    long long int\
    \ xmax1 = 0;\n    long long int ymax1 = 0;\n    long long int zmax1 = 0;\n   \
    \ long long int xmin2 = 0;\n    long long int ymin2 = 0;\n    long long int zmin2\
    \ = 0;\n    long long int xmid2 = 0;\n    long long int ymid2 = 0;\n    long long\
    \ int zmid2 = 0;\n    long long int xmax2 = 0;\n    long long int ymax2 = 0;\n\
    \    long long int zmax2 = 0;\n    long long int xmin3 = 0;\n    long long int\
    \ ymin3 = 0;\n    long long int zmin3 = 0;\n    long long int xmid3 = 0;\n   \
    \ long long int ymid3 = 0;\n    long long int zmid3 = 0;\n    long long int xmax3\
    \ = 0;\n    long long int ymax3 = 0;\n    long long int zmax3 = 0;\n    long long\
    \ int xmin4 = 0;\n    long long int ymin4 = 0;\n    long long int zmin4 = 0;\n\
    \    long long int xmid4 = 0;\n    long long int ymid4 = 0;\n    long long int\
    \ zmid4 = 0;\n    long long int xmax4 = 0;\n    long long int ymax4 = 0;\n   \
    \ long long int zmax4 = 0;\n    long long int xmin5 = 0;\n    long long int ymin5\
    \ = 0;\n    long long int zmin5 = 0;\n    long long int xmid5 = 0;\n    long long\
    \ int ymid5 = 0;\n    long long int zmid5 = 0;\n    long long int xmax5 = 0;\n\
    \    long long int ymax5 = 0;\n    long long int zmax5 = 0;\n    long long int\
    \ xmin6 = 0;\n    long long int ymin6 = 0;\n    long long int zmin6 = 0;\n   \
    \ long \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpghzonjvu.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpghzonjvu.cpp:81:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   81 | }\n      | ^\n/tmp/tmpghzonjvu.cpp:81:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141608
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp;\n    temp = std::stoll(value);\n    diff = temp - ans;\n    ans =\
    \ temp;\n    if (diff < 0) {\n        diff = diff * -1;\n    }\n    if (diff ==\
    \ 0) {\n        return ans;\n    }\n    if (diff > 0 && diff < 1) {\n        return\
    \ ans;\n    }\n    if (diff > 1) {\n        diff = diff - 1;\n    }\n    return\
    \ ans + diff;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpjrcvzw2w: /tmp/tmpjrcvzw2w.cpp:34: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141609
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ n = stoi(value);\n    long m = stoi(value);\n    long d = n - m;\n    long r\
    \ = std::abs(d);\n    if (r > 0) {\n        ans = m;\n        diff = d;\n    }\n\
    \    else {\n        ans = n;\n        diff = -r;\n    }\n    return ans;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp6srw9dwu: /tmp/tmp6srw9dwu.cpp:31: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141609
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp;\n    temp = std::stoll(value);\n    diff = temp - ans;\n    if (diff\
    \ < 0) {\n        diff = diff * -1;\n    }\n    ans = temp;\n    if (diff == 0)\
    \ {\n        return ans;\n    }\n    if (diff > 0) {\n        return ans + 1;\n\
    \    }\n    return ans - 1;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpapgfszv9: /tmp/tmpapgfszv9.cpp:31: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long temp = 0;\n    long sum = 0;\n    long count = 0;\n    long i = 0;\n\
    \    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m = 0;\n    long\
    \ n = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n    long r = 0;\n\
    \    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n    long\
    \ w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long A = 0;\n\
    \    long B = 0;\n    long C = 0;\n    long D = 0;\n    long E = 0;\n    long\
    \ F = 0;\n    long G = 0;\n    long H = 0;\n    long I = 0;\n    long J = 0;\n\
    \    long K = 0;\n    long L = 0;\n    long M = 0;\n    long N = 0;\n    long\
    \ O = 0;\n    long P = 0;\n    long Q = 0;\n    long R = 0;\n    long S = 0;\n\
    \    long T = 0;\n    long U = 0;\n    long V = 0;\n    long W = 0;\n    long\
    \ X = 0;\n    long Y = 0;\n    long Z = 0;\n    long a = 0;\n    long b = 0;\n\
    \    long c = 0;\n    long d = 0;\n    long e = 0;\n    long f = 0;\n    long\
    \ g = 0;\n    long h = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n\
    \    long l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n    long\
    \ p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n\
    \    long u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n    long\
    \ y = 0;\n    long z = 0;\n    long A = 0;\n    long B = 0;\n    long C = 0;\n\
    \    long D = 0;\n    long E = 0;\n    long F = 0;\n    long G = 0;\n    long\
    \ H = 0;\n    long I = 0;\n    long J = 0;\n    long K = 0;\n    long L = 0;\n\
    \    long M = 0;\n    long N = 0;\n    long O = 0;\n    long P = 0;\n    long\
    \ Q = 0;\n    long R = 0;\n    long S = 0;\n    long T = 0;\n    long U = 0;\n\
    \    long V = 0;\n    long W = 0;\n    long X = 0;\n    long Y = 0;\n    long\
    \ Z = 0;\n    long a = 0;\n    long b = 0;\n    long c = 0;\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp12yrkkq9.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp12yrkkq9.cpp:70:10: error: redeclaration of \u2018long int i\u2019\n\
    \   70 |     long i = 0;\n      |          ^\n/tmp/tmp12yrkkq9.cpp:18:10: note:\
    \ \u2018long int i\u2019 previously declared here\n   18 |     long i = 0;\n \
    \     |          ^\n/tmp/tmp12yrkkq9.cpp:71:10: error: redeclaration of \u2018\
    long int j\u2019\n   71 |     long j = 0;\n      |          ^\n/tmp/tmp12yrkkq9.cpp:19:10:\
    \ note: \u2018long int j\u2019 previously declared here\n   19 |     long j =\
    \ 0;\n      |          ^\n/tmp/tmp12yrkkq9.cpp:72:10: error: redeclaration of\
    \ \u2018long int k\u2019\n   72 |     long k = 0;\n      |          ^\n/tmp/tmp12yrkkq9.cpp:20:10:\
    \ note: \u2018long int k\u2019 previously declared here\n   20 |     long k =\
    \ 0;\n      |          ^\n/tmp/tmp12yrkkq9.cpp:73:10: error: redeclaration of\
    \ \u2018long int l\u2019\n   73 |     long l = 0;\n      |          ^\n/tmp/tmp12yrkkq9.cpp:21:10:\
    \ note: \u2018long int l\u2019 previously declared here\n   21 |     long l =\
    \ 0;\n      |          ^\n/tmp/tmp12yrkkq9.cpp:74:10: error: redeclaration of\
    \ \u2018long int m\u2019\n   74 |     long m = 0;\n      |          ^\n/tmp/tmp12yrkkq9.cpp:22:10:\
    \ note: \u2018long int m\u2019 previously declared here\n   22 |     long m =\
    \ 0;\n      |          ^\n/tmp/tmp12yrkkq9.cpp:75:10: error: redeclaration of\
    \ \u2018long int n\u2019\n   75 |     long n = 0;\n      |          ^\n/tmp/tmp12yrkkq9.cpp:23:10:\
    \ note: \u2018long int n\u2019 previously declared here\n   23 |     long n =\
    \ 0;\n      |          ^\n/tmp/tmp12yrkkq9.cpp:76:10: error: redeclaration of\
    \ \u2018long int o\u2019\n   76 |     long o = 0;\n      |          ^\n/tmp/tmp12yrkkq9.cpp:24:10:\
    \ note: \u2018long int o\u2019 previously declared here\n   24 |     long o =\
    \ 0;\n      |          ^\n/tmp/tmp12yrkkq9.cpp:77:10: error: redeclaration of\
    \ \u2018long int p\u2019\n   77 |     long p = 0;\n      |          ^\n/tmp/tmp12yrkkq9.cpp:25:10:\
    \ note: \u2018long int p\u2019 previously declared here\n   25 |     long p =\
    \ 0;\n      |          ^\n/tmp/tmp12yrkkq9.cpp:78:10: error: redeclaration of\
    \ \u2018long int q\u2019\n   78 |     long q = 0;\n      |          ^\n/tmp/tmp1"
  stdout: ''
  timestamp: 1660141609
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ temp;\n    long mod = pow(10, value.size());\n    long digits = value.size();\n\
    \    long power = digits - 1;\n    long i = 0;\n    long count = 0;\n    long\
    \ tempCount = 0;\n    long tempDiff = 0;\n    long tempMod = 0;\n    long tempPower\
    \ = 0;\n    long tempI = 0;\n    long tempCount2 = 0;\n    long tempDiff2 = 0;\n\
    \    long tempMod2 = 0;\n    long tempPower2 = 0;\n    long tempI2 = 0;\n    long\
    \ tempCount3 = 0;\n    long tempDiff3 = 0;\n    long tempMod3 = 0;\n    long tempPower3\
    \ = 0;\n    long tempI3 = 0;\n    long tempCount4 = 0;\n    long tempDiff4 = 0;\n\
    \    long tempMod4 = 0;\n    long tempPower4 = 0;\n    long tempI4 = 0;\n    long\
    \ tempCount5 = 0;\n    long tempDiff5 = 0;\n    long tempMod5 = 0;\n    long tempPower5\
    \ = 0;\n    long tempI5 = 0;\n    long tempCount6 = 0;\n    long tempDiff6 = 0;\n\
    \    long tempMod6 = 0;\n    long tempPower6 = 0;\n    long tempI6 = 0;\n    long\
    \ tempCount7 = 0;\n    long tempDiff7 = 0;\n    long tempMod7 = 0;\n    long tempPower7\
    \ = 0;\n    long tempI7 = 0;\n    long tempCount8 = 0;\n    long tempDiff8 = 0;\n\
    \    long tempMod8 = 0;\n    long tempPower8 = 0;\n    long tempI8 = 0;\n    long\
    \ tempCount9 = 0;\n    long tempDiff9 = 0;\n    long tempMod9 = 0;\n    long tempPower9\
    \ = 0;\n    long tempI9 = 0;\n    long tempCount10 = 0;\n    long tempDiff10 =\
    \ 0;\n    long tempMod10 = 0;\n    long tempPower10 = 0;\n    long tempI10 = 0;\n\
    \    long tempCount11 = 0;\n    long tempDiff11 = 0;\n    long tempMod11 = 0;\n\
    \    long tempPower11 = 0;\n    long tempI11 = 0;\n    long tempCount12 = 0;\n\
    \    long tempDiff12 = 0;\n    long tempMod12 = 0;\n    long tempPower12 = 0;\n\
    \    long tempI12 = 0;\n    long tempCount13 = 0;\n    long tempDiff13 = 0;\n\
    \    long tempMod13 = 0;\n    long tempPower13 = 0;\n    long tempI13 = 0;\n \
    \   long tempCount14 = 0;\n    long tempDiff14 = 0;\n    long tempMod14 = 0;\n\
    \    long tempPower14 = 0;\n    long tempI14 = 0;\n    \n}\nint main() {\n   \
    \ auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpd2ufz6e1: /tmp/tmpd2ufz6e1.cpp:94: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n\
    \    long mid = 0;\n    long diff = 0;\n    long closest = 0;\n    // Find the\
    \ first integer\n    std::string::size_type pos = value.find_first_of(\"0123456789\"\
    );\n    if (pos == std::string::npos) {\n        throw std::invalid_argument(\"\
    Invalid input\");\n    }\n    std::string integer = value.substr(0, pos);\n  \
    \  // Find the second integer\n    pos = value.find_first_of(\"0123456789\", pos\
    \ + 1);\n    if (pos == std::string::npos) {\n        throw std::invalid_argument(\"\
    Invalid input\");\n    }\n    std::string integer = value.substr(pos + 1, std::string::npos);\n\
    \    // Find the midpoint\n    pos = integer.find_first_of(\".\");\n    if (pos\
    \ == std::string::npos) {\n        mid = std::stoi(integer);\n    } else {\n \
    \       mid = std::stoi(integer.substr(0, pos));\n        diff = std::stoi(integer.substr(pos\
    \ + 1));\n    }\n    // Find the closest integer\n    while (lower <= upper) {\n\
    \        mid = (lower + upper) / 2;\n        diff = std::abs(mid - std::stoi(integer));\n\
    \        if (diff < std::numeric_limits<long>::max()) {\n            closest =\
    \ mid;\n            upper = mid;\n        } else {\n            lower = mid +\
    \ 1;\n        }\n    }\n    return closest;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppp35v9cy.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmppp35v9cy.cpp:28:17: error: redeclaration of \u2018std::string integer\u2019\
    \n   28 |     std::string integer = value.substr(pos + 1, std::string::npos);\n\
    \      |                 ^~~~~~~\n/tmp/tmppp35v9cy.cpp:22:17: note: \u2018std::string\
    \ integer\u2019 previously declared here\n   22 |     std::string integer = value.substr(0,\
    \ pos);\n      |                 ^~~~~~~\n"
  stdout: ''
  timestamp: 1660141609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n\
    \    long mid = 0;\n    long diff = std::numeric_limits<long>::max();\n    long\
    \ closest = 0;\n    long diff2 = std::numeric_limits<long>::max();\n    long diff3\
    \ = std::numeric_limits<long>::max();\n    long diff4 = std::numeric_limits<long>::max();\n\
    \    long diff5 = std::numeric_limits<long>::max();\n    long diff6 = std::numeric_limits<long>::max();\n\
    \    long diff7 = std::numeric_limits<long>::max();\n    long diff8 = std::numeric_limits<long>::max();\n\
    \    long diff9 = std::numeric_limits<long>::max();\n    long diff10 = std::numeric_limits<long>::max();\n\
    \    long diff11 = std::numeric_limits<long>::max();\n    long diff12 = std::numeric_limits<long>::max();\n\
    \    long diff13 = std::numeric_limits<long>::max();\n    long diff14 = std::numeric_limits<long>::max();\n\
    \    long diff15 = std::numeric_limits<long>::max();\n    long diff16 = std::numeric_limits<long>::max();\n\
    \    long diff17 = std::numeric_limits<long>::max();\n    long diff18 = std::numeric_limits<long>::max();\n\
    \    long diff19 = std::numeric_limits<long>::max();\n    long diff20 = std::numeric_limits<long>::max();\n\
    \    long diff21 = std::numeric_limits<long>::max();\n    long diff22 = std::numeric_limits<long>::max();\n\
    \    long diff23 = std::numeric_limits<long>::max();\n    long diff24 = std::numeric_limits<long>::max();\n\
    \    long diff25 = std::numeric_limits<long>::max();\n    long diff26 = std::numeric_limits<long>::max();\n\
    \    long diff27 = std::numeric_limits<long>::max();\n    long diff28 = std::numeric_limits<long>::max();\n\
    \    long diff29 = std::numeric_limits<long>::max();\n    long diff30 = std::numeric_limits<long>::max();\n\
    \    long diff31 = std::numeric_limits<long>::max();\n    long diff32 = std::numeric_limits<long>::max();\n\
    \    long diff33 = std::numeric_limits<long>::max();\n    long diff34 = std::numeric_limits<long>::max();\n\
    \    long diff35 = std::numeric_limits<long>::max();\n    long diff36 = std::numeric_limits<\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2d0884vi.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp2d0884vi.cpp:51:38: error: template argument 1 is invalid\n   51 |\
    \     long diff36 = std::numeric_limits<\n      |                            \
    \          ^\n/tmp/tmp2d0884vi.cpp:52:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   52 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660141606
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, diff = 0;\n    long long temp;\n    temp = atof(value.c_str());\n    diff\
    \ = temp - ans;\n    ans = temp;\n    if (diff < 0) {\n        diff += temp;\n\
    \    }\n    diff = diff * -1;\n    return diff;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp2jissyti: /tmp/tmp2jissyti.cpp:27: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n\
    \    long diff = std::abs(value - lower);\n    long mid = diff / 2;\n    long\
    \ midValue = std::abs(mid - lower);\n    if (midValue < diff) {\n        mid =\
    \ diff / 2;\n        midValue = std::abs(mid - lower);\n    }\n    if (midValue\
    \ < diff) {\n        mid = diff / 2;\n        midValue = std::abs(mid - lower);\n\
    \    }\n    if (midValue < diff) {\n        mid = diff / 2;\n        midValue\
    \ = std::abs(mid - lower);\n    }\n    if (midValue < diff) {\n        mid = diff\
    \ / 2;\n        midValue = std::abs(mid - lower);\n    }\n    if (midValue < diff)\
    \ {\n        mid = diff / 2;\n        midValue = std::abs(mid - lower);\n    }\n\
    \    if (midValue < diff) {\n        mid = diff / 2;\n        midValue = std::abs(mid\
    \ - lower);\n    }\n    if (midValue < diff) {\n        mid = diff / 2;\n    \
    \    midValue = std::abs(mid - lower);\n    }\n    if (midValue < diff) {\n  \
    \      mid = diff / 2;\n        midValue = std::abs(mid - lower);\n    }\n   \
    \ if (midValue < diff) {\n        mid = diff / 2;\n        midValue = std::abs(mid\
    \ - lower);\n    }\n    if (midValue < diff) {\n        mid = diff / 2;\n    \
    \    midValue = std::abs(mid - lower);\n    }\n    if (midValue < diff) {\n  \
    \      mid = diff / 2;\n        midValue = std::abs(mid - lower);\n    }\n   \
    \ if (midValue < diff) {\n        mid = diff / 2;\n        midValue = std::abs(mid\
    \ - lower);\n    }\n    if (midValue < diff) {\n        mid = diff / 2;\n    \
    \    midValue = std::abs(mid - lower);\n    }\n    if (midValue < diff) {\n  \
    \      mid = diff / 2;\n        midValue = std::abs(mid - lower);\n    }\n   \
    \ if (midValue < diff) {\n        mid = diff / 2;\n        midValue = std::abs(mid\
    \ - lower);\n    }\n    if (midValue < diff) {\n        mid = diff / 2;\n    \
    \    midValue = std::abs(mid - lower);\n    }\n    if (midValue < diff) {\n  \
    \      mid = diff / 2;\n        midValue = std::abs(mid - lower);\n    }\n   \
    \ if (midValue < diff) {\n        \n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpus87wa42.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpus87wa42.cpp:14:32: error: no match for \u2018operator-\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018long int\u2019)\n   14 |     long diff = std::abs(value - lower);\n\
    \      |                          ~~~~~ ^ ~~~~~\n      |                     \
    \     |       |\n      |                          |       long int\n      |  \
    \                        std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpus87wa42.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:415:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> constexpr\
    \ decltype ((__y.base() - __x.base())) std::operator-(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_IteratorR>&)\u2019\n  415 |     operator-(const\
    \ reverse_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:415:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpus87wa42.cpp:14:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   14\
    \ |     long diff = std::abs(value - lower);\n      |                        \
    \          ^~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpus87wa42.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1209:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> constexpr\
    \ decltype ((__x.base() - __y.base())) std::operator-(const std::move_iterator<_IteratorL>&,\
    \ const std::"
  stdout: ''
  timestamp: 1660141609
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, diff = 0, i = 0;\n    long long temp = 0;\n    while(i < value.size()) {\n\
    \        temp = std::stoll(value.substr(i, 1));\n        diff = std::abs(temp\
    \ - ans);\n        if(diff < diff) {\n            ans = temp;\n        }\n   \
    \     i++;\n    }\n    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp166z9vns: /tmp/tmp166z9vns.cpp:28: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n\
    \    long mid = 0;\n    long diff = 0;\n    long closest = 0;\n    long midval\
    \ = 0;\n    long midval2 = 0;\n    long midval3 = 0;\n    long midval4 = 0;\n\
    \    long midval5 = 0;\n    long midval6 = 0;\n    long midval7 = 0;\n    long\
    \ midval8 = 0;\n    long midval9 = 0;\n    long midval10 = 0;\n    long midval11\
    \ = 0;\n    long midval12 = 0;\n    long midval13 = 0;\n    long midval14 = 0;\n\
    \    long midval15 = 0;\n    long midval16 = 0;\n    long midval17 = 0;\n    long\
    \ midval18 = 0;\n    long midval19 = 0;\n    long midval20 = 0;\n    long midval21\
    \ = 0;\n    long midval22 = 0;\n    long midval23 = 0;\n    long midval24 = 0;\n\
    \    long midval25 = 0;\n    long midval26 = 0;\n    long midval27 = 0;\n    long\
    \ midval28 = 0;\n    long midval29 = 0;\n    long midval30 = 0;\n    long midval31\
    \ = 0;\n    long midval32 = 0;\n    long midval33 = 0;\n    long midval34 = 0;\n\
    \    long midval35 = 0;\n    long midval36 = 0;\n    long midval37 = 0;\n    long\
    \ midval38 = 0;\n    long midval39 = 0;\n    long midval40 = 0;\n    long midval41\
    \ = 0;\n    long midval42 = 0;\n    long midval43 = 0;\n    long midval44 = 0;\n\
    \    long midval45 = 0;\n    long midval46 = 0;\n    long midval47 = 0;\n    long\
    \ midval48 = 0;\n    long midval49 = 0;\n    long midval50 = 0;\n    long midval51\
    \ = 0;\n    long midval52 = 0;\n    long midval53 = 0;\n    long midval54 = 0;\n\
    \    long midval55 = 0;\n    long midval56 = 0;\n    long midval57 = 0;\n    long\
    \ midval58 = 0;\n    long midval59 = 0;\n    long midval60 = 0;\n    long midval61\
    \ = 0;\n    long midval62 = 0;\n    long midval63 = 0;\n    long midval64 = 0;\n\
    \    long midval65 = 0;\n    long midval66 = 0;\n    long midval67 = 0;\n    long\
    \ midval68 = 0;\n    long midval69 = 0;\n    long mid\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp9wsakih7.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp9wsakih7.cpp:87:1: error: expected initializer before \u2018}\u2019\
    \ token\n   87 | }\n      | ^\n/tmp/tmp9wsakih7.cpp:87:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141609
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num = std::stoll(value);\n\
    \    long long int lower = num - 1;\n    long long int upper = num + 1;\n    long\
    \ long int mid;\n    if (lower > upper) {\n        mid = lower;\n    } else {\n\
    \        mid = upper;\n    }\n    long long int midVal = std::stoll(value);\n\
    \    if (mid > midVal) {\n        mid = midVal;\n    }\n    long long int diff\
    \ = abs(mid - num);\n    if (diff < 1) {\n        return mid;\n    }\n    return\
    \ num;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpt6exos8h: /tmp/tmpt6exos8h.cpp:35: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n\
    \    long mid = 0;\n    long diff = 0;\n    long closest = 0;\n    long count\
    \ = 0;\n    long pos = 0;\n    long neg = 0;\n    long last = 0;\n    long lastpos\
    \ = 0;\n    long lastneg = 0;\n    long lastlast = 0;\n    long lastlastpos =\
    \ 0;\n    long lastlastneg = 0;\n    long lastlastlast = 0;\n    long lastlastlastpos\
    \ = 0;\n    long lastlastlastneg = 0;\n    long lastlastlastlast = 0;\n    long\
    \ lastlastlastlastpos = 0;\n    long lastlastlastlastneg = 0;\n    long lastlastlastlastlast\
    \ = 0;\n    long lastlastlastlastpos = 0;\n    long lastlastlastlastneg = 0;\n\
    \    long lastlastlastlastlast = 0;\n    long lastlastlastlastpos = 0;\n    long\
    \ lastlastlastlastneg = 0;\n    long lastlastlastlastlast = 0;\n    long lastlastlastlastpos\
    \ = 0;\n    long lastlastlastlastneg = 0;\n    long lastlastlastlastlast = 0;\n\
    \    long lastlastlastlastpos = 0;\n    long lastlastlastlastneg = 0;\n    long\
    \ lastlastlastlastlast = 0;\n    long lastlastlastlastpos = 0;\n    long lastlastlastlastneg\
    \ = 0;\n    long lastlastlastlastlast = 0;\n    long lastlastlastlastpos = 0;\n\
    \    long lastlastlastlastneg = 0;\n    long lastlastlastlastlast = 0;\n    long\
    \ lastlastlastlastpos = 0;\n    long lastlastlastlastneg = 0;\n    long lastlastlastlastlast\
    \ = 0;\n    long lastlastlastlastpos = 0;\n    long lastlastlastlastneg = 0;\n\
    \    long lastlastlastlastlast = 0;\n    long lastlastlastlastpos = 0;\n    long\
    \ lastlastlastlastneg = 0;\n    long lastlastlastlastlast = 0;\n    long lastlastlastlastpos\
    \ = 0;\n    long lastlastlastlastneg = 0;\n    long lastlastlastlastlast = 0;\n\
    \    long lastlastlastlastpos = 0;\n    long lastlastlastlastneg = 0;\n    long\
    \ lastlastlastlastlast = 0;\n    long lastlastlastlastpos = 0;\n    long lastlastlastlastneg\
    \ = 0;\n    long lastlastlastlastlast = 0;\n    long lastlastlastlastpos = 0;\n\
    \    long lastlastlastlastneg = 0;\n    long lastlastlastlastlast = 0;\n    long\
    \ lastlastlastlastpos = 0;\n    long lastlastlastlastneg = 0;\n    long last\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp57spdssa.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp57spdssa.cpp:33:10: error: redeclaration of \u2018long int lastlastlastlastpos\u2019\
    \n   33 |     long lastlastlastlastpos = 0;\n      |          ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp57spdssa.cpp:30:10: note: \u2018long int lastlastlastlastpos\u2019 previously\
    \ declared here\n   30 |     long lastlastlastlastpos = 0;\n      |          ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp57spdssa.cpp:34:10: error: redeclaration of \u2018long int lastlastlastlastneg\u2019\
    \n   34 |     long lastlastlastlastneg = 0;\n      |          ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp57spdssa.cpp:31:10: note: \u2018long int lastlastlastlastneg\u2019 previously\
    \ declared here\n   31 |     long lastlastlastlastneg = 0;\n      |          ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp57spdssa.cpp:35:10: error: redeclaration of \u2018long int lastlastlastlastlast\u2019\
    \n   35 |     long lastlastlastlastlast = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp57spdssa.cpp:32:10: note: \u2018long int lastlastlastlastlast\u2019 previously\
    \ declared here\n   32 |     long lastlastlastlastlast = 0;\n      |         \
    \ ^~~~~~~~~~~~~~~~~~~~\n/tmp/tmp57spdssa.cpp:36:10: error: redeclaration of \u2018\
    long int lastlastlastlastpos\u2019\n   36 |     long lastlastlastlastpos = 0;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~\n/tmp/tmp57spdssa.cpp:30:10: note: \u2018\
    long int lastlastlastlastpos\u2019 previously declared here\n   30 |     long\
    \ lastlastlastlastpos = 0;\n      |          ^~~~~~~~~~~~~~~~~~~\n/tmp/tmp57spdssa.cpp:37:10:\
    \ error: redeclaration of \u2018long int lastlastlastlastneg\u2019\n   37 |  \
    \   long lastlastlastlastneg = 0;\n      |          ^~~~~~~~~~~~~~~~~~~\n/tmp/tmp57spdssa.cpp:31:10:\
    \ note: \u2018long int lastlastlastlastneg\u2019 previously declared here\n  \
    \ 31 |     long lastlastlastlastneg = 0;\n      |          ^~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp57spdssa.cpp:38:10: error: redeclaration of \u2018long int lastlastlastlastlast\u2019\
    \n   38 |     long lastlastlastlastlast = 0;\n      |          ^~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp57spdssa.cpp:32:10: note: \u2018long int lastlastlastlastlast\u2019 previously\
    \ declared here\n   3"
  stdout: ''
  timestamp: 1660141609
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n \
    \   long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8\
    \ = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long\
    \ temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n\
    \    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19\
    \ = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n   \
    \ long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26\
    \ = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n   \
    \ long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33\
    \ = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n   \
    \ long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40\
    \ = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n   \
    \ long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47\
    \ = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n   \
    \ long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54\
    \ = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n   \
    \ long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61\
    \ = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n   \
    \ long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68\
    \ = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n   \
    \ long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75\
    \ = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n   \
    \ long temp79 = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82\
    \ = 0;\n    long temp83 = 0;\n    long temp84 = 0;\n    long temp85 = 0;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp8wv4j_et: /tmp/tmp8wv4j_et.cpp:102: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141605
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ ans = 0;\n    long diff = std::abs(atoi(value.c_str()));\n    long mid = diff\
    \ / 2;\n    long left = diff - mid;\n    long right = diff + mid;\n    if (left\
    \ > right) {\n        ans = mid;\n    } else {\n        ans = right;\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n   \
    \ assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpn_t47psn: /tmp/tmpn_t47psn.cpp:28: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Declare a variable to hold the\
    \ closest integer to the given number\n    long closest;\n    // Declare a variable\
    \ to hold the difference between the given number\n    // and the closest integer\n\
    \    long difference;\n    // Declare a variable to hold the difference between\
    \ the given number\n    // and the closest integer\n    long closest_difference;\n\
    \    // Declare a variable to hold the difference between the given number\n \
    \   // and the closest integer\n    long closest_closest_difference;\n    // Declare\
    \ a variable to hold the difference between the given number\n    // and the closest\
    \ integer\n    long closest_closest_closest_difference;\n    // Declare a variable\
    \ to hold the difference between the given number\n    // and the closest integer\n\
    \    long closest_closest_closest_closest_difference;\n    // Declare a variable\
    \ to hold the difference between the given number\n    // and the closest integer\n\
    \    long closest_closest_closest_closest_closest_difference;\n    // Declare\
    \ a variable to hold the difference between the given number\n    // and the closest\
    \ integer\n    long closest_closest_closest_closest_closest_closest_difference;\n\
    \    // Declare a variable to hold the difference between the given number\n \
    \   // and the closest integer\n    long closest_closest_closest_closest_closest_closest_closest_difference;\n\
    \    // Declare a variable to hold the difference between the given number\n \
    \   // and the closest integer\n    long closest_closest_closest_closest_closest_closest_closest_difference;\n\
    \    // Declare a variable to hold the difference between the given number\n \
    \   // and the closest integer\n    long closest_closest_closest_closest_closest_closest_closest_difference;\n\
    \    // Declare a variable to hold the difference between the given number\n \
    \   // and the closest integer\n    long closest_closest_closest_closest_closest_closest_closest_closest_closest_difference;\n\
    \    // Declare a variable to hold the difference between the given number\n \
    \   // and the closest integer\n    long closest_closest_closest_closest_closest_closest_closest_closest_difference;\n\
    \    // Declare a variable to hold the difference between the given number\n \
    \   // and the closest integer\n    long closest_closest_closest_closest_closest_closest_closest_closest_closest_difference;\n\
    \    // Declare a variable to hold the difference between the given number\n \
    \   // and the closest integer\n    long closest_closest_closest_closest_closest_closest_closest_closest_closest_difference;\n\
    \    // Declare a variable to hold the difference between the given number\n \
    \   // and the closest integer\n    long closest_closest_closest_closest_closest_closest_closest_closest_closest_difference;\n\
    \    // Declare a variable to hold the difference between the given number\n \
    \   // and the closest integer\n    long closest_closest_closest_closest_closest_closest_closest_closest_closest_difference;\n\
    \    // Declare a variable to hold the difference between the given number\n \
    \   // and the closest integer\n    long closest_closest_closest_closest_closest_closest_closest_closest_closest_closest_\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5tl057v1.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp5tl057v1.cpp:41:10: error: redeclaration of \u2018long int closest_closest_closest_closest_closest_closest_closest_difference\u2019\
    \n   41 |     long closest_closest_closest_closest_closest_closest_closest_difference;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5tl057v1.cpp:38:10: note: \u2018long int closest_closest_closest_closest_closest_closest_closest_difference\u2019\
    \ previously declared here\n   38 |     long closest_closest_closest_closest_closest_closest_closest_difference;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5tl057v1.cpp:44:10: error: redeclaration of \u2018long int closest_closest_closest_closest_closest_closest_closest_difference\u2019\
    \n   44 |     long closest_closest_closest_closest_closest_closest_closest_difference;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5tl057v1.cpp:38:10: note: \u2018long int closest_closest_closest_closest_closest_closest_closest_difference\u2019\
    \ previously declared here\n   38 |     long closest_closest_closest_closest_closest_closest_closest_difference;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5tl057v1.cpp:53:10: error: redeclaration of \u2018long int closest_closest_closest_closest_closest_closest_closest_closest_closest_difference\u2019\
    \n   53 |     long closest_closest_closest_closest_closest_closest_closest_closest_closest_difference;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5tl057v1.cpp:47:10: note: \u2018long int closest_closest_closest_closest_closest_closest_closest_closest_closest_difference\u2019\
    \ previously declared here\n   47 |     long closest_closest_closest_closest_closest_closest_closest_closest_closest_difference;\n\
    \      |          ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\
    /tmp/tmp5tl057v1.cpp:56:10: error:"
  stdout: ''
  timestamp: 1660141609
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int closest;\n    long long\
    \ int difference;\n    long long int temp;\n    long long int temp2;\n    long\
    \ long int temp3;\n    long long int temp4;\n    long long int temp5;\n    long\
    \ long int temp6;\n    long long int temp7;\n    long long int temp8;\n    long\
    \ long int temp9;\n    long long int temp10;\n    long long int temp11;\n    long\
    \ long int temp12;\n    long long int temp13;\n    long long int temp14;\n   \
    \ long long int temp15;\n    long long int temp16;\n    long long int temp17;\n\
    \    long long int temp18;\n    long long int temp19;\n    long long int temp20;\n\
    \    long long int temp21;\n    long long int temp22;\n    long long int temp23;\n\
    \    long long int temp24;\n    long long int temp25;\n    long long int temp26;\n\
    \    long long int temp27;\n    long long int temp28;\n    long long int temp29;\n\
    \    long long int temp30;\n    long long int temp31;\n    long long int temp32;\n\
    \    long long int temp33;\n    long long int temp34;\n    long long int temp35;\n\
    \    long long int temp36;\n    long long int temp37;\n    long long int temp38;\n\
    \    long long int temp39;\n    long long int temp40;\n    long long int temp41;\n\
    \    long long int temp42;\n    long long int temp43;\n    long long int temp44;\n\
    \    long long int temp45;\n    long long int temp46;\n    long long int temp47;\n\
    \    long long int temp48;\n    long long int temp49;\n    long long int temp50;\n\
    \    long long int temp51;\n    long long int temp52;\n    long long int temp53;\n\
    \    long long int temp54;\n    long long int temp55;\n    long long int temp56;\n\
    \    long long int temp57;\n    long long int temp58;\n    long long int temp59;\n\
    \    long long int temp60;\n    long long int temp61;\n    long long int temp62;\n\
    \    long long int temp63;\n    long long int temp64;\n    long long int temp65\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpo8omhn36.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpo8omhn36.cpp:80:1: error: expected initializer before \u2018}\u2019\
    \ token\n   80 | }\n      | ^\n/tmp/tmpo8omhn36.cpp:80:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = std::stoi(value);\n   \
    \ long diff = std::abs(ans - std::numeric_limits<long>::max());\n    if (diff\
    \ > std::numeric_limits<long>::max() / 2) {\n        diff = std::numeric_limits<long>::max()\
    \ - diff;\n    }\n    return std::abs(ans - diff);\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpln3frk1k: /tmp/tmpln3frk1k.cpp:22: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141610
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, sign = 1;\n    long num = std::stoll(value);\n    long diff = abs(num - ans);\n\
    \    if (diff > abs(num - ans)) {\n        sign = -1;\n    }\n    ans = num +\
    \ sign * diff;\n    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpubb_psk8: /tmp/tmpubb_psk8.cpp:25: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141610
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n\
    \    long mid = 0;\n    long diff = 0;\n    long closest = 0;\n    long diff2\
    \ = 0;\n    long closest2 = 0;\n    long mid2 = 0;\n    long mid3 = 0;\n    long\
    \ mid4 = 0;\n    long mid5 = 0;\n    long mid6 = 0;\n    long mid7 = 0;\n    long\
    \ mid8 = 0;\n    long mid9 = 0;\n    long mid10 = 0;\n    long mid11 = 0;\n  \
    \  long mid12 = 0;\n    long mid13 = 0;\n    long mid14 = 0;\n    long mid15 =\
    \ 0;\n    long mid16 = 0;\n    long mid17 = 0;\n    long mid18 = 0;\n    long\
    \ mid19 = 0;\n    long mid20 = 0;\n    long mid21 = 0;\n    long mid22 = 0;\n\
    \    long mid23 = 0;\n    long mid24 = 0;\n    long mid25 = 0;\n    long mid26\
    \ = 0;\n    long mid27 = 0;\n    long mid28 = 0;\n    long mid29 = 0;\n    long\
    \ mid30 = 0;\n    long mid31 = 0;\n    long mid32 = 0;\n    long mid33 = 0;\n\
    \    long mid34 = 0;\n    long mid35 = 0;\n    long mid36 = 0;\n    long mid37\
    \ = 0;\n    long mid38 = 0;\n    long mid39 = 0;\n    long mid40 = 0;\n    long\
    \ mid41 = 0;\n    long mid42 = 0;\n    long mid43 = 0;\n    long mid44 = 0;\n\
    \    long mid45 = 0;\n    long mid46 = 0;\n    long mid47 = 0;\n    long mid48\
    \ = 0;\n    long mid49 = 0;\n    long mid50 = 0;\n    long mid51 = 0;\n    long\
    \ mid52 = 0;\n    long mid53 = 0;\n    long mid54 = 0;\n    long mid55 = 0;\n\
    \    long mid56 = 0;\n    long mid57 = 0;\n    long mid58 = 0;\n    long mid59\
    \ = 0;\n    long mid60 = 0;\n    long mid61 = 0;\n    long mid62 = 0;\n    long\
    \ mid63 = 0;\n    long mid64 = 0;\n    long mid65 = 0;\n    long mid66 = 0;\n\
    \    long mid67 = 0;\n    long mid68 = 0;\n    long mid69 = 0;\n    long mid70\
    \ = 0;\n    long mid71 = 0;\n    long mid72 = 0;\n    long mid73 = 0;\n    long\
    \ mid74 = 0;\n    long mid75 = 0;\n    long mid76 = 0;\n    long mid77 = 0;\n\
    \    long mid78 = 0;\n    long mid79 = 0;\n    long mid80 = 0;\n    \n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpipcoq2i2: /tmp/tmpipcoq2i2.cpp:102: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141610
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long temp = 0;\n    long diff = 0;\n    long i = 0;\n    long j = 0;\n\
    \    long k = 0;\n    long l = 0;\n    long m = 0;\n    long n = 0;\n    long\
    \ o = 0;\n    long p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n\
    \    long t = 0;\n    long u = 0;\n    long v = 0;\n    long w = 0;\n    long\
    \ x = 0;\n    long y = 0;\n    long z = 0;\n    long aa = 0;\n    long bb = 0;\n\
    \    long cc = 0;\n    long dd = 0;\n    long ee = 0;\n    long ff = 0;\n    long\
    \ gg = 0;\n    long hh = 0;\n    long ii = 0;\n    long jj = 0;\n    long kk =\
    \ 0;\n    long ll = 0;\n    long mm = 0;\n    long nn = 0;\n    long oo = 0;\n\
    \    long pp = 0;\n    long qq = 0;\n    long rr = 0;\n    long ss = 0;\n    long\
    \ tt = 0;\n    long uu = 0;\n    long vv = 0;\n    long ww = 0;\n    long xx =\
    \ 0;\n    long yy = 0;\n    long zz = 0;\n    long aaa = 0;\n    long bbb = 0;\n\
    \    long ccc = 0;\n    long ddd = 0;\n    long eee = 0;\n    long fff = 0;\n\
    \    long ggg = 0;\n    long hhh = 0;\n    long iii = 0;\n    long jjj = 0;\n\
    \    long kkk = 0;\n    long lll = 0;\n    long mmm = 0;\n    long nnn = 0;\n\
    \    long ooo = 0;\n    long ppp = 0;\n    long qqq = 0;\n    long rrr = 0;\n\
    \    long sss = 0;\n    long ttt = 0;\n    long uuu = 0;\n    long vvv = 0;\n\
    \    long www = 0;\n    long xxx = 0;\n    long yyy = 0;\n    long zzz = 0;\n\
    \    long aaaa = 0;\n    long bbbb = 0;\n    long cccc = 0;\n    long dddd = 0;\n\
    \    long eeee = 0;\n    long ffff = 0;\n    long gggg = 0;\n    long hhhh = 0;\n\
    \    long iiii = 0;\n    long jjjj = 0;\n    long kkkk = 0;\n    long llll = 0;\n\
    \    long mmmm = 0;\n    long nnnn = 0;\n    long oooo = 0;\n    long pppp = 0;\n\
    \    long qqqq = 0;\n    long rrrr = 0;\n    long ssss = 0;\n    long tttt = 0;\n\
    \    long uuuu = 0;\n    long vvvv = 0;\n\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpcl5rgi3y: /tmp/tmpcl5rgi3y.cpp:113: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp = 0;\n    long long temp2 = 0;\n    long long temp3 = 0;\n    long\
    \ long temp4 = 0;\n    long long temp5 = 0;\n    long long temp6 = 0;\n    long\
    \ long temp7 = 0;\n    long long temp8 = 0;\n    long long temp9 = 0;\n    long\
    \ long temp10 = 0;\n    long long temp11 = 0;\n    long long temp12 = 0;\n   \
    \ long long temp13 = 0;\n    long long temp14 = 0;\n    long long temp15 = 0;\n\
    \    long long temp16 = 0;\n    long long temp17 = 0;\n    long long temp18 =\
    \ 0;\n    long long temp19 = 0;\n    long long temp20 = 0;\n    long long temp21\
    \ = 0;\n    long long temp22 = 0;\n    long long temp23 = 0;\n    long long temp24\
    \ = 0;\n    long long temp25 = 0;\n    long long temp26 = 0;\n    long long temp27\
    \ = 0;\n    long long temp28 = 0;\n    long long temp29 = 0;\n    long long temp30\
    \ = 0;\n    long long temp31 = 0;\n    long long temp32 = 0;\n    long long temp33\
    \ = 0;\n    long long temp34 = 0;\n    long long temp35 = 0;\n    long long temp36\
    \ = 0;\n    long long temp37 = 0;\n    long long temp38 = 0;\n    long long temp39\
    \ = 0;\n    long long temp40 = 0;\n    long long temp41 = 0;\n    long long temp42\
    \ = 0;\n    long long temp43 = 0;\n    long long temp44 = 0;\n    long long temp45\
    \ = 0;\n    long long temp46 = 0;\n    long long temp47 = 0;\n    long long temp48\
    \ = 0;\n    long long temp49 = 0;\n    long long temp50 = 0;\n    long long temp51\
    \ = 0;\n    long long temp52 = 0;\n    long long temp53 = 0;\n    long long temp54\
    \ = 0;\n    long long temp55 = 0;\n    long long temp56 = 0;\n    long long temp57\
    \ = 0;\n    long long temp58 = 0;\n    long long temp59 = 0;\n    long long temp60\
    \ = 0;\n    long long temp61 = 0;\n    long long temp62 = 0;\n    long long temp63\
    \ = 0;\n    long long temp64 = 0;\n    long long temp65 = 0;\n    long long temp66\
    \ = 0;\n    long long temp67 = 0;\n    long long temp68 = 0;\n    long long temp69\
    \ = 0;\n    long long temp70 = 0;\n    long long temp71 = 0;\n    long long temp72\
    \ = 0;\n    long long temp73\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjgxgzpwg.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpjgxgzpwg.cpp:87:1: error: expected initializer before \u2018}\u2019\
    \ token\n   87 | }\n      | ^\n/tmp/tmpjgxgzpwg.cpp:87:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = std::stoi(value);\n   \
    \ if (ans < 0)\n        ans = -ans;\n    long diff = ans - ans % 10;\n    ans\
    \ -= diff;\n    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpfcfho47_: /tmp/tmpfcfho47_.cpp:22: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141610
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = std::stoi(value);\n   \
    \ if (ans < 0) {\n        ans = ans * -1;\n    }\n    long diff = 0;\n    long\
    \ max = 0;\n    long min = 0;\n    long mid = 0;\n    long mid2 = 0;\n    long\
    \ mid3 = 0;\n    long mid4 = 0;\n    long mid5 = 0;\n    long mid6 = 0;\n    long\
    \ mid7 = 0;\n    long mid8 = 0;\n    long mid9 = 0;\n    long mid10 = 0;\n   \
    \ long mid11 = 0;\n    long mid12 = 0;\n    long mid13 = 0;\n    long mid14 =\
    \ 0;\n    long mid15 = 0;\n    long mid16 = 0;\n    long mid17 = 0;\n    long\
    \ mid18 = 0;\n    long mid19 = 0;\n    long mid20 = 0;\n    long mid21 = 0;\n\
    \    long mid22 = 0;\n    long mid23 = 0;\n    long mid24 = 0;\n    long mid25\
    \ = 0;\n    long mid26 = 0;\n    long mid27 = 0;\n    long mid28 = 0;\n    long\
    \ mid29 = 0;\n    long mid30 = 0;\n    long mid31 = 0;\n    long mid32 = 0;\n\
    \    long mid33 = 0;\n    long mid34 = 0;\n    long mid35 = 0;\n    long mid36\
    \ = 0;\n    long mid37 = 0;\n    long mid38 = 0;\n    long mid39 = 0;\n    long\
    \ mid40 = 0;\n    long mid41 = 0;\n    long mid42 = 0;\n    long mid43 = 0;\n\
    \    long mid44 = 0;\n    long mid45 = 0;\n    long mid46 = 0;\n    long mid47\
    \ = 0;\n    long mid48 = 0;\n    long mid49 = 0;\n    long mid50 = 0;\n    long\
    \ mid51 = 0;\n    long mid52 = 0;\n    long mid53 = 0;\n    long mid54 = 0;\n\
    \    long mid55 = 0;\n    long mid56 = 0;\n    long mid57 = 0;\n    long mid58\
    \ = 0;\n    long mid59 = 0;\n    long mid60 = 0;\n    long mid61 = 0;\n    long\
    \ mid62 = 0;\n    long mid63 = 0;\n    long mid64 = 0;\n    long mid65 = 0;\n\
    \    long mid66 = 0;\n    long mid67 = 0;\n    long mid68 = 0;\n    long mid69\
    \ = 0;\n    long mid70 = 0;\n    long mid71 = 0;\n    long mid72 = 0;\n    long\
    \ mid73 = 0;\n    long mid74 = 0;\n    long mid75 = 0;\n    long mid76 = 0;\n\
    \    long mid77 = 0;\n    long mid78 = 0;\n    long mid79 = 0;\n    long mid80\
    \ = 0;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpd50oh8zc: /tmp/tmpd50oh8zc.cpp:104: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4\
    \ = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long\
    \ temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n\
    \    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15\
    \ = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n   \
    \ long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22\
    \ = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n   \
    \ long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29\
    \ = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n   \
    \ long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36\
    \ = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n   \
    \ long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43\
    \ = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n   \
    \ long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50\
    \ = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n   \
    \ long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57\
    \ = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n   \
    \ long temp61 = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64\
    \ = 0;\n    long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n   \
    \ long temp68 = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71\
    \ = 0;\n    long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n   \
    \ long temp75 = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78\
    \ = 0;\n    long temp79 = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n   \
    \ long temp82 = 0;\n    long temp83 = 0;\n    long temp84 = 0;\n    long temp\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpul38oo9h.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpul38oo9h.cpp:100:1: error: expected initializer before \u2018}\u2019\
    \ token\n  100 | }\n      | ^\n/tmp/tmpul38oo9h.cpp:100:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141607
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, temp = 0;\n    long n = stoi(value);\n    long d = n - 1;\n    while (d >=\
    \ 0) {\n        temp = ans;\n        ans += d;\n        d = temp - ans;\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n   \
    \ assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpz2z3xo2j: /tmp/tmpz2z3xo2j.cpp:26: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141610
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ ans = 0, diff = 0;\n    long long temp;\n    temp = atof(value.c_str());\n \
    \   diff = temp - ans;\n    ans = temp;\n    if (diff < 0) {\n        diff = diff\
    \ * -1;\n    }\n    if (diff < 0.5) {\n        diff = diff * 2;\n    }\n    if\
    \ (diff > 0.5) {\n        diff = diff / 2;\n    }\n    return ans + diff;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpp06kbori: /tmp/tmpp06kbori.cpp:32: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141610
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp;\n    temp = std::stoll(value);\n    diff = temp - ans;\n    if (diff\
    \ < 0) {\n        diff = diff * -1;\n    }\n    ans = temp;\n    if (diff == 0)\
    \ {\n        return ans;\n    }\n    long long temp2 = ans;\n    while (temp2\
    \ != 0) {\n        temp2 = temp2 / 10;\n    }\n    return ans;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp6n3uk0ms: /tmp/tmp6n3uk0ms.cpp:33: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long temp = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long\
    \ l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n\
    \    long q = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n    long\
    \ u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n\
    \    long z = 0;\n    long A = 0;\n    long B = 0;\n    long C = 0;\n    long\
    \ D = 0;\n    long E = 0;\n    long F = 0;\n    long G = 0;\n    long H = 0;\n\
    \    long I = 0;\n    long J = 0;\n    long K = 0;\n    long L = 0;\n    long\
    \ M = 0;\n    long N = 0;\n    long O = 0;\n    long P = 0;\n    long Q = 0;\n\
    \    long R = 0;\n    long S = 0;\n    long T = 0;\n    long U = 0;\n    long\
    \ V = 0;\n    long W = 0;\n    long X = 0;\n    long Y = 0;\n    long Z = 0;\n\
    \    long aa = 0;\n    long bb = 0;\n    long cc = 0;\n    long dd = 0;\n    long\
    \ ee = 0;\n    long ff = 0;\n    long gg = 0;\n    long hh = 0;\n    long ii =\
    \ 0;\n    long jj = 0;\n    long kk = 0;\n    long ll = 0;\n    long mm = 0;\n\
    \    long nn = 0;\n    long oo = 0;\n    long pp = 0;\n    long qq = 0;\n    long\
    \ rr = 0;\n    long ss = 0;\n    long tt = 0;\n    long uu = 0;\n    long vv =\
    \ 0;\n    long ww = 0;\n    long xx = 0;\n    long yy = 0;\n    long zz = 0;\n\
    \    long Aa = 0;\n    long Bb = 0;\n    long Cc = 0;\n    long Dd = 0;\n    long\
    \ Ee = 0;\n    long Ff = 0;\n    long Gg = 0;\n    long Hh = 0;\n    long Ii =\
    \ 0;\n    long Jj = 0;\n    long Kk = 0;\n    long Ll = 0;\n    long Mm = 0;\n\
    \    long Nn = 0;\n    long Oo = 0;\n    long Pp = 0;\n    long Qq = 0;\n    long\
    \ Rr = 0;\n    long Ss = 0;\n    long Tt = 0;\n    long Uu = 0;\n    long Vv =\
    \ 0;\n    long Ww = 0;\n    long Xx = 0;\n    long Yy = 0;\n    long Z\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxevzbc6_.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpxevzbc6_.cpp:112:1: error: expected initializer before \u2018}\u2019\
    \ token\n  112 | }\n      | ^\n/tmp/tmpxevzbc6_.cpp:112:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141607
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, diff = 0;\n    long long temp;\n    temp = atof(value.c_str());\n    diff\
    \ = temp - ans;\n    ans = temp;\n    while(diff >= 0){\n        ans += 1;\n \
    \       diff -= 1;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp6zx3b3cr: /tmp/tmp6zx3b3cr.cpp:27: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141610
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp;\n    temp = std::stoll(value);\n    diff = temp - ans;\n    if (diff\
    \ < 0) {\n        diff += 1;\n    }\n    ans = temp;\n    if (diff == 0) {\n \
    \       return ans;\n    }\n    if (diff > 0) {\n        return ans;\n    }\n\
    \    diff = diff * -1;\n    return ans + diff;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpa7o34grz: /tmp/tmpa7o34grz.cpp:33: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int closest;\n    long long\
    \ int closestDiff = std::numeric_limits<long long>::max();\n    long long int\
    \ closestDiffIndex = -1;\n    long long int closestDiffVal = std::numeric_limits<long\
    \ long>::max();\n    long long int closestVal = std::numeric_limits<long long>::max();\n\
    \    long long int closestValIndex = -1;\n    long long int closestValVal = std::numeric_limits<long\
    \ long>::max();\n    long long int closestValIndex2 = -1;\n    long long int closestValVal2\
    \ = std::numeric_limits<long long>::max();\n    long long int closestValIndex3\
    \ = -1;\n    long long int closestValVal3 = std::numeric_limits<long long>::max();\n\
    \    long long int closestValIndex4 = -1;\n    long long int closestValVal4 =\
    \ std::numeric_limits<long long>::max();\n    long long int closestValIndex5 =\
    \ -1;\n    long long int closestValVal5 = std::numeric_limits<long long>::max();\n\
    \    long long int closestValIndex6 = -1;\n    long long int closestValVal6 =\
    \ std::numeric_limits<long long>::max();\n    long long int closestValIndex7 =\
    \ -1;\n    long long int closestValVal7 = std::numeric_limits<long long>::max();\n\
    \    long long int closestValIndex8 = -1;\n    long long int closestValVal8 =\
    \ std::numeric_limits<long long>::max();\n    long long int closestValIndex9 =\
    \ -1;\n    long long int closestValVal9 = std::numeric_limits<long long>::max();\n\
    \    long long int closestValIndex10 = -1;\n    long long int closestValVal10\
    \ = std::numeric_limits<long long>::max();\n    long long int closestValIndex11\
    \ = -1;\n    long long int closestValVal11 = std::numeric_limits<long long>::max();\n\
    \    long long int closestValIndex12 = -1;\n    long long int closestValVal12\
    \ = std::numeric_limits<long long>::max();\n    long long int closestValIndex13\
    \ = -1;\n    long long int closestValVal13 = std::numeric_limits<long long>::max();\n\
    \    long long int closestValIndex14 = -1;\n    long long int closestValVal14\
    \ = std::numeric_limits<long long>::max();\n    long long int closestValIndex15\
    \ = -1;\n    long long int closestValVal15 = std::numeric_limits<long long>::max();\n\
    \    long long int closestValIndex16 = -1;\n    long long int closestValVal16\
    \ = std::numeric_limits<long long>::max();\n    long long int closestValIndex17\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpgd4m94tj.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpgd4m94tj.cpp:51:1: error: expected initializer before \u2018}\u2019\
    \ token\n   51 | }\n      | ^\n/tmp/tmpgd4m94tj.cpp:51:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n\
    \    long diff = std::abs(value - lower);\n    long mid = std::abs(value - upper);\n\
    \    long midVal = std::abs(value - mid);\n    if (diff < midVal) {\n        lower\
    \ = mid;\n        diff = midVal;\n    }\n    if (diff < midVal) {\n        upper\
    \ = mid;\n        diff = midVal;\n    }\n    if (diff == 0) {\n        return\
    \ mid;\n    }\n    if (diff < midVal) {\n        lower = mid;\n        diff =\
    \ midVal;\n    }\n    return lower;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpv1w_z_zt.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpv1w_z_zt.cpp:14:32: error: no match for \u2018operator-\u2019 (operand\
    \ types are \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } and \u2018long int\u2019)\n   14 |     long diff = std::abs(value - lower);\n\
    \      |                          ~~~~~ ^ ~~~~~\n      |                     \
    \     |       |\n      |                          |       long int\n      |  \
    \                        std::string {aka std::__cxx11::basic_string<char>}\n\
    In file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n           \
    \      from /usr/include/c++/9/bits/specfun.h:45,\n                 from /usr/include/c++/9/cmath:1927,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpv1w_z_zt.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:415:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> constexpr\
    \ decltype ((__y.base() - __x.base())) std::operator-(const std::reverse_iterator<_Iterator>&,\
    \ const std::reverse_iterator<_IteratorR>&)\u2019\n  415 |     operator-(const\
    \ reverse_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n/usr/include/c++/9/bits/stl_iterator.h:415:5:\
    \ note:   template argument deduction/substitution failed:\n/tmp/tmpv1w_z_zt.cpp:14:34:\
    \ note:   \u2018std::string\u2019 {aka \u2018std::__cxx11::basic_string<char>\u2019\
    } is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   14\
    \ |     long diff = std::abs(value - lower);\n      |                        \
    \          ^~~~~\nIn file included from /usr/include/c++/9/bits/stl_algobase.h:67,\n\
    \                 from /usr/include/c++/9/bits/specfun.h:45,\n               \
    \  from /usr/include/c++/9/cmath:1927,\n                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:41,\n\
    \                 from /tmp/tmpv1w_z_zt.cpp:2:\n/usr/include/c++/9/bits/stl_iterator.h:1209:5:\
    \ note: candidate: \u2018template<class _IteratorL, class _IteratorR> constexpr\
    \ decltype ((__x.base() - __y.base())) std::operator-(const std::move_iterator<_IteratorL>&,\
    \ const std::"
  stdout: ''
  timestamp: 1660141610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ n = stoi(value);\n    long mid = (n + n) / 2;\n    long mid2 = mid + mid;\n\
    \    long mid3 = mid2 + mid;\n    long mid4 = mid3 + mid;\n    long mid5 = mid4\
    \ + mid;\n    long mid6 = mid5 + mid;\n    long mid7 = mid6 + mid;\n    long mid8\
    \ = mid7 + mid;\n    long mid9 = mid8 + mid;\n    long mid10 = mid9 + mid;\n \
    \   long mid11 = mid10 + mid;\n    long mid12 = mid11 + mid;\n    long mid13 =\
    \ mid12 + mid;\n    long mid14 = mid13 + mid;\n    long mid15 = mid14 + mid;\n\
    \    long mid16 = mid15 + mid;\n    long mid17 = mid16 + mid;\n    long mid18\
    \ = mid17 + mid;\n    long mid19 = mid18 + mid;\n    long mid20 = mid19 + mid;\n\
    \    long mid21 = mid20 + mid;\n    long mid22 = mid21 + mid;\n    long mid23\
    \ = mid22 + mid;\n    long mid24 = mid23 + mid;\n    long mid25 = mid24 + mid;\n\
    \    long mid26 = mid25 + mid;\n    long mid27 = mid26 + mid;\n    long mid28\
    \ = mid27 + mid;\n    long mid29 = mid28 + mid;\n    long mid30 = mid29 + mid;\n\
    \    long mid31 = mid30 + mid;\n    long mid32 = mid31 + mid;\n    long mid33\
    \ = mid32 + mid;\n    long mid34 = mid33 + mid;\n    long mid35 = mid34 + mid;\n\
    \    long mid36 = mid35 + mid;\n    long mid37 = mid36 + mid;\n    long mid38\
    \ = mid37 + mid;\n    long mid39 = mid38 + mid;\n    long mid40 = mid39 + mid;\n\
    \    long mid41 = mid40 + mid;\n    long mid42 = mid41 + mid;\n    long mid43\
    \ = mid42 + mid;\n    long mid44 = mid43 + mid;\n    long mid45 = mid44 + mid;\n\
    \    long mid46 = mid45 + mid;\n    long mid47 = mid46 + \n}\nint main() {\n \
    \   auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpim0j8jcr.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpim0j8jcr.cpp:62:1: error: expected primary-expression before \u2018\
    }\u2019 token\n   62 | }\n      | ^\n/tmp/tmpim0j8jcr.cpp:62:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141610
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = std::stoll(value);\n  \
    \  if (ans == std::stoll(value))\n        return ans;\n    long diff = (ans -\
    \ std::stoll(value)) % ans;\n    if (diff == 0)\n        return ans;\n    return\
    \ ans - diff;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp1tmk72ak: /tmp/tmp1tmk72ak.cpp:24: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141611
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long diff = 0;\n    long sum = 0;\n    long temp = 0;\n    long count\
    \ = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n \
    \   long m = 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n    long q\
    \ = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n \
    \   long v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n    long z\
    \ = 0;\n    long A = 0;\n    long B = 0;\n    long C = 0;\n    long D = 0;\n \
    \   long E = 0;\n    long F = 0;\n    long G = 0;\n    long H = 0;\n    long I\
    \ = 0;\n    long J = 0;\n    long K = 0;\n    long L = 0;\n    long M = 0;\n \
    \   long N = 0;\n    long O = 0;\n    long P = 0;\n    long Q = 0;\n    long R\
    \ = 0;\n    long S = 0;\n    long T = 0;\n    long U = 0;\n    long V = 0;\n \
    \   long W = 0;\n    long X = 0;\n    long Y = 0;\n    long Z = 0;\n    long AA\
    \ = 0;\n    long AB = 0;\n    long AC = 0;\n    long AD = 0;\n    long AE = 0;\n\
    \    long AF = 0;\n    long AG = 0;\n    long AH = 0;\n    long AI = 0;\n    long\
    \ AJ = 0;\n    long AK = 0;\n    long AL = 0;\n    long AM = 0;\n    long AN =\
    \ 0;\n    long AO = 0;\n    long AP = 0;\n    long AQ = 0;\n    long AR = 0;\n\
    \    long AS = 0;\n    long AT = 0;\n    long AU = 0;\n    long AV = 0;\n    long\
    \ AW = 0;\n    long AX = 0;\n    long AY = 0;\n    long AZ = 0;\n    long BA =\
    \ 0;\n    long BB = 0;\n    long BC = 0;\n    long BD = 0;\n    long BE = 0;\n\
    \    long BF = 0;\n    long BG = 0;\n    long BH = 0;\n    long BI = 0;\n    long\
    \ BJ = 0;\n    long BK = 0;\n    long BL = 0;\n    long BM = 0;\n    long BN =\
    \ 0;\n    long BO = 0;\n    long BP = 0;\n    long BQ = 0;\n    long BR = 0;\n\
    \    long BS = 0;\n    long BT = 0;\n    long BU = 0;\n    long BV = 0;\n    long\
    \ BW = 0;\n    long BX = 0;\n    long BY = 0;\n    long B\n}\nint main() {\n \
    \   auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp7msovh9w.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp7msovh9w.cpp:115:1: error: expected initializer before \u2018}\u2019\
    \ token\n  115 | }\n      | ^\n/tmp/tmp7msovh9w.cpp:115:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ long int first = 0;\n    long long int second = 0;\n    long long int third\
    \ = 0;\n    long long int fourth = 0;\n    long long int fifth = 0;\n    long\
    \ long int sixth = 0;\n    long long int seventh = 0;\n    long long int eighth\
    \ = 0;\n    long long int ninth = 0;\n    long long int tenth = 0;\n    long long\
    \ int eleventh = 0;\n    long long int twelfth = 0;\n    long long int thirteenth\
    \ = 0;\n    long long int fourteenth = 0;\n    long long int fifteenth = 0;\n\
    \    long long int sixteenth = 0;\n    long long int seventeenth = 0;\n    long\
    \ long int eighteenth = 0;\n    long long int nineteenth = 0;\n    long long int\
    \ twentieth = 0;\n    long long int twentyfirst = 0;\n    long long int twentysecond\
    \ = 0;\n    long long int twentythird = 0;\n    long long int twentyfourth = 0;\n\
    \    long long int twentyfifth = 0;\n    long long int twentysixth = 0;\n    long\
    \ long int twentyseventh = 0;\n    long long int twentyeighth = 0;\n    long long\
    \ int twentyninth = 0;\n    long long int thirtieth = 0;\n    long long int thirtyfirst\
    \ = 0;\n    long long int thirtysecond = 0;\n    long long int thirtythird = 0;\n\
    \    long long int thirtyfourth = 0;\n    long long int thirtyfifth = 0;\n   \
    \ long long int thirtysixth = 0;\n    long long int thirtyseventh = 0;\n    long\
    \ long int thirtyeighth = 0;\n    long long int thirtyninth = 0;\n    long long\
    \ int fortieth = 0;\n    long long int fortyfirst = 0;\n    long long int fortysecond\
    \ = 0;\n    long long int fortythird = 0;\n    long long int fortyfourth = 0;\n\
    \    long long int fortyfifth = 0;\n    long long int fortysixth = 0;\n    long\
    \ long int fortyseventh = 0;\n    long long int fortyeighth = 0;\n    long long\
    \ int fortyninth = 0;\n    long long int fiftieth = 0;\n    long long int fiftyfirst\
    \ = 0;\n    long long int fiftysecond = 0;\n    long long int fiftythir\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy36jbhhc.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpy36jbhhc.cpp:67:1: error: expected initializer before \u2018}\u2019\
    \ token\n   67 | }\n      | ^\n/tmp/tmpy36jbhhc.cpp:67:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141610
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp;\n    temp = atof(value.c_str());\n    diff = temp - ans;\n    ans\
    \ = temp;\n    if (diff < 0) {\n        diff += 1;\n    }\n    if (diff > 1) {\n\
    \        diff -= 1;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp6n5esc1b: /tmp/tmp6n5esc1b.cpp:29: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141611
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ ans = 0;\n    long diff = 0;\n    long temp = 0;\n    long i = 0;\n    long\
    \ j = 0;\n    long k = 0;\n    long l = 0;\n    long m = 0;\n    long n = 0;\n\
    \    long o = 0;\n    long p = 0;\n    long q = 0;\n    long r = 0;\n    long\
    \ s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n    long w = 0;\n\
    \    long x = 0;\n    long y = 0;\n    long z = 0;\n    long A = 0;\n    long\
    \ B = 0;\n    long C = 0;\n    long D = 0;\n    long E = 0;\n    long F = 0;\n\
    \    long G = 0;\n    long H = 0;\n    long I = 0;\n    long J = 0;\n    long\
    \ K = 0;\n    long L = 0;\n    long M = 0;\n    long N = 0;\n    long O = 0;\n\
    \    long P = 0;\n    long Q = 0;\n    long R = 0;\n    long S = 0;\n    long\
    \ T = 0;\n    long U = 0;\n    long V = 0;\n    long W = 0;\n    long X = 0;\n\
    \    long Y = 0;\n    long Z = 0;\n    long a = 0;\n    long b = 0;\n    long\
    \ c = 0;\n    long d = 0;\n    long e = 0;\n    long f = 0;\n    long g = 0;\n\
    \    long h = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long\
    \ l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n\
    \    long q = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n    long\
    \ u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n\
    \    long z = 0;\n    long A = 0;\n    long B = 0;\n    long C = 0;\n    long\
    \ D = 0;\n    long E = 0;\n    long F = 0;\n    long G = 0;\n    long H = 0;\n\
    \    long I = 0;\n    long J = 0;\n    long K = 0;\n    long L = 0;\n    long\
    \ M = 0;\n    long N = 0;\n    long O = 0;\n    long P = 0;\n    long Q = 0;\n\
    \    long R = 0;\n    long S = 0;\n    long T = 0;\n    long U = 0;\n    long\
    \ V = 0;\n    long W = 0;\n    long X = 0;\n    long Y = 0;\n    long Z = 0;\n\
    \    long a = 0;\n    long b = 0;\n    long c = 0;\n    long d\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp60gayhiq.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp60gayhiq.cpp:69:10: error: redeclaration of \u2018long int i\u2019\n\
    \   69 |     long i = 0;\n      |          ^\n/tmp/tmp60gayhiq.cpp:17:10: note:\
    \ \u2018long int i\u2019 previously declared here\n   17 |     long i = 0;\n \
    \     |          ^\n/tmp/tmp60gayhiq.cpp:70:10: error: redeclaration of \u2018\
    long int j\u2019\n   70 |     long j = 0;\n      |          ^\n/tmp/tmp60gayhiq.cpp:18:10:\
    \ note: \u2018long int j\u2019 previously declared here\n   18 |     long j =\
    \ 0;\n      |          ^\n/tmp/tmp60gayhiq.cpp:71:10: error: redeclaration of\
    \ \u2018long int k\u2019\n   71 |     long k = 0;\n      |          ^\n/tmp/tmp60gayhiq.cpp:19:10:\
    \ note: \u2018long int k\u2019 previously declared here\n   19 |     long k =\
    \ 0;\n      |          ^\n/tmp/tmp60gayhiq.cpp:72:10: error: redeclaration of\
    \ \u2018long int l\u2019\n   72 |     long l = 0;\n      |          ^\n/tmp/tmp60gayhiq.cpp:20:10:\
    \ note: \u2018long int l\u2019 previously declared here\n   20 |     long l =\
    \ 0;\n      |          ^\n/tmp/tmp60gayhiq.cpp:73:10: error: redeclaration of\
    \ \u2018long int m\u2019\n   73 |     long m = 0;\n      |          ^\n/tmp/tmp60gayhiq.cpp:21:10:\
    \ note: \u2018long int m\u2019 previously declared here\n   21 |     long m =\
    \ 0;\n      |          ^\n/tmp/tmp60gayhiq.cpp:74:10: error: redeclaration of\
    \ \u2018long int n\u2019\n   74 |     long n = 0;\n      |          ^\n/tmp/tmp60gayhiq.cpp:22:10:\
    \ note: \u2018long int n\u2019 previously declared here\n   22 |     long n =\
    \ 0;\n      |          ^\n/tmp/tmp60gayhiq.cpp:75:10: error: redeclaration of\
    \ \u2018long int o\u2019\n   75 |     long o = 0;\n      |          ^\n/tmp/tmp60gayhiq.cpp:23:10:\
    \ note: \u2018long int o\u2019 previously declared here\n   23 |     long o =\
    \ 0;\n      |          ^\n/tmp/tmp60gayhiq.cpp:76:10: error: redeclaration of\
    \ \u2018long int p\u2019\n   76 |     long p = 0;\n      |          ^\n/tmp/tmp60gayhiq.cpp:24:10:\
    \ note: \u2018long int p\u2019 previously declared here\n   24 |     long p =\
    \ 0;\n      |          ^\n/tmp/tmp60gayhiq.cpp:77:10: error: redeclaration of\
    \ \u2018long int q\u2019\n   77 |     long q = 0;\n      |          ^\n/tmp/tmp6"
  stdout: ''
  timestamp: 1660141610
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp = 0;\n    long long temp2 = 0;\n    long long temp3 = 0;\n    long\
    \ long temp4 = 0;\n    long long temp5 = 0;\n    long long temp6 = 0;\n    long\
    \ long temp7 = 0;\n    long long temp8 = 0;\n    long long temp9 = 0;\n    long\
    \ long temp10 = 0;\n    long long temp11 = 0;\n    long long temp12 = 0;\n   \
    \ long long temp13 = 0;\n    long long temp14 = 0;\n    long long temp15 = 0;\n\
    \    long long temp16 = 0;\n    long long temp17 = 0;\n    long long temp18 =\
    \ 0;\n    long long temp19 = 0;\n    long long temp20 = 0;\n    long long temp21\
    \ = 0;\n    long long temp22 = 0;\n    long long temp23 = 0;\n    long long temp24\
    \ = 0;\n    long long temp25 = 0;\n    long long temp26 = 0;\n    long long temp27\
    \ = 0;\n    long long temp28 = 0;\n    long long temp29 = 0;\n    long long temp30\
    \ = 0;\n    long long temp31 = 0;\n    long long temp32 = 0;\n    long long temp33\
    \ = 0;\n    long long temp34 = 0;\n    long long temp35 = 0;\n    long long temp36\
    \ = 0;\n    long long temp37 = 0;\n    long long temp38 = 0;\n    long long temp39\
    \ = 0;\n    long long temp40 = 0;\n    long long temp41 = 0;\n    long long temp42\
    \ = 0;\n    long long temp43 = 0;\n    long long temp44 = 0;\n    long long temp45\
    \ = 0;\n    long long temp46 = 0;\n    long long temp47 = 0;\n    long long temp48\
    \ = 0;\n    long long temp49 = 0;\n    long long temp50 = 0;\n    long long temp51\
    \ = 0;\n    long long temp52 = 0;\n    long long temp53 = 0;\n    long long temp54\
    \ = 0;\n    long long temp55 = 0;\n    long long temp56 = 0;\n    long long temp57\
    \ = 0;\n    long long temp58 = 0;\n    long long temp59 = 0;\n    long long temp60\
    \ = 0;\n    long long temp61 = 0;\n    long long temp62 = 0;\n    long long temp63\
    \ = 0;\n    long long temp64 = 0;\n    long long temp65 = 0;\n    long long temp66\
    \ = 0;\n    long long temp67 = 0;\n    long long temp68 = 0;\n    long long temp69\
    \ = 0;\n    long long temp70 = 0;\n    long long temp71 = 0;\n    long long temp72\
    \ = 0;\n    long long temp73\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjgxgzpwg.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpjgxgzpwg.cpp:87:1: error: expected initializer before \u2018}\u2019\
    \ token\n   87 | }\n      | ^\n/tmp/tmpjgxgzpwg.cpp:87:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = std::stoi(value);\n   \
    \ if (ans < 0) {\n        ans = -ans;\n    }\n    long diff = ans - ans % 10;\n\
    \    if (diff == 0) {\n        diff = ans % 10;\n    }\n    ans = ans % 10;\n\
    \    long diff2 = ans - ans % 10;\n    if (diff2 == 0) {\n        diff2 = ans\
    \ % 10;\n    }\n    ans = ans % 10;\n    long diff3 = ans - ans % 10;\n    if\
    \ (diff3 == 0) {\n        diff3 = ans % 10;\n    }\n    ans = ans % 10;\n    long\
    \ diff4 = ans - ans % 10;\n    if (diff4 == 0) {\n        diff4 = ans % 10;\n\
    \    }\n    ans = ans % 10;\n    long diff5 = ans - ans % 10;\n    if (diff5 ==\
    \ 0) {\n        diff5 = ans % 10;\n    }\n    ans = ans % 10;\n    long diff6\
    \ = ans - ans % 10;\n    if (diff6 == 0) {\n        diff6 = ans % 10;\n    }\n\
    \    ans = ans % 10;\n    long diff7 = ans - ans % 10;\n    if (diff7 == 0) {\n\
    \        diff7 = ans % 10;\n    }\n    ans = ans % 10;\n    long diff8 = ans -\
    \ ans % 10;\n    if (diff8 == 0) {\n        diff8 = ans % 10;\n    }\n    ans\
    \ = ans % 10;\n    long diff9 = ans - ans % 10;\n    if (diff9 == 0) {\n     \
    \   diff9 = ans % 10;\n    }\n    ans = ans % 10;\n    long diff10 = ans - ans\
    \ % 10;\n    if (diff10 == 0) {\n        diff10 = ans % 10;\n    }\n    ans =\
    \ ans % 10;\n    long diff11 = ans - ans % 10;\n    if (diff11 == 0) {\n     \
    \   diff11 = ans % 10;\n    }\n    ans = ans % 10;\n    long diff12 = ans - ans\
    \ % 10;\n    if (diff12 == 0) {\n        diff12 = ans % 10;\n    }\n    ans =\
    \ ans % 10;\n    long diff13 = ans - ans % 10;\n    if (diff13 == 0) {\n     \
    \   diff13 = ans % 10;\n    }\n    ans = ans % 10;\n    long diff14 = ans - ans\
    \ % 10;\n    if (diff14 == 0) {\n        diff14 = ans % 10;\n    }\n    ans =\
    \ ans % 10;\n    long diff15 = ans - ans % 10;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpps7vgk83: /tmp/tmpps7vgk83.cpp:91: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141611
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num;\n    long long\
    \ int min;\n    long long int max;\n    long long int mid;\n    long long int\
    \ diff;\n    long long int diff2;\n    long long int diff3;\n    long long int\
    \ diff4;\n    long long int diff5;\n    long long int diff6;\n    long long int\
    \ diff7;\n    long long int diff8;\n    long long int diff9;\n    long long int\
    \ diff10;\n    long long int diff11;\n    long long int diff12;\n    long long\
    \ int diff13;\n    long long int diff14;\n    long long int diff15;\n    long\
    \ long int diff16;\n    long long int diff17;\n    long long int diff18;\n   \
    \ long long int diff19;\n    long long int diff20;\n    long long int diff21;\n\
    \    long long int diff22;\n    long long int diff23;\n    long long int diff24;\n\
    \    long long int diff25;\n    long long int diff26;\n    long long int diff27;\n\
    \    long long int diff28;\n    long long int diff29;\n    long long int diff30;\n\
    \    long long int diff31;\n    long long int diff32;\n    long long int diff33;\n\
    \    long long int diff34;\n    long long int diff35;\n    long long int diff36;\n\
    \    long long int diff37;\n    long long int diff38;\n    long long int diff39;\n\
    \    long long int diff40;\n    long long int diff41;\n    long long int diff42;\n\
    \    long long int diff43;\n    long long int diff44;\n    long long int diff45;\n\
    \    long long int diff46;\n    long long int diff47;\n    long long int diff48;\n\
    \    long long int diff49;\n    long long int diff50;\n    long long int diff51;\n\
    \    long long int diff52;\n    long long int diff53;\n    long long int diff54;\n\
    \    long long int diff55;\n    long long int diff56;\n    long long int diff57;\n\
    \    long long int diff58;\n    long long int diff59;\n    long long int diff60;\n\
    \    long long int diff61;\n    long long int diff62;\n    long long int diff63;\n\
    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpqg_4dw5y: /tmp/tmpqg_4dw5y.cpp:84: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value);\n\
    \    long diff = upper - lower;\n    if (diff > 0) {\n        return lower;\n\
    \    }\n    if (diff < 0) {\n        return upper;\n    }\n    if (diff == 0)\
    \ {\n        return lower;\n    }\n    if (diff < 0) {\n        return upper;\n\
    \    }\n    return lower;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpnx_fky1s: /tmp/tmpnx_fky1s.cpp:31: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141611
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value);\n\
    \    if (upper < lower) {\n        std::swap(lower, upper);\n    }\n    long mid\
    \ = (lower + upper) / 2;\n    if (mid > upper) {\n        mid = upper;\n    }\n\
    \    if (mid < lower) {\n        mid = lower;\n    }\n    return mid;\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp1g9hawa4: /tmp/tmp1g9hawa4.cpp:28: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141611
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num;\n    double num2;\n\
    \    double num3;\n    double num4;\n    double num5;\n    double num6;\n    double\
    \ num7;\n    double num8;\n    double num9;\n    double num10;\n    double num11;\n\
    \    double num12;\n    double num13;\n    double num14;\n    double num15;\n\
    \    double num16;\n    double num17;\n    double num18;\n    double num19;\n\
    \    double num20;\n    double num21;\n    double num22;\n    double num23;\n\
    \    double num24;\n    double num25;\n    double num26;\n    double num27;\n\
    \    double num28;\n    double num29;\n    double num30;\n    double num31;\n\
    \    double num32;\n    double num33;\n    double num34;\n    double num35;\n\
    \    double num36;\n    double num37;\n    double num38;\n    double num39;\n\
    \    double num40;\n    double num41;\n    double num42;\n    double num43;\n\
    \    double num44;\n    double num45;\n    double num46;\n    double num47;\n\
    \    double num48;\n    double num49;\n    double num50;\n    double num51;\n\
    \    double num52;\n    double num53;\n    double num54;\n    double num55;\n\
    \    double num56;\n    double num57;\n    double num58;\n    double num59;\n\
    \    double num60;\n    double num61;\n    double num62;\n    double num63;\n\
    \    double num64;\n    double num65;\n    double num66;\n    double num67;\n\
    \    double num68;\n    double num69;\n    double num70;\n    double num71;\n\
    \    double num72;\n    double num73;\n    double num74;\n    double num75;\n\
    \    double num76;\n    double num77;\n    double num78;\n    double num79;\n\
    \    double num80;\n    double num81;\n    double num82;\n    double num83;\n\
    \    double num84;\n    double num85;\n    double num86;\n    double num87;\n\
    \    double num88;\n    double \n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpzdcjikz4.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpzdcjikz4.cpp:102:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n  102 | }\n      | ^\n/tmp/tmpzdcjikz4.cpp:102:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141611
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ ans = 0, diff = 0;\n    long long temp;\n    long long temp2;\n    long long\
    \ temp3;\n    long long temp4;\n    long long temp5;\n    long long temp6;\n \
    \   long long temp7;\n    long long temp8;\n    long long temp9;\n    long long\
    \ temp10;\n    long long temp11;\n    long long temp12;\n    long long temp13;\n\
    \    long long temp14;\n    long long temp15;\n    long long temp16;\n    long\
    \ long temp17;\n    long long temp18;\n    long long temp19;\n    long long temp20;\n\
    \    long long temp21;\n    long long temp22;\n    long long temp23;\n    long\
    \ long temp24;\n    long long temp25;\n    long long temp26;\n    long long temp27;\n\
    \    long long temp28;\n    long long temp29;\n    long long temp30;\n    long\
    \ long temp31;\n    long long temp32;\n    long long temp33;\n    long long temp34;\n\
    \    long long temp35;\n    long long temp36;\n    long long temp37;\n    long\
    \ long temp38;\n    long long temp39;\n    long long temp40;\n    long long temp41;\n\
    \    long long temp42;\n    long long temp43;\n    long long temp44;\n    long\
    \ long temp45;\n    long long temp46;\n    long long temp47;\n    long long temp48;\n\
    \    long long temp49;\n    long long temp50;\n    long long temp51;\n    long\
    \ long temp52;\n    long long temp53;\n    long long temp54;\n    long long temp55;\n\
    \    long long temp56;\n    long long temp57;\n    long long temp58;\n    long\
    \ long temp59;\n    long long temp60;\n    long long temp61;\n    long long temp62;\n\
    \    long long temp63;\n    long long temp64;\n    long long temp65;\n    long\
    \ long temp66;\n    long long temp67;\n    long long temp68;\n    long long temp69;\n\
    \    long long temp70;\n    long long temp71;\n    long long temp72;\n    long\
    \ long temp73;\n    long long temp74;\n    \n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpyyavumwf: /tmp/tmpyyavumwf.cpp:93: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141611
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int l=atoll(value.c_str());\n\
    \    long long int m=l-1;\n    long long int n=l+1;\n    long long int d=m*m;\n\
    \    long long int e=n*n;\n    long long int f=d+e;\n    long long int g=f+d;\n\
    \    long long int h=g+e;\n    long long int i=h+d;\n    long long int j=i+e;\n\
    \    long long int k=j+d;\n    long long int l=k+e;\n    long long int m=l+d;\n\
    \    long long int n=m+e;\n    long long int d=n+d;\n    long long int e=d+e;\n\
    \    long long int f=e+d;\n    long long int g=f+d;\n    long long int h=g+e;\n\
    \    long long int i=h+d;\n    long long int j=i+e;\n    long long int k=j+d;\n\
    \    long long int l=k+e;\n    long long int m=l+d;\n    long long int n=m+e;\n\
    \    long long int d=n+d;\n    long long int e=d+e;\n    long long int f=e+d;\n\
    \    long long int g=f+d;\n    long long int h=g+e;\n    long long int i=h+d;\n\
    \    long long int j=i+e;\n    long long int k=j+d;\n    long long int l=k+e;\n\
    \    long long int m=l+d;\n    long long int n=m+e;\n    long long int d=n+d;\n\
    \    long long int e=d+e;\n    long long int f=e+d;\n    long long int g=f+d;\n\
    \    long long int h=g+e;\n    long long int i=h+d;\n    long long int j=i+e;\n\
    \    long long int k=j+d;\n    long long int l=k+e;\n    long long int m=l+d;\n\
    \    long long int n=m+e;\n    long long int d=n+d;\n    long long int e=d+e;\n\
    \    long long int f=e+d;\n    long long int g=f+d;\n    long long int h=g+e;\n\
    \    long long int i=h+d;\n    long long int j=i+e;\n    long long int k=j+d;\n\
    \    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmparxn2dh8.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmparxn2dh8.cpp:24:19: error: redeclaration of \u2018long long int l\u2019\
    \n   24 |     long long int l=k+e;\n      |                   ^\n/tmp/tmparxn2dh8.cpp:13:19:\
    \ note: \u2018long long int l\u2019 previously declared here\n   13 |     long\
    \ long int l=atoll(value.c_str());\n      |                   ^\n/tmp/tmparxn2dh8.cpp:25:19:\
    \ error: redeclaration of \u2018long long int m\u2019\n   25 |     long long int\
    \ m=l+d;\n      |                   ^\n/tmp/tmparxn2dh8.cpp:14:19: note: \u2018\
    long long int m\u2019 previously declared here\n   14 |     long long int m=l-1;\n\
    \      |                   ^\n/tmp/tmparxn2dh8.cpp:26:19: error: redeclaration\
    \ of \u2018long long int n\u2019\n   26 |     long long int n=m+e;\n      |  \
    \                 ^\n/tmp/tmparxn2dh8.cpp:15:19: note: \u2018long long int n\u2019\
    \ previously declared here\n   15 |     long long int n=l+1;\n      |        \
    \           ^\n/tmp/tmparxn2dh8.cpp:27:19: error: redeclaration of \u2018long\
    \ long int d\u2019\n   27 |     long long int d=n+d;\n      |                \
    \   ^\n/tmp/tmparxn2dh8.cpp:16:19: note: \u2018long long int d\u2019 previously\
    \ declared here\n   16 |     long long int d=m*m;\n      |                   ^\n\
    /tmp/tmparxn2dh8.cpp:28:19: error: redeclaration of \u2018long long int e\u2019\
    \n   28 |     long long int e=d+e;\n      |                   ^\n/tmp/tmparxn2dh8.cpp:17:19:\
    \ note: \u2018long long int e\u2019 previously declared here\n   17 |     long\
    \ long int e=n*n;\n      |                   ^\n/tmp/tmparxn2dh8.cpp:29:19: error:\
    \ redeclaration of \u2018long long int f\u2019\n   29 |     long long int f=e+d;\n\
    \      |                   ^\n/tmp/tmparxn2dh8.cpp:18:19: note: \u2018long long\
    \ int f\u2019 previously declared here\n   18 |     long long int f=d+e;\n   \
    \   |                   ^\n/tmp/tmparxn2dh8.cpp:30:19: error: redeclaration of\
    \ \u2018long long int g\u2019\n   30 |     long long int g=f+d;\n      |     \
    \              ^\n/tmp/tmparxn2dh8.cpp:19:19: note: \u2018long long int g\u2019\
    \ previously declared here\n   19 |     long long int g=f+d;\n      |        \
    \           ^\n/tmp/tmparxn2"
  stdout: ''
  timestamp: 1660141611
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, sign = 1;\n    long n = std::stoll(value);\n    long d = n - ans;\n    if\
    \ (d < 0) {\n        sign = -1;\n        d = -d;\n    }\n    while (d >= 1) {\n\
    \        ans += d;\n        d = d / 2;\n    }\n    return sign * ans;\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpmeb9xz2b: /tmp/tmpmeb9xz2b.cpp:29: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141611
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long sum = 0;\n    long diff = abs(atoi(value.c_str()));\n    long min\
    \ = diff;\n    long max = diff;\n    long mid = 0;\n    long count = 0;\n    long\
    \ i = 0;\n    while(i < value.size()) {\n        mid = sum + diff/2;\n       \
    \ sum = mid;\n        diff = abs(atoi(value.substr(i, 1).c_str()));\n        if(diff\
    \ < min) {\n            min = diff;\n            ans = mid;\n        }\n     \
    \   if(diff > max) {\n            max = diff;\n            ans = mid;\n      \
    \  }\n        i++;\n        count++;\n    }\n    return ans;\n}\nint main() {\n\
    \    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmphcy0whx7: /tmp/tmphcy0whx7.cpp:41: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141611
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ std::stoi(value);\n    if (ans < 0) {\n        ans = ans * -1;\n    }\n    return\
    \ ans;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp4i5bwzho: /tmp/tmp4i5bwzho.cpp:23: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141611
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n\
    \    long mid = 0;\n    long diff = std::numeric_limits<long>::max();\n    for\
    \ (auto c : value) {\n        mid = (lower + upper) / 2;\n        diff = std::abs(mid\
    \ - std::stod(c));\n        if (diff < diff) {\n            lower = mid;\n   \
    \     } else {\n            upper = mid;\n        }\n    }\n    return lower;\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8amd9jrc.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp8amd9jrc.cpp:18:42: error: no matching function for call to \u2018\
    stod(char&)\u2019\n   18 |         diff = std::abs(mid - std::stod(c));\n    \
    \  |                                          ^\nIn file included from /usr/include/c++/9/string:55,\n\
    \                 from /usr/include/c++/9/bits/locale_classes.h:40,\n        \
    \         from /usr/include/c++/9/bits/ios_base.h:41,\n                 from /usr/include/c++/9/ios:42,\n\
    \                 from /usr/include/c++/9/istream:38,\n                 from /usr/include/c++/9/sstream:38,\n\
    \                 from /usr/include/c++/9/complex:45,\n                 from /usr/include/c++/9/ccomplex:39,\n\
    \                 from /usr/include/x86_64-linux-gnu/c++/9/bits/stdc++.h:54,\n\
    \                 from /tmp/tmp8amd9jrc.cpp:2:\n/usr/include/c++/9/bits/basic_string.h:6536:3:\
    \ note: candidate: \u2018double std::__cxx11::stod(const string&, std::size_t*)\u2019\
    \n 6536 |   stod(const string& __str, size_t* __idx = 0)\n      |   ^~~~\n/usr/include/c++/9/bits/basic_string.h:6536:22:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ string&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n 6536\
    \ |   stod(const string& __str, size_t* __idx = 0)\n      |        ~~~~~~~~~~~~~~^~~~~\n\
    /usr/include/c++/9/bits/basic_string.h:6642:3: note: candidate: \u2018double std::__cxx11::stod(const\
    \ wstring&, std::size_t*)\u2019\n 6642 |   stod(const wstring& __str, size_t*\
    \ __idx = 0)\n      |   ^~~~\n/usr/include/c++/9/bits/basic_string.h:6642:23:\
    \ note:   no known conversion for argument 1 from \u2018char\u2019 to \u2018const\
    \ wstring&\u2019 {aka \u2018const std::__cxx11::basic_string<wchar_t>&\u2019}\n\
    \ 6642 |   stod(const wstring& __str, size_t* __idx = 0)\n      |        ~~~~~~~~~~~~~~~^~~~~\n"
  stdout: ''
  timestamp: 1660141606
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n\
    \    long mid = 0;\n    long diff = 0;\n    long closest;\n    long midValue =\
    \ std::stoi(value);\n    long midValue2 = std::stoi(value);\n    long midValue3\
    \ = std::stoi(value);\n    long midValue4 = std::stoi(value);\n    long midValue5\
    \ = std::stoi(value);\n    long midValue6 = std::stoi(value);\n    long midValue7\
    \ = std::stoi(value);\n    long midValue8 = std::stoi(value);\n    long midValue9\
    \ = std::stoi(value);\n    long midValue10 = std::stoi(value);\n    long midValue11\
    \ = std::stoi(value);\n    long midValue12 = std::stoi(value);\n    long midValue13\
    \ = std::stoi(value);\n    long midValue14 = std::stoi(value);\n    long midValue15\
    \ = std::stoi(value);\n    long midValue16 = std::stoi(value);\n    long midValue17\
    \ = std::stoi(value);\n    long midValue18 = std::stoi(value);\n    long midValue19\
    \ = std::stoi(value);\n    long midValue20 = std::stoi(value);\n    long midValue21\
    \ = std::stoi(value);\n    long midValue22 = std::stoi(value);\n    long midValue23\
    \ = std::stoi(value);\n    long midValue24 = std::stoi(value);\n    long midValue25\
    \ = std::stoi(value);\n    long midValue26 = std::stoi(value);\n    long midValue27\
    \ = std::stoi(value);\n    long midValue28 = std::stoi(value);\n    long midValue29\
    \ = std::stoi(value);\n    long midValue30 = std::stoi(value);\n    long midValue31\
    \ = std::stoi(value);\n    long midValue32 = std::stoi(value);\n    long midValue33\
    \ = std::stoi(value);\n    long midValue34 = std::stoi(value);\n    long midValue35\
    \ = std::stoi(value);\n    long midValue36 = std::stoi(value);\n    long midValue37\
    \ = std::stoi(value);\n    long midValue38 = std::stoi(value);\n    long midValue39\
    \ = std::stoi(value);\n    long midValue40 = std::stoi(value);\n    long midValue41\
    \ = std::stoi(value);\n    long midValue42 = std::stoi(value);\n    long midValue43\
    \ = std::stoi(value);\n    long midValue44 = std::stoi(value);\n    long midValue45\
    \ = std::stoi(value);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmphh02fabm: /tmp/tmphh02fabm.cpp:66: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660141611
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long temp = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long\
    \ l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n\
    \    long q = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n    long\
    \ u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n\
    \    long z = 0;\n    long A = 0;\n    long B = 0;\n    long C = 0;\n    long\
    \ D = 0;\n    long E = 0;\n    long F = 0;\n    long G = 0;\n    long H = 0;\n\
    \    long I = 0;\n    long J = 0;\n    long K = 0;\n    long L = 0;\n    long\
    \ M = 0;\n    long N = 0;\n    long O = 0;\n    long P = 0;\n    long Q = 0;\n\
    \    long R = 0;\n    long S = 0;\n    long T = 0;\n    long U = 0;\n    long\
    \ V = 0;\n    long W = 0;\n    long X = 0;\n    long Y = 0;\n    long Z = 0;\n\
    \    long a = 0;\n    long b = 0;\n    long c = 0;\n    long d = 0;\n    long\
    \ e = 0;\n    long f = 0;\n    long g = 0;\n    long h = 0;\n    long i = 0;\n\
    \    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m = 0;\n    long\
    \ n = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n    long r = 0;\n\
    \    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n    long\
    \ w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long A = 0;\n\
    \    long B = 0;\n    long C = 0;\n    long D = 0;\n    long E = 0;\n    long\
    \ F = 0;\n    long G = 0;\n    long H = 0;\n    long I = 0;\n    long J = 0;\n\
    \    long K = 0;\n    long L = 0;\n    long M = 0;\n    long N = 0;\n    long\
    \ O = 0;\n    long P = 0;\n    long Q = 0;\n    long R = 0;\n    long S = 0;\n\
    \    long T = 0;\n    long U = 0;\n    long V = 0;\n    long W = 0;\n    long\
    \ X = 0;\n    long Y = 0;\n    long Z = 0;\n    long a = 0;\n    long b = 0;\n\
    \    long c = 0;\n    long d = 0;\n    long e\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmjhn9nfs.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpmjhn9nfs.cpp:68:10: error: redeclaration of \u2018long int i\u2019\n\
    \   68 |     long i = 0;\n      |          ^\n/tmp/tmpmjhn9nfs.cpp:16:10: note:\
    \ \u2018long int i\u2019 previously declared here\n   16 |     long i = 0;\n \
    \     |          ^\n/tmp/tmpmjhn9nfs.cpp:69:10: error: redeclaration of \u2018\
    long int j\u2019\n   69 |     long j = 0;\n      |          ^\n/tmp/tmpmjhn9nfs.cpp:17:10:\
    \ note: \u2018long int j\u2019 previously declared here\n   17 |     long j =\
    \ 0;\n      |          ^\n/tmp/tmpmjhn9nfs.cpp:70:10: error: redeclaration of\
    \ \u2018long int k\u2019\n   70 |     long k = 0;\n      |          ^\n/tmp/tmpmjhn9nfs.cpp:18:10:\
    \ note: \u2018long int k\u2019 previously declared here\n   18 |     long k =\
    \ 0;\n      |          ^\n/tmp/tmpmjhn9nfs.cpp:71:10: error: redeclaration of\
    \ \u2018long int l\u2019\n   71 |     long l = 0;\n      |          ^\n/tmp/tmpmjhn9nfs.cpp:19:10:\
    \ note: \u2018long int l\u2019 previously declared here\n   19 |     long l =\
    \ 0;\n      |          ^\n/tmp/tmpmjhn9nfs.cpp:72:10: error: redeclaration of\
    \ \u2018long int m\u2019\n   72 |     long m = 0;\n      |          ^\n/tmp/tmpmjhn9nfs.cpp:20:10:\
    \ note: \u2018long int m\u2019 previously declared here\n   20 |     long m =\
    \ 0;\n      |          ^\n/tmp/tmpmjhn9nfs.cpp:73:10: error: redeclaration of\
    \ \u2018long int n\u2019\n   73 |     long n = 0;\n      |          ^\n/tmp/tmpmjhn9nfs.cpp:21:10:\
    \ note: \u2018long int n\u2019 previously declared here\n   21 |     long n =\
    \ 0;\n      |          ^\n/tmp/tmpmjhn9nfs.cpp:74:10: error: redeclaration of\
    \ \u2018long int o\u2019\n   74 |     long o = 0;\n      |          ^\n/tmp/tmpmjhn9nfs.cpp:22:10:\
    \ note: \u2018long int o\u2019 previously declared here\n   22 |     long o =\
    \ 0;\n      |          ^\n/tmp/tmpmjhn9nfs.cpp:75:10: error: redeclaration of\
    \ \u2018long int p\u2019\n   75 |     long p = 0;\n      |          ^\n/tmp/tmpmjhn9nfs.cpp:23:10:\
    \ note: \u2018long int p\u2019 previously declared here\n   23 |     long p =\
    \ 0;\n      |          ^\n/tmp/tmpmjhn9nfs.cpp:76:10: error: redeclaration of\
    \ \u2018long int q\u2019\n   76 |     long q = 0;\n      |          ^\n/tmp/tmpm"
  stdout: ''
  timestamp: 1660141611
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num;\n    long long\
    \ int min;\n    long long int max;\n    long long int mid;\n    long long int\
    \ diff;\n    long long int diff2;\n    long long int diff3;\n    long long int\
    \ diff4;\n    long long int diff5;\n    long long int diff6;\n    long long int\
    \ diff7;\n    long long int diff8;\n    long long int diff9;\n    long long int\
    \ diff10;\n    long long int diff11;\n    long long int diff12;\n    long long\
    \ int diff13;\n    long long int diff14;\n    long long int diff15;\n    long\
    \ long int diff16;\n    long long int diff17;\n    long long int diff18;\n   \
    \ long long int diff19;\n    long long int diff20;\n    long long int diff21;\n\
    \    long long int diff22;\n    long long int diff23;\n    long long int diff24;\n\
    \    long long int diff25;\n    long long int diff26;\n    long long int diff27;\n\
    \    long long int diff28;\n    long long int diff29;\n    long long int diff30;\n\
    \    long long int diff31;\n    long long int diff32;\n    long long int diff33;\n\
    \    long long int diff34;\n    long long int diff35;\n    long long int diff36;\n\
    \    long long int diff37;\n    long long int diff38;\n    long long int diff39;\n\
    \    long long int diff40;\n    long long int diff41;\n    long long int diff42;\n\
    \    long long int diff43;\n    long long int diff44;\n    long long int diff45;\n\
    \    long long int diff46;\n    long long int diff47;\n    long long int diff48;\n\
    \    long long int diff49;\n    long long int diff50;\n    long long int diff51;\n\
    \    long long int diff52;\n    long long int diff53;\n    long long int diff54;\n\
    \    long long int diff55;\n    long long int diff56;\n    long long int diff57;\n\
    \    long long int diff58;\n    long long int diff59;\n    long long int diff60;\n\
    \    long long int diff61;\n    long long int diff62;\n    long long int diff63;\n\
    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpqg_4dw5y: /tmp/tmpqg_4dw5y.cpp:84: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141604
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int n = 0;\n    long long\
    \ int m = 0;\n    long long int min = 0;\n    long long int max = 0;\n    long\
    \ long int mid = 0;\n    long long int diff = 0;\n    long long int diff2 = 0;\n\
    \    long long int diff3 = 0;\n    long long int diff4 = 0;\n    long long int\
    \ diff5 = 0;\n    long long int diff6 = 0;\n    long long int diff7 = 0;\n   \
    \ long long int diff8 = 0;\n    long long int diff9 = 0;\n    long long int diff10\
    \ = 0;\n    long long int diff11 = 0;\n    long long int diff12 = 0;\n    long\
    \ long int diff13 = 0;\n    long long int diff14 = 0;\n    long long int diff15\
    \ = 0;\n    long long int diff16 = 0;\n    long long int diff17 = 0;\n    long\
    \ long int diff18 = 0;\n    long long int diff19 = 0;\n    long long int diff20\
    \ = 0;\n    long long int diff21 = 0;\n    long long int diff22 = 0;\n    long\
    \ long int diff23 = 0;\n    long long int diff24 = 0;\n    long long int diff25\
    \ = 0;\n    long long int diff26 = 0;\n    long long int diff27 = 0;\n    long\
    \ long int diff28 = 0;\n    long long int diff29 = 0;\n    long long int diff30\
    \ = 0;\n    long long int diff31 = 0;\n    long long int diff32 = 0;\n    long\
    \ long int diff33 = 0;\n    long long int diff34 = 0;\n    long long int diff35\
    \ = 0;\n    long long int diff36 = 0;\n    long long int diff37 = 0;\n    long\
    \ long int diff38 = 0;\n    long long int diff39 = 0;\n    long long int diff40\
    \ = 0;\n    long long int diff41 = 0;\n    long long int diff42 = 0;\n    long\
    \ long int diff43 = 0;\n    long long int diff44 = 0;\n    long long int diff45\
    \ = 0;\n    long long int diff46 = 0;\n    long long int diff47 = 0;\n    long\
    \ long int diff48 = 0;\n    long long int diff49 = 0;\n    long long int diff50\
    \ = 0;\n    long long int diff51 = 0;\n    long long int diff52 = 0;\n    long\
    \ long int diff53 = 0;\n    long long int diff54 = 0;\n    long long int diff55\
    \ = 0;\n    long long int diff56 = 0;\n    long long int diff57 = 0;\n    long\
    \ long int diff58 = 0;\n    long long int diff59 = 0;\n    long long int diff60\
    \ = 0;\n    long \n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxx211r00.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpxx211r00.cpp:79:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   79 | }\n      | ^\n/tmp/tmpxx211r00.cpp:79:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141611
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int temp = 0;\n    long\
    \ long int temp2 = 0;\n    long long int temp3 = 0;\n    long long int temp4 =\
    \ 0;\n    long long int temp5 = 0;\n    long long int temp6 = 0;\n    long long\
    \ int temp7 = 0;\n    long long int temp8 = 0;\n    long long int temp9 = 0;\n\
    \    long long int temp10 = 0;\n    long long int temp11 = 0;\n    long long int\
    \ temp12 = 0;\n    long long int temp13 = 0;\n    long long int temp14 = 0;\n\
    \    long long int temp15 = 0;\n    long long int temp16 = 0;\n    long long int\
    \ temp17 = 0;\n    long long int temp18 = 0;\n    long long int temp19 = 0;\n\
    \    long long int temp20 = 0;\n    long long int temp21 = 0;\n    long long int\
    \ temp22 = 0;\n    long long int temp23 = 0;\n    long long int temp24 = 0;\n\
    \    long long int temp25 = 0;\n    long long int temp26 = 0;\n    long long int\
    \ temp27 = 0;\n    long long int temp28 = 0;\n    long long int temp29 = 0;\n\
    \    long long int temp30 = 0;\n    long long int temp31 = 0;\n    long long int\
    \ temp32 = 0;\n    long long int temp33 = 0;\n    long long int temp34 = 0;\n\
    \    long long int temp35 = 0;\n    long long int temp36 = 0;\n    long long int\
    \ temp37 = 0;\n    long long int temp38 = 0;\n    long long int temp39 = 0;\n\
    \    long long int temp40 = 0;\n    long long int temp41 = 0;\n    long long int\
    \ temp42 = 0;\n    long long int temp43 = 0;\n    long long int temp44 = 0;\n\
    \    long long int temp45 = 0;\n    long long int temp46 = 0;\n    long long int\
    \ temp47 = 0;\n    long long int temp48 = 0;\n    long long int temp49 = 0;\n\
    \    long long int temp50 = 0;\n    long long int temp51 = 0;\n    long long int\
    \ temp52 = 0;\n    long long int temp53 = 0;\n    long long int temp54 = 0;\n\
    \    long long int temp55 = 0;\n    long long int temp56 = 0;\n    long long int\
    \ temp57 = 0;\n    long long int temp58 = 0;\n    long long int temp59 = 0;\n\
    \    long long int temp60 = 0;\n    long long int temp61 = 0;\n    long long int\
    \ temp62 = 0;\n    long long int temp63 = 0;\n    long long int temp64 = 0;\n\
    \    long long int temp\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmplial21z9.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmplial21z9.cpp:78:1: error: expected initializer before \u2018}\u2019\
    \ token\n   78 | }\n      | ^\n/tmp/tmplial21z9.cpp:78:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141611
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, power = 1;\n    long temp = atoi(value.c_str());\n    long diff = abs(temp\
    \ - ans);\n    while (diff > 1) {\n        diff /= 10;\n        power *= 10;\n\
    \    }\n    ans = temp + power;\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpftw6th99: /tmp/tmpftw6th99.cpp:26: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141611
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::numeric_limits<long>::max();\n\
    \    long mid = 0;\n    long diff = std::numeric_limits<long>::max();\n    long\
    \ closest = 0;\n    long diff2 = std::numeric_limits<long>::max();\n    long diff3\
    \ = std::numeric_limits<long>::max();\n    long diff4 = std::numeric_limits<long>::max();\n\
    \    long diff5 = std::numeric_limits<long>::max();\n    long diff6 = std::numeric_limits<long>::max();\n\
    \    long diff7 = std::numeric_limits<long>::max();\n    long diff8 = std::numeric_limits<long>::max();\n\
    \    long diff9 = std::numeric_limits<long>::max();\n    long diff10 = std::numeric_limits<long>::max();\n\
    \    long diff11 = std::numeric_limits<long>::max();\n    long diff12 = std::numeric_limits<long>::max();\n\
    \    long diff13 = std::numeric_limits<long>::max();\n    long diff14 = std::numeric_limits<long>::max();\n\
    \    long diff15 = std::numeric_limits<long>::max();\n    long diff16 = std::numeric_limits<long>::max();\n\
    \    long diff17 = std::numeric_limits<long>::max();\n    long diff18 = std::numeric_limits<long>::max();\n\
    \    long diff19 = std::numeric_limits<long>::max();\n    long diff20 = std::numeric_limits<long>::max();\n\
    \    long diff21 = std::numeric_limits<long>::max();\n    long diff22 = std::numeric_limits<long>::max();\n\
    \    long diff23 = std::numeric_limits<long>::max();\n    long diff24 = std::numeric_limits<long>::max();\n\
    \    long diff25 = std::numeric_limits<long>::max();\n    long diff26 = std::numeric_limits<long>::max();\n\
    \    long diff27 = std::numeric_limits<long>::max();\n    long diff28 = std::numeric_limits<long>::max();\n\
    \    long diff29 = std::numeric_limits<long>::max();\n    long diff30 = std::numeric_limits<long>::max();\n\
    \    long diff31 = std::numeric_limits<long>::max();\n    long diff32 = std::numeric_limits<long>::max();\n\
    \    long diff33 = std::numeric_limits<long>::max();\n    long diff34 = std::numeric_limits<long>::max();\n\
    \    long diff35 = std::numeric_limits<long>::max();\n    long diff36 = std::numeric_limits<\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2d0884vi.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp2d0884vi.cpp:51:38: error: template argument 1 is invalid\n   51 |\
    \     long diff36 = std::numeric_limits<\n      |                            \
    \          ^\n/tmp/tmp2d0884vi.cpp:52:1: warning: no return statement in function\
    \ returning non-void [-Wreturn-type]\n   52 | }\n      | ^\n"
  stdout: ''
  timestamp: 1660141606
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ long temp = 0;\n    long long temp2 = 0;\n    long long temp3 = 0;\n    long\
    \ long temp4 = 0;\n    long long temp5 = 0;\n    long long temp6 = 0;\n    long\
    \ long temp7 = 0;\n    long long temp8 = 0;\n    long long temp9 = 0;\n    long\
    \ long temp10 = 0;\n    long long temp11 = 0;\n    long long temp12 = 0;\n   \
    \ long long temp13 = 0;\n    long long temp14 = 0;\n    long long temp15 = 0;\n\
    \    long long temp16 = 0;\n    long long temp17 = 0;\n    long long temp18 =\
    \ 0;\n    long long temp19 = 0;\n    long long temp20 = 0;\n    long long temp21\
    \ = 0;\n    long long temp22 = 0;\n    long long temp23 = 0;\n    long long temp24\
    \ = 0;\n    long long temp25 = 0;\n    long long temp26 = 0;\n    long long temp27\
    \ = 0;\n    long long temp28 = 0;\n    long long temp29 = 0;\n    long long temp30\
    \ = 0;\n    long long temp31 = 0;\n    long long temp32 = 0;\n    long long temp33\
    \ = 0;\n    long long temp34 = 0;\n    long long temp35 = 0;\n    long long temp36\
    \ = 0;\n    long long temp37 = 0;\n    long long temp38 = 0;\n    long long temp39\
    \ = 0;\n    long long temp40 = 0;\n    long long temp41 = 0;\n    long long temp42\
    \ = 0;\n    long long temp43 = 0;\n    long long temp44 = 0;\n    long long temp45\
    \ = 0;\n    long long temp46 = 0;\n    long long temp47 = 0;\n    long long temp48\
    \ = 0;\n    long long temp49 = 0;\n    long long temp50 = 0;\n    long long temp51\
    \ = 0;\n    long long temp52 = 0;\n    long long temp53 = 0;\n    long long temp54\
    \ = 0;\n    long long temp55 = 0;\n    long long temp56 = 0;\n    long long temp57\
    \ = 0;\n    long long temp58 = 0;\n    long long temp59 = 0;\n    long long temp60\
    \ = 0;\n    long long temp61 = 0;\n    long long temp62 = 0;\n    long long temp63\
    \ = 0;\n    long long temp64 = 0;\n    long long temp65 = 0;\n    long long temp66\
    \ = 0;\n    long long temp67 = 0;\n    long long temp68 = 0;\n    long long temp69\
    \ = 0;\n    long long temp70 = 0;\n    long long temp71 = 0;\n    long long temp72\
    \ = 0;\n    long long temp73\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpjgxgzpwg.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpjgxgzpwg.cpp:87:1: error: expected initializer before \u2018}\u2019\
    \ token\n   87 | }\n      | ^\n/tmp/tmpjgxgzpwg.cpp:87:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141604
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ ans = 0, diff = 0;\n    long long temp = 0;\n    long long temp2 = 0;\n    long\
    \ long temp3 = 0;\n    long long temp4 = 0;\n    long long temp5 = 0;\n    long\
    \ long temp6 = 0;\n    long long temp7 = 0;\n    long long temp8 = 0;\n    long\
    \ long temp9 = 0;\n    long long temp10 = 0;\n    long long temp11 = 0;\n    long\
    \ long temp12 = 0;\n    long long temp13 = 0;\n    long long temp14 = 0;\n   \
    \ long long temp15 = 0;\n    long long temp16 = 0;\n    long long temp17 = 0;\n\
    \    long long temp18 = 0;\n    long long temp19 = 0;\n    long long temp20 =\
    \ 0;\n    long long temp21 = 0;\n    long long temp22 = 0;\n    long long temp23\
    \ = 0;\n    long long temp24 = 0;\n    long long temp25 = 0;\n    long long temp26\
    \ = 0;\n    long long temp27 = 0;\n    long long temp28 = 0;\n    long long temp29\
    \ = 0;\n    long long temp30 = 0;\n    long long temp31 = 0;\n    long long temp32\
    \ = 0;\n    long long temp33 = 0;\n    long long temp34 = 0;\n    long long temp35\
    \ = 0;\n    long long temp36 = 0;\n    long long temp37 = 0;\n    long long temp38\
    \ = 0;\n    long long temp39 = 0;\n    long long temp40 = 0;\n    long long temp41\
    \ = 0;\n    long long temp42 = 0;\n    long long temp43 = 0;\n    long long temp44\
    \ = 0;\n    long long temp45 = 0;\n    long long temp46 = 0;\n    long long temp47\
    \ = 0;\n    long long temp48 = 0;\n    long long temp49 = 0;\n    long long temp50\
    \ = 0;\n    long long temp51 = 0;\n    long long temp52 = 0;\n    long long temp53\
    \ = 0;\n    long long temp54 = 0;\n    long long temp55 = 0;\n    long long temp56\
    \ = 0;\n    long long temp57 = 0;\n    long long temp58 = 0;\n    long long temp59\
    \ = 0;\n    long long temp60 = 0;\n    long long temp61 = 0;\n    long long temp62\
    \ = 0;\n    long long temp63 = 0;\n    long long temp64 = 0;\n    long long temp65\
    \ = 0;\n    long long temp66 = 0;\n    long long temp67 = 0;\n    long long temp68\
    \ = 0;\n    long long temp69 = 0;\n    long long temp70 = 0;\n    long long temp71\
    \ = 0;\n    long long temp72 = 0;\n\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmph76pmdgg: /tmp/tmph76pmdgg.cpp:91: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141607
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Write your code here\n    long\
    \ ans = 0, diff = 0;\n    long num = std::stoll(value);\n    long diff = num -\
    \ ans;\n    while(diff >= 0) {\n        ans += 1;\n        diff -= 1;\n    }\n\
    \    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n   \
    \ assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2wq7s9pb.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp2wq7s9pb.cpp:16:10: error: redeclaration of \u2018long int diff\u2019\
    \n   16 |     long diff = num - ans;\n      |          ^~~~\n/tmp/tmp2wq7s9pb.cpp:14:19:\
    \ note: \u2018long int diff\u2019 previously declared here\n   14 |     long ans\
    \ = 0, diff = 0;\n      |                   ^~~~\n"
  stdout: ''
  timestamp: 1660141611
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num = 0;\n    long long\
    \ int min = 0;\n    long long int max = 0;\n    long long int mid = 0;\n    long\
    \ long int diff = 0;\n    long long int closest = 0;\n    long long int diff2\
    \ = 0;\n    long long int closest2 = 0;\n    long long int diff3 = 0;\n    long\
    \ long int closest3 = 0;\n    long long int diff4 = 0;\n    long long int closest4\
    \ = 0;\n    long long int diff5 = 0;\n    long long int closest5 = 0;\n    long\
    \ long int diff6 = 0;\n    long long int closest6 = 0;\n    long long int diff7\
    \ = 0;\n    long long int closest7 = 0;\n    long long int diff8 = 0;\n    long\
    \ long int closest8 = 0;\n    long long int diff9 = 0;\n    long long int closest9\
    \ = 0;\n    long long int diff10 = 0;\n    long long int closest10 = 0;\n    long\
    \ long int diff11 = 0;\n    long long int closest11 = 0;\n    long long int diff12\
    \ = 0;\n    long long int closest12 = 0;\n    long long int diff13 = 0;\n    long\
    \ long int closest13 = 0;\n    long long int diff14 = 0;\n    long long int closest14\
    \ = 0;\n    long long int diff15 = 0;\n    long long int closest15 = 0;\n    long\
    \ long int diff16 = 0;\n    long long int closest16 = 0;\n    long long int diff17\
    \ = 0;\n    long long int closest17 = 0;\n    long long int diff18 = 0;\n    long\
    \ long int closest18 = 0;\n    long long int diff19 = 0;\n    long long int closest19\
    \ = 0;\n    long long int diff20 = 0;\n    long long int closest20 = 0;\n    long\
    \ long int diff21 = 0;\n    long long int closest21 = 0;\n    long long int diff22\
    \ = 0;\n    long long int closest22 = 0;\n    long long int diff23 = 0;\n    long\
    \ long int closest23 = 0;\n    long long int diff24 = 0;\n    long long int closest24\
    \ = 0;\n    long long int diff25 = 0;\n    long long int closest25 = 0;\n    long\
    \ long int diff26 = 0;\n    long long int closest26 = 0;\n    long long int diff27\
    \ = 0;\n    long long int closest27 = 0;\n    long long int diff28 = 0;\n    long\
    \ long int closest28 = 0;\n    long long int diff29 = 0;\n    long long int closest29\
    \ = 0;\n    long long int diff30 = 0;\n    long long int closest30 = 0;\n    long\
    \ long int diff31 = 0;\n    long long int closest31\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp6bqz4n5m.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp6bqz4n5m.cpp:79:1: error: expected initializer before \u2018}\u2019\
    \ token\n   79 | }\n      | ^\n/tmp/tmp6bqz4n5m.cpp:79:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141611
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0, sign = 1;\n    long num = std::stoll(value);\n    long diff = abs(num - ans);\n\
    \    if (diff > 0.5) {\n        sign = -1;\n    }\n    ans = num + sign * diff;\n\
    \    return ans;\n}\nint main() {\n    auto candidate = closest_integer;\n   \
    \ assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp3j7t4wb_: /tmp/tmp3j7t4wb_.cpp:25: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141612
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int first = 0;\n    long\
    \ long int second = 0;\n    long long int third = 0;\n    long long int fourth\
    \ = 0;\n    long long int fifth = 0;\n    long long int sixth = 0;\n    long long\
    \ int seventh = 0;\n    long long int eighth = 0;\n    long long int ninth = 0;\n\
    \    long long int tenth = 0;\n    long long int eleventh = 0;\n    long long\
    \ int twelfth = 0;\n    long long int thirteenth = 0;\n    long long int fourteenth\
    \ = 0;\n    long long int fifteenth = 0;\n    long long int sixteenth = 0;\n \
    \   long long int seventeenth = 0;\n    long long int eighteenth = 0;\n    long\
    \ long int nineteenth = 0;\n    long long int twentieth = 0;\n    long long int\
    \ twentyfirst = 0;\n    long long int twentysecond = 0;\n    long long int twentythird\
    \ = 0;\n    long long int twentyfourth = 0;\n    long long int twentyfifth = 0;\n\
    \    long long int twentysixth = 0;\n    long long int twentyseventh = 0;\n  \
    \  long long int twentyeighth = 0;\n    long long int twentyninth = 0;\n    long\
    \ long int thirtieth = 0;\n    long long int thirtyfirst = 0;\n    long long int\
    \ thirtysecond = 0;\n    long long int thirtythird = 0;\n    long long int thirtyfourth\
    \ = 0;\n    long long int thirtyfifth = 0;\n    long long int thirtysixth = 0;\n\
    \    long long int thirtyseventh = 0;\n    long long int thirtyeighth = 0;\n \
    \   long long int thirtyninth = 0;\n    long long int fortieth = 0;\n    long\
    \ long int fortyfirst = 0;\n    long long int fortysecond = 0;\n    long long\
    \ int fortythird = 0;\n    long long int fortyfourth = 0;\n    long long int fortyfifth\
    \ = 0;\n    long long int fortysixth = 0;\n    long long int fortyseventh = 0;\n\
    \    long long int fortyeighth = 0;\n    long long int fortyninth = 0;\n    long\
    \ long int fiftieth = 0;\n    long long int fiftyfirst = 0;\n    long long int\
    \ fiftysecond = 0;\n    long long int fiftythird = 0;\n    long \n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmppghc0uwb.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmppghc0uwb.cpp:67:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   67 | }\n      | ^\n/tmp/tmppghc0uwb.cpp:67:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141603
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long sum = 0;\n    long temp = 0;\n    long count = 0;\n    long i =\
    \ 0;\n    long j = 0;\n    long k = 0;\n    long l = 0;\n    long m = 0;\n   \
    \ long n = 0;\n    long o = 0;\n    long p = 0;\n    long q = 0;\n    long r =\
    \ 0;\n    long s = 0;\n    long t = 0;\n    long u = 0;\n    long v = 0;\n   \
    \ long w = 0;\n    long x = 0;\n    long y = 0;\n    long z = 0;\n    long A =\
    \ 0;\n    long B = 0;\n    long C = 0;\n    long D = 0;\n    long E = 0;\n   \
    \ long F = 0;\n    long G = 0;\n    long H = 0;\n    long I = 0;\n    long J =\
    \ 0;\n    long K = 0;\n    long L = 0;\n    long M = 0;\n    long N = 0;\n   \
    \ long O = 0;\n    long P = 0;\n    long Q = 0;\n    long R = 0;\n    long S =\
    \ 0;\n    long T = 0;\n    long U = 0;\n    long V = 0;\n    long W = 0;\n   \
    \ long X = 0;\n    long Y = 0;\n    long Z = 0;\n    long a = 0;\n    long b =\
    \ 0;\n    long c = 0;\n    long d = 0;\n    long e = 0;\n    long f = 0;\n   \
    \ long g = 0;\n    long h = 0;\n    long i = 0;\n    long j = 0;\n    long k =\
    \ 0;\n    long l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n   \
    \ long p = 0;\n    long q = 0;\n    long r = 0;\n    long s = 0;\n    long t =\
    \ 0;\n    long u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n   \
    \ long y = 0;\n    long z = 0;\n    long A = 0;\n    long B = 0;\n    long C =\
    \ 0;\n    long D = 0;\n    long E = 0;\n    long F = 0;\n    long G = 0;\n   \
    \ long H = 0;\n    long I = 0;\n    long J = 0;\n    long K = 0;\n    long L =\
    \ 0;\n    long M = 0;\n    long N = 0;\n    long O = 0;\n    long P = 0;\n   \
    \ long Q = 0;\n    long R = 0;\n    long S = 0;\n    long T = 0;\n    long U =\
    \ 0;\n    long V = 0;\n    long W = 0;\n    long X = 0;\n    long Y = 0;\n   \
    \ long Z = 0;\n    long a = 0;\n    long b = 0;\n    long c = 0;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyuywo84f.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpyuywo84f.cpp:70:10: error: redeclaration of \u2018long int i\u2019\n\
    \   70 |     long i = 0;\n      |          ^\n/tmp/tmpyuywo84f.cpp:18:10: note:\
    \ \u2018long int i\u2019 previously declared here\n   18 |     long i = 0;\n \
    \     |          ^\n/tmp/tmpyuywo84f.cpp:71:10: error: redeclaration of \u2018\
    long int j\u2019\n   71 |     long j = 0;\n      |          ^\n/tmp/tmpyuywo84f.cpp:19:10:\
    \ note: \u2018long int j\u2019 previously declared here\n   19 |     long j =\
    \ 0;\n      |          ^\n/tmp/tmpyuywo84f.cpp:72:10: error: redeclaration of\
    \ \u2018long int k\u2019\n   72 |     long k = 0;\n      |          ^\n/tmp/tmpyuywo84f.cpp:20:10:\
    \ note: \u2018long int k\u2019 previously declared here\n   20 |     long k =\
    \ 0;\n      |          ^\n/tmp/tmpyuywo84f.cpp:73:10: error: redeclaration of\
    \ \u2018long int l\u2019\n   73 |     long l = 0;\n      |          ^\n/tmp/tmpyuywo84f.cpp:21:10:\
    \ note: \u2018long int l\u2019 previously declared here\n   21 |     long l =\
    \ 0;\n      |          ^\n/tmp/tmpyuywo84f.cpp:74:10: error: redeclaration of\
    \ \u2018long int m\u2019\n   74 |     long m = 0;\n      |          ^\n/tmp/tmpyuywo84f.cpp:22:10:\
    \ note: \u2018long int m\u2019 previously declared here\n   22 |     long m =\
    \ 0;\n      |          ^\n/tmp/tmpyuywo84f.cpp:75:10: error: redeclaration of\
    \ \u2018long int n\u2019\n   75 |     long n = 0;\n      |          ^\n/tmp/tmpyuywo84f.cpp:23:10:\
    \ note: \u2018long int n\u2019 previously declared here\n   23 |     long n =\
    \ 0;\n      |          ^\n/tmp/tmpyuywo84f.cpp:76:10: error: redeclaration of\
    \ \u2018long int o\u2019\n   76 |     long o = 0;\n      |          ^\n/tmp/tmpyuywo84f.cpp:24:10:\
    \ note: \u2018long int o\u2019 previously declared here\n   24 |     long o =\
    \ 0;\n      |          ^\n/tmp/tmpyuywo84f.cpp:77:10: error: redeclaration of\
    \ \u2018long int p\u2019\n   77 |     long p = 0;\n      |          ^\n/tmp/tmpyuywo84f.cpp:25:10:\
    \ note: \u2018long int p\u2019 previously declared here\n   25 |     long p =\
    \ 0;\n      |          ^\n/tmp/tmpyuywo84f.cpp:78:10: error: redeclaration of\
    \ \u2018long int q\u2019\n   78 |     long q = 0;\n      |          ^\n/tmp/tmpy"
  stdout: ''
  timestamp: 1660141611
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    long ans =\
    \ 0;\n    long l = 0;\n    long h = 0;\n    long mid = 0;\n    long mid2 = 0;\n\
    \    long mid3 = 0;\n    long mid4 = 0;\n    long mid5 = 0;\n    long mid6 = 0;\n\
    \    long mid7 = 0;\n    long mid8 = 0;\n    long mid9 = 0;\n    long mid10 =\
    \ 0;\n    long mid11 = 0;\n    long mid12 = 0;\n    long mid13 = 0;\n    long\
    \ mid14 = 0;\n    long mid15 = 0;\n    long mid16 = 0;\n    long mid17 = 0;\n\
    \    long mid18 = 0;\n    long mid19 = 0;\n    long mid20 = 0;\n    long mid21\
    \ = 0;\n    long mid22 = 0;\n    long mid23 = 0;\n    long mid24 = 0;\n    long\
    \ mid25 = 0;\n    long mid26 = 0;\n    long mid27 = 0;\n    long mid28 = 0;\n\
    \    long mid29 = 0;\n    long mid30 = 0;\n    long mid31 = 0;\n    long mid32\
    \ = 0;\n    long mid33 = 0;\n    long mid34 = 0;\n    long mid35 = 0;\n    long\
    \ mid36 = 0;\n    long mid37 = 0;\n    long mid38 = 0;\n    long mid39 = 0;\n\
    \    long mid40 = 0;\n    long mid41 = 0;\n    long mid42 = 0;\n    long mid43\
    \ = 0;\n    long mid44 = 0;\n    long mid45 = 0;\n    long mid46 = 0;\n    long\
    \ mid47 = 0;\n    long mid48 = 0;\n    long mid49 = 0;\n    long mid50 = 0;\n\
    \    long mid51 = 0;\n    long mid52 = 0;\n    long mid53 = 0;\n    long mid54\
    \ = 0;\n    long mid55 = 0;\n    long mid56 = 0;\n    long mid57 = 0;\n    long\
    \ mid58 = 0;\n    long mid59 = 0;\n    long mid60 = 0;\n    long mid61 = 0;\n\
    \    long mid62 = 0;\n    long mid63 = 0;\n    long mid64 = 0;\n    long mid65\
    \ = 0;\n    long mid66 = 0;\n    long mid67 = 0;\n    long mid68 = 0;\n    long\
    \ mid69 = 0;\n    long mid70 = 0;\n    long mid71 = 0;\n    long mid72 = 0;\n\
    \    long mid73 = 0;\n    long mid74 = 0;\n    long mid75 = 0;\n    long mid76\
    \ = 0;\n    long mid77 = 0;\n    long mid78 = 0;\n    long mid79 = 0;\n    long\
    \ mid80 = 0;\n    long mid81 = 0;\n    long mid82 = 0;\n    long mid83 = 0;\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpf2fruqxz: /tmp/tmpf2fruqxz.cpp:103: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141612
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long lower = 0, upper = std::stoll(value),\
    \ mid;\n    long diff = upper - lower;\n    while (diff > 0) {\n        mid =\
    \ (lower + upper) / 2;\n        if (mid * mid > diff) {\n            upper = mid;\n\
    \        } else {\n            lower = mid;\n        }\n        diff = upper -\
    \ lower;\n    }\n    return lower;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpyy2n4ofj: /tmp/tmpyy2n4ofj.cpp:28: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141612
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long temp = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long\
    \ l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n\
    \    long q = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n    long\
    \ u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n\
    \    long z = 0;\n    long A = 0;\n    long B = 0;\n    long C = 0;\n    long\
    \ D = 0;\n    long E = 0;\n    long F = 0;\n    long G = 0;\n    long H = 0;\n\
    \    long I = 0;\n    long J = 0;\n    long K = 0;\n    long L = 0;\n    long\
    \ M = 0;\n    long N = 0;\n    long O = 0;\n    long P = 0;\n    long Q = 0;\n\
    \    long R = 0;\n    long S = 0;\n    long T = 0;\n    long U = 0;\n    long\
    \ V = 0;\n    long W = 0;\n    long X = 0;\n    long Y = 0;\n    long Z = 0;\n\
    \    long aa = 0;\n    long bb = 0;\n    long cc = 0;\n    long dd = 0;\n    long\
    \ ee = 0;\n    long ff = 0;\n    long gg = 0;\n    long hh = 0;\n    long ii =\
    \ 0;\n    long jj = 0;\n    long kk = 0;\n    long ll = 0;\n    long mm = 0;\n\
    \    long nn = 0;\n    long oo = 0;\n    long pp = 0;\n    long qq = 0;\n    long\
    \ rr = 0;\n    long ss = 0;\n    long tt = 0;\n    long uu = 0;\n    long vv =\
    \ 0;\n    long ww = 0;\n    long xx = 0;\n    long yy = 0;\n    long zz = 0;\n\
    \    long Aa = 0;\n    long Bb = 0;\n    long Cc = 0;\n    long Dd = 0;\n    long\
    \ Ee = 0;\n    long Ff = 0;\n    long Gg = 0;\n    long Hh = 0;\n    long Ii =\
    \ 0;\n    long Jj = 0;\n    long Kk = 0;\n    long Ll = 0;\n    long Mm = 0;\n\
    \    long Nn = 0;\n    long Oo = 0;\n    long Pp = 0;\n    long Qq = 0;\n    long\
    \ Rr = 0;\n    long Ss = 0;\n    long Tt = 0;\n    long Uu = 0;\n    long Vv =\
    \ 0;\n    long Ww = 0;\n    long Xx = 0;\n    long Yy = 0;\n    long Z\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxevzbc6_.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpxevzbc6_.cpp:112:1: error: expected initializer before \u2018}\u2019\
    \ token\n  112 | }\n      | ^\n/tmp/tmpxevzbc6_.cpp:112:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141607
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long diff = 0;\n\
    \    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4\
    \ = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long\
    \ temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n\
    \    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15\
    \ = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n   \
    \ long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22\
    \ = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n   \
    \ long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29\
    \ = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n   \
    \ long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36\
    \ = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n   \
    \ long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43\
    \ = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n   \
    \ long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50\
    \ = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n   \
    \ long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57\
    \ = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n   \
    \ long temp61 = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64\
    \ = 0;\n    long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n   \
    \ long temp68 = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71\
    \ = 0;\n    long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n   \
    \ long temp75 = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78\
    \ = 0;\n    long temp79 = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n   \
    \ long temp82 = 0;\n    long temp83 = 0;\n    long temp84 = 0;\n    long temp\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpul38oo9h.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpul38oo9h.cpp:100:1: error: expected initializer before \u2018}\u2019\
    \ token\n  100 | }\n      | ^\n/tmp/tmpul38oo9h.cpp:100:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141607
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ temp = 0;\n    long diff2 = 0;\n    long temp2 = 0;\n    long diff3 = 0;\n \
    \   long temp3 = 0;\n    long diff4 = 0;\n    long temp4 = 0;\n    long diff5\
    \ = 0;\n    long temp5 = 0;\n    long diff6 = 0;\n    long temp6 = 0;\n    long\
    \ diff7 = 0;\n    long temp7 = 0;\n    long diff8 = 0;\n    long temp8 = 0;\n\
    \    long diff9 = 0;\n    long temp9 = 0;\n    long diff10 = 0;\n    long temp10\
    \ = 0;\n    long diff11 = 0;\n    long temp11 = 0;\n    long diff12 = 0;\n   \
    \ long temp12 = 0;\n    long diff13 = 0;\n    long temp13 = 0;\n    long diff14\
    \ = 0;\n    long temp14 = 0;\n    long diff15 = 0;\n    long temp15 = 0;\n   \
    \ long diff16 = 0;\n    long temp16 = 0;\n    long diff17 = 0;\n    long temp17\
    \ = 0;\n    long diff18 = 0;\n    long temp18 = 0;\n    long diff19 = 0;\n   \
    \ long temp19 = 0;\n    long diff20 = 0;\n    long temp20 = 0;\n    long diff21\
    \ = 0;\n    long temp21 = 0;\n    long diff22 = 0;\n    long temp22 = 0;\n   \
    \ long diff23 = 0;\n    long temp23 = 0;\n    long diff24 = 0;\n    long temp24\
    \ = 0;\n    long diff25 = 0;\n    long temp25 = 0;\n    long diff26 = 0;\n   \
    \ long temp26 = 0;\n    long diff27 = 0;\n    long temp27 = 0;\n    long diff28\
    \ = 0;\n    long temp28 = 0;\n    long diff29 = 0;\n    long temp29 = 0;\n   \
    \ long diff30 = 0;\n    long temp30 = 0;\n    long diff31 = 0;\n    long temp31\
    \ = 0;\n    long diff32 = 0;\n    long temp32 = 0;\n    long diff33 = 0;\n   \
    \ long temp33 = 0;\n    long diff34 = 0;\n    long temp34 = 0;\n    long diff35\
    \ = 0;\n    long temp35 = 0;\n    long diff36 = 0;\n    long temp36 = 0;\n   \
    \ long diff37 = 0;\n    long temp37 = 0;\n    long diff38 = 0;\n    long temp38\
    \ = 0;\n    long diff39 = 0;\n    long temp39 = 0;\n    long diff40 = 0;\n   \
    \ long temp40 = 0;\n    long diff41 = 0;\n    long temp41 = 0;\n    long diff42\
    \ = 0;\n    long temp42 = 0;\n    long diff43 = 0;\n    long temp43 = 0;\n   \
    \ long diff\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpebi77oti.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpebi77oti.cpp:100:1: error: expected initializer before \u2018}\u2019\
    \ token\n  100 | }\n      | ^\n/tmp/tmpebi77oti.cpp:100:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141611
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0;\n    long temp = 0;\n\
    \    long diff = 0;\n    long i = 0;\n    long j = 0;\n    long k = 0;\n    long\
    \ l = 0;\n    long m = 0;\n    long n = 0;\n    long o = 0;\n    long p = 0;\n\
    \    long q = 0;\n    long r = 0;\n    long s = 0;\n    long t = 0;\n    long\
    \ u = 0;\n    long v = 0;\n    long w = 0;\n    long x = 0;\n    long y = 0;\n\
    \    long z = 0;\n    long A = 0;\n    long B = 0;\n    long C = 0;\n    long\
    \ D = 0;\n    long E = 0;\n    long F = 0;\n    long G = 0;\n    long H = 0;\n\
    \    long I = 0;\n    long J = 0;\n    long K = 0;\n    long L = 0;\n    long\
    \ M = 0;\n    long N = 0;\n    long O = 0;\n    long P = 0;\n    long Q = 0;\n\
    \    long R = 0;\n    long S = 0;\n    long T = 0;\n    long U = 0;\n    long\
    \ V = 0;\n    long W = 0;\n    long X = 0;\n    long Y = 0;\n    long Z = 0;\n\
    \    long aa = 0;\n    long bb = 0;\n    long cc = 0;\n    long dd = 0;\n    long\
    \ ee = 0;\n    long ff = 0;\n    long gg = 0;\n    long hh = 0;\n    long ii =\
    \ 0;\n    long jj = 0;\n    long kk = 0;\n    long ll = 0;\n    long mm = 0;\n\
    \    long nn = 0;\n    long oo = 0;\n    long pp = 0;\n    long qq = 0;\n    long\
    \ rr = 0;\n    long ss = 0;\n    long tt = 0;\n    long uu = 0;\n    long vv =\
    \ 0;\n    long ww = 0;\n    long xx = 0;\n    long yy = 0;\n    long zz = 0;\n\
    \    long Aa = 0;\n    long Bb = 0;\n    long Cc = 0;\n    long Dd = 0;\n    long\
    \ Ee = 0;\n    long Ff = 0;\n    long Gg = 0;\n    long Hh = 0;\n    long Ii =\
    \ 0;\n    long Jj = 0;\n    long Kk = 0;\n    long Ll = 0;\n    long Mm = 0;\n\
    \    long Nn = 0;\n    long Oo = 0;\n    long Pp = 0;\n    long Qq = 0;\n    long\
    \ Rr = 0;\n    long Ss = 0;\n    long Tt = 0;\n    long Uu = 0;\n    long Vv =\
    \ 0;\n    long Ww = 0;\n    long Xx = 0;\n    long Yy = 0;\n    long Z\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpy2cu0ocm.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpy2cu0ocm.cpp:112:1: error: expected initializer before \u2018}\u2019\
    \ token\n  112 | }\n      | ^\n/tmp/tmpy2cu0ocm.cpp:112:1: warning: no return\
    \ statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141611
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n \
    \   long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8\
    \ = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long\
    \ temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n\
    \    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19\
    \ = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n   \
    \ long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26\
    \ = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n   \
    \ long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33\
    \ = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n   \
    \ long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40\
    \ = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n   \
    \ long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47\
    \ = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n   \
    \ long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54\
    \ = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n   \
    \ long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61\
    \ = 0;\n    long temp62 = 0;\n    long temp63 = 0;\n    long temp64 = 0;\n   \
    \ long temp65 = 0;\n    long temp66 = 0;\n    long temp67 = 0;\n    long temp68\
    \ = 0;\n    long temp69 = 0;\n    long temp70 = 0;\n    long temp71 = 0;\n   \
    \ long temp72 = 0;\n    long temp73 = 0;\n    long temp74 = 0;\n    long temp75\
    \ = 0;\n    long temp76 = 0;\n    long temp77 = 0;\n    long temp78 = 0;\n   \
    \ long temp79 = 0;\n    long temp80 = 0;\n    long temp81 = 0;\n    long temp82\
    \ = 0;\n    long temp83 = 0;\n    long temp84 = 0;\n    long temp85 = 0;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp8wv4j_et: /tmp/tmp8wv4j_et.cpp:102: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660141605
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long ans = 0, diff = 0;\n    long\
    \ temp = 0;\n    long a = stoi(value);\n    long b = ans;\n    long c = a;\n \
    \   long d = b;\n    long e = c;\n    long f = d;\n    long g = e;\n    long h\
    \ = f;\n    long i = g;\n    long j = h;\n    long k = i;\n    long l = j;\n \
    \   long m = k;\n    long n = l;\n    long o = m;\n    long p = n;\n    long q\
    \ = o;\n    long r = p;\n    long s = q;\n    long t = r;\n    long u = s;\n \
    \   long v = t;\n    long w = u;\n    long x = v;\n    long y = w;\n    long z\
    \ = x;\n    long a = stoi(value);\n    long b = ans;\n    long c = a;\n    long\
    \ d = b;\n    long e = c;\n    long f = d;\n    long g = e;\n    long h = f;\n\
    \    long i = g;\n    long j = h;\n    long k = i;\n    long l = j;\n    long\
    \ m = k;\n    long n = l;\n    long o = m;\n    long p = n;\n    long q = o;\n\
    \    long r = p;\n    long s = q;\n    long t = r;\n    long u = s;\n    long\
    \ v = t;\n    long w = u;\n    long x = v;\n    long y = w;\n    long z = x;\n\
    \    long a = stoi(value);\n    long b = ans;\n    long c = a;\n    long d = b;\n\
    \    long e = c;\n    long f = d;\n    long g = e;\n    long h = f;\n    long\
    \ i = g;\n    long j = h;\n    long k = i;\n    long l = j;\n    long m = k;\n\
    \    long n = l;\n    long o = m;\n    long p = n;\n    long q = o;\n    long\
    \ r = p;\n    long s = q;\n    long t = r;\n    long u = s;\n    long v = t;\n\
    \    long w = u;\n    long x = v;\n    long y = w;\n    long z = x;\n    long\
    \ a = stoi(value);\n    long b = ans;\n    long c = a;\n    long d = b;\n    long\
    \ e = c;\n    long f = d;\n    long g = e;\n    long h = f;\n    long i = g;\n\
    \    long j = h;\n    long k = i;\n    long l = j;\n    long m = k;\n    long\
    \ n = l;\n    long o = m;\n    \n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpb9y0nett.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpb9y0nett.cpp:41:10: error: redeclaration of \u2018long int a\u2019\n\
    \   41 |     long a = stoi(value);\n      |          ^\n/tmp/tmpb9y0nett.cpp:15:10:\
    \ note: \u2018long int a\u2019 previously declared here\n   15 |     long a =\
    \ stoi(value);\n      |          ^\n/tmp/tmpb9y0nett.cpp:42:10: error: redeclaration\
    \ of \u2018long int b\u2019\n   42 |     long b = ans;\n      |          ^\n/tmp/tmpb9y0nett.cpp:16:10:\
    \ note: \u2018long int b\u2019 previously declared here\n   16 |     long b =\
    \ ans;\n      |          ^\n/tmp/tmpb9y0nett.cpp:43:10: error: redeclaration of\
    \ \u2018long int c\u2019\n   43 |     long c = a;\n      |          ^\n/tmp/tmpb9y0nett.cpp:17:10:\
    \ note: \u2018long int c\u2019 previously declared here\n   17 |     long c =\
    \ a;\n      |          ^\n/tmp/tmpb9y0nett.cpp:44:10: error: redeclaration of\
    \ \u2018long int d\u2019\n   44 |     long d = b;\n      |          ^\n/tmp/tmpb9y0nett.cpp:18:10:\
    \ note: \u2018long int d\u2019 previously declared here\n   18 |     long d =\
    \ b;\n      |          ^\n/tmp/tmpb9y0nett.cpp:45:10: error: redeclaration of\
    \ \u2018long int e\u2019\n   45 |     long e = c;\n      |          ^\n/tmp/tmpb9y0nett.cpp:19:10:\
    \ note: \u2018long int e\u2019 previously declared here\n   19 |     long e =\
    \ c;\n      |          ^\n/tmp/tmpb9y0nett.cpp:46:10: error: redeclaration of\
    \ \u2018long int f\u2019\n   46 |     long f = d;\n      |          ^\n/tmp/tmpb9y0nett.cpp:20:10:\
    \ note: \u2018long int f\u2019 previously declared here\n   20 |     long f =\
    \ d;\n      |          ^\n/tmp/tmpb9y0nett.cpp:47:10: error: redeclaration of\
    \ \u2018long int g\u2019\n   47 |     long g = e;\n      |          ^\n/tmp/tmpb9y0nett.cpp:21:10:\
    \ note: \u2018long int g\u2019 previously declared here\n   21 |     long g =\
    \ e;\n      |          ^\n/tmp/tmpb9y0nett.cpp:48:10: error: redeclaration of\
    \ \u2018long int h\u2019\n   48 |     long h = f;\n      |          ^\n/tmp/tmpb9y0nett.cpp:22:10:\
    \ note: \u2018long int h\u2019 previously declared here\n   22 |     long h =\
    \ f;\n      |          ^\n/tmp/tmpb9y0nett.cpp:49:10: error: redeclaration of\
    \ \u2018long int i\u2019\n   49 |     long i = g;\n    "
  stdout: ''
  timestamp: 1660141611
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    long long int num;\n    double temp;\n\
    \    temp = atof(value.c_str());\n    num = temp;\n    long long int temp2;\n\
    \    temp2 = num;\n    long long int temp3;\n    temp3 = num;\n    long long int\
    \ temp4;\n    temp4 = num;\n    long long int temp5;\n    temp5 = num;\n    long\
    \ long int temp6;\n    temp6 = num;\n    long long int temp7;\n    temp7 = num;\n\
    \    long long int temp8;\n    temp8 = num;\n    long long int temp9;\n    temp9\
    \ = num;\n    long long int temp10;\n    temp10 = num;\n    long long int temp11;\n\
    \    temp11 = num;\n    long long int temp12;\n    temp12 = num;\n    long long\
    \ int temp13;\n    temp13 = num;\n    long long int temp14;\n    temp14 = num;\n\
    \    long long int temp15;\n    temp15 = num;\n    long long int temp16;\n   \
    \ temp16 = num;\n    long long int temp17;\n    temp17 = num;\n    long long int\
    \ temp18;\n    temp18 = num;\n    long long int temp19;\n    temp19 = num;\n \
    \   long long int temp20;\n    temp20 = num;\n    long long int temp21;\n    temp21\
    \ = num;\n    long long int temp22;\n    temp22 = num;\n    long long int temp23;\n\
    \    temp23 = num;\n    long long int temp24;\n    temp24 = num;\n    long long\
    \ int temp25;\n    temp25 = num;\n    long long int temp26;\n    temp26 = num;\n\
    \    long long int temp27;\n    temp27 = num;\n    long long int temp28;\n   \
    \ temp28 = num;\n    long long int temp29;\n    temp29 = num;\n    long long int\
    \ temp30;\n    temp30 = num;\n    long long int temp31;\n    temp31 = num;\n \
    \   long long int temp32;\n    temp32 = num;\n    long long int temp33;\n    temp33\
    \ = num;\n    long long int temp34;\n    temp34 = num;\n    long long int temp35;\n\
    \    temp35 = num;\n    long long int \n}\nint main() {\n    auto candidate =\
    \ closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa4hr8efo.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpa4hr8efo.cpp:86:1: error: expected unqualified-id before \u2018}\u2019\
    \ token\n   86 | }\n      | ^\n/tmp/tmpa4hr8efo.cpp:86:1: warning: no return statement\
    \ in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660141612
