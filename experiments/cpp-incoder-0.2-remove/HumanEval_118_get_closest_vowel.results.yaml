language: cpp
name: HumanEval_118_get_closest_vowel
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = vowels.rbegin() + vowels.size();\n    std::string vowels_reverse2 = vowels.rbegin()\
    \ + vowels.size() + 1;\n    std::string vowels_reverse3 = vowels.rbegin() + vowels.size()\
    \ + 2;\n    std::string vowels_reverse4 = vowels.rbegin() + vowels.size() + 3;\n\
    \    std::string vowels_reverse5 = vowels.rbegin() + vowels.size() + 4;\n    std::string\
    \ vowels_reverse6 = vowels.rbegin() + vowels.size() + 5;\n    std::string vowels_reverse7\
    \ = vowels.rbegin() + vowels.size() + 6;\n    std::string vowels_reverse8 = vowels.rbegin()\
    \ + vowels.size() + 7;\n    std::string vowels_reverse9 = vowels.rbegin() + vowels.size()\
    \ + 8;\n    std::string vowels_reverse10 = vowels.rbegin() + vowels.size() + 9;\n\
    \    std::string vowels_reverse11 = vowels.rbegin() + vowels.size() + 10;\n  \
    \  std::string vowels_reverse12 = vowels.rbegin() + vowels.size() + 11;\n    std::string\
    \ vowels_reverse13 = vowels.rbegin() + vowels.size() + 12;\n    std::string vowels_reverse14\
    \ = vowels.rbegin() + vowels.size() + 13;\n    std::string vowels_reverse15 =\
    \ vowels.rbegin() + vowels.size() + 14;\n    std::string vowels_reverse16 = vowels.rbegin()\
    \ + vowels.size() + 15;\n    std::string vowels_reverse17 = vowels.rbegin() +\
    \ vowels.size() + 16;\n    std::string vowels_reverse18 = vowels.rbegin() + vowels.size()\
    \ + 17;\n    std::string vowels_reverse19 = vowels.rbegin() + vowels.size() +\
    \ 18;\n    std::string vowels_reverse20 = vowels.rbegin() + vowels.size() + 19;\n\
    \    std::string vowels_reverse21 = vowels.rbegin() + vowels.size() + 20;\n  \
    \  std::string vowels_reverse22 = vowels.rbegin() + vowels.size() + 21;\n    std::string\
    \ vowels_reverse23 = vowels.rbegin() + vowels.size() + 22;\n    std::string vowels_reverse24\
    \ = vowels.rbegin() + vowels.size() + 23;\n    std::string vowels_reverse25 =\
    \ vowels.rbegin() + vowels.size() + 24;\n    std::string vowels_reverse26 = vowels.rbegin()\
    \ + vowels.size() + 25;\n    std::string vowels_reverse27 = vowels.rbegin() +\
    \ vowels.size() + 26;\n    std::string vowels_reverse28 = vowels.rbegin() + vowels.size()\
    \ + 27;\n    std::string vowels_reverse29 = vowels.rbegin() + vowels.size() +\
    \ 28;\n    std::string vowels_reverse30 = vowels.r\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpo3y5xsnx.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int len = word.size();\n\
    \    std::string ans = \"\";\n    int i = 0;\n    while (i < len) {\n        int\
    \ j = i + 1;\n        while (j < len) {\n            if (word[i] == word[j] &&\
    \ word[i] != word[j]) {\n                int k = j;\n                while (k\
    \ < len) {\n                    if (word[k] == word[j] && word[k] != word[j])\
    \ {\n                        k = k + 1;\n                    }\n             \
    \       else {\n                        break;\n                    }\n      \
    \          }\n                if (k == len) {\n                    ans = ans +\
    \ word[i];\n                }\n                else {\n                    ans\
    \ = ans + word[i] + word[k];\n                }\n            }\n            else\
    \ {\n                break;\n            }\n            j = j + 1;\n        }\n\
    \        i = i + 1;\n    }\n    return ans;\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqr9kep4j.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start = \"aeiouAEIOU\";\n    std::string\
    \ vowels_start_end = \"AEIOUaeiou\";\n    std::string vowels_start_end_end = \"\
    aeiouAEIOUaeiou\";\n    std::string vowels_start_end_end_end = \"aeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_end_end_end = \"aeiouAEIOUaeiou\";\n    std::string\
    \ vowels_start_end_end_end_end_end = \"aeiouAEIOUaeiou\";\n    std::string vowels_start_end_end_end_end_end_end\
    \ = \"aeiouAEIOUaeiou\";\n    std::string vowels_start_end_end_end_end_end_end_end\
    \ = \"aeiouAEIOUaeiou\";\n    std::string vowels_start_end_end_end_end_end_end_end_end\
    \ = \"aeiouAEIOUaeiou\";\n    std::string vowels_start_end_end_end_end_end_end_end_end\
    \ = \"aeiouAEIOUaeiou\";\n    std::string vowels_start_end_end_end_end_end_end_end_end_end\
    \ = \"aeiouAEIOUaeiou\";\n    std::string vowels_start_end_end_end_end_end_end_end_end_end_end\
    \ = \"aeiouAEIOUaeiou\";\n    std::string vowels_start_end_end_end_end_end_end_end_end_end_end\
    \ = \"aeiouAEIOUaeiou\";\n    std::string vowels_start_end_end_end_end_end_end_end_end_end_end\
    \ = \"aeiouAEIOUaeiou\";\n    std::string vowels_start_end_end_end_end_end_end_end_end_end_end_end\
    \ = \"aeiouAEIOUaeiou\";\n    std::string vowels_start_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = \"aeiouAEIOUaeiou\";\n    std::string vowels_start_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = \"aeiouAEIOUaeiou\";\n    std::string vowels_start_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = \"aeiouAEIOUaeiou\";\n    std::string vowels_start_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = \"aeiouAEIOUaeiou\";\n    std::string vowels_start_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = \"aeiouAEIOUaeiou\";\n    std::string vowels_start_end_end_end_end_end_end_end_end_end_end_end_end_end\
    \ = \"aeiouAEIOUaeiou\";\n    std::string vowels_start_end_end_end_end_\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpehv0u8rz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin = \"aeiouAEIOU\";\n    std::string\
    \ vowels_begin2 = \"aeiouAEIOUaeiou\";\n    std::string vowels_begin3 = \"aeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_begin4 = \"aeiouAEIOUaeiouAEIOUaeiou\";\n    std::string\
    \ vowels_begin5 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOU\";\n    std::string vowels_begin6\
    \ = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\";\n    std::string vowels_begin7 =\
    \ \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\";\n    std::string vowels_begin8\
    \ = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\";\n    std::string vowels_begin9\
    \ = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\";\n    std::string vowels_begin10\
    \ = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\";\n    std::string\
    \ vowels_begin11 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_begin12 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_begin13 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_begin14 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_begin15 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_begin16 = \"aeiouAEIOUaeiouAEIOUaeiouAE\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpggjmj_0n.cpp:27:34: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_begin16 = \"aeiouAEIOUaeiouAEIOUaeiouAE\n\
    \                                  ^\n/tmp/tmpggjmj_0n.cpp:27:5: error: missing\
    \ terminating \" character\n     std::string vowels_begin16 = \"aeiouAEIOUaeiouAEIOUaeiouAE\n\
    \     ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpggjmj_0n.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_al"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Your code goes here\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    int len = word.size();\n    int i = 0;\n    int j = 0;\n    int k = 0;\n\
    \    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n\
    \    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n\
    \    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n\
    \    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n    int e = 0;\n\
    \    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n    int j = 0;\n\
    \    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n    int o = 0;\n\
    \    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n    int t = 0;\n\
    \    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n    int y = 0;\n\
    \    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n    int d = 0;\n\
    \    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n    int i = 0;\n\
    \    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n    int n = 0;\n\
    \    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n    int s = 0;\n\
    \    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n    int x = 0;\n\
    \    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n    int c = 0;\n\
    \    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n    int h = 0;\n\
    \    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n    int m = 0;\n\
    \    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n    int r = 0;\n\
    \    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n    int w = 0;\n\
    \    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n    int b = 0;\n\
    \    int c = 0;\n    int d = 0;\n    int e = 0;\n    int f = 0;\n    int g = 0;\n\
    \    int h = 0;\n    int i = 0;\n    int j = 0;\n    int k = 0;\n    int l = 0;\n\
    \    int m = 0;\n    int n = 0;\n    int o = 0;\n    int p = 0;\n    int q = 0;\n\
    \    int r = 0;\n    int s = 0;\n    int t = 0;\n    int u = 0;\n    int v = 0;\n\
    \    int w = 0;\n    int x = 0;\n    int y = 0;\n    int z = 0;\n    int a = 0;\n\
    \    int b = 0;\n    int c = 0;\n    int d = 0;\n\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8uf1rvr2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int n = word.size();\n\
    \    int m = vowels.size();\n    int vowel_index = 0;\n    int consonant_index\
    \ = 0;\n    std::string vowel_found = \"\";\n    std::string consonant_found =\
    \ \"\";\n    for(int i = n-1; i>=0; i--){\n        if(word[i] == 'a'){\n     \
    \       vowel_index = i;\n        }\n        if(word[i] == 'e'){\n           \
    \ vowel_index = i;\n        }\n        if(word[i] == 'i'){\n            vowel_index\
    \ = i;\n        }\n        if(word[i] == 'o'){\n            vowel_index = i;\n\
    \        }\n        if(word[i] == 'u'){\n            vowel_index = i;\n      \
    \  }\n    }\n    for(int i = m-1; i>=0; i--){\n        if(word[i] == 'a'){\n \
    \           consonant_index = i;\n        }\n        if(word[i] == 'e'){\n   \
    \         consonant_index = i;\n        }\n        if(word[i] == 'i'){\n     \
    \       consonant_index = i;\n        }\n        if(word[i] == 'o'){\n       \
    \     consonant_index = i;\n        }\n        if(word[i] == 'u'){\n         \
    \   consonant_index = i;\n        }\n    }\n    if(vowel_index == -1){\n     \
    \   return \"\";\n    }\n    if(consonant_index == -1){\n        return \"\";\n\
    \    }\n    if(vowel_index > consonant_index){\n        vowel_found = word[vowel_index];\n\
    \    }\n    else{\n        consonant_found = word[consonant_index];\n    }\n \
    \   if(vowel_found == consonant_found){\n        return \"\";\n    }\n    if(vowel_found\
    \ < consonant_found){\n        return vowel_found;\n    }\n    else{\n       \
    \ return consonant_found;\n    }\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpq0erauav.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = vowels.rbegin();\n    std::string vowels_reverse2 = vowels.rend();\n    std::string\
    \ vowels_reverse3 = vowels.rbegin();\n    std::string vowels_reverse4 = vowels.rend();\n\
    \    std::string vowels_reverse5 = vowels.rbegin();\n    std::string vowels_reverse6\
    \ = vowels.rend();\n    std::string vowels_reverse7 = vowels.rbegin();\n    std::string\
    \ vowels_reverse8 = vowels.rend();\n    std::string vowels_reverse9 = vowels.rbegin();\n\
    \    std::string vowels_reverse10 = vowels.rend();\n    std::string vowels_reverse11\
    \ = vowels.rbegin();\n    std::string vowels_reverse12 = vowels.rend();\n    std::string\
    \ vowels_reverse13 = vowels.rbegin();\n    std::string vowels_reverse14 = vowels.rend();\n\
    \    std::string vowels_reverse15 = vowels.rbegin();\n    std::string vowels_reverse16\
    \ = vowels.rend();\n    std::string vowels_reverse17 = vowels.rbegin();\n    std::string\
    \ vowels_reverse18 = vowels.rend();\n    std::string vowels_reverse19 = vowels.rbegin();\n\
    \    std::string vowels_reverse20 = vowels.rend();\n    std::string vowels_reverse21\
    \ = vowels.rbegin();\n    std::string vowels_reverse22 = vowels.rend();\n    std::string\
    \ vowels_reverse23 = vowels.rbegin();\n    std::string vowels_reverse24 = vowels.rend();\n\
    \    std::string vowels_reverse25 = vowels.rbegin();\n    std::string vowels_reverse26\
    \ = vowels.rend();\n    std::string vowels_reverse27 = vowels.rbegin();\n    std::string\
    \ vowels_reverse28 = vowels.rend();\n    std::string vowels_reverse29 = vowels.rbegin();\n\
    \    std::string vowels_reverse30 = vowels.rend();\n    std::string vowels_reverse31\
    \ = vowels.rbegin();\n    std::string vowels_reverse32 = vowels.rend();\n    std::string\
    \ vowels_reverse33 = vowels.rbegin();\n    std::string vowels_reverse34 = vowels.rend();\n\
    \    std::string vowels_reverse35 = vowels.rbegin();\n    std::string vowels_reverse36\
    \ = vowels.rend();\n    std::string vowels_reverse37 = vowels.rbegin();\n    std::string\
    \ vowels_reverse38 = vowels.rend();\n    std::string vowels_reverse39 = vowels.rbegin();\n\
    \    std::string vowels_reverse40 = vowels.rend();\n    std::string vowels_reverse41\
    \ = vowels.rbegin();\n\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_gwghk_g.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin = \"aeiouAEIOU\";\n    std::string\
    \ vowels_begin2 = \"AEIOUaeiou\";\n    std::string vowels_end2 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_begin3 = \"aeiouAEIOU\";\n    std::string vowels_end3\
    \ = \"aeiouAEIOU\";\n    std::string vowels_begin4 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end4 = \"aeiouAEIOU\";\n    std::string vowels_begin5 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end5 = \"aeiouAEIOU\";\n    std::string vowels_begin6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end6 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_begin7 = \"aeiouAEIOU\";\n    std::string vowels_end7 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_begin8 = \"aeiouAEIOU\";\n    std::string vowels_end8\
    \ = \"aeiouAEIOU\";\n    std::string vowels_begin9 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end9 = \"aeiouAEIOU\";\n    std::string vowels_begin10 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end10 = \"aeiouAEIOU\";\n    std::string vowels_begin11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end11 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_begin12 = \"aeiouAEIOU\";\n    std::string vowels_end12 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_begin13 = \"aeiouAEIOU\";\n    std::string vowels_end13\
    \ = \"aeiouAEIOU\";\n    std::string vowels_begin14 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end14 = \"aeiouAEIOU\";\n    std::string vowels_begin15 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end15 = \"aeiouAEIOU\";\n    std::string vowels_begin16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end16 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_begin17 = \"aeiouAEIOU\";\n    std::string vowels_end17 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_begin18 = \"aeiouAEIOU\";\n    std::string vowels_end18\
    \ = \"aeiouAEIOU\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpg8dk1ijh.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpba_jslus.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpba_jslus.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpba_jslus.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin = \"aeiouAEIOU\";\n    std::string\
    \ vowels_begin2 = \"AEIOUaeiou\";\n    std::string vowels_end2 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_begin3 = \"aeiouAEIOU\";\n    std::string vowels_end3\
    \ = \"aeiouAEIOU\";\n    std::string vowels_begin4 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end4 = \"aeiouAEIOU\";\n    std::string vowels_begin5 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end5 = \"aeiouAEIOU\";\n    std::string vowels_begin6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end6 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_begin7 = \"aeiouAEIOU\";\n    std::string vowels_end7 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_begin8 = \"aeiouAEIOU\";\n    std::string vowels_end8\
    \ = \"aeiouAEIOU\";\n    std::string vowels_begin9 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end9 = \"aeiouAEIOU\";\n    std::string vowels_begin10 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end10 = \"aeiouAEIOU\";\n    std::string vowels_begin11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end11 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_begin12 = \"aeiouAEIOU\";\n    std::string vowels_end12 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_begin13 = \"aeiouAEIOU\";\n    std::string vowels_end13\
    \ = \"aeiouAEIOU\";\n    std::string vowels_begin14 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end14 = \"aeiouAEIOU\";\n    std::string vowels_begin15 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end15 = \"aeiouAEIOU\";\n    std::string vowels_begin16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end16 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_begin17 = \"aeiouAEIOU\";\n    std::string vowels_end17 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_begin18 = \"aeiouAEIOU\";\n    std::string vowels_end18\
    \ = \"aeiouAEIOU\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpg8dk1ijh.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpu9sxgxia.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpu9sxgxia.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpu9sxgxia.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Your code here\n    std::string vowels = \"aeiouAEIOU\";\n \
    \   std::string vowels_end = \"AEIOU\";\n    std::string vowels_start = \"a\"\
    ;\n    std::string vowels_start_end = \"AEIOUa\";\n    std::string vowels_start_end_2\
    \ = \"aAEIOU\";\n    std::string vowels_start_end_3 = \"aAEIOUa\";\n    std::string\
    \ vowels_start_end_4 = \"aAEIOUAEIOU\";\n    std::string vowels_start_end_5 =\
    \ \"aAEIOUAEIOUa\";\n    std::string vowels_start_end_6 = \"aAEIOUAEIOUAEIOU\"\
    ;\n    std::string vowels_start_end_7 = \"aAEIOUAEIOUAEIOUa\";\n    std::string\
    \ vowels_start_end_8 = \"aAEIOUAEIOUAEIOUAEIOU\";\n    std::string vowels_start_end_9\
    \ = \"aAEIOUAEIOUAEIOUAEIOUa\";\n    std::string vowels_start_end_10 = \"aAEIOUAEIOUAEIOUAEIOUAEIOU\"\
    ;\n    std::string vowels_start_end_11 = \"aAEIOUAEIOUAEIOUAEIOUAEIOUa\";\n  \
    \  std::string vowels_start_end_12 = \"aAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\";\n  \
    \  std::string vowels_start_end_13 = \"aAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUa\";\n \
    \   std::string vowels_start_end_14 = \"aAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\
    ;\n    std::string vowels_start_end_15 = \"aAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUa\"\
    ;\n    std::string vowels_start_end_16 = \"aAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\
    ;\n    std::string vowels_start_end_17 = \"aAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUa\"\
    ;\n    std::string vowels_start_end_18 = \"aAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOUAEIOU\"\
    ;\n    std::string vowels_start_end_19 = \"aAEIOUAEIOUAEIOUAEIOUAEIOUAE\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpdjbygla1.cpp:32:39: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_start_end_19 = \"aAEIOUAEIOUAEIOUAEIOUAEIOUAE\n\
    \                                       ^\n/tmp/tmpdjbygla1.cpp:32:5: error: missing\
    \ terminating \" character\n     std::string vowels_start_end_19 = \"aAEIOUAEIOUAEIOUAEIOUAEIOUAE\n\
    \     ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpdjbygla1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Your code here\n    std::string vowels = \"aeiouAEIOU\";\n \
    \   std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"aeiouAEIOU\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"aeiouAEIOU\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"aeiouAEIOU\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"aeiouAEIOU\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"aeiouAEIOU\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"aeiouAEIOU\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"aeiouAEIOU\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprdt9kjyf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int n = word.size();\n\
    \    for(int i = n-1; i >= 0; i--) {\n        if(vowels.find(word[i]) != std::string::npos)\
    \ {\n            return word[i];\n        }\n    }\n    return \"\";\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp4q6w0h4a.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpu9sxgxia.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpu9sxgxia.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpu9sxgxia.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Your code here\n    std::string vowels = \"aeiouAEIOU\";\n \
    \   std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"aeiouAEIOU\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"aeiouAEIOU\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"aeiouAEIOU\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"aeiouAEIOU\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"aeiouAEIOU\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"aeiouAEIOU\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"aeiouAEIOU\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprdt9kjyf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"AEIOUaeiou\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"AEIOUaeiou\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"AEIOUaeiou\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"AEIOU\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp581oqr9s.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp581oqr9s.cpp:46:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n \
    \                from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp581oqr9s.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected prima"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start = \"aeiouAEIOU\";\n    std::string\
    \ vowels_start_end = \"aeiouAEIOUaeiou\";\n    std::string vowels_start_end_2\
    \ = \"aeiouAEIOUaeiouAEIOU\";\n    std::string vowels_start_end_3 = \"aeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_4 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOU\";\n\
    \    std::string vowels_start_end_5 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_6 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_7 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_8 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_9 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_10 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_11 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_12 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_13 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_14 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_15\n}\nint main() {\n    auto candidate =\
    \ get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_v59cxpq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reversed\
    \ = vowels.rbegin() + vowels.size();\n    std::string vowels_reversed_reversed\
    \ = vowels_reversed + vowels_reversed;\n    std::string vowels_reversed_reversed_reversed\
    \ = vowels_reversed_reversed + vowels_reversed_reversed;\n    std::string vowels_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed + vowels_reversed_reversed_reversed;\n \
    \   std::string vowels_reversed_reversed_reversed_reversed_reversed = vowels_reversed_reversed_reversed_reversed\
    \ + vowels_reversed_reversed_reversed_reversed;\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed + vowels_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed + vowels_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed + vowels_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ + vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n \
    \   std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ + vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ + vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpe8edm0r2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8jzuojoy.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmp8jzuojoy.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8jzuojoy.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq0alwgwr.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpq0alwgwr.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpq0alwgwr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = vowels.substr(0, vowels.size() - 1);\n    std::string vowels_reverse2 = vowels_reverse.substr(0,\
    \ vowels_reverse.size() - 1);\n    std::string vowels_reverse3 = vowels_reverse2.substr(0,\
    \ vowels_reverse2.size() - 1);\n    std::string vowels_reverse4 = vowels_reverse3.substr(0,\
    \ vowels_reverse3.size() - 1);\n    std::string vowels_reverse5 = vowels_reverse4.substr(0,\
    \ vowels_reverse4.size() - 1);\n    std::string vowels_reverse6 = vowels_reverse5.substr(0,\
    \ vowels_reverse5.size() - 1);\n    std::string vowels_reverse7 = vowels_reverse6.substr(0,\
    \ vowels_reverse6.size() - 1);\n    std::string vowels_reverse8 = vowels_reverse7.substr(0,\
    \ vowels_reverse7.size() - 1);\n    std::string vowels_reverse9 = vowels_reverse8.substr(0,\
    \ vowels_reverse8.size() - 1);\n    std::string vowels_reverse10 = vowels_reverse9.substr(0,\
    \ vowels_reverse9.size() - 1);\n    std::string vowels_reverse11 = vowels_reverse10.substr(0,\
    \ vowels_reverse10.size() - 1);\n    std::string vowels_reverse12 = vowels_reverse11.substr(0,\
    \ vowels_reverse11.size() - 1);\n    std::string vowels_reverse13 = vowels_reverse12.substr(0,\
    \ vowels_reverse12.size() - 1);\n    std::string vowels_reverse14 = vowels_reverse13.substr(0,\
    \ vowels_reverse13.size() - 1);\n    std::string vowels_reverse15 = vowels_reverse14.substr(0,\
    \ vowels_reverse14.size() - 1);\n    std::string vowels_reverse16 = vowels_reverse15.substr(0,\
    \ vowels_reverse15.size() - 1);\n    std::string vowels_reverse17 = vowels_reverse16.substr(0,\
    \ vowels_reverse16.size() - 1);\n    std::string vowels_reverse18 = vowels_reverse17.substr(0,\
    \ vowels_reverse17.size() - 1);\n    std::string vowels_reverse19 = vowels_reverse18.substr(0,\
    \ vowels_reverse18.size() - 1);\n    std::string vowels_reverse20 = vowels_reverse19.substr(0,\
    \ vowels_reverse19.size() - 1);\n    std::string vowels_reverse21 = vowels_reverse20.substr(0,\
    \ vowels_reverse20.size() - 1);\n    std::string vowels_reverse22 = vowels_reverse21.substr(0,\
    \ vowels_reverse21.size() - 1);\n    std::string vowels_reverse23 = vowels_reverse22.substr(0,\
    \ vowels_reverse22.size() - 1);\n    std::string vowels_reverse24 = vowels_reverse23.substr(0,\
    \ vowels_reverse23.size() - 1);\n    std::string vowels_reverse25 = vowels_reverse24.substr(0,\
    \ vowels_\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0fzfet_p.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reversed\
    \ = vowels.rbegin() + vowels.size();\n    std::string vowels_reversed_reversed\
    \ = vowels_reversed + vowels_reversed;\n    std::string vowels_reversed_reversed_reversed\
    \ = vowels_reversed_reversed + vowels_reversed_reversed;\n    std::string vowels_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed + vowels_reversed_reversed_reversed;\n \
    \   std::string vowels_reversed_reversed_reversed_reversed_reversed = vowels_reversed_reversed_reversed_reversed\
    \ + vowels_reversed_reversed_reversed_reversed;\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed + vowels_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed + vowels_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed + vowels_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ + vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n \
    \   std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ + vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ + vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed;\n\
    \    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ + vowels_reversed_reversed_reverse\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxlb6n1sn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = vowels.substr(0, vowels.size() - 1);\n    std::string vowels_reverse2 = vowels_reverse.substr(0,\
    \ vowels_reverse.size() - 1);\n    std::string vowels_reverse3 = vowels_reverse2.substr(0,\
    \ vowels_reverse2.size() - 1);\n    std::string vowels_reverse4 = vowels_reverse3.substr(0,\
    \ vowels_reverse3.size() - 1);\n    std::string vowels_reverse5 = vowels_reverse4.substr(0,\
    \ vowels_reverse4.size() - 1);\n    std::string vowels_reverse6 = vowels_reverse5.substr(0,\
    \ vowels_reverse5.size() - 1);\n    std::string vowels_reverse7 = vowels_reverse6.substr(0,\
    \ vowels_reverse6.size() - 1);\n    std::string vowels_reverse8 = vowels_reverse7.substr(0,\
    \ vowels_reverse7.size() - 1);\n    std::string vowels_reverse9 = vowels_reverse8.substr(0,\
    \ vowels_reverse8.size() - 1);\n    std::string vowels_reverse10 = vowels_reverse9.substr(0,\
    \ vowels_reverse9.size() - 1);\n    std::string vowels_reverse11 = vowels_reverse10.substr(0,\
    \ vowels_reverse10.size() - 1);\n    std::string vowels_reverse12 = vowels_reverse11.substr(0,\
    \ vowels_reverse11.size() - 1);\n    std::string vowels_reverse13 = vowels_reverse12.substr(0,\
    \ vowels_reverse12.size() - 1);\n    std::string vowels_reverse14 = vowels_reverse13.substr(0,\
    \ vowels_reverse13.size() - 1);\n    std::string vowels_reverse15 = vowels_reverse14.substr(0,\
    \ vowels_reverse14.size() - 1);\n    std::string vowels_reverse16 = vowels_reverse15.substr(0,\
    \ vowels_reverse15.size() - 1);\n    std::string vowels_reverse17 = vowels_reverse16.substr(0,\
    \ vowels_reverse16.size() - 1);\n    std::string vowels_reverse18 = vowels_reverse17.substr(0,\
    \ vowels_reverse17.size() - 1);\n    std::string vowels_reverse19 = vowels_reverse18.substr(0,\
    \ vowels_reverse18.size() - 1);\n    std::string vowels_reverse20 = vowels_reverse19.substr(0,\
    \ vowels_reverse19.size() - 1);\n    std::string vowels_reverse21 = vowels_reverse20.substr(0,\
    \ vowels_reverse20.size() - 1);\n    std::string vowels_reverse22 = vowels_reverse21.substr(0,\
    \ vowels_reverse21.size() - 1);\n    std::string vowels_reverse23 = vowels_reverse22.substr(0,\
    \ vowels_reverse22.size() - 1);\n    std::string vowels_reverse24 = vowels_reverse23.substr(0,\
    \ vowels_reverse23.size() - 1);\n    std::string vowels_reverse25 = vowels_reverse24.substr(0,\
    \ vowels_\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0fzfet_p.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_iswxc_h.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmp_iswxc_h.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_iswxc_h.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"AEIOUaeiou\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"AEIOUaeiou\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmptykv21cj.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmptykv21cj.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmptykv21cj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Your code here\n    std::string vowels = \"aeiouAEIOU\";\n \
    \   int n = word.size();\n    int vowel_pos = -1;\n    int vowel_len = vowels.size();\n\
    \    for(int i=n-1; i>=0; i--){\n        if(vowels.find(word[i]) != std::string::npos){\n\
    \            vowel_pos = i;\n            break;\n        }\n    }\n    if(vowel_pos\
    \ == -1){\n        return \"\";\n    }\n    int vowel_start_pos = vowel_pos;\n\
    \    int vowel_end_pos = vowel_pos;\n    for(int i=vowel_pos+1; i<n; i++){\n \
    \       if(vowels.find(word[i]) != std::string::npos){\n            vowel_end_pos\
    \ = i;\n            break;\n        }\n    }\n    std::string vowel_start = word.substr(0,\
    \ vowel_start_pos);\n    std::string vowel_end = word.substr(vowel_end_pos+1,\
    \ n-1);\n    std::string vowel_middle = word.substr(vowel_start_pos+1, vowel_end_pos);\n\
    \    std::string vowel_middle1 = word.substr(vowel_start_pos+1, vowel_end_pos);\n\
    \    std::string vowel_middle2 = word.substr(vowel_start_pos+1, vowel_end_pos);\n\
    \    std::string vowel_middle3 = word.substr(vowel_start_pos+1, vowel_end_pos);\n\
    \    std::string vowel_middle4 = word.substr(vowel_start_pos+1, vowel_end_pos);\n\
    \    std::string vowel_middle5 = word.substr(vowel_start_pos+1, vowel_end_pos);\n\
    \    std::string vowel_middle6 = word.substr(vowel_start_pos+1, vowel_end_pos);\n\
    \    std::string vowel_middle7 = word.substr(vowel_start_pos+1, vowel_end_pos);\n\
    \    std::string vowel_middle8 = word.substr(vowel_start_pos+1, vowel_end_pos);\n\
    \    std::string vowel_middle9 = word.substr(vowel_start_pos+1, vowel_end_pos);\n\
    \    std::string vowel_middle10 = word.substr(vowel_start_pos+1, vowel_end_pos);\n\
    \    std::string vowel_middle11 = word.substr(vowel_start_pos+1, vowel_end_pos);\n\
    \    std::string vowel_middle12 = word.substr(vowel_start_pos+1, vowel_end_pos);\n\
    \    std::string vowel_middle13 = word.substr(vowel_start_pos+1, vowel_end_pos);\n\
    \    std::string vowel_middle14 = word.substr(vowel_start_pos+1, vowel_end_pos);\n\
    \    std::string vowel_middle15 = word.substr(vowel_start_pos+1, vowel_end_pos);\n\
    \    std::string vowel_middle16 = word.substr(vowel_start_pos+1, vowel_end_pos);\n\
    \    std::string vowel_middle17 = word.substr(vowel_\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpiz0nw92b.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Your code here\n    std::string vowels = \"aeiouAEIOU\";\n \
    \   std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse3 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse4 = \"aeiouAEIOU\";\n    std::string vowels_reverse5 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse6 = \"aeiouAEIOU\";\n    std::string vowels_reverse7\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse8 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse9 = \"aeiouAEIOU\";\n    std::string vowels_reverse10 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse11 = \"aeiouAEIOU\";\n    std::string vowels_reverse12\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse13 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse14 = \"aeiouAEIOU\";\n    std::string vowels_reverse15 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse16 = \"aeiouAEIOU\";\n    std::string vowels_reverse17\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse18 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse19 = \"aeiouAEIOU\";\n    std::string vowels_reverse20 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse21 = \"aeiouAEIOU\";\n    std::string vowels_reverse22\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse23 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse24 = \"aeiouAEIOU\";\n    std::string vowels_reverse25 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse26 = \"aeiouAEIOU\";\n    std::string vowels_reverse27\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse28 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse29 = \"aeiouAEIOU\";\n    std::string vowels_reverse30 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse31 = \"aeiouAEIOU\";\n    std::string vowels_reverse32\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse33 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse34 = \"aeiouAEIOU\";\n    std::string vowels_reverse35 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpp0xtj9ud.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin = \"aeiouAEIOU\";\n    std::string\
    \ vowels_begin2 = \"AEIOUaeiou\";\n    std::string vowels_end2 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_begin3 = \"aeiouAEIOU\";\n    std::string vowels_end3\
    \ = \"aeiouAEIOU\";\n    std::string vowels_begin4 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end4 = \"aeiouAEIOU\";\n    std::string vowels_begin5 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end5 = \"aeiouAEIOU\";\n    std::string vowels_begin6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end6 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_begin7 = \"aeiouAEIOU\";\n    std::string vowels_end7 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_begin8 = \"aeiouAEIOU\";\n    std::string vowels_end8\
    \ = \"aeiouAEIOU\";\n    std::string vowels_begin9 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end9 = \"aeiouAEIOU\";\n    std::string vowels_begin10 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end10 = \"aeiouAEIOU\";\n    std::string vowels_begin11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end11 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_begin12 = \"aeiouAEIOU\";\n    std::string vowels_end12 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_begin13 = \"aeiouAEIOU\";\n    std::string vowels_end13\
    \ = \"aeiouAEIOU\";\n    std::string vowels_begin14 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end14 = \"aeiouAEIOU\";\n    std::string vowels_begin15 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end15 = \"aeiouAEIOU\";\n    std::string vowels_begin16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end16 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_begin17 = \"aeiouAEIOU\";\n    std::string vowels_end17 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_begin18 = \"aeiouAEIOU\";\n    std::string vowels_end18\
    \ = \"aeiouAEIOU\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpg8dk1ijh.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"AEIOUaeiou\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"AEIOUaeiou\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"AEIOUaeiou\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"AEIOU\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp681_i71f.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp681_i71f.cpp:46:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n \
    \                from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp681_i71f.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected prima"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int len = word.length();\n\
    \    for(int i = len-1; i >= 0; i--) {\n        if(vowels.find(word.substr(i,\
    \ 1)) != std::string::npos) {\n            return word.substr(i, 1);\n       \
    \ }\n    }\n    return \"\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp3vllvchl.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"AEIOUaeiou\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"AEIOUaeiou\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"AEIOUaeiou\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"AEIOU\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp681_i71f.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp681_i71f.cpp:46:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n \
    \                from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp681_i71f.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected prima"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpu9sxgxia.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpu9sxgxia.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpu9sxgxia.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int n = word.size();\n\
    \    int vowel_count = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        if\
    \ (vowels.find(word[i]) != std::string::npos) {\n            vowel_count++;\n\
    \        }\n    }\n    if (vowel_count == 0) {\n        return \"\";\n    }\n\
    \    int vowel_pos = 0;\n    for (int i = n - 1; i >= 0; i--) {\n        if (vowels.find(word[i])\
    \ != std::string::npos) {\n            vowel_pos = i;\n            break;\n  \
    \      }\n    }\n    int vowel_pos_1 = vowel_pos + 1;\n    int vowel_pos_2 = vowel_pos\
    \ + 2;\n    int vowel_pos_3 = vowel_pos + 3;\n    int vowel_pos_4 = vowel_pos\
    \ + 4;\n    int vowel_pos_5 = vowel_pos + 5;\n    int vowel_pos_6 = vowel_pos\
    \ + 6;\n    int vowel_pos_7 = vowel_pos + 7;\n    int vowel_pos_8 = vowel_pos\
    \ + 8;\n    int vowel_pos_9 = vowel_pos + 9;\n    int vowel_pos_10 = vowel_pos\
    \ + 10;\n    int vowel_pos_11 = vowel_pos + 11;\n    int vowel_pos_12 = vowel_pos\
    \ + 12;\n    int vowel_pos_13 = vowel_pos + 13;\n    int vowel_pos_14 = vowel_pos\
    \ + 14;\n    int vowel_pos_15 = vowel_pos + 15;\n    int vowel_pos_16 = vowel_pos\
    \ + 16;\n    int vowel_pos_17 = vowel_pos + 17;\n    int vowel_pos_18 = vowel_pos\
    \ + 18;\n    int vowel_pos_19 = vowel_pos + 19;\n    int vowel_pos_20 = vowel_pos\
    \ + 20;\n    int vowel_pos_21 = vowel_pos + 21;\n    int vowel_pos_22 = vowel_pos\
    \ + 22;\n    int vowel_pos_23 = vowel_pos + 23;\n    int vowel_pos_24 = vowel_pos\
    \ + 24;\n    int vowel_pos_25 = vowel_pos + 25;\n    int vowel_pos_26 = vowel_pos\
    \ + 26;\n    int vowel_pos_27 = vowel_pos + 27;\n    int vowel_pos_28 = vowel_pos\
    \ + 28;\n    int vowel_pos_29 = vowel_pos + 29;\n    int vowel_pos_30 = vowel_pos\
    \ + 30;\n    int vowel_pos_31 = vowel_pos + 31;\n    int vowel_pos_32 = vowel_pos\
    \ + 32;\n    int vowel_pos_33 = vowel_pos + 33;\n    int vowel_pos_34 = vowel_pos\
    \ + 34;\n    int vowel_pos_35 = vowel_pos + 35;\n    int vowel_pos_36 = vowel_pos\
    \ + 36;\n    int vowel_pos_\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpk01uh1ad.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"AEIOUaeiou\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"AEIOUaeiou\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"AEIOUaeiou\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"AEIOU\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp681_i71f.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp681_i71f.cpp:46:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n \
    \                from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp681_i71f.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected prima"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"AEIOUaeiou\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"AEIOUaeiou\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"AEIOUaeiou\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp79k501jq.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmp79k501jq.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp79k501jq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_iswxc_h.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmp_iswxc_h.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_iswxc_h.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8jzuojoy.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmp8jzuojoy.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8jzuojoy.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin = \"aeiouAEIOU\";\n    std::string\
    \ vowels_begin2 = \"AEIOUaeiou\";\n    std::string vowels_end2 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_begin3 = \"aeiouAEIOU\";\n    std::string vowels_end3\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin4 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end4 = \"AEIOUaeiou\";\n    std::string vowels_begin5 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end5 = \"AEIOUaeiou\";\n    std::string vowels_begin6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end6 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_begin7 = \"aeiouAEIOU\";\n    std::string vowels_end7 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_begin8 = \"aeiouAEIOU\";\n    std::string vowels_end8\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin9 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end9 = \"AEIOUaeiou\";\n    std::string vowels_begin10 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end10 = \"AEIOUaeiou\";\n    std::string vowels_begin11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end11 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_begin12 = \"aeiouAEIOU\";\n    std::string vowels_end12 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_begin13 = \"aeiouAEIOU\";\n    std::string vowels_end13\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin14 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end14 = \"AEIOUaeiou\";\n    std::string vowels_begin15 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end15 = \"AEIOUaeiou\";\n    std::string vowels_begin16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end16 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_begin17 = \"aeiouAEIOU\";\n    std::string vowels_end17 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_begin18 = \"aeiouAEIOU\";\n    std::string vowels_end18\
    \ = \"AEIOUaeiou\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpgxt7dhx6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int len = word.length();\n\
    \    std::string vowel_found = \"\";\n    for (int i = len - 1; i >= 0; i--) {\n\
    \        if (vowels.find(word[i]) != std::string::npos) {\n            vowel_found\
    \ = word[i];\n            break;\n        }\n    }\n    return vowel_found;\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7e4ek5md.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reversed\
    \ = vowels.rbegin() + vowels.size();\n    std::string vowels_reversed_2 = vowels.rbegin()\
    \ + vowels.size() - 1;\n    std::string vowels_reversed_3 = vowels.rbegin() +\
    \ vowels.size() - 2;\n    std::string vowels_reversed_4 = vowels.rbegin() + vowels.size()\
    \ - 3;\n    std::string vowels_reversed_5 = vowels.rbegin() + vowels.size() -\
    \ 4;\n    std::string vowels_reversed_6 = vowels.rbegin() + vowels.size() - 5;\n\
    \    std::string vowels_reversed_7 = vowels.rbegin() + vowels.size() - 6;\n  \
    \  std::string vowels_reversed_8 = vowels.rbegin() + vowels.size() - 7;\n    std::string\
    \ vowels_reversed_9 = vowels.rbegin() + vowels.size() - 8;\n    std::string vowels_reversed_10\
    \ = vowels.rbegin() + vowels.size() - 9;\n    std::string vowels_reversed_11 =\
    \ vowels.rbegin() + vowels.size() - 10;\n    std::string vowels_reversed_12 =\
    \ vowels.rbegin() + vowels.size() - 11;\n    std::string vowels_reversed_13 =\
    \ vowels.rbegin() + vowels.size() - 12;\n    std::string vowels_reversed_14 =\
    \ vowels.rbegin() + vowels.size() - 13;\n    std::string vowels_reversed_15 =\
    \ vowels.rbegin() + vowels.size() - 14;\n    std::string vowels_reversed_16 =\
    \ vowels.rbegin() + vowels.size() - 15;\n    std::string vowels_reversed_17 =\
    \ vowels.rbegin() + vowels.size() - 16;\n    std::string vowels_reversed_18 =\
    \ vowels.rbegin() + vowels.size() - 17;\n    std::string vowels_reversed_19 =\
    \ vowels.rbegin() + vowels.size() - 18;\n    std::string vowels_reversed_20 =\
    \ vowels.rbegin() + vowels.size() - 19;\n    std::string vowels_reversed_21 =\
    \ vowels.rbegin() + vowels.size() - 20;\n    std::string vowels_reversed_22 =\
    \ vowels.rbegin() + vowels.size() - 21;\n    std::string vowels_reversed_23 =\
    \ vowels.rbegin() + vowels.size() - 22;\n    std::string vowels_reversed_24 =\
    \ vowels.rbegin() + vowels.size() - 23;\n    std::string vowels_reversed_25 =\
    \ vowels.rbegin() + vowels.size() - 24;\n    std::string vowels_reversed_26 =\
    \ vowels.rbegin() + vowels.size() - 25;\n    std::string vowels_reversed_27 =\
    \ vowels.rbegin() + vowels.size() - 26;\n    std::string vowels_reversed_28 =\
    \ vowels.rbegin() + vowels.size() - 27;\n    \n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpkk4xf1bn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = vowels.substr(0, vowels.size() - 1);\n    std::string vowels_reverse_reverse\
    \ = vowels_reverse.substr(0, vowels_reverse.size() - 1);\n    std::string vowels_reverse_reverse_vowels\
    \ = vowels_reverse_reverse.substr(0, vowels_reverse_reverse.size() - 1);\n   \
    \ std::string vowels_reverse_reverse_vowels_reverse = vowels_reverse_reverse_vowels.substr(0,\
    \ vowels_reverse_reverse_vowels.size() - 1);\n    std::string vowels_reverse_reverse_vowels_reverse_vowels\
    \ = vowels_reverse_reverse_vowels_reverse.substr(0, vowels_reverse_reverse_vowels_reverse.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_vowels_reverse_vowels_reverse\
    \ = vowels_reverse_reverse_vowels_reverse_vowels.substr(0, vowels_reverse_reverse_vowels_reverse_vowels.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_vowels_reverse_vowels_reverse_vowels_reverse\
    \ = vowels_reverse_reverse_vowels_reverse_vowels_reverse.substr(0, vowels_reverse_reverse_vowels_reverse_vowels_reverse.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_vowels_reverse_vowels_reverse_vowels_reverse_vowels_reverse\
    \ = vowels_reverse_reverse_vowels_reverse_vowels_reverse_vowels_reverse.substr(0,\
    \ vowels_reverse_reverse_vowels_reverse_vowels_reverse_vowels_reverse.size() -\
    \ 1);\n    std::string vowels_reverse_reverse_vowels_reverse_vowels_reverse_vowels_reverse_vowels_reverse_vowels_reverse\
    \ = vowels_reverse_reverse_vowels_reverse_vowels_reverse_vowels_reverse_vowels_reverse.substr(0,\
    \ vowels_reverse_reverse_vowels_reverse_vowels_reverse_vowels_reverse_vowels_reverse.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_vowels_reverse_vowels_reverse_vowels_reverse_vowels_reverse_vowels_reverse_vowels_reverse\
    \ = vowels_reverse_reverse_vowels_reverse_vowels_reverse_vowels_reverse_vowels_reverse_vowels_reverse_vowels_reverse.substr(0,\
    \ vowels_reverse_reverse_vowels_reverse_vowels_reverse_vowels_reverse_vowels_reverse_vowels_reverse_vowels_reverse.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_vowels_reverse_vowels_reverse_vowels_reverse_vowels_reverse_vowels_reverse_vowels_reverse_vowels_reverse\
    \ = vowels_reverse_reverse_vowels_reverse_vowels_reverse_vowels_reverse_vowels_reverse_vowels_reverse_vowels_reverse_vowels_reverse.substr(0,\
    \ vowels_reverse_reverse_vowels_reverse_vowels_reverse_vowels_reverse_vowels_reverse_vowels_reverse_vowels_reverse_vowels_reverse.size()\
    \ - 1);\n    std::string vowel\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmplhc9x5my.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"AEIOUaeiou\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"AEIOUaeiou\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"AEIOUaeiou\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp79k501jq.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmp79k501jq.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp79k501jq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int len = word.length();\n\
    \    int vowel_count = 0;\n    int consonant_count = 0;\n    for(int i = len-1;\
    \ i >= 0; i--) {\n        if(vowels.find(word[i]) != std::string::npos) {\n  \
    \          vowel_count++;\n        } else {\n            consonant_count++;\n\
    \        }\n    }\n    if(vowel_count > consonant_count) {\n        return word;\n\
    \    }\n    std::string vowel_before = word.substr(0, len-1);\n    std::string\
    \ vowel_after = word.substr(len-1, 1);\n    std::string vowel_before2 = word.substr(0,\
    \ len-2);\n    std::string vowel_after2 = word.substr(len-2, 1);\n    std::string\
    \ vowel_before3 = word.substr(0, len-3);\n    std::string vowel_after3 = word.substr(len-3,\
    \ 1);\n    std::string vowel_before4 = word.substr(0, len-4);\n    std::string\
    \ vowel_after4 = word.substr(len-4, 1);\n    std::string vowel_before5 = word.substr(0,\
    \ len-5);\n    std::string vowel_after5 = word.substr(len-5, 1);\n    std::string\
    \ vowel_before6 = word.substr(0, len-6);\n    std::string vowel_after6 = word.substr(len-6,\
    \ 1);\n    std::string vowel_before7 = word.substr(0, len-7);\n    std::string\
    \ vowel_after7 = word.substr(len-7, 1);\n    std::string vowel_before8 = word.substr(0,\
    \ len-8);\n    std::string vowel_after8 = word.substr(len-8, 1);\n    std::string\
    \ vowel_before9 = word.substr(0, len-9);\n    std::string vowel_after9 = word.substr(len-9,\
    \ 1);\n    std::string vowel_before10 = word.substr(0, len-10);\n    std::string\
    \ vowel_after10 = word.substr(len-10, 1);\n    std::string vowel_before11 = word.substr(0,\
    \ len-11);\n    std::string vowel_after11 = word.substr(len-11, 1);\n    std::string\
    \ vowel_before12 = word.substr(0, len-12);\n    std::string vowel_after12 = word.substr(len-12,\
    \ 1);\n    std::string vowel_before13 = word.substr(0, len-13);\n    std::string\
    \ vowel_after13 = word.substr(len-13, 1);\n    std::string vowel_before14 = word.substr(0,\
    \ len-14);\n    std::string vowel_after14 = word.substr(len-14, 1);\n    std::string\
    \ vowel_before15 = word.substr(0, len-15);\n    std::string vowel_after15 = word.substr(len-15,\
    \ 1);\n    std::string vowel_before16 = word.substr(0, len-16);\n    std::string\
    \ vowel_after16 = word.substr(len-16, 1);\n    std::string vowel_before17\n}\n\
    int main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpk5qvsrhn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Your code goes here\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end = \"AEIOUaeiou\";\n    std::string vowels_start\
    \ = \"aeiouAEIOU\";\n    std::string vowels_start_end = \"aeiouAEIOUaeiou\";\n\
    \    std::string vowels_start_end_2 = \"aeiouAEIOUaeiouAEIOU\";\n    std::string\
    \ vowels_start_end_3 = \"aeiouAEIOUaeiouAEIOUaeiou\";\n    std::string vowels_start_end_4\
    \ = \"aeiouAEIOUaeiouAEIOUaeiouAEIOU\";\n    std::string vowels_start_end_5 =\
    \ \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\";\n    std::string vowels_start_end_6\
    \ = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\";\n    std::string vowels_start_end_7\
    \ = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\";\n    std::string vowels_start_end_8\
    \ = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\";\n    std::string vowels_start_end_9\
    \ = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\";\n    std::string\
    \ vowels_start_end_10 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_11 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_12 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_13 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_14 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    \n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9rrninaq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start = \"aeiouAEIOU\";\n    std::string\
    \ vowels_start_end = \"aeiouAEIOUaeiou\";\n    std::string vowels_start_end_2\
    \ = \"aeiouAEIOUaeiouAEIOU\";\n    std::string vowels_start_end_3 = \"aeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_4 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOU\";\n\
    \    std::string vowels_start_end_5 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_6 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_7 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_8 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_9 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_10 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_11 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_12 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_13 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_14 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_15\n}\nint main() {\n    auto candidate =\
    \ get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_v59cxpq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"AEIOUaeiou\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"AEIOUaeiou\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"AEIOUaeiou\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"AEIOU\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp581oqr9s.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp581oqr9s.cpp:46:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n \
    \                from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp581oqr9s.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected prima"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Your code goes here\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"aeiouAEIOU\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"aeiouAEIOU\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"aeiouAEIOU\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"aeiouAEIOU\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"aeiouAEIOU\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"aeiouAEIOU\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"aeiouAEIOU\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0alqa2k_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start = \"aeiouAEIOU\";\n    std::string\
    \ vowels_start_end = \"aeiouAEIOUaeiou\";\n    std::string vowels_start_end_2\
    \ = \"aeiouAEIOUaeiouAEIOUaeiou\";\n    std::string vowels_start_end_3 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_4 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_5 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_6 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_7 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_8 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_9 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_10 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_11 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_12 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUae\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpv4g2zr2l.cpp:24:39: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_start_end_12 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUae\n\
    \                                       ^\n/tmp/tmpv4g2zr2l.cpp:24:5: error: missing\
    \ terminating \" character\n     std::string vowels_start_end_12 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUae\n\
    \     ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpv4g2zr2l.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::_"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Your code goes here\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string vowels_rev = \"AEIOUaeiou\";\n    int vowels_len = vowels.size();\n\
    \    int vowels_rev_len = vowels_rev.size();\n    int n = word.size();\n    std::string\
    \ vowel_found = \"\";\n    int vowel_found_index = 0;\n    int vowel_found_index_rev\
    \ = 0;\n    int vowel_found_index_rev2 = 0;\n    int vowel_found_index_rev3 =\
    \ 0;\n    int vowel_found_index_rev4 = 0;\n    int vowel_found_index_rev5 = 0;\n\
    \    int vowel_found_index_rev6 = 0;\n    int vowel_found_index_rev7 = 0;\n  \
    \  int vowel_found_index_rev8 = 0;\n    int vowel_found_index_rev9 = 0;\n    int\
    \ vowel_found_index_rev10 = 0;\n    int vowel_found_index_rev11 = 0;\n    int\
    \ vowel_found_index_rev12 = 0;\n    int vowel_found_index_rev13 = 0;\n    int\
    \ vowel_found_index_rev14 = 0;\n    int vowel_found_index_rev15 = 0;\n    int\
    \ vowel_found_index_rev16 = 0;\n    int vowel_found_index_rev17 = 0;\n    int\
    \ vowel_found_index_rev18 = 0;\n    int vowel_found_index_rev19 = 0;\n    int\
    \ vowel_found_index_rev20 = 0;\n    int vowel_found_index_rev21 = 0;\n    int\
    \ vowel_found_index_rev22 = 0;\n    int vowel_found_index_rev23 = 0;\n    int\
    \ vowel_found_index_rev24 = 0;\n    int vowel_found_index_rev25 = 0;\n    int\
    \ vowel_found_index_rev26 = 0;\n    int vowel_found_index_rev27 = 0;\n    int\
    \ vowel_found_index_rev28 = 0;\n    int vowel_found_index_rev29 = 0;\n    int\
    \ vowel_found_index_rev30 = 0;\n    int vowel_found_index_rev31 = 0;\n    int\
    \ vowel_found_index_rev32 = 0;\n    int vowel_found_index_rev33 = 0;\n    int\
    \ vowel_found_index_rev34 = 0;\n    int vowel_found_index_rev35 = 0;\n    int\
    \ vowel_found_index_rev36 = 0;\n    int vowel_found_index_rev37 = 0;\n    int\
    \ vowel_found_index_rev38 = 0;\n    int vowel_found_index_rev39 = 0;\n    int\
    \ vowel_found_index_rev40 = 0;\n    int vowel_found_index_rev41 = 0;\n    int\
    \ vowel_found_index_rev42 = 0;\n    int vowel_found_index_rev43 = 0;\n    int\
    \ vowel_found_index_rev44 = 0;\n    int vowel_found_index_rev45 = 0;\n    int\
    \ vowel_found_index_rev46 = 0;\n    int vowel_found_index_rev47 = 0;\n    int\
    \ vowel_found_index_rev48 = 0;\n    int vowel_found_index_rev49 = 0;\n    int\
    \ vowel_found_index_\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpu8ahruqt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = vowels.substr(0, vowels.size() - 1);\n    std::string vowels_reverse2 = vowels_reverse.substr(0,\
    \ vowels_reverse.size() - 1);\n    std::string vowels_reverse3 = vowels_reverse2.substr(0,\
    \ vowels_reverse2.size() - 1);\n    std::string vowels_reverse4 = vowels_reverse3.substr(0,\
    \ vowels_reverse3.size() - 1);\n    std::string vowels_reverse5 = vowels_reverse4.substr(0,\
    \ vowels_reverse4.size() - 1);\n    std::string vowels_reverse6 = vowels_reverse5.substr(0,\
    \ vowels_reverse5.size() - 1);\n    std::string vowels_reverse7 = vowels_reverse6.substr(0,\
    \ vowels_reverse6.size() - 1);\n    std::string vowels_reverse8 = vowels_reverse7.substr(0,\
    \ vowels_reverse7.size() - 1);\n    std::string vowels_reverse9 = vowels_reverse8.substr(0,\
    \ vowels_reverse8.size() - 1);\n    std::string vowels_reverse10 = vowels_reverse9.substr(0,\
    \ vowels_reverse9.size() - 1);\n    std::string vowels_reverse11 = vowels_reverse10.substr(0,\
    \ vowels_reverse10.size() - 1);\n    std::string vowels_reverse12 = vowels_reverse11.substr(0,\
    \ vowels_reverse11.size() - 1);\n    std::string vowels_reverse13 = vowels_reverse12.substr(0,\
    \ vowels_reverse12.size() - 1);\n    std::string vowels_reverse14 = vowels_reverse13.substr(0,\
    \ vowels_reverse13.size() - 1);\n    std::string vowels_reverse15 = vowels_reverse14.substr(0,\
    \ vowels_reverse14.size() - 1);\n    std::string vowels_reverse16 = vowels_reverse15.substr(0,\
    \ vowels_reverse15.size() - 1);\n    std::string vowels_reverse17 = vowels_reverse16.substr(0,\
    \ vowels_reverse16.size() - 1);\n    std::string vowels_reverse18 = vowels_reverse17.substr(0,\
    \ vowels_reverse17.size() - 1);\n    std::string vowels_reverse19 = vowels_reverse18.substr(0,\
    \ vowels_reverse18.size() - 1);\n    std::string vowels_reverse20 = vowels_reverse19.substr(0,\
    \ vowels_reverse19.size() - 1);\n    std::string vowels_reverse21 = vowels_reverse20.substr(0,\
    \ vowels_reverse20.size() - 1);\n    std::string vowels_reverse22 = vowels_reverse21.substr(0,\
    \ vowels_reverse21.size() - 1);\n    std::string vowels_reverse23 = vowels_reverse22.substr(0,\
    \ vowels_reverse22.size() - 1);\n    std::string vowels_reverse24 = vowels_reverse23.substr(0,\
    \ vowels_reverse23.size() - 1);\n    std::string vowels_reverse25 = vowels_reverse24.substr(0,\
    \ vowels_\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0fzfet_p.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = vowels.rbegin() + vowels.size();\n    std::string vowels_reverse2 = vowels.rbegin()\
    \ + vowels.size() - 1;\n    std::string vowels_reverse3 = vowels.rbegin() + vowels.size()\
    \ - 2;\n    std::string vowels_reverse4 = vowels.rbegin() + vowels.size() - 3;\n\
    \    std::string vowels_reverse5 = vowels.rbegin() + vowels.size() - 4;\n    std::string\
    \ vowels_reverse6 = vowels.rbegin() + vowels.size() - 5;\n    std::string vowels_reverse7\
    \ = vowels.rbegin() + vowels.size() - 6;\n    std::string vowels_reverse8 = vowels.rbegin()\
    \ + vowels.size() - 7;\n    std::string vowels_reverse9 = vowels.rbegin() + vowels.size()\
    \ - 8;\n    std::string vowels_reverse10 = vowels.rbegin() + vowels.size() - 9;\n\
    \    std::string vowels_reverse11 = vowels.rbegin() + vowels.size() - 10;\n  \
    \  std::string vowels_reverse12 = vowels.rbegin() + vowels.size() - 11;\n    std::string\
    \ vowels_reverse13 = vowels.rbegin() + vowels.size() - 12;\n    std::string vowels_reverse14\
    \ = vowels.rbegin() + vowels.size() - 13;\n    std::string vowels_reverse15 =\
    \ vowels.rbegin() + vowels.size() - 14;\n    std::string vowels_reverse16 = vowels.rbegin()\
    \ + vowels.size() - 15;\n    std::string vowels_reverse17 = vowels.rbegin() +\
    \ vowels.size() - 16;\n    std::string vowels_reverse18 = vowels.rbegin() + vowels.size()\
    \ - 17;\n    std::string vowels_reverse19 = vowels.rbegin() + vowels.size() -\
    \ 18;\n    std::string vowels_reverse20 = vowels.rbegin() + vowels.size() - 19;\n\
    \    std::string vowels_reverse21 = vowels.rbegin() + vowels.size() - 20;\n  \
    \  std::string vowels_reverse22 = vowels.rbegin() + vowels.size() - 21;\n    std::string\
    \ vowels_reverse23 = vowels.rbegin() + vowels.size() - 22;\n    std::string vowels_reverse24\
    \ = vowels.rbegin() + vowels.size() - 23;\n    std::string vowels_reverse25 =\
    \ vowels.rbegin() + vowels.size() - 24;\n    std::string vowels_reverse26 = vowels.rbegin()\
    \ + vowels.size() - 25;\n    std::string vowels_reverse27 = vowels.rbegin() +\
    \ vowels.size() - 26;\n    std::string vowels_reverse28 = vowels.rbegin() + vowels.size()\
    \ - 27;\n    std::string vowels_reverse29 = vowels.rbegin() + vowels.size() -\
    \ 28;\n    std::string vowels_reverse30 = vowels.r\n}\nint main() {\n    auto\
    \ candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"\
    ));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"easy\"\
    )) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpjwffw_pw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start = \"aeiouAEIOU\";\n    std::string\
    \ vowels_start_end = \"aeiouAEIOUaeiou\";\n    std::string vowels_start_end_2\
    \ = \"aeiouAEIOUaeiouAEIOUaeiou\";\n    std::string vowels_start_end_3 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_4 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_5 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_6 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_7 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_8 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_9 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_10 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_11 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_12 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUae\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpv4g2zr2l.cpp:24:39: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_start_end_12 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUae\n\
    \                                       ^\n/tmp/tmpv4g2zr2l.cpp:24:5: error: missing\
    \ terminating \" character\n     std::string vowels_start_end_12 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUae\n\
    \     ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpv4g2zr2l.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::_"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start = \"aeiouAEIOU\";\n    std::string\
    \ vowels_start_end = \"aeiouAEIOUaeiou\";\n    std::string vowels_start_end_2\
    \ = \"aeiouAEIOUaeiouAEIOU\";\n    std::string vowels_start_end_3 = \"aeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_4 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOU\";\n\
    \    std::string vowels_start_end_5 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_6 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_7 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_8 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_9 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_10 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_11 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_12 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_13 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_14 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_15\n}\nint main() {\n    auto candidate =\
    \ get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_v59cxpq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Your code here\n    std::string vowels = \"aeiouAEIOU\";\n \
    \   std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"aeiouAEIOU\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"aeiouAEIOU\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"aeiouAEIOU\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"aeiouAEIOU\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"aeiouAEIOU\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"aeiouAEIOU\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"aeiouAEIOU\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprdt9kjyf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start = \"aeiouAEIOU\";\n    std::string\
    \ vowels_start_end = \"aeiouAEIOUaeiou\";\n    std::string vowels_start_end_2\
    \ = \"aeiouAEIOUaeiouAEIOU\";\n    std::string vowels_start_end_3 = \"aeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_4 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOU\";\n\
    \    std::string vowels_start_end_5 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_6 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_7 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_8 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_9 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_10 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_11 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_12 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_13 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_14 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_15\n}\nint main() {\n    auto candidate =\
    \ get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_v59cxpq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_end\
    \ = \"AEIOU\";\n    std::string vowels_start = \"aeiou\";\n    std::string vowels_start_end\
    \ = \"aeiouAEIOU\";\n    std::string vowels_start_end_2 = \"AEIOUaeiou\";\n  \
    \  std::string vowels_start_end_3 = \"aeiouAEIOUaeiou\";\n    std::string vowels_start_end_4\
    \ = \"AEIOUaeiouAEIOU\";\n    std::string vowels_start_end_5 = \"aeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_6 = \"AEIOUaeiouAEIOUaeiou\";\n    std::string\
    \ vowels_start_end_7 = \"aeiouAEIOUaeiouAEIOUaeiou\";\n    std::string vowels_start_end_8\
    \ = \"AEIOUaeiouAEIOUaeiouAEIOU\";\n    std::string vowels_start_end_9 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_10 = \"AEIOUaeiouAEIOUaeiouAEIOUaeiou\";\n\
    \    std::string vowels_start_end_11 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_12 = \"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_13 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_14 = \"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_15 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_16 = \"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_17 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_18 = \"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIO\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2s911i7y.cpp:30:39: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_start_end_18 = \"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIO\n\
    \                                       ^\n/tmp/tmp2s911i7y.cpp:30:5: error: missing\
    \ terminating \" character\n     std::string vowels_start_end_18 = \"AEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIO\n\
    \     ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp2s911i7y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 st"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"AEIOUaeiou\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"AEIOUaeiou\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkf27l5_m.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpkf27l5_m.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpkf27l5_m.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    int vowel_pos = 0;\n\
    \    int vowel_len = vowels.size();\n    int consonant_pos = word.size()-1;\n\
    \    int consonant_len = word.length();\n    \n    while(vowel_pos < vowel_len\
    \ && consonant_pos >= 0) {\n        if(word[vowel_pos] == vowels[vowel_pos]) {\n\
    \            vowel_pos++;\n        }\n        else {\n            vowel_pos =\
    \ 0;\n        }\n        if(word[consonant_pos] == vowels[vowel_pos]) {\n    \
    \        consonant_pos--;\n        }\n        else {\n            consonant_pos\
    \ = word.length()-1;\n        }\n    }\n    \n    if(vowel_pos < vowel_len &&\
    \ consonant_pos >= 0) {\n        return word;\n    }\n    else {\n        return\
    \ \"\";\n    }\n}\nint main() {\n    auto candidate = get_closest_vowel;\n   \
    \ assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpokg9gm69.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"AEIOUaeiou\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"AEIOUaeiou\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"AEIOUaeiou\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"AEIOU\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8mu_12px.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp8mu_12px.cpp:46:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n \
    \                from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8mu_12px.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected prima"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = vowels.rbegin() + vowels.size();\n    std::string vowels_reverse_reverse =\
    \ vowels_reverse.rbegin() + vowels_reverse.size();\n    std::string vowels_reverse_reverse_reverse\
    \ = vowels_reverse_reverse.rbegin() + vowels_reverse_reverse.size();\n    std::string\
    \ vowels_reverse_reverse_reverse_reverse = vowels_reverse_reverse_reverse.rbegin()\
    \ + vowels_reverse_reverse_reverse.size();\n    std::string vowels_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse.rbegin() + vowels_reverse_reverse_reverse_reverse.size();\n\
    \    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse = vowels_reverse_reverse_reverse_reverse_reverse.rbegin()\
    \ + vowels_reverse_reverse_reverse_reverse_reverse.size();\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse.rbegin() + vowels_reverse_reverse_reverse_reverse_reverse.size();\n\
    \    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse.rbegin() +\
    \ vowels_reverse_reverse_reverse_reverse_reverse.size();\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse.rbegin() +\
    \ vowels_reverse_reverse_reverse_reverse.size();\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse.rbegin() +\
    \ vowels_reverse_reverse_reverse_reverse.size();\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse.rbegin()\
    \ + vowels_reverse_reverse_reverse_reverse.size();\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse.rbegin()\
    \ + vowels_reverse_reverse_reverse_reverse.size();\n    std::string vowels_reverse_reverse_reverse_reverse\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpgh3w7s5w.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"AEIOUaeiou\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"AEIOUaeiou\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"AEIOUaeiou\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"AEIOUaeiou\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"AEIOUaeiou\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"AEIOUaeiou\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"AEIOU\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphms_35wf.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmphms_35wf.cpp:46:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n \
    \                from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmphms_35wf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected prima"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Your code goes here\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"aeiouAEIOU\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"aeiouAEIOU\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"aeiouAEIOU\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"aeiouAEIOU\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"aeiouAEIOU\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"aeiouAEIOU\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"aeiouAEIOU\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0alqa2k_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"AEIOUaeiou\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"AEIOUaeiou\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"AEIOUaeiou\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"AEIOU\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp681_i71f.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp681_i71f.cpp:46:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n \
    \                from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp681_i71f.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected prima"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_iswxc_h.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmp_iswxc_h.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_iswxc_h.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start = \"aeiouAEIOU\";\n    std::string\
    \ vowels_start_end = \"AEIOUaeiouAEIOU\";\n    std::string vowels_start_end_2\
    \ = \"aeiouAEIOUaeiouAEIOU\";\n    std::string vowels_start_end_3 = \"aeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_4 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOU\";\n\
    \    std::string vowels_start_end_5 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_6 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_7 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_8 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_9 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_10 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_11 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_12 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_13 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_14 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_54j3wkx.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp8jzuojoy.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmp8jzuojoy.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8jzuojoy.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin = \"aeiouAEIOU\";\n    std::string\
    \ vowels_begin2 = \"aeiouAEIOU\";\n    std::string vowels_end2 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_begin3 = \"aeiouAEIOU\";\n    std::string vowels_end3\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin4 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end4 = \"AEIOUaeiou\";\n    std::string vowels_begin5 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end5 = \"AEIOUaeiou\";\n    std::string vowels_begin6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end6 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_begin7 = \"aeiouAEIOU\";\n    std::string vowels_end7 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_begin8 = \"aeiouAEIOU\";\n    std::string vowels_end8\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin9 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end9 = \"AEIOUaeiou\";\n    std::string vowels_begin10 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end10 = \"AEIOUaeiou\";\n    std::string vowels_begin11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end11 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_begin12 = \"aeiouAEIOU\";\n    std::string vowels_end12 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_begin13 = \"aeiouAEIOU\";\n    std::string vowels_end13\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin14 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end14 = \"AEIOUaeiou\";\n    std::string vowels_begin15 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end15 = \"AEIOUaeiou\";\n    std::string vowels_begin16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end16 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_begin17 = \"aeiouAEIOU\";\n    std::string vowels_end17 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_begin18 = \"aeiouAEIOU\";\n    std::string vowels_end18\
    \ = \"AEIOUaeiou\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpngmj2xf0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748882
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Your code here\n    std::string vowels = \"aeiouAEIOU\";\n \
    \   std::string vowels_reverse = vowels.substr(0, vowels.size() - 1);\n    std::string\
    \ vowels_reverse_reverse = vowels_reverse.substr(0, vowels_reverse.size() - 1);\n\
    \    std::string vowels_reverse_reverse_reverse = vowels_reverse_reverse.substr(0,\
    \ vowels_reverse_reverse.size() - 1);\n    std::string vowels_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse.substr(0, vowels_reverse_reverse_reverse.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_reverse_reverse_reverse = vowels_reverse_reverse_reverse_reverse.substr(0,\
    \ vowels_reverse_reverse_reverse_reverse.size() - 1);\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse.substr(0, vowels_reverse_reverse_reverse_reverse_reverse.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse.substr(0, vowels_reverse_reverse_reverse_reverse_reverse_reverse.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse.substr(0, vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse.substr(0,\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse.size() - 1);\n\
    \    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse.substr(0,\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse.size() - 1);\n\
    \    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse.substr(0,\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse.size() - 1);\n\
    \    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp81xpuhkn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748882
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"AEIOUaeiou\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"AEIOUaeiou\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"AEIOUaeiou\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp79k501jq.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmp79k501jq.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp79k501jq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Your code goes here\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse2 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse3 = vowels.substr(0, vowels.size() - 1);\n    std::string\
    \ vowels_reverse4 = vowels.substr(vowels.size() - 1, vowels.size());\n    std::string\
    \ vowels_reverse5 = vowels.substr(0, vowels.size() - 1);\n    std::string vowels_reverse6\
    \ = vowels.substr(vowels.size() - 1, vowels.size());\n    std::string vowels_reverse7\
    \ = vowels.substr(0, vowels.size() - 1);\n    std::string vowels_reverse8 = vowels.substr(vowels.size()\
    \ - 1, vowels.size());\n    std::string vowels_reverse9 = vowels.substr(0, vowels.size()\
    \ - 1);\n    std::string vowels_reverse10 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse11 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse12 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse13 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse14 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse15 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse16 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse17 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse18 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse19 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse20 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse21 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse22 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse23 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse24 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse25 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse26 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse27 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse28 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse29 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse30 = vowels.substr(vowels.size() - 1, vowel\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmph6stoboc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748882
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_iswxc_h.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmp_iswxc_h.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_iswxc_h.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp3kdrpso0.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmp3kdrpso0.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp3kdrpso0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748882
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = vowels.substr(0, vowels.size() - 1);\n    std::string vowels_reverse_reverse\
    \ = vowels_reverse.substr(0, vowels_reverse.size() - 1);\n    std::string vowels_reverse_reverse_vowels\
    \ = vowels_reverse_reverse.substr(0, vowels_reverse_reverse.size() - 1);\n   \
    \ std::string vowels_reverse_reverse_vowels_reverse = vowels_reverse_reverse_vowels.substr(0,\
    \ vowels_reverse_reverse_vowels.size() - 1);\n    std::string vowels_reverse_reverse_vowels_reverse_reverse\
    \ = vowels_reverse_reverse_vowels_reverse.substr(0, vowels_reverse_reverse_vowels_reverse.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_vowels_reverse_reverse_vowels\
    \ = vowels_reverse_reverse_vowels_reverse_reverse.substr(0, vowels_reverse_reverse_vowels_reverse_reverse.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_vowels_reverse_reverse_vowels_reverse\
    \ = vowels_reverse_reverse_vowels_reverse_reverse_vowels.substr(0, vowels_reverse_reverse_vowels_reverse_reverse_vowels.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_vowels_reverse_reverse_vowels_reverse_reverse\
    \ = vowels_reverse_reverse_vowels_reverse_reverse_vowels_reverse_reverse.substr(0,\
    \ vowels_reverse_reverse_vowels_reverse_reverse_vowels_reverse.size() - 1);\n\
    \    std::string vowels_reverse_reverse_vowels_reverse_reverse_vowels_reverse_reverse_vowels\
    \ = vowels_reverse_reverse_vowels_reverse_reverse_vowels_reverse_reverse_vowels.substr(0,\
    \ vowels_reverse_reverse_vowels_reverse_reverse_vowels_reverse_reverse.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_vowels_reverse_reverse_vowels_reverse_reverse_vowels_reverse\
    \ = vowels_reverse_reverse_vowels_reverse_reverse_vowels_reverse_reverse_vowels_reverse.substr(0,\
    \ vowels_reverse_reverse_vowels_reverse_reverse_vowels_reverse_reverse_vowels.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_vowels_reverse_reverse_vowels_reverse_reverse_vowels_reverse_reverse\
    \ = vowels_reverse_reverse_vowels_reverse_reverse_vowels_reverse_reverse_vowels_reverse_reverse_vowels.substr(0,\
    \ vowels_reverse_reverse_vowels_reverse_reverse_vowels_reverse_reverse_vowels.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_vowels_reverse_reverse_vowels_reverse_reverse_vowels_reverse_reverse_vowels\
    \ = vowels_reverse_reverse_vowels_reverse_reverse_vowels_reverse_reverse_vowels_reverse_reverse_vowels_reverse.\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpvlyig2vi.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin = \"aeiouAEIOU\";\n    std::string\
    \ vowels_begin2 = \"AEIOUaeiou\";\n    std::string vowels_end2 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_begin3 = \"AEIOUaeiou\";\n    std::string vowels_end3\
    \ = \"aeiouAEIOU\";\n    std::string vowels_begin4 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end4 = \"aeiouAEIOU\";\n    std::string vowels_begin5 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end5 = \"aeiouAEIOU\";\n    std::string vowels_begin6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end6 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_begin7 = \"aeiouAEIOU\";\n    std::string vowels_end7 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_begin8 = \"aeiouAEIOU\";\n    std::string vowels_end8\
    \ = \"aeiouAEIOU\";\n    std::string vowels_begin9 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end9 = \"aeiouAEIOU\";\n    std::string vowels_begin10 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end10 = \"aeiouAEIOU\";\n    std::string vowels_begin11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end11 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_begin12 = \"aeiouAEIOU\";\n    std::string vowels_end12 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_begin13 = \"aeiouAEIOU\";\n    std::string vowels_end13\
    \ = \"aeiouAEIOU\";\n    std::string vowels_begin14 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end14 = \"aeiouAEIOU\";\n    std::string vowels_begin15 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end15 = \"aeiouAEIOU\";\n    std::string vowels_begin16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end16 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_begin17 = \"aeiouAEIOU\";\n    std::string vowels_end17 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_begin18 = \"aeiouAEIOU\";\n    std::string vowels_end18\
    \ = \"aeiouAEIOU\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpq5epvtld.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748882
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Your code here\n    std::string vowels = \"aeiouAEIOU\";\n \
    \   std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"aeiouAEIOU\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"aeiouAEIOU\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"aeiouAEIOU\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"aeiouAEIOU\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"aeiouAEIOU\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"aeiouAEIOU\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"aeiouAEIOU\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprdt9kjyf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Your code here\n    std::string vowels = \"aeiouAEIOU\";\n \
    \   std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"aeiouAEIOUaeiou\";\n    std::string vowels_reverse3 = \"aeiouAEIOUaeiou\"\
    ;\n    std::string vowels_reverse4 = \"aeiouAEIOUaeiou\";\n    std::string vowels_reverse5\
    \ = \"aeiouAEIOUaeiou\";\n    std::string vowels_reverse6 = \"aeiouAEIOUaeiou\"\
    ;\n    std::string vowels_reverse7 = \"aeiouAEIOUaeiou\";\n    std::string vowels_reverse8\
    \ = \"aeiouAEIOUaeiou\";\n    std::string vowels_reverse9 = \"aeiouAEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOUaeiou\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOUaeiou\"\
    ;\n    std::string vowels_reverse13 = \"aeiouAEIOUaeiou\";\n    std::string vowels_reverse14\
    \ = \"aeiouAEIOUaeiou\";\n    std::string vowels_reverse15 = \"aeiouAEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"aeiouAEIOUaeiou\";\n    std::string vowels_reverse17\
    \ = \"aeiouAEIOUaeiou\";\n    std::string vowels_reverse18 = \"aeiouAEIOUaeiou\"\
    ;\n    std::string vowels_reverse19 = \"aeiouAEIOUaeiou\";\n    std::string vowels_reverse20\
    \ = \"aeiouAEIOUaeiou\";\n    std::string vowels_reverse21 = \"aeiouAEIOUaeiou\"\
    ;\n    std::string vowels_reverse22 = \"aeiouAEIOUaeiou\";\n    std::string vowels_reverse23\
    \ = \"aeiouAEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOUaeiou\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOUaeiou\";\n    std::string vowels_reverse27 = \"aeiouAEIOUaeiou\"\
    ;\n    std::string vowels_reverse28 = \"aeiouAEIOUaeiou\";\n    std::string vowels_reverse29\
    \ = \"aeiouAEIOUaeiou\";\n    std::string vowels_reverse30 = \"aeiouAEIOUaeiou\"\
    ;\n    std::string vowels_reverse31 = \"aeiouAEIOUaeiou\";\n    \n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpu2nx36aa.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748882
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_start = \"aeiouAEIOU\";\n    std::string\
    \ vowels_start_end = \"AEIOUaeiouAEIOU\";\n    std::string vowels_start_end_2\
    \ = \"aeiouAEIOUaeiouAEIOU\";\n    std::string vowels_start_end_3 = \"aeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_4 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOU\";\n\
    \    std::string vowels_start_end_5 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_6 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_7 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_8 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_9 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_10 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_11 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_12 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_13 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiou\"\
    ;\n    std::string vowels_start_end_14 = \"aeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOUaeiouAEIOU\"\
    ;\n    std::string vowels_start_end_\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_54j3wkx.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq0alwgwr.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpq0alwgwr.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpq0alwgwr.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"AEIOUaeiou\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"AEIOUaeiou\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"AEIOUaeiou\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpz8nm2zo6.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpz8nm2zo6.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpz8nm2zo6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748882
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_end\
    \ = \"AEIOUaeiou\";\n    std::string vowels_begin = \"aeiouAEIOU\";\n    std::string\
    \ vowels_begin2 = \"AEIOUaeiou\";\n    std::string vowels_end2 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_begin3 = \"AEIOUaeiou\";\n    std::string vowels_end3\
    \ = \"aeiouAEIOU\";\n    std::string vowels_begin4 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end4 = \"aeiouAEIOU\";\n    std::string vowels_begin5 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end5 = \"aeiouAEIOU\";\n    std::string vowels_begin6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end6 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_begin7 = \"aeiouAEIOU\";\n    std::string vowels_end7 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_begin8 = \"aeiouAEIOU\";\n    std::string vowels_end8\
    \ = \"aeiouAEIOU\";\n    std::string vowels_begin9 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end9 = \"aeiouAEIOU\";\n    std::string vowels_begin10 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end10 = \"aeiouAEIOU\";\n    std::string vowels_begin11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end11 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_begin12 = \"aeiouAEIOU\";\n    std::string vowels_end12 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_begin13 = \"aeiouAEIOU\";\n    std::string vowels_end13\
    \ = \"aeiouAEIOU\";\n    std::string vowels_begin14 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_end14 = \"aeiouAEIOU\";\n    std::string vowels_begin15 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_end15 = \"aeiouAEIOU\";\n    std::string vowels_begin16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_end16 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_begin17 = \"aeiouAEIOU\";\n    std::string vowels_end17 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_begin18 = \"aeiouAEIOU\";\n    std::string vowels_end18\
    \ = \"aeiouAEIOU\";\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpq5epvtld.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748882
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpu9sxgxia.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpu9sxgxia.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpu9sxgxia.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = vowels + vowels.substr(1, vowels.size());\n    std::string vowels_reverse_reverse\
    \ = vowels_reverse + vowels_reverse.substr(1, vowels_reverse.size());\n    std::string\
    \ vowels_reverse_reverse_reverse = vowels_reverse_reverse + vowels_reverse_reverse.substr(1,\
    \ vowels_reverse_reverse.size());\n    std::string vowels_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse + vowels_reverse_reverse_reverse.substr(1,\
    \ vowels_reverse_reverse_reverse.size());\n    std::string vowels_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse + vowels_reverse_reverse_reverse_reverse.substr(1,\
    \ vowels_reverse_reverse_reverse_reverse.size());\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse + vowels_reverse_reverse_reverse_reverse_reverse.substr(1,\
    \ vowels_reverse_reverse_reverse_reverse_reverse.size());\n    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse + vowels_reverse_reverse_reverse_reverse_reverse_reverse.substr(1,\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse.size());\n    std::string\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse = vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ + vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse.substr(1, vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse.size());\n\
    \    std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse + vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse.substr(1,\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse.size());\n  \
    \  std::string vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse\
    \ = vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse + vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse_reverse.substr(1,\
    \ vowels_reverse_reverse_reverse_reverse_reverse_reverse_reverse\n}\nint main()\
    \ {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"yogurt\"\
    )) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp2rwyliox.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748882
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reversed\
    \ = vowels.rbegin() + vowels.size();\n    std::string vowels_reversed_2 = vowels.rbegin()\
    \ + vowels.size() - 1;\n    std::string vowels_reversed_3 = vowels.rbegin() +\
    \ vowels.size() - 2;\n    std::string vowels_reversed_4 = vowels.rbegin() + vowels.size()\
    \ - 3;\n    std::string vowels_reversed_5 = vowels.rbegin() + vowels.size() -\
    \ 4;\n    std::string vowels_reversed_6 = vowels.rbegin() + vowels.size() - 5;\n\
    \    std::string vowels_reversed_7 = vowels.rbegin() + vowels.size() - 6;\n  \
    \  std::string vowels_reversed_8 = vowels.rbegin() + vowels.size() - 7;\n    std::string\
    \ vowels_reversed_9 = vowels.rbegin() + vowels.size() - 8;\n    std::string vowels_reversed_10\
    \ = vowels.rbegin() + vowels.size() - 9;\n    std::string vowels_reversed_11 =\
    \ vowels.rbegin() + vowels.size() - 10;\n    std::string vowels_reversed_12 =\
    \ vowels.rbegin() + vowels.size() - 11;\n    std::string vowels_reversed_13 =\
    \ vowels.rbegin() + vowels.size() - 12;\n    std::string vowels_reversed_14 =\
    \ vowels.rbegin() + vowels.size() - 13;\n    std::string vowels_reversed_15 =\
    \ vowels.rbegin() + vowels.size() - 14;\n    std::string vowels_reversed_16 =\
    \ vowels.rbegin() + vowels.size() - 15;\n    std::string vowels_reversed_17 =\
    \ vowels.rbegin() + vowels.size() - 16;\n    std::string vowels_reversed_18 =\
    \ vowels.rbegin() + vowels.size() - 17;\n    std::string vowels_reversed_19 =\
    \ vowels.rbegin() + vowels.size() - 18;\n    std::string vowels_reversed_20 =\
    \ vowels.rbegin() + vowels.size() - 19;\n    std::string vowels_reversed_21 =\
    \ vowels.rbegin() + vowels.size() - 20;\n    std::string vowels_reversed_22 =\
    \ vowels.rbegin() + vowels.size() - 21;\n    std::string vowels_reversed_23 =\
    \ vowels.rbegin() + vowels.size() - 22;\n    std::string vowels_reversed_24 =\
    \ vowels.rbegin() + vowels.size() - 23;\n    std::string vowels_reversed_25 =\
    \ vowels.rbegin() + vowels.size() - 24;\n    std::string vowels_reversed_26 =\
    \ vowels.rbegin() + vowels.size() - 25;\n    std::string vowels_reversed_27 =\
    \ vowels.rbegin() + vowels.size() - 26;\n    std::string vowels_reversed_28 =\
    \ vowels.rbegin() + vowels.size() - 27;\n    \n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpkk4xf1bn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_iswxc_h.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmp_iswxc_h.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_iswxc_h.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reversed\
    \ = vowels.substr(0, vowels.size() - 1);\n    std::string vowels_reversed_reversed\
    \ = vowels_reversed.substr(0, vowels_reversed.size() - 1);\n    std::string vowels_reversed_reversed_reversed\
    \ = vowels_reversed_reversed.substr(0, vowels_reversed_reversed.size() - 1);\n\
    \    std::string vowels_reversed_reversed_reversed_reversed = vowels_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed.size() - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed.substr(0, vowels_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed.substr(0, vowels_reversed_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.substr(0,\
    \ vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed.size()\
    \ - 1);\n    std::string vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed\
    \ = vowels_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_reversed_\n\
    }\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprcad9zne.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748882
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"AEIOU\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpc5bq899t.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmpc5bq899t.cpp:46:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n \
    \                from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpc5bq899t.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected prima"
  stdout: ''
  timestamp: 1659748882
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpa4is6gub.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpa4is6gub.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpa4is6gub.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748882
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Your code here\n    std::string vowels = \"aeiouAEIOU\";\n \
    \   std::string vowels_reverse = \"AEIOUaeiou\";\n    std::string vowels_reverse2\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse3 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse4 = \"aeiouAEIOU\";\n    std::string vowels_reverse5 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse6 = \"aeiouAEIOU\";\n    std::string vowels_reverse7\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse8 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse9 = \"AEIOUaeiou\";\n    std::string vowels_reverse10 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse11 = \"AEIOUaeiou\";\n    std::string vowels_reverse12\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse13 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse14 = \"aeiouAEIOU\";\n    std::string vowels_reverse15 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse16 = \"aeiouAEIOU\";\n    std::string vowels_reverse17\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse18 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse19 = \"AEIOUaeiou\";\n    std::string vowels_reverse20 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse21 = \"AEIOUaeiou\";\n    std::string vowels_reverse22\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse23 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse24 = \"aeiouAEIOU\";\n    std::string vowels_reverse25 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse26 = \"aeiouAEIOU\";\n    std::string vowels_reverse27\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse28 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse29 = \"AEIOUaeiou\";\n    std::string vowels_reverse30 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse31 = \"AEIOUaeiou\";\n    std::string vowels_reverse32\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse33 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse34 = \"aeiouAEIOU\";\n    std::string vowels_reverse35 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse\n}\nint main() {\n    auto candidate = get_closest_vowel;\n\
    \    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"full\"\
    )) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprdt9kjyf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    // Your code goes here\n    std::string vowels = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse2 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse3 = vowels.substr(0, vowels.size() - 1);\n    std::string\
    \ vowels_reverse4 = vowels.substr(vowels.size() - 1, vowels.size());\n    std::string\
    \ vowels_reverse5 = vowels.substr(0, vowels.size() - 1);\n    std::string vowels_reverse6\
    \ = vowels.substr(vowels.size() - 1, vowels.size());\n    std::string vowels_reverse7\
    \ = vowels.substr(0, vowels.size() - 1);\n    std::string vowels_reverse8 = vowels.substr(vowels.size()\
    \ - 1, vowels.size());\n    std::string vowels_reverse9 = vowels.substr(0, vowels.size()\
    \ - 1);\n    std::string vowels_reverse10 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse11 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse12 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse13 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse14 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse15 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse16 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse17 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse18 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse19 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse20 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse21 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse22 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse23 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse24 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse25 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse26 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse27 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse28 = vowels.substr(vowels.size() - 1, vowels.size());\n\
    \    std::string vowels_reverse29 = vowels.substr(0, vowels.size() - 1);\n   \
    \ std::string vowels_reverse30 = vowels.substr(vowels.size() - 1, vowel\n}\nint\
    \ main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmph6stoboc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748882
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = vowels.substr(0, vowels.size() - 1);\n    std::string vowels_reverse_reverse\
    \ = vowels_reverse.substr(0, vowels_reverse.size() - 1);\n    std::string vowels_reverse_reverse_2\
    \ = vowels_reverse_reverse.substr(0, vowels_reverse_reverse.size() - 1);\n   \
    \ std::string vowels_reverse_reverse_3 = vowels_reverse_reverse_2.substr(0, vowels_reverse_reverse_2.size()\
    \ - 1);\n    std::string vowels_reverse_reverse_4 = vowels_reverse_reverse_3.substr(0,\
    \ vowels_reverse_reverse_3.size() - 1);\n    std::string vowels_reverse_reverse_5\
    \ = vowels_reverse_reverse_4.substr(0, vowels_reverse_reverse_4.size() - 1);\n\
    \    std::string vowels_reverse_reverse_6 = vowels_reverse_reverse_5.substr(0,\
    \ vowels_reverse_reverse_5.size() - 1);\n    std::string vowels_reverse_reverse_7\
    \ = vowels_reverse_reverse_6.substr(0, vowels_reverse_reverse_6.size() - 1);\n\
    \    std::string vowels_reverse_reverse_8 = vowels_reverse_reverse_7.substr(0,\
    \ vowels_reverse_reverse_7.size() - 1);\n    std::string vowels_reverse_reverse_9\
    \ = vowels_reverse_reverse_8.substr(0, vowels_reverse_reverse_8.size() - 1);\n\
    \    std::string vowels_reverse_reverse_10 = vowels_reverse_reverse_9.substr(0,\
    \ vowels_reverse_reverse_9.size() - 1);\n    std::string vowels_reverse_reverse_11\
    \ = vowels_reverse_reverse_10.substr(0, vowels_reverse_reverse_10.size() - 1);\n\
    \    std::string vowels_reverse_reverse_12 = vowels_reverse_reverse_11.substr(0,\
    \ vowels_reverse_reverse_11.size() - 1);\n    std::string vowels_reverse_reverse_13\
    \ = vowels_reverse_reverse_12.substr(0, vowels_reverse_reverse_12.size() - 1);\n\
    \    std::string vowels_reverse_reverse_14 = vowels_reverse_reverse_13.substr(0,\
    \ vowels_reverse_reverse_13.size() - 1);\n    std::string vowels_reverse_reverse_15\
    \ = vowels_reverse_reverse_14.substr(0, vowels_reverse_reverse_14.size() - 1);\n\
    \    std::string vowels_reverse_reverse_16 = vowels_reverse_reverse_15.substr(0,\
    \ vowels_reverse_reverse_15.size() - 1);\n    std::string vowels_reverse_reverse_17\
    \ = vowels_reverse_reverse_16.substr(0, vowels_reverse_reverse_16.size() - 1);\n\
    \    std::string vowels_reverse_reverse_18 = vowels_reverse_reverse_17.substr(0,\
    \ vowels_reverse_reverse_17.size() - 1);\n    std::string vowels_reverse_reverse_19\
    \ = vowels_reverse_reverse_18.substr(0, vowel\n}\nint main() {\n    auto candidate\
    \ = get_closest_vowel;\n    assert(candidate((\"yogurt\")) == (\"u\"));\n    assert(candidate((\"\
    full\")) == (\"u\"));\n    assert(candidate((\"easy\")) == (\"\"));\n    assert(candidate((\"\
    eAsy\")) == (\"\"));\n    assert(candidate((\"ali\")) == (\"\"));\n    assert(candidate((\"\
    bad\")) == (\"a\"));\n    assert(candidate((\"most\")) == (\"o\"));\n    assert(candidate((\"\
    ab\")) == (\"\"));\n    assert(candidate((\"ba\")) == (\"\"));\n    assert(candidate((\"\
    quick\")) == (\"\"));\n    assert(candidate((\"anime\")) == (\"i\"));\n    assert(candidate((\"\
    Asia\")) == (\"\"));\n    assert(candidate((\"Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp4au5in69.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659748882
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"aeiouAEIOU\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmqj1kr4y.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpmqj1kr4y.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmqj1kr4y.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"aeiouAEIOU\";\n    std::string vowels_reverse6\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse7 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse10 = \"AEIOUaeiou\";\n    std::string vowels_reverse11\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"aeiouAEIOU\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"aeiouAEIOU\";\n    std::string vowels_reverse16\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse17 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse20 = \"AEIOUaeiou\";\n    std::string vowels_reverse21\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"aeiouAEIOU\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"aeiouAEIOU\";\n    std::string vowels_reverse26\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse27 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse30 = \"AEIOUaeiou\";\n    std::string vowels_reverse31\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"aeiouAEIOU\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"aeiouAEIOU\";\n    std::string vowels_reverse36\
    \ = \"AEIOU\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp681_i71f.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"AEIOU\n                 \
    \                   ^\n/tmp/tmp681_i71f.cpp:46:5: error: missing terminating \"\
    \ character\n     std::string vowels_reverse36 = \"AEIOU\n     ^\nIn file included\
    \ from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n \
    \                from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp681_i71f.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected prima"
  stdout: ''
  timestamp: 1659748881
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a word.\
    \ Your task is to find the closest vowel that stands between \n// two consonants\
    \ from the right side of the word (case sensitive).\n// Vowels in the beginning\
    \ and ending doesn't count. Return empty string if you didn't\n// find any vowel\
    \ met the above condition. \n// You may assume that the given string contains\
    \ English letter only.\n// Example:\nstd::string get_closest_vowel(std::string\
    \ word) {\n    std::string vowels = \"aeiouAEIOU\";\n    std::string vowels_reverse\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse2 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse3 = \"AEIOUaeiou\";\n    std::string vowels_reverse4 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse5 = \"AEIOUaeiou\";\n    std::string vowels_reverse6\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse7 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse8 = \"aeiouAEIOU\";\n    std::string vowels_reverse9 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse10 = \"aeiouAEIOU\";\n    std::string vowels_reverse11\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse12 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse13 = \"AEIOUaeiou\";\n    std::string vowels_reverse14 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse15 = \"AEIOUaeiou\";\n    std::string vowels_reverse16\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse17 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse18 = \"aeiouAEIOU\";\n    std::string vowels_reverse19 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse20 = \"aeiouAEIOU\";\n    std::string vowels_reverse21\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse22 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse23 = \"AEIOUaeiou\";\n    std::string vowels_reverse24 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse25 = \"AEIOUaeiou\";\n    std::string vowels_reverse26\
    \ = \"aeiouAEIOU\";\n    std::string vowels_reverse27 = \"AEIOUaeiou\";\n    std::string\
    \ vowels_reverse28 = \"aeiouAEIOU\";\n    std::string vowels_reverse29 = \"AEIOUaeiou\"\
    ;\n    std::string vowels_reverse30 = \"aeiouAEIOU\";\n    std::string vowels_reverse31\
    \ = \"AEIOUaeiou\";\n    std::string vowels_reverse32 = \"aeiouAEIOU\";\n    std::string\
    \ vowels_reverse33 = \"AEIOUaeiou\";\n    std::string vowels_reverse34 = \"aeiouAEIOU\"\
    ;\n    std::string vowels_reverse35 = \"AEIOUaeiou\";\n    std::string vowels_reverse36\
    \ = \"aeiouAE\n}\nint main() {\n    auto candidate = get_closest_vowel;\n    assert(candidate((\"\
    yogurt\")) == (\"u\"));\n    assert(candidate((\"full\")) == (\"u\"));\n    assert(candidate((\"\
    easy\")) == (\"\"));\n    assert(candidate((\"eAsy\")) == (\"\"));\n    assert(candidate((\"\
    ali\")) == (\"\"));\n    assert(candidate((\"bad\")) == (\"a\"));\n    assert(candidate((\"\
    most\")) == (\"o\"));\n    assert(candidate((\"ab\")) == (\"\"));\n    assert(candidate((\"\
    ba\")) == (\"\"));\n    assert(candidate((\"quick\")) == (\"\"));\n    assert(candidate((\"\
    anime\")) == (\"i\"));\n    assert(candidate((\"Asia\")) == (\"\"));\n    assert(candidate((\"\
    Above\")) == (\"o\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpppfsb3xs.cpp:46:36: warning: missing terminating \" character [enabled\
    \ by default]\n     std::string vowels_reverse36 = \"aeiouAE\n               \
    \                     ^\n/tmp/tmpppfsb3xs.cpp:46:5: error: missing terminating\
    \ \" character\n     std::string vowels_reverse36 = \"aeiouAE\n     ^\nIn file\
    \ included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpppfsb3xs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected p"
  stdout: ''
  timestamp: 1659748881
