{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "cs",
  "prompt": "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    public static List<List<long>> KSmallestPairs(List<long> nums1, List<long> nums2, long k) {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    public static void Main(string[] args) {\n    Debug.Assert(KSmallestPairs((new List<long>(new long[]{(long)1L, (long)3L, (long)7L})), (new List<long>(new long[]{(long)2L, (long)4L, (long)6L})), (2L)).Equals((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L}), (List<long>)new List<long>(new long[]{(long)1L, (long)4L})}))));\n    Debug.Assert(KSmallestPairs((new List<long>(new long[]{(long)1L, (long)3L, (long)7L})), (new List<long>(new long[]{(long)2L, (long)4L, (long)6L})), (1L)).Equals((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L})}))));\n    Debug.Assert(KSmallestPairs((new List<long>(new long[]{(long)1L, (long)3L, (long)7L})), (new List<long>(new long[]{(long)2L, (long)4L, (long)6L})), (7L)).Equals((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L}), (List<long>)new List<long>(new long[]{(long)1L, (long)4L}), (List<long>)new List<long>(new long[]{(long)3L, (long)2L}), (List<long>)new List<long>(new long[]{(long)1L, (long)6L}), (List<long>)new List<long>(new long[]{(long)3L, (long)4L}), (List<long>)new List<long>(new long[]{(long)3L, (long)6L}), (List<long>)new List<long>(new long[]{(long)7L, (long)2L})}))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<List<long>> pairs = new List<List<long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                pairs.Add(new List<long> { nums1[i], nums2[j] });\n            }\n        }\n        pairs.Sort((a, b) => {\n            long sumA = a[0] + a[1];\n            long sumB = b[0] + b[1];\n            if (sumA == sumB) {\n                return 0;\n            }\n            return sumA < sumB ? -1 : 1;\n        });\n        for (int i = 0; i < k && i < pairs.Count; i++) {\n            result.Add(pairs[i]);\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Add(new Pair(nums1[i], nums2[0], 0));\n        }\n        for (int i = 0; i < k && !minHeap.IsEmpty(); i++) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.SecondIndex < nums2.Count - 1) {\n                minHeap.Add(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) return result;\n        // Sort the first array\n        nums1.Sort();\n        // Sort the second array\n        nums2.Sort();\n        // Create a min heap of size k\n        MinHeap heap = new MinHeap(k);\n        // Add the first k elements to the heap\n        for (long i = 0; i < k && i < nums1.Count; i++) {\n            heap.Insert(new List<long> { nums1[(int)i], nums2[0] });\n        }\n        // Iterate through the second array\n        for (long i = 1; i < nums2.Count; i++) {\n            // Iterate through the heap\n            for (long j = 0; j < k && j < nums1.Count; j++) {\n                // Get the current element\n                List<long> curr = heap.Get(j);\n                // If the current element is greater than the current element in the second array, replace it\n                if (curr[1] > nums2[(int)i]) {\n                    heap.Replace(j, new List<long> { nums1[(int)j], nums2[(int)i] });\n                }\n            }\n        }\n        // Return the heap\n        return heap.GetHeap();",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<long> sums = new List<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                sums.Add(nums1[i] + nums2[j]);\n            }\n        }\n        sums.Sort();\n        for (int i = 0; i < k; i++) {\n            long sum = sums[i];\n            for (int j = 0; j < nums1.Count; j++) {\n                for (int l = 0; l < nums2.Count; l++) {\n                    if (nums1[j] + nums2[l] == sum) {\n                        List<long> pair = new List<long>();\n                        pair.Add(nums1[j]);\n                        pair.Add(nums2[l]);\n                        result.Add(pair);\n                        break;\n                    }\n                }\n            }\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<List<long>> pairs = new List<List<long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                pairs.Add(new List<long> { nums1[i], nums2[j] });\n            }\n        }\n        pairs.Sort((a, b) => (int)(a[0] + a[1] - b[0] - b[1]));\n        for (int i = 0; i < k && i < pairs.Count; i++) {\n            result.Add(pairs[i]);\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap<Tuple<long, long, long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new Tuple<long, long, long>(nums1[i] + nums2[0], i, 0));\n        }\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long>() { nums1[(int)pair.Item2], nums2[(int)pair.Item3] });\n            if (pair.Item3 + 1 < nums2.Count) {\n                minHeap.Insert(new Tuple<long, long, long>(nums1[(int)pair.Item2] + nums2[(int)pair.Item3 + 1], pair.Item2, pair.Item3 + 1));\n            }\n            k--;\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap<Tuple<long, long, long>>(k);\n        var visited = new HashSet<Tuple<long, long>>();\n        var first = new Tuple<long, long, long>(nums1[0] + nums2[0], 0, 0);\n        minHeap.Add(first);\n        visited.Add(new Tuple<long, long>(0, 0));\n        while (minHeap.Count > 0 && k > 0) {\n            var current = minHeap.Remove();\n            result.Add(new List<long> { nums1[current.Item2], nums2[current.Item3] });\n            k--;\n            if (current.Item2 + 1 < nums1.Count) {\n                var next = new Tuple<long, long, long>(nums1[current.Item2 + 1] + nums2[current.Item3], current.Item2 + 1, current.Item3);\n                if (!visited.Contains(new Tuple<long, long>(current.Item2 + 1, current.Item3))) {\n                    minHeap.Add(next);\n                    visited.Add(new Tuple<long, long>(current.Item2 + 1, current.Item3));\n                }\n            }\n            if (current.Item3 + 1 < nums2.Count) {\n                var next = new Tuple<long, long, long>(nums1[current.Item2] + nums2[current.Item3 + 1], current.Item2, current.Item3 + 1);\n                if (!visited.Contains(new Tuple<long, long>(current.Item2, current.Item3 + 1))) {\n                    minHeap.Add(next);\n                    visited.Add(new Tuple<long, long>(current.Item2, current.Item3 + 1));\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap<Pair>();\n        var visited = new HashSet<Pair>();\n        var firstPair = new Pair(0, 0, nums1[0] + nums2[0]);\n        minHeap.Insert(firstPair);\n        visited.Add(firstPair);\n        for (int i = 0; i < k && !minHeap.IsEmpty(); i++) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { nums1[pair.FirstIndex], nums2[pair.SecondIndex] });\n            var newPair1 = new Pair(pair.FirstIndex, pair.SecondIndex + 1, nums1[pair.FirstIndex] + nums2[pair.SecondIndex + 1]);\n            var newPair2 = new Pair(pair.FirstIndex + 1, pair.SecondIndex, nums1[pair.FirstIndex + 1] + nums2[pair.SecondIndex]);\n            if (pair.SecondIndex + 1 < nums2.Count && !visited.Contains(newPair1)) {\n                minHeap.Insert(newPair1);\n                visited.Add(newPair1);\n            }\n            if (pair.FirstIndex + 1 < nums1.Count && !visited.Contains(newPair2)) {\n                minHeap.Insert(newPair2);\n                visited.Add(newPair2);\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        if (k > nums1.Count * nums2.Count) {\n            k = nums1.Count * nums2.Count;\n        }\n        // Sort the first array.\n        nums1.Sort();\n        // Sort the second array.\n        nums2.Sort();\n        // Create a min heap.\n        MinHeap<List<long>> minHeap = new MinHeap<List<long>>();\n        // Add the first element from each array to the heap.\n        minHeap.Add(new List<long>() { nums1[0], nums2[0] });\n        // Add the first element to the result.\n        result.Add(new List<long>() { nums1[0], nums2[0] });\n        // Create a set to keep track of the elements that have been added to the heap.\n        HashSet<List<long>> set = new HashSet<List<long>>();\n        set.Add(new List<long>() { nums1[0], nums2[0] });\n        // Loop while the result size is less than k.\n        while (result.Count < k) {\n            // Get the minimum element from the heap.\n            List<long> min = minHeap.ExtractMin();\n            // Add the minimum element to the result.\n            result.Add(min);\n            // Get the index of the first element in the minimum element.\n            long index1 = nums1.IndexOf(min[0]);\n            // Get the index of the second element in the minimum element.\n            long index2 = nums2.IndexOf(min[1]);\n            // If the index of the first element is less than the length of the first array - 1, add the next element from the first array to the heap.\n            if (index1 < nums1.Count - 1) {\n                List<long> next1 = new List<long>() { nums1[index1 + 1], nums2[index2] };\n",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                minHeap.Insert(new List<long> { nums1[i], nums2[j] }, sum);\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            result.Add(minHeap.ExtractMin());\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var heap = new Heap<List<long>>(nums1.Count * nums2.Count);\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                heap.Insert(new List<long> { nums1[i], nums2[j] });\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            result.Add(heap.ExtractMin());\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                minHeap.Insert(new List<long>() { nums1[i], nums2[j] });\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            result.Add(minHeap.ExtractMin());\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) return result;\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new Pair(nums1[i], nums2[0], 0));\n        }\n        for (int i = 0; i < k && !minHeap.IsEmpty(); i++) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.SecondIndex < nums2.Count - 1) {\n                minHeap.Insert(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<long> sums = new List<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                sums.Add(nums1[i] + nums2[j]);\n            }\n        }\n        sums.Sort();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                if (result.Count == k) {\n                    return result;\n                }\n                if (sums[0] == nums1[i] + nums2[j]) {\n                    result.Add(new List<long>() { nums1[i], nums2[j] });\n                    sums.RemoveAt(0);\n                }\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first array\n        nums1.Sort();\n        // Sort the second array\n        nums2.Sort();\n        // Create a min heap\n        MinHeap heap = new MinHeap();\n        // Add the first element of the first array and the first element of the second array to the heap\n        heap.Add(new List<long>() { nums1[0], nums2[0] });\n        // Create a set to store the elements already added to the heap\n        HashSet<List<long>> set = new HashSet<List<long>>();\n        set.Add(new List<long>() { 0, 0 });\n        // While the heap is not empty and the number of elements in the result is less than k\n        while (heap.Count > 0 && result.Count < k) {\n            // Remove the top element from the heap\n            List<long> pair = heap.Remove();\n            // Add the pair to the result\n            result.Add(pair);\n            // Get the indices of the elements in the pair\n            long i = pair[0];\n            long j = pair[1];\n            // If the first element in the pair is not the last element in the first array\n            if (i < nums1.Count - 1) {\n                // Create a new pair with the next element in the first array and the same element in the second array\n                List<long> newPair = new List<long>() { nums1[i + 1], nums2[j] };\n                // If the new pair has not been added to the heap\n                if (!set.Contains(newPair)) {\n                    // Add the new pair to the heap\n                    heap.Add(newPair);\n                    // Add the new pair to the set\n                    set.Add(newPair);\n                }\n            }\n            // If the second element in the pair is not the last element in the second array\n            if (j < nums2.Count - 1) {\n                // Create a new pair with the same element",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        SortedDictionary<long, List<List<long>>> dict = new SortedDictionary<long, List<List<long>>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                long sum = nums1[i] + nums2[j];\n                if (!dict.ContainsKey(sum)) {\n                    dict[sum] = new List<List<long>>();\n                }\n                dict[sum].Add(new List<long>() { nums1[i], nums2[j] });\n            }\n        }\n        foreach (long key in dict.Keys) {\n            foreach (List<long> pair in dict[key]) {\n                result.Add(pair);\n                k--;\n                if (k == 0) {\n                    return result;\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<List<long>>(k);\n        for (long i = 0; i < nums1.Count; i++) {\n            for (long j = 0; j < nums2.Count; j++) {\n                var sum = nums1[(int)i] + nums2[(int)j];\n                if (pq.Count < k) {\n                    pq.Enqueue(new List<long> { nums1[(int)i], nums2[(int)j] });\n                } else {\n                    if (pq.Peek()[0] + pq.Peek()[1] > sum) {\n                        pq.Dequeue();\n                        pq.Enqueue(new List<long> { nums1[(int)i], nums2[(int)j] });\n                    }\n                }\n            }\n        }\n        while (pq.Count > 0) {\n            result.Add(pq.Dequeue());\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var heap = new Heap<Tuple<long, long, long>>();\n        for (var i = 0; i < nums1.Count; i++) {\n            heap.Insert(new Tuple<long, long, long>(nums1[i] + nums2[0], i, 0));\n        }\n        while (result.Count < k && heap.Count > 0) {\n            var item = heap.Extract();\n            result.Add(new List<long> { nums1[item.Item2], nums2[item.Item3] });\n            if (item.Item3 + 1 < nums2.Count) {\n                heap.Insert(new Tuple<long, long, long>(nums1[item.Item2] + nums2[item.Item3 + 1], item.Item2, item.Item3 + 1));\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // sort the arrays\n        nums1.Sort();\n        nums2.Sort();\n        // create a min heap\n        MinHeap heap = new MinHeap(k);\n        // add the first element of each array to the heap\n        heap.Add(new List<long>() { nums1[0], nums2[0] });\n        // create a set to keep track of the pairs we've already seen\n        HashSet<List<long>> seen = new HashSet<List<long>>();\n        seen.Add(new List<long>() { nums1[0], nums2[0] });\n        // loop until we have k pairs\n        while (result.Count < k) {\n            // get the smallest pair\n            List<long> pair = heap.Remove();\n            // add it to the result\n            result.Add(pair);\n            // get the indices of the elements in the pair\n            long i = pair[0];\n            long j = pair[1];\n            // add the next pair with the first element and the next element of the second array\n            if (seen.Add(new List<long>() { i, j + 1 })) {\n                heap.Add(new List<long>() { i, j + 1 });\n            }\n            // if we haven't reached the end of the first array, add the next pair with the next element of the first array and the first element of the second array\n            if (i + 1 < nums1.Count && seen.Add(new List<long>() { i + 1, j })) {\n                heap.Add(new List<long>() { i + 1, j });\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                minHeap.Insert(new Pair(nums1[i], nums2[j], sum));\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            var pair = minHeap.ExtractMin();\n            if (pair == null) {\n                break;\n            }\n            result.Add(new List<long> { pair.First, pair.Second });\n        }\n        return result;"
  ]
}