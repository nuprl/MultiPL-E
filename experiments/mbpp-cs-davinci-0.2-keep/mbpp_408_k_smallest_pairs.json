{
  "name": "mbpp_408_k_smallest_pairs",
  "language": "cs",
  "prompt": "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    // Write a function to find k number of smallest pairs which consist of one element from the first array and one element from the second array.\n    public static List<List<long>> KSmallestPairs(List<long> nums1, List<long> nums2, long k) {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_408_k_smallest_pairs.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    public static void Main(string[] args) {\n    Debug.Assert(KSmallestPairs((new List<long>(new long[]{(long)1L, (long)3L, (long)7L})), (new List<long>(new long[]{(long)2L, (long)4L, (long)6L})), (2L)).Equals((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L}), (List<long>)new List<long>(new long[]{(long)1L, (long)4L})}))));\n    Debug.Assert(KSmallestPairs((new List<long>(new long[]{(long)1L, (long)3L, (long)7L})), (new List<long>(new long[]{(long)2L, (long)4L, (long)6L})), (1L)).Equals((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L})}))));\n    Debug.Assert(KSmallestPairs((new List<long>(new long[]{(long)1L, (long)3L, (long)7L})), (new List<long>(new long[]{(long)2L, (long)4L, (long)6L})), (7L)).Equals((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L}), (List<long>)new List<long>(new long[]{(long)1L, (long)4L}), (List<long>)new List<long>(new long[]{(long)3L, (long)2L}), (List<long>)new List<long>(new long[]{(long)1L, (long)6L}), (List<long>)new List<long>(new long[]{(long)3L, (long)4L}), (List<long>)new List<long>(new long[]{(long)3L, (long)6L}), (List<long>)new List<long>(new long[]{(long)7L, (long)2L})}))));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<List<long>> pairs = new List<List<long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                pairs.Add(new List<long> { nums1[i], nums2[j] });\n            }\n        }\n        pairs.Sort((a, b) => {\n            long sumA = a[0] + a[1];\n            long sumB = b[0] + b[1];\n            if (sumA == sumB) {\n                return 0;\n            }\n            return sumA < sumB ? -1 : 1;\n        });\n        for (int i = 0; i < k && i < pairs.Count; i++) {\n            result.Add(pairs[i]);\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Add(new Pair(nums1[i], nums2[0], 0));\n        }\n        for (int i = 0; i < k && !minHeap.IsEmpty(); i++) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.SecondIndex < nums2.Count - 1) {\n                minHeap.Add(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) return result;\n        // Sort the first array\n        nums1.Sort();\n        // Sort the second array\n        nums2.Sort();\n        // Create a min heap of size k\n        MinHeap heap = new MinHeap(k);\n        // Add the first k elements to the heap\n        for (long i = 0; i < k && i < nums1.Count; i++) {\n            heap.Insert(new List<long> { nums1[(int)i], nums2[0] });\n        }\n        // Iterate through the second array\n        for (long i = 1; i < nums2.Count; i++) {\n            // Iterate through the heap\n            for (long j = 0; j < k && j < nums1.Count; j++) {\n                // Get the current element\n                List<long> curr = heap.Get(j);\n                // If the current element is greater than the current element in the second array, replace it\n                if (curr[1] > nums2[(int)i]) {\n                    heap.Replace(j, new List<long> { nums1[(int)j], nums2[(int)i] });\n                }\n            }\n        }\n        // Return the heap\n        return heap.GetHeap();",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<long> sums = new List<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                sums.Add(nums1[i] + nums2[j]);\n            }\n        }\n        sums.Sort();\n        for (int i = 0; i < k; i++) {\n            long sum = sums[i];\n            for (int j = 0; j < nums1.Count; j++) {\n                for (int l = 0; l < nums2.Count; l++) {\n                    if (nums1[j] + nums2[l] == sum) {\n                        List<long> pair = new List<long>();\n                        pair.Add(nums1[j]);\n                        pair.Add(nums2[l]);\n                        result.Add(pair);\n                        break;\n                    }\n                }\n            }\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<List<long>> pairs = new List<List<long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                pairs.Add(new List<long> { nums1[i], nums2[j] });\n            }\n        }\n        pairs.Sort((a, b) => (int)(a[0] + a[1] - b[0] - b[1]));\n        for (int i = 0; i < k && i < pairs.Count; i++) {\n            result.Add(pairs[i]);\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap<Tuple<long, long, long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new Tuple<long, long, long>(nums1[i] + nums2[0], i, 0));\n        }\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long>() { nums1[(int)pair.Item2], nums2[(int)pair.Item3] });\n            if (pair.Item3 + 1 < nums2.Count) {\n                minHeap.Insert(new Tuple<long, long, long>(nums1[(int)pair.Item2] + nums2[(int)pair.Item3 + 1], pair.Item2, pair.Item3 + 1));\n            }\n            k--;\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap<Tuple<long, long, long>>(k);\n        var visited = new HashSet<Tuple<long, long>>();\n        var first = new Tuple<long, long, long>(nums1[0] + nums2[0], 0, 0);\n        minHeap.Add(first);\n        visited.Add(new Tuple<long, long>(0, 0));\n        while (minHeap.Count > 0 && k > 0) {\n            var current = minHeap.Remove();\n            result.Add(new List<long> { nums1[current.Item2], nums2[current.Item3] });\n            k--;\n            if (current.Item2 + 1 < nums1.Count) {\n                var next = new Tuple<long, long, long>(nums1[current.Item2 + 1] + nums2[current.Item3], current.Item2 + 1, current.Item3);\n                if (!visited.Contains(new Tuple<long, long>(current.Item2 + 1, current.Item3))) {\n                    minHeap.Add(next);\n                    visited.Add(new Tuple<long, long>(current.Item2 + 1, current.Item3));\n                }\n            }\n            if (current.Item3 + 1 < nums2.Count) {\n                var next = new Tuple<long, long, long>(nums1[current.Item2] + nums2[current.Item3 + 1], current.Item2, current.Item3 + 1);\n                if (!visited.Contains(new Tuple<long, long>(current.Item2, current.Item3 + 1))) {\n                    minHeap.Add(next);\n                    visited.Add(new Tuple<long, long>(current.Item2, current.Item3 + 1));\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap<Pair>();\n        var visited = new HashSet<Pair>();\n        var firstPair = new Pair(0, 0, nums1[0] + nums2[0]);\n        minHeap.Insert(firstPair);\n        visited.Add(firstPair);\n        for (int i = 0; i < k && !minHeap.IsEmpty(); i++) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { nums1[pair.FirstIndex], nums2[pair.SecondIndex] });\n            var newPair1 = new Pair(pair.FirstIndex, pair.SecondIndex + 1, nums1[pair.FirstIndex] + nums2[pair.SecondIndex + 1]);\n            var newPair2 = new Pair(pair.FirstIndex + 1, pair.SecondIndex, nums1[pair.FirstIndex + 1] + nums2[pair.SecondIndex]);\n            if (pair.SecondIndex + 1 < nums2.Count && !visited.Contains(newPair1)) {\n                minHeap.Insert(newPair1);\n                visited.Add(newPair1);\n            }\n            if (pair.FirstIndex + 1 < nums1.Count && !visited.Contains(newPair2)) {\n                minHeap.Insert(newPair2);\n                visited.Add(newPair2);\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        if (k > nums1.Count * nums2.Count) {\n            k = nums1.Count * nums2.Count;\n        }\n        // Sort the first array.\n        nums1.Sort();\n        // Sort the second array.\n        nums2.Sort();\n        // Create a min heap.\n        MinHeap<List<long>> minHeap = new MinHeap<List<long>>();\n        // Add the first element from each array to the heap.\n        minHeap.Add(new List<long>() { nums1[0], nums2[0] });\n        // Add the first element to the result.\n        result.Add(new List<long>() { nums1[0], nums2[0] });\n        // Create a set to keep track of the elements that have been added to the heap.\n        HashSet<List<long>> set = new HashSet<List<long>>();\n        set.Add(new List<long>() { nums1[0], nums2[0] });\n        // Loop while the result size is less than k.\n        while (result.Count < k) {\n            // Get the minimum element from the heap.\n            List<long> min = minHeap.ExtractMin();\n            // Add the minimum element to the result.\n            result.Add(min);\n            // Get the index of the first element in the minimum element.\n            long index1 = nums1.IndexOf(min[0]);\n            // Get the index of the second element in the minimum element.\n            long index2 = nums2.IndexOf(min[1]);\n            // If the index of the first element is less than the length of the first array - 1, add the next element from the first array to the heap.\n            if (index1 < nums1.Count - 1) {\n                List<long> next1 = new List<long>() { nums1[index1 + 1], nums2[index2] };\n",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                minHeap.Insert(new List<long> { nums1[i], nums2[j] }, sum);\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            result.Add(minHeap.ExtractMin());\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var heap = new Heap<List<long>>(nums1.Count * nums2.Count);\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                heap.Insert(new List<long> { nums1[i], nums2[j] });\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            result.Add(heap.ExtractMin());\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                minHeap.Insert(new List<long>() { nums1[i], nums2[j] });\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            result.Add(minHeap.ExtractMin());\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) return result;\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new Pair(nums1[i], nums2[0], 0));\n        }\n        for (int i = 0; i < k && !minHeap.IsEmpty(); i++) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.SecondIndex < nums2.Count - 1) {\n                minHeap.Insert(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<long> sums = new List<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                sums.Add(nums1[i] + nums2[j]);\n            }\n        }\n        sums.Sort();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                if (result.Count == k) {\n                    return result;\n                }\n                if (sums[0] == nums1[i] + nums2[j]) {\n                    result.Add(new List<long>() { nums1[i], nums2[j] });\n                    sums.RemoveAt(0);\n                }\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first array\n        nums1.Sort();\n        // Sort the second array\n        nums2.Sort();\n        // Create a min heap\n        MinHeap heap = new MinHeap();\n        // Add the first element of the first array and the first element of the second array to the heap\n        heap.Add(new List<long>() { nums1[0], nums2[0] });\n        // Create a set to store the elements already added to the heap\n        HashSet<List<long>> set = new HashSet<List<long>>();\n        set.Add(new List<long>() { 0, 0 });\n        // While the heap is not empty and the number of elements in the result is less than k\n        while (heap.Count > 0 && result.Count < k) {\n            // Remove the top element from the heap\n            List<long> pair = heap.Remove();\n            // Add the pair to the result\n            result.Add(pair);\n            // Get the indices of the elements in the pair\n            long i = pair[0];\n            long j = pair[1];\n            // If the first element in the pair is not the last element in the first array\n            if (i < nums1.Count - 1) {\n                // Create a new pair with the next element in the first array and the same element in the second array\n                List<long> newPair = new List<long>() { nums1[i + 1], nums2[j] };\n                // If the new pair has not been added to the heap\n                if (!set.Contains(newPair)) {\n                    // Add the new pair to the heap\n                    heap.Add(newPair);\n                    // Add the new pair to the set\n                    set.Add(newPair);\n                }\n            }\n            // If the second element in the pair is not the last element in the second array\n            if (j < nums2.Count - 1) {\n                // Create a new pair with the same element",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        SortedDictionary<long, List<List<long>>> dict = new SortedDictionary<long, List<List<long>>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                long sum = nums1[i] + nums2[j];\n                if (!dict.ContainsKey(sum)) {\n                    dict[sum] = new List<List<long>>();\n                }\n                dict[sum].Add(new List<long>() { nums1[i], nums2[j] });\n            }\n        }\n        foreach (long key in dict.Keys) {\n            foreach (List<long> pair in dict[key]) {\n                result.Add(pair);\n                k--;\n                if (k == 0) {\n                    return result;\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<List<long>>(k);\n        for (long i = 0; i < nums1.Count; i++) {\n            for (long j = 0; j < nums2.Count; j++) {\n                var sum = nums1[(int)i] + nums2[(int)j];\n                if (pq.Count < k) {\n                    pq.Enqueue(new List<long> { nums1[(int)i], nums2[(int)j] });\n                } else {\n                    if (pq.Peek()[0] + pq.Peek()[1] > sum) {\n                        pq.Dequeue();\n                        pq.Enqueue(new List<long> { nums1[(int)i], nums2[(int)j] });\n                    }\n                }\n            }\n        }\n        while (pq.Count > 0) {\n            result.Add(pq.Dequeue());\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var heap = new Heap<Tuple<long, long, long>>();\n        for (var i = 0; i < nums1.Count; i++) {\n            heap.Insert(new Tuple<long, long, long>(nums1[i] + nums2[0], i, 0));\n        }\n        while (result.Count < k && heap.Count > 0) {\n            var item = heap.Extract();\n            result.Add(new List<long> { nums1[item.Item2], nums2[item.Item3] });\n            if (item.Item3 + 1 < nums2.Count) {\n                heap.Insert(new Tuple<long, long, long>(nums1[item.Item2] + nums2[item.Item3 + 1], item.Item2, item.Item3 + 1));\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // sort the arrays\n        nums1.Sort();\n        nums2.Sort();\n        // create a min heap\n        MinHeap heap = new MinHeap(k);\n        // add the first element of each array to the heap\n        heap.Add(new List<long>() { nums1[0], nums2[0] });\n        // create a set to keep track of the pairs we've already seen\n        HashSet<List<long>> seen = new HashSet<List<long>>();\n        seen.Add(new List<long>() { nums1[0], nums2[0] });\n        // loop until we have k pairs\n        while (result.Count < k) {\n            // get the smallest pair\n            List<long> pair = heap.Remove();\n            // add it to the result\n            result.Add(pair);\n            // get the indices of the elements in the pair\n            long i = pair[0];\n            long j = pair[1];\n            // add the next pair with the first element and the next element of the second array\n            if (seen.Add(new List<long>() { i, j + 1 })) {\n                heap.Add(new List<long>() { i, j + 1 });\n            }\n            // if we haven't reached the end of the first array, add the next pair with the next element of the first array and the first element of the second array\n            if (i + 1 < nums1.Count && seen.Add(new List<long>() { i + 1, j })) {\n                heap.Add(new List<long>() { i + 1, j });\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                minHeap.Insert(new Pair(nums1[i], nums2[j], sum));\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            var pair = minHeap.ExtractMin();\n            if (pair == null) {\n                break;\n            }\n            result.Add(new List<long> { pair.First, pair.Second });\n        }\n        return result;",
    "        // Write your code here.\n        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        minHeap.Insert(new Pair(nums1[0], nums2[0], 0, 0));\n        visited.Add(GetKey(0, 0));\n        while (k > 0 && minHeap.Size > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long>() { pair.Num1, pair.Num2 });\n            var i = pair.Index1;\n            var j = pair.Index2;\n            if (i + 1 < nums1.Count && !visited.Contains(GetKey(i + 1, j))) {\n                minHeap.Insert(new Pair(nums1[i + 1], nums2[j], i + 1, j));\n                visited.Add(GetKey(i + 1, j));\n            }\n            if (j + 1 < nums2.Count && !visited.Contains(GetKey(i, j + 1))) {\n                minHeap.Insert(new Pair(nums1[i], nums2[j + 1], i, j + 1));\n                visited.Add(GetKey(i, j + 1));\n            }\n            k--;\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<long> sums = new List<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                sums.Add(nums1[i] + nums2[j]);\n            }\n        }\n        sums.Sort();\n        for (int i = 0; i < k; i++) {\n            result.Add(new List<long>() { sums[i] });\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<Tuple<long, long, long>>();\n        for (var i = 0; i < nums1.Count; i++) {\n            pq.Enqueue(new Tuple<long, long, long>(nums1[i] + nums2[0], i, 0));\n        }\n        while (k > 0 && pq.Count > 0) {\n            var t = pq.Dequeue();\n            result.Add(new List<long> { nums1[t.Item2], nums2[t.Item3] });\n            if (t.Item3 + 1 < nums2.Count) {\n                pq.Enqueue(new Tuple<long, long, long>(nums1[t.Item2] + nums2[t.Item3 + 1], t.Item2, t.Item3 + 1));\n            }\n            k--;\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) return result;\n        // sort the first array\n        nums1.Sort();\n        // sort the second array\n        nums2.Sort();\n        // create a min heap\n        MinHeap heap = new MinHeap();\n        // add the first pair to the heap\n        heap.Add(new Pair(nums1[0], nums2[0]));\n        // create a hashset to store the pairs we have already added to the heap\n        HashSet<string> set = new HashSet<string>();\n        set.Add(nums1[0].ToString() + \",\" + nums2[0].ToString());\n        // loop k times\n        for (int i = 0; i < k; i++) {\n            // get the min pair from the heap\n            Pair pair = heap.GetMin();\n            // add the pair to the result\n            result.Add(new List<long>() { pair.First, pair.Second });\n            // check if we can add the next pair from the first array\n            if (pair.FirstIndex + 1 < nums1.Count) {\n                // create the next pair\n                Pair nextPair = new Pair(nums1[pair.FirstIndex + 1], pair.Second);\n                // check if we have already added this pair to the heap\n                if (!set.Contains(nextPair.First.ToString() + \",\" + nextPair.Second.ToString())) {\n                    // add the pair to the heap\n                    heap.Add(nextPair);\n                    // add the pair to the hashset\n                    set.Add(nextPair.First.ToString() + \",\" + nextPair.Second.ToString());\n                }\n            }\n            // check if we can add the next pair from the second array\n            if (pair.SecondIndex + 1 < nums2.Count) {\n                // create the next pair\n                Pair nextPair = new Pair(pair.First, nums2[pair.SecondIndex + 1]);\n                // check if we have already added this pair to the heap\n               ",
    "        // Write your code here.\n        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        minHeap.Insert(new Pair(0, 0, nums1[0] + nums2[0]));\n        visited.Add(\"0-0\");\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { nums1[pair.FirstIndex], nums2[pair.SecondIndex] });\n            k--;\n            if (pair.FirstIndex + 1 < nums1.Count && !visited.Contains($\"{pair.FirstIndex + 1}-{pair.SecondIndex}\")) {\n                minHeap.Insert(new Pair(pair.FirstIndex + 1, pair.SecondIndex, nums1[pair.FirstIndex + 1] + nums2[pair.SecondIndex]));\n                visited.Add($\"{pair.FirstIndex + 1}-{pair.SecondIndex}\");\n            }\n            if (pair.SecondIndex + 1 < nums2.Count && !visited.Contains($\"{pair.FirstIndex}-{pair.SecondIndex + 1}\")) {\n                minHeap.Insert(new Pair(pair.FirstIndex, pair.SecondIndex + 1, nums1[pair.FirstIndex] + nums2[pair.SecondIndex + 1]));\n                visited.Add($\"{pair.FirstIndex}-{pair.SecondIndex + 1}\");\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap<List<long>>(k);\n        var visited = new HashSet<List<long>>();\n        var first = new List<long> {nums1[0], nums2[0]};\n        minHeap.Add(first);\n        visited.Add(first);\n        while (minHeap.Count > 0 && result.Count < k) {\n            var current = minHeap.Remove();\n            result.Add(current);\n            var next1 = new List<long> {current[0] + 1, current[1]};\n            var next2 = new List<long> {current[0], current[1] + 1};\n            if (nums1.Count > next1[0] && nums2.Count > next1[1] && !visited.Contains(next1)) {\n                minHeap.Add(next1);\n                visited.Add(next1);\n            }\n            if (nums1.Count > next2[0] && nums2.Count > next2[1] && !visited.Contains(next2)) {\n                minHeap.Add(next2);\n                visited.Add(next2);\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<Tuple<long, long, long>>();\n        for (long i = 0; i < nums1.Count; i++) {\n            pq.Enqueue(new Tuple<long, long, long>(nums1[(int)i] + nums2[0], i, 0));\n        }\n        while (k > 0 && pq.Count > 0) {\n            var t = pq.Dequeue();\n            result.Add(new List<long> { nums1[(int)t.Item2], nums2[(int)t.Item3] });\n            if (t.Item3 + 1 < nums2.Count) {\n                pq.Enqueue(new Tuple<long, long, long>(nums1[(int)t.Item2] + nums2[(int)t.Item3 + 1], t.Item2, t.Item3 + 1));\n            }\n            k--;\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<List<long>> pairs = new List<List<long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                pairs.Add(new List<long> { nums1[i], nums2[j] });\n            }\n        }\n        pairs.Sort((a, b) => (int)(a[0] + a[1] - b[0] - b[1]));\n        for (int i = 0; i < k && i < pairs.Count; i++) {\n            result.Add(pairs[i]);\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<Tuple<long, long, long>>();\n        pq.Enqueue(new Tuple<long, long, long>(nums1[0] + nums2[0], 0, 0));\n        var visited = new HashSet<Tuple<long, long>>();\n        visited.Add(new Tuple<long, long>(0, 0));\n        while (k > 0 && pq.Count > 0) {\n            var cur = pq.Dequeue();\n            result.Add(new List<long> { nums1[cur.Item2], nums2[cur.Item3] });\n            k--;\n            if (cur.Item2 + 1 < nums1.Count && !visited.Contains(new Tuple<long, long>(cur.Item2 + 1, cur.Item3))) {\n                pq.Enqueue(new Tuple<long, long, long>(nums1[cur.Item2 + 1] + nums2[cur.Item3], cur.Item2 + 1, cur.Item3));\n                visited.Add(new Tuple<long, long>(cur.Item2 + 1, cur.Item3));\n            }\n            if (cur.Item3 + 1 < nums2.Count && !visited.Contains(new Tuple<long, long>(cur.Item2, cur.Item3 + 1))) {\n                pq.Enqueue(new Tuple<long, long, long>(nums1[cur.Item2] + nums2[cur.Item3 + 1], cur.Item2, cur.Item3 + 1));\n                visited.Add(new Tuple<long, long>(cur.Item2, cur.Item3 + 1));\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        SortedDictionary<long, List<List<long>>> dict = new SortedDictionary<long, List<List<long>>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                long sum = nums1[i] + nums2[j];\n                if (!dict.ContainsKey(sum)) {\n                    dict[sum] = new List<List<long>>();\n                }\n                dict[sum].Add(new List<long> { nums1[i], nums2[j] });\n            }\n        }\n        foreach (var pair in dict) {\n            foreach (var item in pair.Value) {\n                result.Add(item);\n                if (result.Count == k) {\n                    return result;\n                }\n            }\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        SortedDictionary<long, List<List<long>>> sums = new SortedDictionary<long, List<List<long>>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                long sum = nums1[i] + nums2[j];\n                if (!sums.ContainsKey(sum)) {\n                    sums.Add(sum, new List<List<long>>());\n                }\n                sums[sum].Add(new List<long> { nums1[i], nums2[j] });\n            }\n        }\n        foreach (long sum in sums.Keys) {\n            foreach (List<long> pair in sums[sum]) {\n                result.Add(pair);\n                if (result.Count == k) {\n                    return result;\n                }\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the arrays\n        nums1.Sort();\n        nums2.Sort();\n        // Create a min heap\n        MinHeap heap = new MinHeap();\n        // Add the first element of each array to the heap\n        heap.Add(new List<long>() { nums1[0], nums2[0] });\n        // Add the first element of each array to the result\n        result.Add(new List<long>() { nums1[0], nums2[0] });\n        // Create a dictionary to keep track of the elements that have been added to the heap\n        Dictionary<List<long>, bool> dict = new Dictionary<List<long>, bool>();\n        dict.Add(new List<long>() { nums1[0], nums2[0] }, true);\n        // While the heap is not empty and the result size is less than k\n        while (heap.Count > 0 && result.Count < k) {\n            // Remove the top element from the heap\n            List<long> pair = heap.Remove();\n            // Get the first element of the pair\n            long num1 = pair[0];\n            // Get the second element of the pair\n            long num2 = pair[1];\n            // If the first element is not the last element of the first array\n            if (nums1.IndexOf(num1) < nums1.Count - 1) {\n                // Create a new pair with the next element of the first array and the second element of the current pair\n                List<long> newPair = new List<long>() { nums1[nums1.IndexOf(num1) + 1], num2 };\n                // If the new pair has not been added to the heap\n                if (!dict.ContainsKey(newPair)) {\n                    // Add the new pair to the heap\n                    heap.Add(newPair);\n                    // Add the new pair to the dictionary\n                    dict.Add(newPair, true);\n                    // Add the new pair to the",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new Pair(nums1[i], nums2[0], 0));\n        }\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.SecondIndex < nums2.Count - 1) {\n                minHeap.Insert(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n            k--;\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        SortedDictionary<long, List<List<long>>> sums = new SortedDictionary<long, List<List<long>>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                long sum = nums1[i] + nums2[j];\n                if (!sums.ContainsKey(sum)) {\n                    sums.Add(sum, new List<List<long>>());\n                }\n                sums[sum].Add(new List<long>() { nums1[i], nums2[j] });\n            }\n        }\n        foreach (long key in sums.Keys) {\n            foreach (List<long> pair in sums[key]) {\n                result.Add(pair);\n                k--;\n                if (k == 0) {\n                    return result;\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n\n        var pq = new PriorityQueue<List<long>>(k);\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                if (pq.Count < k) {\n                    pq.Enqueue(new List<long> { nums1[i], nums2[j] });\n                } else {\n                    if (sum < pq.Peek()[0] + pq.Peek()[1]) {\n                        pq.Dequeue();\n                        pq.Enqueue(new List<long> { nums1[i], nums2[j] });\n                    }\n                }\n            }\n        }\n\n        while (pq.Count > 0) {\n            result.Add(pq.Dequeue());\n        }\n\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<Tuple<long, long, long>>(k);\n        for (long i = 0; i < nums1.Count; i++) {\n            for (long j = 0; j < nums2.Count; j++) {\n                var sum = nums1[(int)i] + nums2[(int)j];\n                if (pq.Count < k) {\n                    pq.Enqueue(new Tuple<long, long, long>(i, j, sum));\n                } else {\n                    var peek = pq.Peek();\n                    if (sum < peek.Item3) {\n                        pq.Dequeue();\n                        pq.Enqueue(new Tuple<long, long, long>(i, j, sum));\n                    }\n                }\n            }\n        }\n        while (pq.Count > 0) {\n            var peek = pq.Dequeue();\n            result.Add(new List<long> { nums1[(int)peek.Item1], nums2[(int)peek.Item2] });\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<List<long>> pairs = new List<List<long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                pairs.Add(new List<long> { nums1[i], nums2[j] });\n            }\n        }\n        pairs.Sort((a, b) => (int)(a[0] + a[1] - b[0] - b[1]));\n        for (int i = 0; i < k && i < pairs.Count; i++) {\n            result.Add(pairs[i]);\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<Tuple<long, long, long>>();\n        for (long i = 0; i < nums1.Count; i++) {\n            for (long j = 0; j < nums2.Count; j++) {\n                pq.Enqueue(new Tuple<long, long, long>(i, j, nums1[(int)i] + nums2[(int)j]));\n            }\n        }\n        while (k > 0 && pq.Count > 0) {\n            var t = pq.Dequeue();\n            result.Add(new List<long> { nums1[(int)t.Item1], nums2[(int)t.Item2] });\n            k--;\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        var first = new List<long>() { nums1[0], nums2[0], 0, 0 };\n        minHeap.Insert(first);\n        visited.Add(first[2] + \",\" + first[3]);\n        while (k > 0 && minHeap.Count > 0) {\n            var current = minHeap.ExtractMin();\n            result.Add(new List<long>() { current[0], current[1] });\n            k--;\n            var i = current[2];\n            var j = current[3];\n            if (i + 1 < nums1.Count) {\n                var next = new List<long>() { nums1[i + 1], nums2[j], i + 1, j };\n                if (!visited.Contains(next[2] + \",\" + next[3])) {\n                    minHeap.Insert(next);\n                    visited.Add(next[2] + \",\" + next[3]);\n                }\n            }\n            if (j + 1 < nums2.Count) {\n                var next = new List<long>() { nums1[i], nums2[j + 1], i, j + 1 };\n                if (!visited.Contains(next[2] + \",\" + next[3])) {\n                    minHeap.Insert(next);\n                    visited.Add(next[2] + \",\" + next[3]);\n                }\n            }\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // sort the two arrays\n        nums1.Sort();\n        nums2.Sort();\n        // create a min heap\n        MinHeap heap = new MinHeap();\n        // add the first pair to the heap\n        heap.Add(new Pair(nums1[0], nums2[0]));\n        // create a hash set to track the pairs that have been added to the heap\n        HashSet<string> set = new HashSet<string>();\n        set.Add(nums1[0] + \",\" + nums2[0]);\n        // loop through the heap\n        while (result.Count < k && heap.Count > 0) {\n            // get the pair with the smallest sum\n            Pair pair = heap.Remove();\n            // add the pair to the result\n            result.Add(new List<long> { pair.First, pair.Second });\n            // get the next pair with the first element from the first array\n            if (pair.FirstIndex < nums1.Count - 1) {\n                long first = nums1[pair.FirstIndex + 1];\n                long second = pair.Second;\n                string key = first + \",\" + second;\n                if (!set.Contains(key)) {\n                    heap.Add(new Pair(first, second));\n                    set.Add(key);\n                }\n            }\n            // get the next pair with the first element from the second array\n            if (pair.SecondIndex < nums2.Count - 1) {\n                long first = pair.First;\n                long second = nums2[pair.SecondIndex + 1];\n                string key = first + \",\" + second;\n                if (!set.Contains(key)) {\n                    heap.Add(new Pair(first, second));\n                    set.Add(key);\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        foreach (var num1 in nums1) {\n            foreach (var num2 in nums2) {\n                minHeap.Add(new List<long> { num1, num2 });\n            }\n        }\n        while (k > 0 && minHeap.Count > 0) {\n            result.Add(minHeap.Remove());\n            k--;\n        }\n        return result;",
    "        // Write your code here.\n        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new Pair(nums1[i], nums2[0], 0));\n        }\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            k--;\n            if (pair.SecondIndex < nums2.Count - 1) {\n                minHeap.Insert(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        long[,] matrix = new long[nums1.Count, nums2.Count];\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                matrix[i, j] = nums1[i] + nums2[j];\n            }\n        }\n        long[] rowMin = new long[nums1.Count];\n        long[] colMin = new long[nums2.Count];\n        for (int i = 0; i < nums1.Count; i++) {\n            rowMin[i] = long.MaxValue;\n            for (int j = 0; j < nums2.Count; j++) {\n                rowMin[i] = Math.Min(rowMin[i], matrix[i, j]);\n            }\n        }\n        for (int j = 0; j < nums2.Count; j++) {\n            colMin[j] = long.MaxValue;\n            for (int i = 0; i < nums1.Count; i++) {\n                colMin[j] = Math.Min(colMin[j], matrix[i, j]);\n            }\n        }\n        long[] minHeap = new long[nums1.Count + nums2.Count];\n        int minHeapSize = 0;\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap[minHeapSize++] = rowMin[i];\n        }\n        for (int j = 0; j < nums2.Count; j++) {\n            minHeap[minHeapSize++] = colMin[j];\n        }\n        BuildMinHeap(minHeap, minHeapSize);\n        while (k > 0) {\n            long min = ExtractMin(minHeap, ref minHeapSize);\n            int i = 0;\n            int j = 0;\n            for (i =",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        minHeap.Add(new Pair(nums1[0], nums2[0], 0, 0));\n        visited.Add(0 + \",\" + 0);\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.Remove();\n            result.Add(new List<long> { pair.First, pair.Second });\n            var i = pair.FirstIndex;\n            var j = pair.SecondIndex;\n            if (i + 1 < nums1.Count && !visited.Contains((i + 1) + \",\" + j)) {\n                minHeap.Add(new Pair(nums1[i + 1], nums2[j], i + 1, j));\n                visited.Add((i + 1) + \",\" + j);\n            }\n            if (j + 1 < nums2.Count && !visited.Contains(i + \",\" + (j + 1))) {\n                minHeap.Add(new Pair(nums1[i], nums2[j + 1], i, j + 1));\n                visited.Add(i + \",\" + (j + 1));\n            }\n            k--;\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<Tuple<long, long>> pairs = new List<Tuple<long, long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                pairs.Add(new Tuple<long, long>(nums1[i], nums2[j]));\n            }\n        }\n        pairs.Sort((x, y) => x.Item1 + x.Item2 - y.Item1 - y.Item2);\n        for (int i = 0; i < k && i < pairs.Count; i++) {\n            result.Add(new List<long>() { pairs[i].Item1, pairs[i].Item2 });\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the arrays.\n        nums1.Sort();\n        nums2.Sort();\n        // Create a priority queue.\n        PriorityQueue<List<long>> pq = new PriorityQueue<List<long>>();\n        // Add the first pair to the priority queue.\n        pq.Add(new List<long>() { nums1[0], nums2[0], 0, 0 });\n        // Keep track of the pairs we've seen.\n        HashSet<string> seen = new HashSet<string>();\n        seen.Add(nums1[0] + \",\" + nums2[0]);\n        // While we have not seen k pairs.\n        while (result.Count < k && pq.Count > 0) {\n            // Get the pair with the smallest sum.\n            List<long> pair = pq.Remove();\n            // Add the pair to the result.\n            result.Add(new List<long>() { pair[0], pair[1] });\n            // Get the indices of the pair.\n            long i = pair[2];\n            long j = pair[3];\n            // If we can add a pair with the next element in nums1.\n            if (i + 1 < nums1.Count) {\n                // Get the pair.\n                List<long> newPair = new List<long>() { nums1[i + 1], nums2[j], i + 1, j };\n                // If we have not seen this pair.\n                if (!seen.Contains(newPair[0] + \",\" + newPair[1])) {\n                    // Add the pair to the priority queue.\n                    pq.Add(newPair);\n                    // Add the pair to the seen set.\n                    seen.Add(newPair[0] + \",\" + newPair[1]);\n                }\n            }\n            // If we can add a pair with the next element in nums2.\n            if (j + 1 < nums2.Count)",
    "        var result = new List<List<long>>();\n        var heap = new Heap<Tuple<long, long, long>>(k, (a, b) => a.Item3.CompareTo(b.Item3));\n        foreach (var n1 in nums1) {\n            foreach (var n2 in nums2) {\n                heap.Add(new Tuple<long, long, long>(n1, n2, n1 + n2));\n            }\n        }\n        while (heap.Count > 0) {\n            var t = heap.Remove();\n            result.Add(new List<long> { t.Item1, t.Item2 });\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        int i = 0;\n        int j = 0;\n        while (k > 0) {\n            if (i >= nums1.Count) {\n                j++;\n            } else if (j >= nums2.Count) {\n                i++;\n            } else {\n                if (nums1[i] < nums2[j]) {\n                    i++;\n                } else {\n                    j++;\n                }\n            }\n            k--;\n        }\n        i--;\n        j--;\n        while (k < 0) {\n            if (i < 0) {\n                j--;\n            } else if (j < 0) {\n                i--;\n            } else {\n                if (nums1[i] > nums2[j]) {\n                    i--;\n                } else {\n                    j--;\n                }\n            }\n            k++;\n        }\n        i++;\n        j++;\n        while (i < nums1.Count && j < nums2.Count) {\n            result.Add(new List<long>() { nums1[i], nums2[j] });\n            if (i + 1 < nums1.Count && j + 1 < nums2.Count) {\n                if (nums1[i + 1] < nums2[j + 1]) {\n                    i++;\n                } else {\n                    j++;\n                }\n            } else if (i + 1 < nums1.Count) {\n                i++;\n            } else {\n                j++;\n            }\n        }\n        return result;",
    "        // Assume that nums1 and nums2 are sorted.\n        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        minHeap.Insert(new Pair(nums1[0], nums2[0]));\n        visited.Add(nums1[0] + \",\" + nums2[0]);\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long>() { pair.First, pair.Second });\n            if (visited.Add(pair.First + \",\" + (pair.Second + 1))) {\n                minHeap.Insert(new Pair(pair.First, pair.Second + 1));\n            }\n            if (visited.Add((pair.First + 1) + \",\" + pair.Second)) {\n                minHeap.Insert(new Pair(pair.First + 1, pair.Second));\n            }\n            k--;\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var heap = new Heap<long>(nums1.Count * nums2.Count);\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                heap.Insert(nums1[i] + nums2[j]);\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            var sum = heap.ExtractMin();\n            var pair = new List<long>();\n            for (int j = 0; j < nums1.Count; j++) {\n                for (int l = 0; l < nums2.Count; l++) {\n                    if (nums1[j] + nums2[l] == sum) {\n                        pair.Add(nums1[j]);\n                        pair.Add(nums2[l]);\n                        break;\n                    }\n                }\n                if (pair.Count > 0) {\n                    break;\n                }\n            }\n            result.Add(pair);\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new Pair(nums1[i], nums2[0], 0));\n        }\n        for (int i = 0; i < k && !minHeap.IsEmpty(); i++) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.SecondIndex < nums2.Count - 1) {\n                minHeap.Insert(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        var visited = new HashSet<long>();\n        minHeap.Add(new Pair(nums1[0], nums2[0], 0, 0));\n        visited.Add(0);\n        while (minHeap.Count > 0 && k > 0) {\n            var pair = minHeap.Remove();\n            result.Add(new List<long> { pair.First, pair.Second });\n            k--;\n            var nextFirst = pair.FirstIndex + 1;\n            var nextSecond = pair.SecondIndex + 1;\n            if (nextFirst < nums1.Count && !visited.Contains(nextFirst * nums2.Count + pair.SecondIndex)) {\n                minHeap.Add(new Pair(nums1[nextFirst], nums2[pair.SecondIndex], nextFirst, pair.SecondIndex));\n                visited.Add(nextFirst * nums2.Count + pair.SecondIndex);\n            }\n            if (nextSecond < nums2.Count && !visited.Contains(pair.FirstIndex * nums2.Count + nextSecond)) {\n                minHeap.Add(new Pair(nums1[pair.FirstIndex], nums2[nextSecond], pair.FirstIndex, nextSecond));\n                visited.Add(pair.FirstIndex * nums2.Count + nextSecond);\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new Pair(nums1[i], nums2[0], 0));\n        }\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.SecondIndex + 1 < nums2.Count) {\n                minHeap.Insert(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n            k--;\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<List<long>> pairs = new List<List<long>>();\n        for (long i = 0; i < nums1.Count; i++) {\n            for (long j = 0; j < nums2.Count; j++) {\n                pairs.Add(new List<long>() { nums1[(int)i], nums2[(int)j] });\n            }\n        }\n        pairs.Sort((a, b) => (int)(a[0] + a[1] - b[0] - b[1]));\n        for (long i = 0; i < k && i < pairs.Count; i++) {\n            result.Add(pairs[(int)i]);\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<List<long>> pairs = new List<List<long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                pairs.Add(new List<long>() { nums1[i], nums2[j] });\n            }\n        }\n        pairs.Sort((a, b) => (int)(a[0] + a[1] - b[0] - b[1]));\n        for (int i = 0; i < k && i < pairs.Count; i++) {\n            result.Add(pairs[i]);\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first array\n        nums1.Sort();\n        // Sort the second array\n        nums2.Sort();\n        // Create a min heap\n        MinHeap heap = new MinHeap();\n        // Add the first pair to the heap\n        heap.Add(new Pair(nums1[0], nums2[0]));\n        // Create a hash set to store the pairs that have already been added to the heap\n        HashSet<string> set = new HashSet<string>();\n        set.Add(nums1[0].ToString() + \",\" + nums2[0].ToString());\n        // While the heap is not empty and the number of pairs that have been added to the result is less than k\n        while (heap.Count > 0 && result.Count < k) {\n            // Remove the pair with the smallest sum from the heap\n            Pair pair = heap.Remove();\n            // Add the pair to the result\n            result.Add(new List<long> { pair.Num1, pair.Num2 });\n            // If the first number in the pair is not the last number in the first array\n            if (pair.Num1Index < nums1.Count - 1) {\n                // Create a new pair with the next number in the first array and the same number in the second array\n                Pair newPair = new Pair(nums1[pair.Num1Index + 1], pair.Num2);\n                // If the pair has not already been added to the heap\n                if (!set.Contains(newPair.Num1.ToString() + \",\" + newPair.Num2.ToString())) {\n                    // Add the pair to the heap\n                    heap.Add(newPair);\n                    // Add the pair to the hash set\n                    set.Add(newPair.Num1.ToString() + \",\" + newPair.Num2.ToString());\n                }\n            }\n            // If the second number in the pair is not the last number in the second array\n            if (",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<Tuple<long, long>>(k);\n        for (long i = 0; i < nums1.Count; i++) {\n            for (long j = 0; j < nums2.Count; j++) {\n                if (pq.Count < k) {\n                    pq.Push(new Tuple<long, long>(nums1[(int)i], nums2[(int)j]));\n                } else {\n                    var pair = pq.Peek();\n                    if (nums1[(int)i] + nums2[(int)j] < pair.Item1 + pair.Item2) {\n                        pq.Pop();\n                        pq.Push(new Tuple<long, long>(nums1[(int)i], nums2[(int)j]));\n                    }\n                }\n            }\n        }\n        while (pq.Count > 0) {\n            var pair = pq.Pop();\n            result.Add(new List<long> { pair.Item1, pair.Item2 });\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first array.\n        nums1.Sort();\n        // Sort the second array.\n        nums2.Sort();\n        // Create a priority queue to store the pairs.\n        PriorityQueue<List<long>> pq = new PriorityQueue<List<long>>();\n        // Add the first pair to the priority queue.\n        pq.Add(new List<long>() { nums1[0], nums2[0], 0, 0 });\n        // Keep track of the pairs we have seen.\n        HashSet<string> seen = new HashSet<string>();\n        seen.Add(nums1[0] + \",\" + nums2[0]);\n        // While we have not found k pairs and the priority queue is not empty.\n        while (result.Count < k && pq.Count > 0) {\n            // Get the pair with the smallest sum.\n            List<long> pair = pq.Remove();\n            // Add the pair to the result.\n            result.Add(new List<long>() { pair[0], pair[1] });\n            // Get the indices of the pair.\n            long i = pair[2];\n            long j = pair[3];\n            // If we can add a pair with the next element in the first array.\n            if (i + 1 < nums1.Count) {\n                // If we have not seen the pair before.\n                if (!seen.Contains(nums1[i + 1] + \",\" + nums2[j])) {\n                    // Add the pair to the priority queue.\n                    pq.Add(new List<long>() { nums1[i + 1], nums2[j], i + 1, j });\n                    // Add the pair to the seen set.\n                    seen.Add(nums1[i + 1] + \",\" + nums2[j]);\n                }\n            }\n            // If we can add a pair with the next element in the second array.\n            if (j + 1 < nums",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        minHeap.Push(new Tuple<long, long>(0, 0));\n        visited.Add(\"0,0\");\n        while (minHeap.Count > 0 && result.Count < k) {\n            var pair = minHeap.Pop();\n            result.Add(new List<long> { nums1[pair.Item1], nums2[pair.Item2] });\n            if (pair.Item1 + 1 < nums1.Count && !visited.Contains((pair.Item1 + 1) + \",\" + pair.Item2)) {\n                minHeap.Push(new Tuple<long, long>(pair.Item1 + 1, pair.Item2));\n                visited.Add((pair.Item1 + 1) + \",\" + pair.Item2);\n            }\n            if (pair.Item2 + 1 < nums2.Count && !visited.Contains(pair.Item1 + \",\" + (pair.Item2 + 1))) {\n                minHeap.Push(new Tuple<long, long>(pair.Item1, pair.Item2 + 1));\n                visited.Add(pair.Item1 + \",\" + (pair.Item2 + 1));\n            }\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        long[,] matrix = new long[nums1.Count, nums2.Count];\n        for (long i = 0; i < nums1.Count; i++) {\n            for (long j = 0; j < nums2.Count; j++) {\n                matrix[i, j] = nums1[(int)i] + nums2[(int)j];\n            }\n        }\n        List<long> sums = new List<long>();\n        for (long i = 0; i < nums1.Count; i++) {\n            for (long j = 0; j < nums2.Count; j++) {\n                sums.Add(matrix[i, j]);\n            }\n        }\n        sums.Sort();\n        for (long i = 0; i < k; i++) {\n            long sum = sums[(int)i];\n            for (long j = 0; j < nums1.Count; j++) {\n                for (long l = 0; l < nums2.Count; l++) {\n                    if (matrix[j, l] == sum) {\n                        List<long> pair = new List<long>();\n                        pair.Add(nums1[(int)j]);\n                        pair.Add(nums2[(int)l]);\n                        result.Add(pair);\n                        matrix[j, l] = -1;\n                        break;\n                    }\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap<long>();\n        for (long i = 0; i < nums1.Count; i++) {\n            for (long j = 0; j < nums2.Count; j++) {\n                minHeap.Insert(nums1[(int)i] + nums2[(int)j]);\n            }\n        }\n        for (long i = 0; i < k; i++) {\n            var sum = minHeap.ExtractMin();\n            var pair = new List<long>();\n            pair.Add(sum);\n            pair.Add(sum);\n            result.Add(pair);\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                if (minHeap.Count < k) {\n                    minHeap.Add(sum);\n                } else if (sum < minHeap.Peek()) {\n                    minHeap.Pop();\n                    minHeap.Add(sum);\n                }\n            }\n        }\n        while (minHeap.Count > 0) {\n            var sum = minHeap.Pop();\n            var pair = new List<long>();\n            for (int i = 0; i < nums1.Count; i++) {\n                for (int j = 0; j < nums2.Count; j++) {\n                    if (nums1[i] + nums2[j] == sum) {\n                        pair.Add(nums1[i]);\n                        pair.Add(nums2[j]);\n                        result.Add(pair);\n                        break;\n                    }\n                }\n            }\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        SortedSet<Tuple<long, int, int>> minHeap = new SortedSet<Tuple<long, int, int>>();\n        minHeap.Add(new Tuple<long, int, int>(nums1[0] + nums2[0], 0, 0));\n        HashSet<int> seen = new HashSet<int>();\n        seen.Add(0);\n        while (result.Count < k && minHeap.Count > 0) {\n            Tuple<long, int, int> current = minHeap.Min;\n            minHeap.Remove(current);\n            result.Add(new List<long>() { nums1[current.Item2], nums2[current.Item3] });\n            int newX = current.Item2;\n            int newY = current.Item3 + 1;\n            if (newY < nums2.Count && !seen.Contains(newX * nums2.Count + newY)) {\n                minHeap.Add(new Tuple<long, int, int>(nums1[newX] + nums2[newY], newX, newY));\n                seen.Add(newX * nums2.Count + newY);\n            }\n            newX = current.Item2 + 1;\n            newY = current.Item3;\n            if (newX < nums1.Count && !seen.Contains(newX * nums2.Count + newY)) {\n                minHeap.Add(new Tuple<long, int, int>(nums1[newX] + nums2[newY], newX, newY));\n                seen.Add(newX * nums2.Count + newY);\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Use a min heap to store the k smallest pairs.\n        // The heap will be sorted by the sum of the pair.\n        // The heap will have a maximum size of k.\n        // The heap will store the index of the pair in the nums1 and nums2 arrays.\n        // The heap will store the sum of the pair.\n        // The heap will store the pair.\n        MinHeap<long> heap = new MinHeap<long>();\n        // The first pair is the first element of nums1 and the first element of nums2.\n        heap.Insert(nums1[0] + nums2[0], 0, 0, new List<long>() { nums1[0], nums2[0] });\n        // The heap will store the index of the pair in the nums1 and nums2 arrays.\n        // The heap will store the sum of the pair.\n        // The heap will store the pair.\n        // The heap will store the index of the pair in the nums1 and nums2 arrays.\n        // The heap will store the sum of the pair.\n        // The heap will store the pair.\n        // The heap will store the index of the pair in the nums1 and nums2 arrays.\n        // The heap will store the sum of the pair.\n        // The heap will store the pair.\n        // The heap will store the index of the pair in the nums1 and nums2 arrays.\n        // The heap will store the sum of the pair.\n        // The heap will store the pair.\n        // The heap will store the index of the pair in the nums1 and nums2 arrays.\n        // The heap will store the sum of the pair.\n        // The heap will store the pair.\n        // The heap will store the index of the pair in the nums1 and nums2 arrays.\n        // The heap will store the sum of the pair.\n        // The heap will store the pair.\n        // The heap will store the index of the pair in the nums1",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0 || k == 0) {\n            return result;\n        }\n        int i = 0;\n        int j = 0;\n        while (k > 0) {\n            if (i == nums1.Count) {\n                j++;\n            } else if (j == nums2.Count) {\n                i++;\n            } else {\n                if (nums1[i] < nums2[j]) {\n                    i++;\n                } else {\n                    j++;\n                }\n            }\n            k--;\n        }\n        i--;\n        j--;\n        while (i >= 0 && j >= 0) {\n            result.Add(new List<long> { nums1[i], nums2[j] });\n            if (i == 0) {\n                j--;\n            } else if (j == 0) {\n                i--;\n            } else {\n                if (nums1[i - 1] < nums2[j - 1]) {\n                    i--;\n                } else {\n                    j--;\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<List<long>>(new List<long> { 0, 0 }, (a, b) => nums1[(int)a[0]] + nums2[(int)a[1]] < nums1[(int)b[0]] + nums2[(int)b[1]]);\n        while (k > 0 && pq.Count > 0) {\n            var pair = pq.Dequeue();\n            result.Add(new List<long> { nums1[(int)pair[0]], nums2[(int)pair[1]] });\n            if (pair[0] + 1 < nums1.Count) {\n                pq.Enqueue(new List<long> { pair[0] + 1, pair[1] });\n            }\n            if (pair[0] == 0 && pair[1] + 1 < nums2.Count) {\n                pq.Enqueue(new List<long> { pair[0], pair[1] + 1 });\n            }\n            k--;\n        }\n        return result;",
    "        // Fill this in.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) return result;\n        if (k == 0) return result;\n        if (k > nums1.Count * nums2.Count) k = nums1.Count * nums2.Count;\n        // Create a min heap\n        MinHeap heap = new MinHeap(k);\n        // Add the first k elements to the heap\n        for (int i = 0; i < k && i < nums1.Count; i++) {\n            heap.Add(new List<long> { nums1[i], nums2[0], 0 });\n        }\n        // Add the rest of the elements to the heap\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 1; j < nums2.Count; j++) {\n                heap.Add(new List<long> { nums1[i], nums2[j], 0 });\n            }\n        }\n        // Pop the first k elements from the heap\n        for (int i = 0; i < k; i++) {\n            result.Add(heap.Pop());\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first array.\n        nums1.Sort();\n        // Sort the second array.\n        nums2.Sort();\n        // Initialize the priority queue.\n        PriorityQueue<Tuple<long, long, long>> pq = new PriorityQueue<Tuple<long, long, long>>();\n        // Add the first pair to the priority queue.\n        pq.Add(new Tuple<long, long, long>(nums1[0] + nums2[0], 0, 0));\n        // Initialize the visited array.\n        bool[,] visited = new bool[nums1.Count, nums2.Count];\n        visited[0, 0] = true;\n        // While the priority queue is not empty and we still need to add more pairs.\n        while (pq.Count > 0 && k > 0) {\n            // Get the pair with the smallest sum.\n            Tuple<long, long, long> pair = pq.Pop();\n            // Add the pair to the result.\n            result.Add(new List<long>() { nums1[(int)pair.Item2], nums2[(int)pair.Item3] });\n            // Decrement k.\n            k--;\n            // If we can add the pair with the next element from the first array.\n            if (pair.Item2 + 1 < nums1.Count && !visited[(int)pair.Item2 + 1, (int)pair.Item3]) {\n                // Add the pair to the priority queue.\n                pq.Add(new Tuple<long, long, long>(nums1[(int)pair.Item2 + 1] + nums2[(int)pair.Item3], pair.Item2 + 1, pair.Item3));\n                // Mark the pair as visited.\n                visited[(int)pair.Item2 + 1, (int)pair.Item3] = true;\n            }\n            // If we can add the pair with the next element from the second array.",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // sort the first array\n        nums1.Sort();\n        // sort the second array\n        nums2.Sort();\n        // create a min heap of size k\n        MinHeap heap = new MinHeap(k);\n        // add the first pair to the min heap\n        heap.Add(new Pair(nums1[0], nums2[0]));\n        // create a hashset to keep track of the pairs that have been added to the min heap\n        HashSet<string> set = new HashSet<string>();\n        set.Add(nums1[0] + \",\" + nums2[0]);\n        // loop through the first array\n        for (int i = 0; i < nums1.Count; i++) {\n            // loop through the second array\n            for (int j = 0; j < nums2.Count; j++) {\n                // if the pair has already been added to the min heap, skip it\n                if (set.Contains(nums1[i] + \",\" + nums2[j])) {\n                    continue;\n                }\n                // add the pair to the min heap\n                heap.Add(new Pair(nums1[i], nums2[j]));\n                // add the pair to the hashset\n                set.Add(nums1[i] + \",\" + nums2[j]);\n            }\n        }\n        // loop through the min heap\n        for (int i = 0; i < k; i++) {\n            // get the pair from the min heap\n            Pair pair = heap.Get();\n            // if the pair is null, break out of the loop\n            if (pair == null) {\n                break;\n            }\n            // add the pair to the result\n            result.Add(new List<long>() { pair.num1, pair.num2 });\n        }\n        // return the result\n        return result;",
    "        // Write your code here.\n        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new Pair(nums1[i], nums2[0], 0));\n        }\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.SecondIndex + 1 < nums2.Count) {\n                minHeap.Insert(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n            k--;\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort nums1 and nums2\n        nums1.Sort();\n        nums2.Sort();\n        // Create a min heap of size k\n        MinHeap minHeap = new MinHeap(k);\n        // Add the first k pairs to the min heap\n        for (int i = 0; i < k && i < nums1.Count; i++) {\n            minHeap.Add(new List<long> { nums1[i], nums2[0], 0 });\n        }\n        // While the min heap is not empty\n        while (minHeap.Size() > 0) {\n            // Remove the top pair from the min heap\n            List<long> pair = minHeap.Remove();\n            // Add the pair to the result\n            result.Add(new List<long> { pair[0], pair[1] });\n            // If the pair's second element's index is less than the length of nums2 - 1\n            if (pair[2] < nums2.Count - 1) {\n                // Add the next pair to the min heap\n                minHeap.Add(new List<long> { pair[0], nums2[(int)pair[2] + 1], pair[2] + 1 });\n            }\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        long[,] matrix = new long[nums1.Count, nums2.Count];\n        for (long i = 0; i < nums1.Count; i++) {\n            for (long j = 0; j < nums2.Count; j++) {\n                matrix[i, j] = nums1[(int)i] + nums2[(int)j];\n            }\n        }\n        long[] min = new long[nums1.Count];\n        for (long i = 0; i < nums1.Count; i++) {\n            min[i] = matrix[i, 0];\n        }\n        for (long i = 0; i < k; i++) {\n            long minIndex = 0;\n            for (long j = 1; j < nums1.Count; j++) {\n                if (min[j] < min[minIndex]) {\n                    minIndex = j;\n                }\n            }\n            result.Add(new List<long>() { nums1[minIndex], nums2[0] });\n            min[minIndex] = long.MaxValue;\n            for (long j = 1; j < nums2.Count; j++) {\n                if (matrix[minIndex, j] < min[minIndex]) {\n                    min[minIndex] = matrix[minIndex, j];\n                }\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) return result;\n        // Sort the arrays\n        nums1.Sort();\n        nums2.Sort();\n        // Create a min heap\n        MinHeap heap = new MinHeap(k);\n        // Add the first k pairs to the heap\n        for (int i = 0; i < k && i < nums1.Count; i++) {\n            heap.Add(new List<long> { nums1[i], nums2[0], 0 });\n        }\n        // While the heap is not empty\n        while (heap.Count > 0) {\n            // Pop the top pair\n            List<long> pair = heap.Pop();\n            // Add the pair to the result\n            result.Add(new List<long> { pair[0], pair[1] });\n            // If the second element of the pair is not the last element of the second array\n            if (pair[2] < nums2.Count - 1) {\n                // Add the next pair to the heap\n                heap.Add(new List<long> { pair[0], nums2[(int)pair[2] + 1], pair[2] + 1 });\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<Tuple<long, long, long>>();\n        for (long i = 0; i < nums1.Count; i++) {\n            pq.Enqueue(new Tuple<long, long, long>(nums1[(int)i] + nums2[0], i, 0));\n        }\n        for (long i = 0; i < k && pq.Count > 0; i++) {\n            var t = pq.Dequeue();\n            result.Add(new List<long> { nums1[(int)t.Item2], nums2[(int)t.Item3] });\n            if (t.Item3 < nums2.Count - 1) {\n                pq.Enqueue(new Tuple<long, long, long>(nums1[(int)t.Item2] + nums2[(int)t.Item3 + 1], t.Item2, t.Item3 + 1));\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<List<long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                var pair = new List<long> { nums1[i], nums2[j] };\n                pq.Enqueue(pair, sum);\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            if (pq.Count == 0) {\n                break;\n            }\n            result.Add(pq.Dequeue());\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<List<long>> pairs = new List<List<long>>();\n        for (long i = 0; i < nums1.Count; i++) {\n            for (long j = 0; j < nums2.Count; j++) {\n                pairs.Add(new List<long>() { nums1[(int)i], nums2[(int)j] });\n            }\n        }\n        pairs.Sort((a, b) => (int)(a[0] + a[1] - b[0] - b[1]));\n        for (long i = 0; i < k && i < pairs.Count; i++) {\n            result.Add(pairs[(int)i]);\n        }\n        return result;",
    "        // Write your code here.\n        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        foreach (var num1 in nums1) {\n            foreach (var num2 in nums2) {\n                minHeap.Insert(new List<long> { num1, num2 });\n            }\n        }\n        while (k > 0 && minHeap.Count > 0) {\n            result.Add(minHeap.Remove());\n            k--;\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<Pair>();\n        var visited = new HashSet<Pair>();\n        var start = new Pair(0, 0, nums1[0] + nums2[0]);\n        pq.Enqueue(start);\n        visited.Add(start);\n        while (pq.Count > 0 && result.Count < k) {\n            var pair = pq.Dequeue();\n            result.Add(new List<long> { nums1[pair.i], nums2[pair.j] });\n            if (pair.i + 1 < nums1.Count) {\n                var newPair = new Pair(pair.i + 1, pair.j, nums1[pair.i + 1] + nums2[pair.j]);\n                if (!visited.Contains(newPair)) {\n                    pq.Enqueue(newPair);\n                    visited.Add(newPair);\n                }\n            }\n            if (pair.j + 1 < nums2.Count) {\n                var newPair = new Pair(pair.i, pair.j + 1, nums1[pair.i] + nums2[pair.j + 1]);\n                if (!visited.Contains(newPair)) {\n                    pq.Enqueue(newPair);\n                    visited.Add(newPair);\n                }\n            }\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0)\n            return result;\n        int[] index = new int[nums1.Count];\n        while (k > 0 && index[0] < nums2.Count) {\n            long min = long.MaxValue;\n            int minIndex = 0;\n            for (int i = 0; i < nums1.Count; i++) {\n                if (index[i] < nums2.Count && nums1[i] + nums2[index[i]] < min) {\n                    min = nums1[i] + nums2[index[i]];\n                    minIndex = i;\n                }\n            }\n            result.Add(new List<long>() { nums1[minIndex], nums2[index[minIndex]] });\n            index[minIndex]++;\n            k--;\n        }\n        return result;",
    "        // Write your code here.\n        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new List<long> { nums1[i], nums2[0], 0 });\n        }\n        while (k > 0 && minHeap.Count > 0) {\n            var current = minHeap.ExtractMin();\n            result.Add(new List<long> { current[0], current[1] });\n            var nextIndex = current[2] + 1;\n            if (nextIndex < nums2.Count) {\n                minHeap.Insert(new List<long> { current[0], nums2[nextIndex], nextIndex });\n            }\n            k--;\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first array.\n        nums1.Sort();\n        // Sort the second array.\n        nums2.Sort();\n        // Create a min heap.\n        MinHeap heap = new MinHeap();\n        // Add the first pair to the heap.\n        heap.Add(new Pair(nums1[0], nums2[0]));\n        // Create a set to store the pairs we have already seen.\n        HashSet<Pair> seen = new HashSet<Pair>();\n        // Add the first pair to the set.\n        seen.Add(new Pair(nums1[0], nums2[0]));\n        // While we still need to add more pairs to the result.\n        while (result.Count < k) {\n            // Get the smallest pair from the heap.\n            Pair pair = heap.GetMin();\n            // Add the pair to the result.\n            result.Add(new List<long>() { pair.num1, pair.num2 });\n            // Get the next pair from the first array.\n            Pair nextPair1 = new Pair(pair.num1, nums2[0]);\n            // If we have not seen the next pair from the first array.\n            if (!seen.Contains(nextPair1)) {\n                // Add the next pair from the first array to the heap.\n                heap.Add(nextPair1);\n                // Add the next pair from the first array to the set.\n                seen.Add(nextPair1);\n            }\n            // Get the next pair from the second array.\n            Pair nextPair2 = new Pair(nums1[0], pair.num2);\n            // If we have not seen the next pair from the second array.\n            if (!seen.Contains(nextPair2)) {\n                // Add the next pair from the second array to the heap.\n                heap.Add(nextPair2);\n                // Add the next pair from the second array to the set.\n                seen.Add(nextP",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap<Pair>();\n        var visited = new HashSet<Pair>();\n        var firstPair = new Pair(0, 0, nums1[0] + nums2[0]);\n        minHeap.Add(firstPair);\n        visited.Add(firstPair);\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.Remove();\n            result.Add(new List<long> { nums1[pair.i], nums2[pair.j] });\n            k--;\n            var newPair = new Pair(pair.i + 1, pair.j, nums1[pair.i + 1] + nums2[pair.j]);\n            if (pair.i + 1 < nums1.Count && !visited.Contains(newPair)) {\n                minHeap.Add(newPair);\n                visited.Add(newPair);\n            }\n            newPair = new Pair(pair.i, pair.j + 1, nums1[pair.i] + nums2[pair.j + 1]);\n            if (pair.j + 1 < nums2.Count && !visited.Contains(newPair)) {\n                minHeap.Add(newPair);\n                visited.Add(newPair);\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) return result;\n        // Sort the first array\n        nums1.Sort();\n        // Sort the second array\n        nums2.Sort();\n        // Create a min heap\n        MinHeap heap = new MinHeap();\n        // Add the first pair to the heap\n        heap.Add(new Pair(nums1[0], nums2[0]));\n        // Add the first pair to the result\n        result.Add(new List<long> { nums1[0], nums2[0] });\n        // Create a set to store the pairs we have already added to the heap\n        HashSet<string> set = new HashSet<string>();\n        set.Add(nums1[0] + \",\" + nums2[0]);\n        // While we have not added k pairs to the result\n        while (result.Count < k) {\n            // Get the smallest pair from the heap\n            Pair pair = heap.ExtractMin();\n            // Get the first element of the pair\n            long first = pair.First;\n            // Get the second element of the pair\n            long second = pair.Second;\n            // If the first element is not the last element in the first array\n            if (first != nums1[nums1.Count - 1]) {\n                // Get the index of the first element in the first array\n                int index = nums1.IndexOf(first);\n                // Get the next element in the first array\n                long next = nums1[index + 1];\n                // Create a new pair with the next element in the first array and the second element in the second array\n                Pair newPair = new Pair(next, second);\n                // If the new pair is not in the set\n                if (!set.Contains(next + \",\" + second)) {\n                    // Add the new pair to the heap\n                    heap.Add(newPair);\n                    // Add the new pair to the set\n                    set.Add(next + \",\" + second);\n                    // Add the new pair to the result\n                    result.Add(new List<long>",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        SortedDictionary<long, List<List<long>>> sorted = new SortedDictionary<long, List<List<long>>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                long sum = nums1[i] + nums2[j];\n                if (!sorted.ContainsKey(sum)) {\n                    sorted[sum] = new List<List<long>>();\n                }\n                sorted[sum].Add(new List<long>() { nums1[i], nums2[j] });\n            }\n        }\n        foreach (var item in sorted) {\n            foreach (var pair in item.Value) {\n                result.Add(pair);\n                if (result.Count == k) {\n                    return result;\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        minHeap.Insert(new Pair(nums1[0], nums2[0]));\n        visited.Add(nums1[0] + \",\" + nums2[0]);\n        while (result.Count < k && minHeap.Count > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long>() { pair.First, pair.Second });\n            if (pair.FirstIndex + 1 < nums1.Count) {\n                var newPair = new Pair(nums1[pair.FirstIndex + 1], pair.Second);\n                if (!visited.Contains(newPair.First + \",\" + newPair.Second)) {\n                    minHeap.Insert(newPair);\n                    visited.Add(newPair.First + \",\" + newPair.Second);\n                }\n            }\n            if (pair.SecondIndex + 1 < nums2.Count) {\n                var newPair = new Pair(pair.First, nums2[pair.SecondIndex + 1]);\n                if (!visited.Contains(newPair.First + \",\" + newPair.Second)) {\n                    minHeap.Insert(newPair);\n                    visited.Add(newPair.First + \",\" + newPair.Second);\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        minHeap.Add(new Pair(nums1[0], nums2[0], 0, 0));\n        visited.Add(0 + \",\" + 0);\n        while (result.Count < k && minHeap.Count > 0) {\n            var pair = minHeap.Remove();\n            result.Add(new List<long> { pair.Num1, pair.Num2 });\n            var i = pair.Index1;\n            var j = pair.Index2;\n            if (i + 1 < nums1.Count && !visited.Contains((i + 1) + \",\" + j)) {\n                minHeap.Add(new Pair(nums1[i + 1], nums2[j], i + 1, j));\n                visited.Add((i + 1) + \",\" + j);\n            }\n            if (j + 1 < nums2.Count && !visited.Contains(i + \",\" + (j + 1))) {\n                minHeap.Add(new Pair(nums1[i], nums2[j + 1], i, j + 1));\n                visited.Add(i + \",\" + (j + 1));\n            }\n        }\n        return result;",
    "        List<List<long>> res = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return res;\n        }\n        // Use a min heap to store the sum of each pair.\n        // The heap stores the index of the second array.\n        // The first element of the pair is the index of the first array.\n        // The second element of the pair is the index of the second array.\n        // The third element of the pair is the sum of the pair.\n        MinHeap heap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            heap.Insert(new List<long> {i, 0, nums1[i] + nums2[0]});\n        }\n        while (k > 0 && heap.Size() > 0) {\n            List<long> pair = heap.ExtractMin();\n            res.Add(new List<long> {nums1[(int)pair[0]], nums2[(int)pair[1]]});\n            if (pair[1] + 1 < nums2.Count) {\n                heap.Insert(new List<long> {pair[0], pair[1] + 1, nums1[(int)pair[0]] + nums2[(int)(pair[1] + 1)]});\n            }\n            k--;\n        }\n        return res;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<List<long>> pairs = new List<List<long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                List<long> pair = new List<long>();\n                pair.Add(nums1[i]);\n                pair.Add(nums2[j]);\n                pairs.Add(pair);\n            }\n        }\n        pairs = pairs.OrderBy(pair => pair[0] + pair[1]).ToList();\n        for (int i = 0; i < k && i < pairs.Count; i++) {\n            result.Add(pairs[i]);\n        }\n        return result;",
    "        // Write your code here.\n        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        foreach (var num1 in nums1) {\n            foreach (var num2 in nums2) {\n                var sum = num1 + num2;\n                minHeap.Insert(new List<long> { num1, num2 }, sum);\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            result.Add(minHeap.ExtractMin());\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first array in ascending order.\n        nums1.Sort();\n        // Sort the second array in descending order.\n        nums2.Sort();\n        nums2.Reverse();\n        // Create a min heap to store the pairs.\n        MinHeap<List<long>> minHeap = new MinHeap<List<long>>();\n        // Create a set to store the pairs.\n        HashSet<List<long>> set = new HashSet<List<long>>();\n        // Add the pair (nums1[0], nums2[0]) to the heap and set.\n        minHeap.Add(new List<long> { nums1[0], nums2[0] });\n        set.Add(new List<long> { nums1[0], nums2[0] });\n        // Add the pairs to the heap and set until the heap has k pairs.\n        while (minHeap.Count < k) {\n            // Get the pair with the smallest sum.\n            List<long> pair = minHeap.Remove();\n            // Add the pair (nums1[0], pair[1]) to the heap and set if it is not already in the set.\n            if (!set.Contains(new List<long> { nums1[0], pair[1] })) {\n                minHeap.Add(new List<long> { nums1[0], pair[1] });\n                set.Add(new List<long> { nums1[0], pair[1] });\n            }\n            // Add the pair (pair[0], nums2[0]) to the heap and set if it is not already in the set.\n            if (!set.Contains(new List<long> { pair[0], nums2[0] })) {\n                minHeap.Add(new List<long> { pair[0], nums2[0] });\n                set.Add(new List<long> { pair[0], nums2[0] });",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        long[] index = new long[nums1.Count];\n        while (k > 0) {\n            long min_val = long.MaxValue;\n            long min_index = -1;\n            for (long i = 0; i < nums1.Count; i++) {\n                if (index[i] >= nums2.Count) {\n                    continue;\n                }\n                if (nums1[i] + nums2[index[i]] < min_val) {\n                    min_val = nums1[i] + nums2[index[i]];\n                    min_index = i;\n                }\n            }\n            if (min_index == -1) {\n                break;\n            }\n            result.Add(new List<long>() { nums1[min_index], nums2[index[min_index]] });\n            index[min_index]++;\n            k--;\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Add(new Pair(nums1[i], nums2[0], 0));\n        }\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.Remove();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.Index + 1 < nums2.Count) {\n                minHeap.Add(new Pair(pair.First, nums2[(int)pair.Index + 1], pair.Index + 1));\n            }\n            k--;\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if(nums1.Count == 0 || nums2.Count == 0)\n            return result;\n        if(k > nums1.Count * nums2.Count)\n            k = nums1.Count * nums2.Count;\n        List<long> sums = new List<long>();\n        for(int i = 0; i < nums1.Count; i++)\n            for(int j = 0; j < nums2.Count; j++)\n                sums.Add(nums1[i] + nums2[j]);\n        sums.Sort();\n        for(int i = 0; i < k; i++)\n            for(int j = 0; j < nums1.Count; j++)\n                for(int l = 0; l < nums2.Count; l++)\n                    if(nums1[j] + nums2[l] == sums[i])\n                        result.Add(new List<long>{nums1[j], nums2[l]});\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0 || k == 0) {\n            return result;\n        }\n        // Sort the first array.\n        nums1.Sort();\n        // Sort the second array.\n        nums2.Sort();\n        // Create a min heap.\n        MinHeap heap = new MinHeap();\n        // Add the first pair to the heap.\n        heap.Add(new Pair(nums1[0], nums2[0], 0, 0));\n        // Add the pairs to the result.\n        while (k > 0 && heap.Count > 0) {\n            // Get the pair with the smallest sum.\n            Pair pair = heap.Pop();\n            // Add the pair to the result.\n            result.Add(new List<long>() { pair.First, pair.Second });\n            // Add the next pair from the first array.\n            if (pair.FirstIndex + 1 < nums1.Count) {\n                heap.Add(new Pair(nums1[pair.FirstIndex + 1], pair.Second, pair.FirstIndex + 1, pair.SecondIndex));\n            }\n            // Add the next pair from the second array.\n            if (pair.SecondIndex + 1 < nums2.Count && pair.FirstIndex == 0) {\n                heap.Add(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.FirstIndex, pair.SecondIndex + 1));\n            }\n            k--;\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<Tuple<long, long, long>>();\n        for (long i = 0; i < Math.Min(k, nums1.Count); i++) {\n            pq.Enqueue(new Tuple<long, long, long>(nums1[(int)i] + nums2[0], i, 0));\n        }\n        while (k > 0 && pq.Count > 0) {\n            var t = pq.Dequeue();\n            result.Add(new List<long> { nums1[(int)t.Item2], nums2[(int)t.Item3] });\n            if (t.Item3 < nums2.Count - 1) {\n                pq.Enqueue(new Tuple<long, long, long>(nums1[(int)t.Item2] + nums2[(int)t.Item3 + 1], t.Item2, t.Item3 + 1));\n            }\n            k--;\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        minHeap.Add(new Pair(nums1[0], nums2[0], 0, 0));\n        visited.Add(0 + \",\" + 0);\n        while (minHeap.Count > 0 && k > 0) {\n            var pair = minHeap.Remove();\n            result.Add(new List<long> { pair.Num1, pair.Num2 });\n            k--;\n            var i = pair.Index1;\n            var j = pair.Index2;\n            if (i + 1 < nums1.Count && !visited.Contains((i + 1) + \",\" + j)) {\n                minHeap.Add(new Pair(nums1[i + 1], nums2[j], i + 1, j));\n                visited.Add((i + 1) + \",\" + j);\n            }\n            if (j + 1 < nums2.Count && !visited.Contains(i + \",\" + (j + 1))) {\n                minHeap.Add(new Pair(nums1[i], nums2[j + 1], i, j + 1));\n                visited.Add(i + \",\" + (j + 1));\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first array.\n        nums1.Sort();\n        // Sort the second array.\n        nums2.Sort();\n        // Initialize the heap.\n        Heap<long> heap = new Heap<long>();\n        // Add the first pair to the heap.\n        heap.Add(nums1[0] + nums2[0], new List<long>() { nums1[0], nums2[0] });\n        // Initialize the set of visited pairs.\n        HashSet<string> visited = new HashSet<string>();\n        visited.Add(nums1[0].ToString() + \",\" + nums2[0].ToString());\n        // Add the first pair to the result.\n        result.Add(new List<long>() { nums1[0], nums2[0] });\n        // Iterate over the heap.\n        while (heap.Count > 0 && result.Count < k) {\n            // Get the current pair.\n            List<long> pair = heap.Pop();\n            // Add the current pair to the result.\n            result.Add(pair);\n            // Get the indices of the current pair.\n            long i = pair[0];\n            long j = pair[1];\n            // Check if the pair (i, j + 1) is valid.\n            if (j + 1 < nums2.Count && !visited.Contains(i.ToString() + \",\" + (j + 1).ToString())) {\n                // Add the pair (i, j + 1) to the heap.\n                heap.Add(i + nums2[(int)(j + 1)], new List<long>() { i, j + 1 });\n                // Add the pair (i, j + 1) to the set of visited pairs.\n                visited.Add(i.ToString() + \",\" + (j + 1).ToString());\n            }\n            // Check if the pair (i + 1, j) is valid.\n           ",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<List<long>>((a, b) => a[0] + a[1] - b[0] - b[1]);\n        for (int i = 0; i < nums1.Count; i++) {\n            pq.Add(new List<long> { nums1[i], nums2[0], 0 });\n        }\n        while (k > 0 && pq.Count > 0) {\n            var pair = pq.Remove();\n            result.Add(new List<long> { pair[0], pair[1] });\n            k--;\n            if (pair[2] < nums2.Count - 1) {\n                pq.Add(new List<long> { pair[0], nums2[(int)pair[2] + 1], pair[2] + 1 });\n            }\n        }\n        return result;",
    "        // Write your code here.\n        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (var i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new Pair(nums1[i], nums2[0], 0));\n        }\n        for (var i = 0; i < k && minHeap.Count > 0; i++) {\n            var pair = minHeap.Remove();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.SecondIndex < nums2.Count - 1) {\n                minHeap.Insert(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        SortedDictionary<long, List<List<long>>> dict = new SortedDictionary<long, List<List<long>>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                long sum = nums1[i] + nums2[j];\n                if (!dict.ContainsKey(sum)) {\n                    dict.Add(sum, new List<List<long>>());\n                }\n                dict[sum].Add(new List<long>() { nums1[i], nums2[j] });\n            }\n        }\n        foreach (long key in dict.Keys) {\n            foreach (List<long> pair in dict[key]) {\n                result.Add(pair);\n                k--;\n                if (k == 0) {\n                    return result;\n                }\n            }\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        if (k == 0) {\n            return result;\n        }\n        List<long> sums = new List<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                sums.Add(nums1[i] + nums2[j]);\n            }\n        }\n        sums.Sort();\n        long sum = sums[(int)k - 1];\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                if (nums1[i] + nums2[j] <= sum) {\n                    result.Add(new List<long> { nums1[i], nums2[j] });\n                }\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<List<long>> pairs = new List<List<long>>();\n        for (long i = 0; i < nums1.Count; i++) {\n            for (long j = 0; j < nums2.Count; j++) {\n                List<long> pair = new List<long>();\n                pair.Add(nums1[(int)i]);\n                pair.Add(nums2[(int)j]);\n                pairs.Add(pair);\n            }\n        }\n        pairs.Sort((a, b) => (int)(a[0] + a[1] - b[0] - b[1]));\n        for (long i = 0; i < k && i < pairs.Count; i++) {\n            result.Add(pairs[(int)i]);\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<List<long>>(new List<long> { nums1[0], nums2[0] }, (a, b) => a[0] + a[1] < b[0] + b[1]);\n        var visited = new HashSet<List<long>>();\n        visited.Add(new List<long> { 0, 0 });\n        while (result.Count < k && pq.Count > 0) {\n            var pair = pq.Dequeue();\n            result.Add(pair);\n            var i = pair[0];\n            var j = pair[1];\n            if (i + 1 < nums1.Count) {\n                var newPair = new List<long> { i + 1, j };\n                if (!visited.Contains(newPair)) {\n                    pq.Enqueue(newPair);\n                    visited.Add(newPair);\n                }\n            }\n            if (j + 1 < nums2.Count) {\n                var newPair = new List<long> { i, j + 1 };\n                if (!visited.Contains(newPair)) {\n                    pq.Enqueue(newPair);\n                    visited.Add(newPair);\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<List<long>>(new List<long> { nums1[0], nums2[0] }, (a, b) => a[0] + a[1] < b[0] + b[1]);\n        var visited = new HashSet<List<long>>();\n        visited.Add(new List<long> { 0, 0 });\n        while (result.Count < k && pq.Count > 0) {\n            var pair = pq.Dequeue();\n            result.Add(pair);\n            var i = pair[0];\n            var j = pair[1];\n            if (i + 1 < nums1.Count && !visited.Contains(new List<long> { i + 1, j })) {\n                pq.Enqueue(new List<long> { nums1[i + 1], nums2[j] });\n                visited.Add(new List<long> { i + 1, j });\n            }\n            if (j + 1 < nums2.Count && !visited.Contains(new List<long> { i, j + 1 })) {\n                pq.Enqueue(new List<long> { nums1[i], nums2[j + 1] });\n                visited.Add(new List<long> { i, j + 1 });\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Create a min heap of size k.\n        MinHeap heap = new MinHeap(k);\n        // Add the first k pairs to the heap.\n        for (long i = 0; i < Math.Min(k, nums1.Count); i++) {\n            heap.Add(new Pair(nums1[(int)i], nums2[0]));\n        }\n        // Add the remaining pairs to the heap.\n        for (long i = 1; i < nums2.Count; i++) {\n            for (long j = 0; j < Math.Min(k, nums1.Count); j++) {\n                Pair p = heap.Peek();\n                if (nums1[(int)j] + nums2[(int)i] < p.Sum) {\n                    heap.Remove();\n                    heap.Add(new Pair(nums1[(int)j], nums2[(int)i]));\n                }\n            }\n        }\n        // Convert the heap to a list.\n        while (heap.Count > 0) {\n            Pair p = heap.Remove();\n            result.Add(new List<long> { p.First, p.Second });\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) return result;\n        // Create a min heap of size k\n        MinHeap heap = new MinHeap(k);\n        // Add the first k pairs to the heap\n        for (int i = 0; i < k && i < nums1.Count; i++) {\n            heap.Add(new List<long>() { nums1[i], nums2[0], 0 });\n        }\n        // While the heap is not empty\n        while (heap.Count > 0) {\n            // Remove the top element from the heap\n            List<long> pair = heap.Remove();\n            // Add the pair to the result\n            result.Add(new List<long>() { pair[0], pair[1] });\n            // If the pair's second element's index is less than the length of nums2 - 1\n            if (pair[2] < nums2.Count - 1) {\n                // Add the next pair to the heap\n                heap.Add(new List<long>() { pair[0], nums2[(int)pair[2] + 1], pair[2] + 1 });\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<Tuple<long, long, long>>(k);\n        for (int i = 0; i < nums1.Count; i++) {\n            pq.Add(new Tuple<long, long, long>(nums1[i] + nums2[0], i, 0));\n        }\n        while (k-- > 0 && pq.Count > 0) {\n            var t = pq.Remove();\n            result.Add(new List<long> { nums1[(int)t.Item2], nums2[(int)t.Item3] });\n            if (t.Item3 == nums2.Count - 1) {\n                continue;\n            }\n            pq.Add(new Tuple<long, long, long>(nums1[(int)t.Item2] + nums2[(int)t.Item3 + 1], t.Item2, t.Item3 + 1));\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first array\n        nums1.Sort();\n        // Sort the second array\n        nums2.Sort();\n        // Create a priority queue to store the pairs\n        PriorityQueue<List<long>> pq = new PriorityQueue<List<long>>();\n        // Add the first pair to the priority queue\n        pq.Add(new List<long>() { nums1[0], nums2[0], 0, 0 });\n        // Add the first pair to the result\n        result.Add(new List<long>() { nums1[0], nums2[0] });\n        // Add the rest of the pairs to the priority queue\n        for (long i = 0; i < k - 1; i++) {\n            // Get the pair with the smallest sum\n            List<long> pair = pq.Remove();\n            // Get the indices of the elements in the pair\n            long firstIndex = pair[2];\n            long secondIndex = pair[3];\n            // If the first element in the pair is the last element in the first array\n            if (firstIndex == nums1.Count - 1) {\n                // Add the pair with the second element incremented by one to the priority queue\n                pq.Add(new List<long>() { nums1[firstIndex], nums2[secondIndex + 1], firstIndex, secondIndex + 1 });\n                // Add the pair with the second element incremented by one to the result\n                result.Add(new List<long>() { nums1[firstIndex], nums2[secondIndex + 1] });\n            }\n            // If the second element in the pair is the last element in the second array\n            else if (secondIndex == nums2.Count - 1) {\n                // Add the pair with the first element incremented by one to the priority queue\n                pq.Add(new List<long>() { nums1[firstIndex + 1], nums2[secondIndex], firstIndex + 1, secondIndex });\n                // Add the pair with the first",
    "        // Write your code here.\n        var result = new List<List<long>>();\n        var pq = new PriorityQueue<List<long>>();\n        pq.Enqueue(new List<long> { nums1[0], nums2[0], 0, 0 });\n        var visited = new HashSet<string>();\n        visited.Add(\"0,0\");\n        while (pq.Count > 0 && k > 0) {\n            var curr = pq.Dequeue();\n            result.Add(new List<long> { curr[0], curr[1] });\n            k--;\n            var i = curr[2];\n            var j = curr[3];\n            if (i + 1 < nums1.Count && !visited.Contains($\"{i+1},{j}\")) {\n                pq.Enqueue(new List<long> { nums1[i + 1], nums2[j], i + 1, j });\n                visited.Add($\"{i+1},{j}\");\n            }\n            if (j + 1 < nums2.Count && !visited.Contains($\"{i},{j+1}\")) {\n                pq.Enqueue(new List<long> { nums1[i], nums2[j + 1], i, j + 1 });\n                visited.Add($\"{i},{j+1}\");\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0 || k == 0) {\n            return result;\n        }\n        // Sort the first array.\n        nums1.Sort();\n        // Sort the second array.\n        nums2.Sort();\n        // Create a min heap.\n        MinHeap heap = new MinHeap();\n        // Add the first pair to the heap.\n        heap.Add(new Pair(nums1[0], nums2[0]));\n        // Add the first pair to the result.\n        result.Add(new List<long> { nums1[0], nums2[0] });\n        // Create a hash set to store the pairs that have been added to the heap.\n        HashSet<Pair> set = new HashSet<Pair>();\n        set.Add(new Pair(nums1[0], nums2[0]));\n        // Add the next k - 1 pairs to the heap.\n        for (long i = 0; i < k - 1; i++) {\n            // Get the smallest pair from the heap.\n            Pair pair = heap.GetMin();\n            // Add the smallest pair to the result.\n            result.Add(new List<long> { pair.First, pair.Second });\n            // Add the next pair to the heap.\n            if (pair.FirstIndex + 1 < nums1.Count && !set.Contains(new Pair(nums1[(int)pair.FirstIndex + 1], pair.Second))) {\n                heap.Add(new Pair(nums1[(int)pair.FirstIndex + 1], pair.Second, pair.FirstIndex + 1));\n                set.Add(new Pair(nums1[(int)pair.FirstIndex + 1], pair.Second));\n            }\n            // Add the next pair to the heap.\n            if (pair.SecondIndex + 1 < nums2.Count && !set.Contains(new Pair(pair.First, nums2[(int)pair.SecondIndex + 1]))) {\n                heap.Add(new Pair(pair.First, nums2[(int)",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0 || k == 0) {\n            return result;\n        }\n        // Sort the first array.\n        nums1.Sort();\n        // Sort the second array.\n        nums2.Sort();\n        // Initialize the heap.\n        Heap<List<long>> heap = new Heap<List<long>>(nums1.Count * nums2.Count);\n        // Add the first element to the heap.\n        heap.Add(new List<long>() { nums1[0], nums2[0], 0, 0 });\n        // Add the first element to the result.\n        result.Add(new List<long>() { nums1[0], nums2[0] });\n        // Add the remaining elements to the heap and result.\n        for (int i = 1; i < k; i++) {\n            // Get the next element.\n            List<long> next = heap.Remove();\n            // Add the next element to the result.\n            result.Add(new List<long>() { next[0], next[1] });\n            // Add the next element's children to the heap.\n            if (next[2] < nums1.Count - 1) {\n                heap.Add(new List<long>() { nums1[(int)next[2] + 1], next[1], next[2] + 1, next[3] });\n            }\n            if (next[3] < nums2.Count - 1) {\n                heap.Add(new List<long>() { next[0], nums2[(int)next[3] + 1], next[2], next[3] + 1 });\n            }\n        }\n        return result;",
    "        // Write your code here\n        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        minHeap.Insert(new Pair(nums1[0], nums2[0], 0, 0));\n        visited.Add(0 + \",\" + 0);\n        while (k > 0 && minHeap.Size > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            var i = pair.FirstIndex;\n            var j = pair.SecondIndex;\n            if (i + 1 < nums1.Count && !visited.Contains((i + 1) + \",\" + j)) {\n                minHeap.Insert(new Pair(nums1[i + 1], nums2[j], i + 1, j));\n                visited.Add((i + 1) + \",\" + j);\n            }\n            if (j + 1 < nums2.Count && !visited.Contains(i + \",\" + (j + 1))) {\n                minHeap.Insert(new Pair(nums1[i], nums2[j + 1], i, j + 1));\n                visited.Add(i + \",\" + (j + 1));\n            }\n            k--;\n        }\n        return result;",
    "        // Write your code here.\n        var result = new List<List<long>>();\n        var heap = new Heap<List<long>>(new List<long>[] { nums1, nums2 }, (a, b) => a[0] + a[1] - b[0] - b[1]);\n        while (k-- > 0 && heap.Count > 0) {\n            var pair = heap.Remove();\n            result.Add(pair);\n            if (pair[0] == nums1[0] && pair[1] < nums2[nums2.Count - 1]) {\n                heap.Add(new List<long>() { nums1[0], pair[1] + 1 });\n            }\n            if (pair[0] < nums1[nums1.Count - 1]) {\n                heap.Add(new List<long>() { pair[0] + 1, pair[1] });\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<Tuple<long, long, long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            pq.Enqueue(new Tuple<long, long, long>(nums1[i] + nums2[0], i, 0));\n        }\n        while (k > 0 && pq.Count > 0) {\n            var t = pq.Dequeue();\n            result.Add(new List<long> { nums1[t.Item2], nums2[t.Item3] });\n            if (t.Item3 + 1 < nums2.Count) {\n                pq.Enqueue(new Tuple<long, long, long>(nums1[t.Item2] + nums2[t.Item3 + 1], t.Item2, t.Item3 + 1));\n            }\n            k--;\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) return result;\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        minHeap.Add(new Pair(0, 0, nums1[0] + nums2[0]));\n        visited.Add(0 + \",\" + 0);\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.Remove();\n            result.Add(new List<long> { nums1[pair.I], nums2[pair.J] });\n            k--;\n            if (pair.I + 1 < nums1.Count && !visited.Contains((pair.I + 1) + \",\" + pair.J)) {\n                minHeap.Add(new Pair(pair.I + 1, pair.J, nums1[pair.I + 1] + nums2[pair.J]));\n                visited.Add((pair.I + 1) + \",\" + pair.J);\n            }\n            if (pair.J + 1 < nums2.Count && !visited.Contains(pair.I + \",\" + (pair.J + 1))) {\n                minHeap.Add(new Pair(pair.I, pair.J + 1, nums1[pair.I] + nums2[pair.J + 1]));\n                visited.Add(pair.I + \",\" + (pair.J + 1));\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        minHeap.Add(new Pair(nums1[0], nums2[0], 0, 0));\n        visited.Add(0 + \",\" + 0);\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.Pop();\n            result.Add(new List<long>() { pair.First, pair.Second });\n            k--;\n            var first = pair.FirstIndex;\n            var second = pair.SecondIndex;\n            if (first + 1 < nums1.Count && !visited.Contains((first + 1) + \",\" + second)) {\n                minHeap.Add(new Pair(nums1[first + 1], nums2[second], first + 1, second));\n                visited.Add((first + 1) + \",\" + second);\n            }\n            if (second + 1 < nums2.Count && !visited.Contains(first + \",\" + (second + 1))) {\n                minHeap.Add(new Pair(nums1[first], nums2[second + 1], first, second + 1));\n                visited.Add(first + \",\" + (second + 1));\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) return result;\n        List<List<long>> heap = new List<List<long>>();\n        for (long i = 0; i < nums1.Count; i++) {\n            heap.Add(new List<long> { nums1[(int)i], nums2[0], 0 });\n        }\n        Heapify(heap);\n        while (k > 0 && heap.Count > 0) {\n            List<long> pair = heap[0];\n            result.Add(new List<long> { pair[0], pair[1] });\n            long index = pair[2];\n            if (index + 1 < nums2.Count) {\n                heap[0] = new List<long> { pair[0], nums2[(int)index + 1], index + 1 };\n            } else {\n                heap[0] = heap[heap.Count - 1];\n                heap.RemoveAt(heap.Count - 1);\n            }\n            Heapify(heap);\n            k--;\n        }\n        return result;",
    "        // Write your code here.\n        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (var i = 0; i < nums1.Count; i++) {\n            for (var j = 0; j < nums2.Count; j++) {\n                minHeap.Insert(new List<long> { nums1[i], nums2[j] });\n            }\n        }\n        for (var i = 0; i < k; i++) {\n            result.Add(minHeap.Remove());\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<long> sums = new List<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                sums.Add(nums1[i] + nums2[j]);\n            }\n        }\n        sums.Sort();\n        for (int i = 0; i < k; i++) {\n            result.Add(new List<long>());\n            result[i].Add(sums[i]);\n            result[i].Add(sums[i] - nums1[0]);\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var heap = new Heap<Tuple<long, long, long>>(false);\n        for (long i = 0; i < nums1.Count; i++) {\n            for (long j = 0; j < nums2.Count; j++) {\n                heap.Add(new Tuple<long, long, long>(nums1[(int)i] + nums2[(int)j], i, j));\n            }\n        }\n        for (long i = 0; i < k; i++) {\n            var item = heap.Pop();\n            if (item == null) {\n                break;\n            }\n            result.Add(new List<long> { nums1[(int)item.Item2], nums2[(int)item.Item3] });\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<long> sums = new List<long>();\n        for (long i = 0; i < nums1.Count; i++) {\n            for (long j = 0; j < nums2.Count; j++) {\n                sums.Add(nums1[(int)i] + nums2[(int)j]);\n            }\n        }\n        sums.Sort();\n        for (long i = 0; i < k; i++) {\n            for (long j = 0; j < nums1.Count; j++) {\n                for (long l = 0; l < nums2.Count; l++) {\n                    if (nums1[(int)j] + nums2[(int)l] == sums[(int)i]) {\n                        List<long> pair = new List<long>();\n                        pair.Add(nums1[(int)j]);\n                        pair.Add(nums2[(int)l]);\n                        result.Add(pair);\n                        nums2[(int)l] = long.MaxValue;\n                        break;\n                    }\n                }\n            }\n        }\n        return result;",
    "        // Assume that nums1 and nums2 are sorted.\n        var result = new List<List<long>>();\n        var heap = new Heap<List<long>>(k);\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var pair = new List<long> { nums1[i], nums2[j] };\n                heap.Add(pair);\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            result.Add(heap.Pop());\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Create a min heap of size k.\n        MinHeap heap = new MinHeap(k);\n        // Add first k pairs to the heap.\n        for (int i = 0; i < Math.Min(nums1.Count, k); i++) {\n            heap.Add(new Pair(nums1[i], nums2[0], 0));\n        }\n        // Add the rest of the pairs to the heap.\n        for (int i = 1; i < nums2.Count; i++) {\n            for (int j = 0; j < Math.Min(nums1.Count, k); j++) {\n                heap.Add(new Pair(nums1[j], nums2[i], i));\n            }\n        }\n        // Pop the pairs from the heap.\n        while (heap.Size > 0) {\n            Pair pair = heap.Pop();\n            result.Add(new List<long>() { pair.First, pair.Second });\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<List<long>>((a, b) => a[0] + a[1] > b[0] + b[1]);\n        for (int i = 0; i < nums1.Count; i++) {\n            pq.Enqueue(new List<long>() { nums1[i], nums2[0], 0 });\n        }\n        while (k > 0 && pq.Count > 0) {\n            var pair = pq.Dequeue();\n            result.Add(new List<long>() { pair[0], pair[1] });\n            k--;\n            if (pair[2] < nums2.Count - 1) {\n                pq.Enqueue(new List<long>() { pair[0], nums2[(int)pair[2] + 1], pair[2] + 1 });\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Add(new Pair(nums1[i], nums2[0], 0));\n        }\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.Pop();\n            result.Add(new List<long> { pair.Num1, pair.Num2 });\n            if (pair.Index2 + 1 < nums2.Count) {\n                minHeap.Add(new Pair(pair.Num1, nums2[(int)pair.Index2 + 1], pair.Index2 + 1));\n            }\n            k--;\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<long> sums = new List<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                sums.Add(nums1[i] + nums2[j]);\n            }\n        }\n        sums.Sort();\n        for (int i = 0; i < k && i < sums.Count; i++) {\n            result.Add(new List<long> { sums[i] });\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        // TODO: Write your code here\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first array.\n        nums1.Sort();\n        // Sort the second array.\n        nums2.Sort();\n        // Create a min heap.\n        Heap<long> heap = new Heap<long>(nums1.Count * nums2.Count);\n        // Add all the pairs to the heap.\n        for (long i = 0; i < nums1.Count; i++) {\n            for (long j = 0; j < nums2.Count; j++) {\n                heap.Add(nums1[(int)i] + nums2[(int)j]);\n            }\n        }\n        // Get the k smallest pairs.\n        for (long i = 0; i < k; i++) {\n            result.Add(new List<long>() { heap.GetMin(), heap.GetMin() });\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var pq = new PriorityQueue<Tuple<long, long, long>>(k);\n        foreach (var n1 in nums1) {\n            foreach (var n2 in nums2) {\n                pq.Enqueue(new Tuple<long, long, long>(n1, n2, n1 + n2));\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            var t = pq.Dequeue();\n            result.Add(new List<long>() { t.Item1, t.Item2 });\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        SortedDictionary<long, List<List<long>>> dict = new SortedDictionary<long, List<List<long>>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                long sum = nums1[i] + nums2[j];\n                if (!dict.ContainsKey(sum)) {\n                    dict.Add(sum, new List<List<long>>());\n                }\n                dict[sum].Add(new List<long> { nums1[i], nums2[j] });\n            }\n        }\n        foreach (long key in dict.Keys) {\n            foreach (List<long> pair in dict[key]) {\n                result.Add(pair);\n                k--;\n                if (k == 0) {\n                    return result;\n                }\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Create a min heap to store the pairs.\n        MinHeap<List<long>> minHeap = new MinHeap<List<long>>();\n        // Create a hashset to store the visited pairs.\n        HashSet<string> visited = new HashSet<string>();\n        // Create a list to store the first pair.\n        List<long> firstPair = new List<long>();\n        firstPair.Add(nums1[0]);\n        firstPair.Add(nums2[0]);\n        // Add the first pair to the min heap.\n        minHeap.Add(firstPair);\n        // Add the first pair to the hashset.\n        visited.Add(nums1[0].ToString() + \",\" + nums2[0].ToString());\n        // While the min heap is not empty and the result size is less than k.\n        while (minHeap.Count > 0 && result.Count < k) {\n            // Pop the top pair from the min heap.\n            List<long> pair = minHeap.Pop();\n            // Add the pair to the result.\n            result.Add(pair);\n            // Get the first number of the pair.\n            long firstNumber = pair[0];\n            // Get the second number of the pair.\n            long secondNumber = pair[1];\n            // If the first number is less than the last number of nums1.\n            if (firstNumber < nums1[nums1.Count - 1]) {\n                // Create a new pair.\n                List<long> newPair = new List<long>();\n                // Add the first number to the new pair.\n                newPair.Add(firstNumber);\n                // Add the next number of the second number to the new pair.\n                newPair.Add(secondNumber + 1);\n                // If the new pair is not visited.\n                if (!visited.Contains(firstNumber.ToString() + \",\" + (secondNumber + 1).ToString())) {",
    "        var result = new List<List<long>>();\n        var heap = new Heap<long>((a, b) => a.Item1 + a.Item2 < b.Item1 + b.Item2);\n        foreach (var n1 in nums1) {\n            foreach (var n2 in nums2) {\n                heap.Push(new Tuple<long, long>(n1, n2));\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            var t = heap.Pop();\n            result.Add(new List<long>() { t.Item1, t.Item2 });\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap<Tuple<long, long, long>>(k);\n        var visited = new HashSet<Tuple<long, long>>();\n        minHeap.Add(new Tuple<long, long, long>(nums1[0] + nums2[0], 0, 0));\n        visited.Add(new Tuple<long, long>(0, 0));\n        while (minHeap.Count > 0 && result.Count < k) {\n            var current = minHeap.ExtractMin();\n            result.Add(new List<long> { nums1[(int)current.Item2], nums2[(int)current.Item3] });\n            if (current.Item2 + 1 < nums1.Count && !visited.Contains(new Tuple<long, long>(current.Item2 + 1, current.Item3))) {\n                minHeap.Add(new Tuple<long, long, long>(nums1[(int)current.Item2 + 1] + nums2[(int)current.Item3], current.Item2 + 1, current.Item3));\n                visited.Add(new Tuple<long, long>(current.Item2 + 1, current.Item3));\n            }\n            if (current.Item3 + 1 < nums2.Count && !visited.Contains(new Tuple<long, long>(current.Item2, current.Item3 + 1))) {\n                minHeap.Add(new Tuple<long, long, long>(nums1[(int)current.Item2] + nums2[(int)current.Item3 + 1], current.Item2, current.Item3 + 1));\n                visited.Add(new Tuple<long, long>(current.Item2, current.Item3 + 1));\n            }\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<List<long>> pairs = new List<List<long>>();\n        for (long i = 0; i < nums1.Count; i++) {\n            for (long j = 0; j < nums2.Count; j++) {\n                List<long> pair = new List<long>();\n                pair.Add(nums1[(int)i]);\n                pair.Add(nums2[(int)j]);\n                pairs.Add(pair);\n            }\n        }\n        pairs.Sort((a, b) => {\n            if (a[0] + a[1] < b[0] + b[1]) {\n                return -1;\n            } else if (a[0] + a[1] > b[0] + b[1]) {\n                return 1;\n            } else {\n                return 0;\n            }\n        });\n        for (long i = 0; i < k && i < pairs.Count; i++) {\n            result.Add(pairs[(int)i]);\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first array and the second array.\n        nums1.Sort();\n        nums2.Sort();\n        // Initialize the heap.\n        Heap<Pair> heap = new Heap<Pair>();\n        // Add the first pair to the heap.\n        heap.Add(new Pair(nums1[0], nums2[0]));\n        // Add the first pair to the result.\n        result.Add(new List<long> { nums1[0], nums2[0] });\n        // Initialize the set to store the pairs we have already added to the heap.\n        HashSet<Pair> set = new HashSet<Pair>();\n        set.Add(new Pair(nums1[0], nums2[0]));\n        // Loop until we have added k pairs to the result.\n        while (result.Count < k) {\n            // Get the pair with the smallest sum from the heap.\n            Pair pair = heap.Pop();\n            // Get the indices of the elements of the pair.\n            int i = nums1.IndexOf(pair.First);\n            int j = nums2.IndexOf(pair.Second);\n            // If the first element of the pair is not the last element of the first array, add the pair with the first element increased by one to the heap.\n            if (i < nums1.Count - 1) {\n                Pair newPair = new Pair(nums1[i + 1], nums2[j]);\n                if (!set.Contains(newPair)) {\n                    heap.Add(newPair);\n                    set.Add(newPair);\n                }\n            }\n            // If the second element of the pair is not the last element of the second array, add the pair with the second element increased by one to the heap.\n            if (j < nums2.Count - 1) {\n                Pair newPair = new Pair(nums1[i], nums2[j + 1]);\n                if (!",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<Tuple<long, long, long>>(k);\n        for (long i = 0; i < nums1.Count; i++) {\n            for (long j = 0; j < nums2.Count; j++) {\n                var sum = nums1[(int)i] + nums2[(int)j];\n                if (pq.Count < k) {\n                    pq.Add(new Tuple<long, long, long>(i, j, sum));\n                } else if (sum < pq.Peek().Item3) {\n                    pq.Pop();\n                    pq.Add(new Tuple<long, long, long>(i, j, sum));\n                }\n            }\n        }\n        while (pq.Count > 0) {\n            var item = pq.Pop();\n            result.Add(new List<long>() { nums1[(int)item.Item1], nums2[(int)item.Item2] });\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<long> sums = new List<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                sums.Add(nums1[i] + nums2[j]);\n            }\n        }\n        sums.Sort();\n        for (int i = 0; i < k; i++) {\n            if (i >= sums.Count) {\n                break;\n            }\n            long sum = sums[i];\n            for (int j = 0; j < nums1.Count; j++) {\n                for (int l = 0; l < nums2.Count; l++) {\n                    if (nums1[j] + nums2[l] == sum) {\n                        result.Add(new List<long> { nums1[j], nums2[l] });\n                    }\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) return result;\n        var pq = new PriorityQueue<long, List<long>>(k);\n        for (int i = 0; i < nums1.Count; i++) {\n            pq.Enqueue(nums1[i] + nums2[0], new List<long> { nums1[i], nums2[0] });\n        }\n        while (k > 0 && pq.Count > 0) {\n            var pair = pq.Dequeue();\n            result.Add(pair.Value);\n            var last = pair.Value.Last();\n            var index = nums2.IndexOf(last);\n            if (index + 1 < nums2.Count) {\n                pq.Enqueue(pair.Value[0] + nums2[index + 1], new List<long> { pair.Value[0], nums2[index + 1] });\n            }\n            k--;\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        minHeap.Add(new Pair(nums1[0], nums2[0]));\n        var visited = new HashSet<Pair>();\n        visited.Add(new Pair(nums1[0], nums2[0]));\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.Pop();\n            result.Add(new List<long> { pair.First, pair.Second });\n            k--;\n            var first = pair.First;\n            var second = pair.Second;\n            if (nums1.Count > 1) {\n                var newPair = new Pair(nums1[1], second);\n                if (!visited.Contains(newPair)) {\n                    minHeap.Add(newPair);\n                    visited.Add(newPair);\n                }\n            }\n            if (nums2.Count > 1) {\n                var newPair = new Pair(first, nums2[1]);\n                if (!visited.Contains(newPair)) {\n                    minHeap.Add(newPair);\n                    visited.Add(newPair);\n                }\n            }\n        }\n        return result;",
    "        // Assume that nums1 and nums2 are sorted in ascending order.\n        var result = new List<List<long>>();\n        var pq = new PriorityQueue<List<long>>(new List<long> { 0, 0 }, (a, b) => nums1[(int)a[0]] + nums2[(int)a[1]] - nums1[(int)b[0]] - nums2[(int)b[1]]);\n        while (pq.Count > 0 && k > 0) {\n            var pair = pq.Pop();\n            result.Add(new List<long> { nums1[(int)pair[0]], nums2[(int)pair[1]] });\n            if (pair[0] + 1 < nums1.Count) {\n                pq.Push(new List<long> { pair[0] + 1, pair[1] });\n            }\n            if (pair[0] == 0 && pair[1] + 1 < nums2.Count) {\n                pq.Push(new List<long> { pair[0], pair[1] + 1 });\n            }\n            k--;\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // sort the first array\n        nums1.Sort();\n        // sort the second array\n        nums2.Sort();\n        // create a min heap\n        Heap minHeap = new Heap(k);\n        // add the first k elements to the heap\n        for (int i = 0; i < k && i < nums1.Count; i++) {\n            minHeap.Add(new List<long>() { nums1[i], nums2[0], 0 });\n        }\n        // loop through the heap\n        while (minHeap.Count > 0) {\n            // get the min element\n            List<long> minElement = minHeap.RemoveMin();\n            // add the min element to the result\n            result.Add(new List<long>() { minElement[0], minElement[1] });\n            // if the index is less than the size of the second array\n            if (minElement[2] < nums2.Count - 1) {\n                // add the next element to the heap\n                minHeap.Add(new List<long>() { minElement[0], nums2[(int)minElement[2] + 1], minElement[2] + 1 });\n            }\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        long[,] sums = new long[nums1.Count, nums2.Count];\n        for (long i = 0; i < nums1.Count; i++) {\n            for (long j = 0; j < nums2.Count; j++) {\n                sums[i, j] = nums1[(int)i] + nums2[(int)j];\n            }\n        }\n        long[] min = new long[k];\n        long[] minIndex = new long[k];\n        for (long i = 0; i < k; i++) {\n            min[i] = long.MaxValue;\n            minIndex[i] = -1;\n        }\n        for (long i = 0; i < nums1.Count; i++) {\n            for (long j = 0; j < nums2.Count; j++) {\n                long sum = sums[i, j];\n                if (sum < min[k - 1]) {\n                    min[k - 1] = sum;\n                    minIndex[k - 1] = i * nums2.Count + j;\n                    for (long l = k - 1; l > 0; l--) {\n                        if (min[l] < min[l - 1]) {\n                            long temp = min[l];\n                            min[l] = min[l - 1];\n                            min[l - 1] = temp;\n                            long tempIndex = minIndex[l];\n                            minIndex[l] = minIndex[l - 1];\n                            minIndex[l - 1] = tempIndex;\n                        }\n                    }\n                }\n            }\n        }\n        for (long i = 0; i < k; i++) {\n            if (minIndex[i] == -1) {\n                break;\n            }\n            long index = minIndex[i];\n            long num1Index = index / nums2.Count;\n            long num2Index = index % num",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new Pair(nums1[i], nums2[0], 0));\n        }\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            k--;\n            if (pair.SecondIndex < nums2.Count - 1) {\n                minHeap.Insert(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) return result;\n        // Sort the first array.\n        nums1.Sort();\n        // Sort the second array.\n        nums2.Sort();\n        // Create a min heap of size k.\n        MinHeap heap = new MinHeap(k);\n        // For each element in the first array.\n        for (int i = 0; i < nums1.Count; i++) {\n            // For each element in the second array.\n            for (int j = 0; j < nums2.Count; j++) {\n                // Add the pair to the heap.\n                heap.Add(new List<long>() { nums1[i], nums2[j] });\n            }\n        }\n        // Return the heap.\n        return heap.GetHeap();",
    "        var res = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return res;\n        }\n        var pq = new PriorityQueue<List<long>>(k);\n        for (var i = 0; i < nums1.Count; i++) {\n            for (var j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                if (pq.Count < k) {\n                    pq.Enqueue(new List<long>() { nums1[i], nums2[j] });\n                } else {\n                    if (sum < pq.Peek()[0] + pq.Peek()[1]) {\n                        pq.Dequeue();\n                        pq.Enqueue(new List<long>() { nums1[i], nums2[j] });\n                    }\n                }\n            }\n        }\n        while (pq.Count > 0) {\n            res.Add(pq.Dequeue());\n        }\n        return res;",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap<Tuple<long, long, long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                minHeap.Insert(new Tuple<long, long, long>(nums1[i] + nums2[j], nums1[i], nums2[j]));\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            var pair = minHeap.ExtractMin();\n            if (pair == null) {\n                break;\n            }\n            result.Add(new List<long> { pair.Item2, pair.Item3 });\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // create a min heap\n        MinHeap<Tuple<long, long, long>> minHeap = new MinHeap<Tuple<long, long, long>>();\n        // add the first pair to the heap\n        minHeap.Add(new Tuple<long, long, long>(nums1[0] + nums2[0], 0, 0));\n        // create a set to keep track of the pairs we've already added to the heap\n        HashSet<Tuple<long, long>> set = new HashSet<Tuple<long, long>>();\n        set.Add(new Tuple<long, long>(0, 0));\n        // loop through the heap\n        while (result.Count < k && minHeap.Count > 0) {\n            // get the top element\n            Tuple<long, long, long> top = minHeap.Pop();\n            // add the pair to the result\n            result.Add(new List<long> { nums1[top.Item2], nums2[top.Item3] });\n            // add the next pair from the first array\n            if (top.Item2 + 1 < nums1.Count) {\n                Tuple<long, long> next = new Tuple<long, long>(top.Item2 + 1, top.Item3);\n                if (!set.Contains(next)) {\n                    minHeap.Add(new Tuple<long, long, long>(nums1[next.Item1] + nums2[next.Item2], next.Item1, next.Item2));\n                    set.Add(next);\n                }\n            }\n            // add the next pair from the second array\n            if (top.Item3 + 1 < nums2.Count) {\n                Tuple<long, long> next = new Tuple<long, long>(top.Item2, top.Item3 + 1);\n                if (!set.Contains(next)) {\n                    minHeap.Add(new Tuple<long, long, long>(n",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var queue = new SortedSet<Tuple<long, long, long>>();\n        for (long i = 0; i < Math.Min(k, nums1.Count); i++) {\n            queue.Add(new Tuple<long, long, long>(nums1[(int)i] + nums2[0], i, 0));\n        }\n        while (result.Count < k && queue.Count > 0) {\n            var current = queue.Min;\n            queue.Remove(current);\n            result.Add(new List<long> { nums1[(int)current.Item2], nums2[(int)current.Item3] });\n            if (current.Item3 + 1 < nums2.Count) {\n                queue.Add(new Tuple<long, long, long>(nums1[(int)current.Item2] + nums2[(int)current.Item3 + 1], current.Item2, current.Item3 + 1));\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first array.\n        nums1.Sort();\n        // Sort the second array.\n        nums2.Sort();\n        // Create a min heap of size k.\n        MinHeap minHeap = new MinHeap(k);\n        // Add the first pair to the heap.\n        minHeap.Add(new Pair(nums1[0], nums2[0]));\n        // Create a set to keep track of the pairs we have already visited.\n        HashSet<Pair> visited = new HashSet<Pair>();\n        visited.Add(new Pair(nums1[0], nums2[0]));\n        // While the heap is not empty.\n        while (minHeap.Count > 0) {\n            // Remove the min pair from the heap.\n            Pair minPair = minHeap.RemoveMin();\n            // Add the pair to the result.\n            result.Add(new List<long>() { minPair.First, minPair.Second });\n            // If the result has k pairs, return the result.\n            if (result.Count == k) {\n                return result;\n            }\n            // Add the next pair from the first array to the heap if it has not been visited.\n            Pair nextPair1 = new Pair(minPair.First + 1, minPair.Second);\n            if (visited.Contains(nextPair1) == false) {\n                minHeap.Add(nextPair1);\n                visited.Add(nextPair1);\n            }\n            // Add the next pair from the second array to the heap if it has not been visited.\n            Pair nextPair2 = new Pair(minPair.First, minPair.Second + 1);\n            if (visited.Contains(nextPair2) == false) {\n                minHeap.Add(nextPair2);\n                visited.Add(nextPair2);\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0 || k == 0) {\n            return result;\n        }\n        // Create a min heap with the first element from each array.\n        MinHeap heap = new MinHeap(nums1[0] + nums2[0]);\n        // Add the first element from each array to the heap.\n        heap.Add(new List<long> { nums1[0], nums2[0] });\n        // Add the first element from each array to the result.\n        result.Add(new List<long> { nums1[0], nums2[0] });\n        // Create a dictionary to keep track of the pairs that have been added to the heap.\n        Dictionary<string, bool> dict = new Dictionary<string, bool>();\n        dict.Add(nums1[0] + \",\" + nums2[0], true);\n        // While the heap is not empty and the result size is less than k.\n        while (heap.Size() > 0 && result.Count < k) {\n            // Get the top element from the heap.\n            List<long> top = heap.Remove();\n            // Get the first element from the top element.\n            long num1 = top[0];\n            // Get the second element from the top element.\n            long num2 = top[1];\n            // If the first element is less than the last element in the first array.\n            if (num1 < nums1[nums1.Count - 1]) {\n                // Add the first element and the last element in the second array to the heap.\n                heap.Add(new List<long> { num1, nums2[nums2.Count - 1] });\n                // Add the first element and the last element in the second array to the dictionary.\n                dict.Add(num1 + \",\" + nums2[nums2.Count - 1], true);\n            }\n            // If the second element is less than the last element in the second array.\n            if (num2 < nums2[nums2.Count - 1]) {\n                // Add the last",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0 || k == 0) {\n            return result;\n        }\n        // Create a min heap of size k.\n        MinHeap heap = new MinHeap(k);\n        // Add the first k pairs to the heap.\n        for (int i = 0; i < k && i < nums1.Count; i++) {\n            heap.Add(new List<long> { nums1[i], nums2[0], 0 });\n        }\n        // Add the rest of the pairs to the heap.\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 1; j < nums2.Count; j++) {\n                heap.Add(new List<long> { nums1[i], nums2[j], j });\n            }\n        }\n        // Get the k smallest pairs from the heap.\n        for (int i = 0; i < k && i < heap.Size; i++) {\n            result.Add(heap.ExtractMin());\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        SortedDictionary<long, List<List<long>>> sumToPairs = new SortedDictionary<long, List<List<long>>>();\n        foreach (long num1 in nums1) {\n            foreach (long num2 in nums2) {\n                long sum = num1 + num2;\n                if (!sumToPairs.ContainsKey(sum)) {\n                    sumToPairs[sum] = new List<List<long>>();\n                }\n                sumToPairs[sum].Add(new List<long> { num1, num2 });\n            }\n        }\n        foreach (long sum in sumToPairs.Keys) {\n            foreach (List<long> pair in sumToPairs[sum]) {\n                result.Add(pair);\n                if (result.Count == k) {\n                    return result;\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var heap = new Heap<long>();\n        var visited = new HashSet<long>();\n        foreach (var n1 in nums1) {\n            foreach (var n2 in nums2) {\n                var sum = n1 + n2;\n                if (visited.Contains(sum)) continue;\n                visited.Add(sum);\n                heap.Insert(sum);\n            }\n        }\n        for (var i = 0; i < k; i++) {\n            var sum = heap.ExtractMin();\n            var n1 = sum / 2;\n            var n2 = sum - n1;\n            result.Add(new List<long> {n1, n2});\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<List<long>>(k);\n        for (var i = 0; i < nums1.Count; i++) {\n            for (var j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                var pair = new List<long> { nums1[i], nums2[j] };\n                if (pq.Count < k) {\n                    pq.Add(pair, sum);\n                } else {\n                    if (pq.PeekPriority() > sum) {\n                        pq.Pop();\n                        pq.Add(pair, sum);\n                    }\n                }\n            }\n        }\n        while (pq.Count > 0) {\n            result.Add(pq.Pop());\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                if (minHeap.Count < k) {\n                    minHeap.Add(new Pair(nums1[i], nums2[j], sum));\n                } else if (sum < minHeap.Peek().Sum) {\n                    minHeap.Pop();\n                    minHeap.Add(new Pair(nums1[i], nums2[j], sum));\n                }\n            }\n        }\n        while (minHeap.Count > 0) {\n            var pair = minHeap.Pop();\n            result.Add(new List<long> { pair.First, pair.Second });\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> kSmallestPairs = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return kSmallestPairs;\n        }\n        List<List<long>> pairs = new List<List<long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                pairs.Add(new List<long>() { nums1[i], nums2[j] });\n            }\n        }\n        pairs.Sort((a, b) => (int)(a[0] + a[1] - b[0] - b[1]));\n        for (int i = 0; i < k && i < pairs.Count; i++) {\n            kSmallestPairs.Add(pairs[i]);\n        }\n        return kSmallestPairs;",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                minHeap.Add(sum);\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            var sum = minHeap.ExtractMin();\n            var pair = new List<long>();\n            pair.Add(sum);\n            pair.Add(sum);\n            result.Add(pair);\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        SortedDictionary<long, List<List<long>>> sums = new SortedDictionary<long, List<List<long>>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                long sum = nums1[i] + nums2[j];\n                List<long> pair = new List<long> { nums1[i], nums2[j] };\n                if (sums.ContainsKey(sum)) {\n                    sums[sum].Add(pair);\n                } else {\n                    sums.Add(sum, new List<List<long>> { pair });\n                }\n            }\n        }\n        foreach (long key in sums.Keys) {\n            foreach (List<long> pair in sums[key]) {\n                result.Add(pair);\n                if (result.Count == k) {\n                    return result;\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) return result;\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        minHeap.Insert(new Pair(nums1[0], nums2[0], 0, 0));\n        visited.Add(0 + \",\" + 0);\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.FirstIndex + 1 < nums1.Count && !visited.Contains((pair.FirstIndex + 1) + \",\" + pair.SecondIndex)) {\n                minHeap.Insert(new Pair(nums1[pair.FirstIndex + 1], nums2[pair.SecondIndex], pair.FirstIndex + 1, pair.SecondIndex));\n                visited.Add((pair.FirstIndex + 1) + \",\" + pair.SecondIndex);\n            }\n            if (pair.SecondIndex + 1 < nums2.Count && !visited.Contains(pair.FirstIndex + \",\" + (pair.SecondIndex + 1))) {\n                minHeap.Insert(new Pair(nums1[pair.FirstIndex], nums2[pair.SecondIndex + 1], pair.FirstIndex, pair.SecondIndex + 1));\n                visited.Add(pair.FirstIndex + \",\" + (pair.SecondIndex + 1));\n            }\n            k--;\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<List<long>>(k);\n        for (var i = 0; i < nums1.Count; i++) {\n            for (var j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                if (pq.Count < k) {\n                    pq.Enqueue(new List<long> { nums1[i], nums2[j] });\n                } else if (sum < pq.Peek()[0] + pq.Peek()[1]) {\n                    pq.Dequeue();\n                    pq.Enqueue(new List<long> { nums1[i], nums2[j] });\n                }\n            }\n        }\n        while (pq.Count > 0) {\n            result.Add(pq.Dequeue());\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<Tuple<long, long, long>>(k);\n        for (long i = 0; i < nums1.Count; i++) {\n            pq.Enqueue(new Tuple<long, long, long>(nums1[(int)i] + nums2[0], i, 0));\n        }\n        while (k > 0 && pq.Count > 0) {\n            var tuple = pq.Dequeue();\n            result.Add(new List<long> { nums1[(int)tuple.Item2], nums2[(int)tuple.Item3] });\n            k--;\n            if (tuple.Item3 < nums2.Count - 1) {\n                pq.Enqueue(new Tuple<long, long, long>(nums1[(int)tuple.Item2] + nums2[(int)tuple.Item3 + 1], tuple.Item2, tuple.Item3 + 1));\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Add(new Pair(nums1[i], nums2[0], 0));\n        }\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.Pop();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.SecondIndex < nums2.Count - 1) {\n                minHeap.Add(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n            k--;\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first array.\n        nums1.Sort();\n        // Sort the second array.\n        nums2.Sort();\n        // Create a min heap.\n        MinHeap heap = new MinHeap();\n        // Add the first pair to the heap.\n        heap.Add(new Pair(nums1[0], nums2[0]));\n        // Create a hashset to keep track of the pairs we have already added to the heap.\n        HashSet<string> set = new HashSet<string>();\n        set.Add(nums1[0].ToString() + \",\" + nums2[0].ToString());\n        // While the heap is not empty and we have not added k pairs to the result.\n        while (heap.Count > 0 && result.Count < k) {\n            // Pop the pair with the smallest sum.\n            Pair pair = heap.Pop();\n            // Add the pair to the result.\n            result.Add(new List<long> { pair.First, pair.Second });\n            // If the first element of the pair is not the last element of the first array.\n            if (pair.FirstIndex < nums1.Count - 1) {\n                // Create a new pair with the next element of the first array and the same element of the second array.\n                Pair newPair = new Pair(nums1[pair.FirstIndex + 1], pair.Second);\n                // If we have not added this pair to the heap yet.\n                if (!set.Contains(newPair.First.ToString() + \",\" + newPair.Second.ToString())) {\n                    // Add the pair to the heap.\n                    heap.Add(newPair);\n                    // Add the pair to the hashset.\n                    set.Add(newPair.First.ToString() + \",\" + newPair.Second.ToString());\n                }\n            }\n            // If the second element of the pair is not the last element of the second array.\n            if (pair.Second",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap<long>(k);\n        for (var i = 0; i < nums1.Count; i++) {\n            for (var j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                if (minHeap.Count < k) {\n                    minHeap.Add(sum);\n                } else if (minHeap.Peek() > sum) {\n                    minHeap.Remove();\n                    minHeap.Add(sum);\n                }\n            }\n        }\n        while (minHeap.Count > 0) {\n            result.Add(new List<long> { minHeap.Remove(), minHeap.Remove() });\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var heap = new Heap<List<long>>(nums1.Count * nums2.Count);\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var pair = new List<long> { nums1[i], nums2[j] };\n                heap.Insert(pair);\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            result.Add(heap.ExtractMin());\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        minHeap.Insert(new Pair(nums1[0], nums2[0], 0, 0));\n        visited.Add(0 + \",\" + 0);\n        while (minHeap.Count > 0 && k > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.Num1, pair.Num2 });\n            k--;\n            if (pair.Index1 + 1 < nums1.Count && !visited.Contains((pair.Index1 + 1) + \",\" + pair.Index2)) {\n                minHeap.Insert(new Pair(nums1[pair.Index1 + 1], nums2[pair.Index2], pair.Index1 + 1, pair.Index2));\n                visited.Add((pair.Index1 + 1) + \",\" + pair.Index2);\n            }\n            if (pair.Index2 + 1 < nums2.Count && !visited.Contains(pair.Index1 + \",\" + (pair.Index2 + 1))) {\n                minHeap.Insert(new Pair(nums1[pair.Index1], nums2[pair.Index2 + 1], pair.Index1, pair.Index2 + 1));\n                visited.Add(pair.Index1 + \",\" + (pair.Index2 + 1));\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) return result;\n        var heap = new Heap<List<long>>(k);\n        var visited = new HashSet<List<long>>();\n        var first = new List<long>() { nums1[0], nums2[0] };\n        heap.Insert(first);\n        visited.Add(first);\n        while (heap.Count > 0 && result.Count < k) {\n            var pair = heap.Extract();\n            result.Add(pair);\n            var x = pair[0];\n            var y = pair[1];\n            if (x < nums1[nums1.Count - 1]) {\n                var next = new List<long>() { x + 1, y };\n                if (!visited.Contains(next)) {\n                    heap.Insert(next);\n                    visited.Add(next);\n                }\n            }\n            if (y < nums2[nums2.Count - 1]) {\n                var next = new List<long>() { x, y + 1 };\n                if (!visited.Contains(next)) {\n                    heap.Insert(next);\n                    visited.Add(next);\n                }\n            }\n        }\n        return result;",
    "        // Write your code here.\n        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                if (minHeap.Count < k) {\n                    minHeap.Insert(new List<long> { nums1[i], nums2[j] });\n                } else if (sum < minHeap.Peek()[0] + minHeap.Peek()[1]) {\n                    minHeap.Remove();\n                    minHeap.Insert(new List<long> { nums1[i], nums2[j] });\n                }\n            }\n        }\n        while (minHeap.Count > 0) {\n            result.Add(minHeap.Remove());\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        minHeap.Push(new Pair(nums1[0], nums2[0], 0, 0));\n        visited.Add(0 + \",\" + 0);\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.Pop();\n            result.Add(new List<long> { pair.Num1, pair.Num2 });\n            k--;\n            if (pair.Index1 + 1 < nums1.Count && !visited.Contains((pair.Index1 + 1) + \",\" + pair.Index2)) {\n                minHeap.Push(new Pair(nums1[pair.Index1 + 1], nums2[pair.Index2], pair.Index1 + 1, pair.Index2));\n                visited.Add((pair.Index1 + 1) + \",\" + pair.Index2);\n            }\n            if (pair.Index2 + 1 < nums2.Count && !visited.Contains(pair.Index1 + \",\" + (pair.Index2 + 1))) {\n                minHeap.Push(new Pair(nums1[pair.Index1], nums2[pair.Index2 + 1], pair.Index1, pair.Index2 + 1));\n                visited.Add(pair.Index1 + \",\" + (pair.Index2 + 1));\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<List<long>>(k);\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                if (pq.Count < k) {\n                    pq.Enqueue(new List<long> { nums1[i], nums2[j] });\n                } else {\n                    if (sum < pq.Peek()[0] + pq.Peek()[1]) {\n                        pq.Dequeue();\n                        pq.Enqueue(new List<long> { nums1[i], nums2[j] });\n                    }\n                }\n            }\n        }\n        while (pq.Count > 0) {\n            result.Add(pq.Dequeue());\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var heap = new Heap<List<long>>(k);\n        var visited = new HashSet<long>();\n        foreach (var n1 in nums1) {\n            foreach (var n2 in nums2) {\n                var hash = n1 * n2;\n                if (visited.Contains(hash)) continue;\n                visited.Add(hash);\n                var pair = new List<long> { n1, n2 };\n                heap.Insert(pair);\n            }\n        }\n        while (heap.Count > 0) {\n            result.Add(heap.Extract());\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                minHeap.Insert(new List<long>() { nums1[i], nums2[j] });\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            result.Add(minHeap.ExtractMin());\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        minHeap.Insert(new Pair(nums1[0], nums2[0], 0, 0));\n        visited.Add(0 + \",\" + 0);\n        while (result.Count < k && minHeap.Count > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            var i = pair.FirstIndex;\n            var j = pair.SecondIndex;\n            if (i + 1 < nums1.Count && !visited.Contains((i + 1) + \",\" + j)) {\n                minHeap.Insert(new Pair(nums1[i + 1], nums2[j], i + 1, j));\n                visited.Add((i + 1) + \",\" + j);\n            }\n            if (j + 1 < nums2.Count && !visited.Contains(i + \",\" + (j + 1))) {\n                minHeap.Insert(new Pair(nums1[i], nums2[j + 1], i, j + 1));\n                visited.Add(i + \",\" + (j + 1));\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var heap = new Heap<List<long>>(k);\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                if (heap.Count < k) {\n                    heap.Add(new List<long> { nums1[i], nums2[j] });\n                } else if (sum < heap.Peek()[0] + heap.Peek()[1]) {\n                    heap.Pop();\n                    heap.Add(new List<long> { nums1[i], nums2[j] });\n                }\n            }\n        }\n        while (heap.Count > 0) {\n            result.Add(heap.Pop());\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first array\n        nums1.Sort();\n        // Sort the second array\n        nums2.Sort();\n        // Create a min heap\n        MinHeap heap = new MinHeap();\n        // Add the first element of the first array and the first element of the second array to the heap\n        heap.Add(new Pair(nums1[0], nums2[0]));\n        // Create a hash set to store the pairs already added to the heap\n        HashSet<Pair> set = new HashSet<Pair>();\n        set.Add(new Pair(nums1[0], nums2[0]));\n        // While the heap is not empty and the size of the result is less than k\n        while (heap.Count > 0 && result.Count < k) {\n            // Get the pair with the smallest sum\n            Pair pair = heap.Remove();\n            // Add the pair to the result\n            result.Add(new List<long> { pair.First, pair.Second });\n            // Get the index of the first element of the pair in the first array\n            int index1 = nums1.IndexOf(pair.First);\n            // Get the index of the second element of the pair in the second array\n            int index2 = nums2.IndexOf(pair.Second);\n            // If the index of the first element of the pair in the first array is less than the size of the first array minus one\n            if (index1 < nums1.Count - 1) {\n                // Create a new pair with the first element of the pair in the first array and the first element of the second array\n                Pair newPair1 = new Pair(nums1[index1 + 1], nums2[0]);\n                // If the new pair is not in the hash set\n                if (!set.Contains(newPair1)) {\n                    // Add the new pair to the heap\n                    heap.Add(newPair1);\n                    // Add the new pair to the hash set\n                    set.Add(new",
    "        var result = new List<List<long>>();\n        if (k == 0) {\n            return result;\n        }\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap<Pair>();\n        var visited = new HashSet<Pair>();\n        var start = new Pair(0, 0, nums1[0] + nums2[0]);\n        minHeap.Insert(start);\n        visited.Add(start);\n        while (result.Count < k && minHeap.Count > 0) {\n            var min = minHeap.ExtractMin();\n            result.Add(new List<long> { nums1[min.i], nums2[min.j] });\n            if (min.i + 1 < nums1.Count) {\n                var newPair = new Pair(min.i + 1, min.j, nums1[min.i + 1] + nums2[min.j]);\n                if (!visited.Contains(newPair)) {\n                    minHeap.Insert(newPair);\n                    visited.Add(newPair);\n                }\n            }\n            if (min.j + 1 < nums2.Count) {\n                var newPair = new Pair(min.i, min.j + 1, nums1[min.i] + nums2[min.j + 1]);\n                if (!visited.Contains(newPair)) {\n                    minHeap.Insert(newPair);\n                    visited.Add(newPair);\n                }\n            }\n        }\n        return result;",
    "        // Create a min heap of size k.\n        var minHeap = new MinHeap<List<long>>(k);\n        // Iterate through the first array.\n        foreach (var num1 in nums1) {\n            // Iterate through the second array.\n            foreach (var num2 in nums2) {\n                // Create a new pair.\n                var pair = new List<long> { num1, num2 };\n                // If the heap is not full, add the pair to the heap.\n                if (minHeap.Count < k) {\n                    minHeap.Add(pair);\n                }\n                // If the heap is full and the pair is smaller than the top of the heap, remove the top of the heap and add the pair.\n                else if (pair.Sum() < minHeap.Peek().Sum()) {\n                    minHeap.Remove();\n                    minHeap.Add(pair);\n                }\n            }\n        }\n        // Return the heap.\n        return minHeap.ToList();",
    "        // Fill this in.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) return result;\n        if (k == 0) return result;\n        List<long> sums = new List<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                sums.Add(nums1[i] + nums2[j]);\n            }\n        }\n        sums.Sort();\n        long min = sums[0];\n        long max = sums[sums.Count - 1];\n        long mid = 0;\n        while (min < max) {\n            mid = (min + max) / 2;\n            int count = 0;\n            for (int i = 0; i < sums.Count; i++) {\n                if (sums[i] <= mid) count++;\n            }\n            if (count < k) min = mid + 1;\n            else max = mid;\n        }\n        long target = min;\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                if (nums1[i] + nums2[j] <= target) {\n                    List<long> pair = new List<long>();\n                    pair.Add(nums1[i]);\n                    pair.Add(nums2[j]);\n                    result.Add(pair);\n                }\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first array\n        nums1.Sort();\n        // Sort the second array\n        nums2.Sort();\n        // Create a list of pairs\n        List<List<long>> pairs = new List<List<long>>();\n        // Create a list of indices\n        List<long> indices = new List<long>();\n        for (long i = 0; i < nums1.Count; i++) {\n            indices.Add(0);\n        }\n        // Create a list of sums\n        List<long> sums = new List<long>();\n        for (long i = 0; i < nums1.Count; i++) {\n            sums.Add(nums1[(int)i] + nums2[0]);\n        }\n        // Create a list of pairs\n        for (long i = 0; i < nums1.Count; i++) {\n            List<long> pair = new List<long>();\n            pair.Add(nums1[(int)i]);\n            pair.Add(nums2[0]);\n            pairs.Add(pair);\n        }\n        // Create a list of sums\n        List<long> sortedSums = new List<long>(sums);\n        sortedSums.Sort();\n        // Find the k smallest pairs\n        for (long i = 0; i < k; i++) {\n            // Find the minimum sum\n            long minSum = sortedSums[0];\n            // Find the index of the minimum sum\n            long minSumIndex = sums.IndexOf(minSum);\n            // Add the pair to the result\n            result.Add(pairs[(int)minSumIndex]);\n            // Increment the index\n            indices[(int)minSumIndex]++;\n            // If the index is out of bounds, set the sum to infinity\n            if (indices[(int)minSumIndex] >= nums2.Count) {\n                sums[(int)minSumIndex] = long.MaxValue;\n            } else {\n                //",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap<long>();\n        foreach (var num1 in nums1) {\n            foreach (var num2 in nums2) {\n                minHeap.Insert(num1 + num2);\n            }\n        }\n        for (var i = 0; i < k; i++) {\n            var num = minHeap.ExtractMin();\n            if (num == null) {\n                break;\n            }\n            result.Add(new List<long> { nums1[0], nums2[0] });\n        }\n        return result;",
    "        // Assumptions:\n        // - nums1 and nums2 are not null\n        // - k >= 0\n        // Approach:\n        // - Use a min heap to store the k smallest pairs\n        // - For each element in nums1, add all pairs with nums2 elements to the heap\n        // - If the heap size is greater than k, remove the smallest pair\n        // - Return the heap as a list of pairs\n        var heap = new MinHeap<List<long>>();\n        foreach (var n1 in nums1) {\n            foreach (var n2 in nums2) {\n                var pair = new List<long> { n1, n2 };\n                if (heap.Count < k) {\n                    heap.Add(pair);\n                } else {\n                    if (pair[0] + pair[1] < heap.Peek()[0] + heap.Peek()[1]) {\n                        heap.Remove();\n                        heap.Add(pair);\n                    }\n                }\n            }\n        }\n        return heap.ToList();",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first array.\n        nums1.Sort();\n        // Sort the second array.\n        nums2.Sort();\n        // Create a min heap.\n        MinHeap<long> minHeap = new MinHeap<long>(k);\n        // Add the first pair to the min heap.\n        minHeap.Add(new List<long>() { nums1[0], nums2[0] });\n        // Create a set to keep track of the pairs we've already seen.\n        HashSet<List<long>> seen = new HashSet<List<long>>();\n        seen.Add(new List<long>() { nums1[0], nums2[0] });\n        // Loop until we have k pairs.\n        while (result.Count < k) {\n            // Get the pair with the smallest sum from the min heap.\n            List<long> pair = minHeap.Remove();\n            // Add the pair to the result.\n            result.Add(pair);\n            // Get the next pair with the first element from the first array and the second element from the second array.\n            List<long> nextPair = new List<long>() { pair[0], nums2[nums2.IndexOf(pair[1]) + 1] };\n            // If we haven't seen the next pair and it's valid, add it to the min heap and the set.\n            if (!seen.Contains(nextPair) && nums2.IndexOf(pair[1]) + 1 < nums2.Count) {\n                minHeap.Add(nextPair);\n                seen.Add(nextPair);\n            }\n            // Get the next pair with the first element from the second array and the second element from the first array.\n            nextPair = new List<long>() { nums1[nums1.IndexOf(pair[0]) + 1], pair[1] };\n            // If we haven't seen the next pair and it's valid, add it to the min heap and",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0)\n            return result;\n        var minHeap = new MinHeap(nums1.Count);\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new Pair(nums1[i], nums2[0], 0));\n        }\n        for (int i = 0; i < k && !minHeap.IsEmpty(); i++) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.SecondIndex < nums2.Count - 1) {\n                minHeap.Insert(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var pq = new PriorityQueue<List<long>>();\n        pq.Enqueue(new List<long>() { nums1[0], nums2[0], 0, 0 });\n        while (pq.Count > 0 && k > 0) {\n            var pair = pq.Dequeue();\n            result.Add(new List<long>() { pair[0], pair[1] });\n            k--;\n            if (pair[2] < nums1.Count - 1) {\n                pq.Enqueue(new List<long>() { nums1[(int)pair[2] + 1], pair[1], pair[2] + 1, pair[3] });\n            }\n            if (pair[2] == 0 && pair[3] < nums2.Count - 1) {\n                pq.Enqueue(new List<long>() { pair[0], nums2[(int)pair[3] + 1], pair[2], pair[3] + 1 });\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first array and the second array.\n        nums1.Sort();\n        nums2.Sort();\n        // Initialize the heap.\n        Heap<long> heap = new Heap<long>();\n        // Initialize the visited array.\n        bool[,] visited = new bool[nums1.Count, nums2.Count];\n        // Add the first pair to the heap.\n        heap.Add(nums1[0] + nums2[0], new List<long>() { 0, 0 });\n        visited[0, 0] = true;\n        // While the heap is not empty and the result has less than k pairs.\n        while (heap.Count > 0 && result.Count < k) {\n            // Get the pair with the smallest sum.\n            List<long> pair = heap.Remove();\n            // Add the pair to the result.\n            result.Add(new List<long>() { nums1[pair[0]], nums2[pair[1]] });\n            // Add the right pair to the heap.\n            if (pair[1] + 1 < nums2.Count && !visited[pair[0], pair[1] + 1]) {\n                heap.Add(nums1[pair[0]] + nums2[pair[1] + 1], new List<long>() { pair[0], pair[1] + 1 });\n                visited[pair[0], pair[1] + 1] = true;\n            }\n            // Add the bottom pair to the heap.\n            if (pair[0] + 1 < nums1.Count && !visited[pair[0] + 1, pair[1]]) {\n                heap.Add(nums1[pair[0] + 1] + nums2[pair[1]], new List<long>() { pair[0] + 1, pair[1] });\n                visited[pair[0] + 1, pair[1]] = true;\n            }\n        }\n        return result;",
    "        // Write your code here.\n        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) return result;\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        minHeap.Insert(new Pair(nums1[0], nums2[0], 0, 0));\n        visited.Add(\"0,0\");\n        while (result.Count < k && minHeap.Size > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            var i = pair.FirstIndex;\n            var j = pair.SecondIndex;\n            if (i + 1 < nums1.Count && !visited.Contains($\"{i + 1},{j}\")) {\n                minHeap.Insert(new Pair(nums1[i + 1], nums2[j], i + 1, j));\n                visited.Add($\"{i + 1},{j}\");\n            }\n            if (j + 1 < nums2.Count && !visited.Contains($\"{i},{j + 1}\")) {\n                minHeap.Insert(new Pair(nums1[i], nums2[j + 1], i, j + 1));\n                visited.Add($\"{i},{j + 1}\");\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var pq = new PriorityQueue<List<long>>(new List<long> { nums1[0], nums2[0] }, (x, y) => x[0] + x[1] < y[0] + y[1]);\n        var visited = new HashSet<List<long>>();\n        visited.Add(new List<long> { 0, 0 });\n        while (result.Count < k && pq.Count > 0) {\n            var pair = pq.Dequeue();\n            result.Add(pair);\n            var i = pair[0];\n            var j = pair[1];\n            if (i + 1 < nums1.Count && !visited.Contains(new List<long> { i + 1, j })) {\n                pq.Enqueue(new List<long> { nums1[i + 1], nums2[j] });\n                visited.Add(new List<long> { i + 1, j });\n            }\n            if (j + 1 < nums2.Count && !visited.Contains(new List<long> { i, j + 1 })) {\n                pq.Enqueue(new List<long> { nums1[i], nums2[j + 1] });\n                visited.Add(new List<long> { i, j + 1 });\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                minHeap.Insert(new List<long> { nums1[i], nums2[j] }, sum);\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            if (minHeap.Count == 0) {\n                break;\n            }\n            result.Add(minHeap.ExtractMin().Item1);\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var heap = new MinHeap<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                var sum = nums1[i] + nums2[j];\n                if (heap.Count < k) {\n                    heap.Add(sum);\n                } else if (sum < heap.Peek()) {\n                    heap.Pop();\n                    heap.Add(sum);\n                }\n            }\n        }\n        while (heap.Count > 0) {\n            var sum = heap.Pop();\n            var pair = new List<long>();\n            for (int i = 0; i < nums1.Count; i++) {\n                for (int j = 0; j < nums2.Count; j++) {\n                    if (nums1[i] + nums2[j] == sum) {\n                        pair.Add(nums1[i]);\n                        pair.Add(nums2[j]);\n                        result.Add(pair);\n                        break;\n                    }\n                }\n            }\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<long> sums = new List<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                sums.Add(nums1[i] + nums2[j]);\n            }\n        }\n        sums.Sort();\n        for (int i = 0; i < k; i++) {\n            long sum = sums[i];\n            for (int j = 0; j < nums1.Count; j++) {\n                for (int l = 0; l < nums2.Count; l++) {\n                    if (nums1[j] + nums2[l] == sum) {\n                        result.Add(new List<long> { nums1[j], nums2[l] });\n                    }\n                }\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<long> sums = new List<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                sums.Add(nums1[i] + nums2[j]);\n            }\n        }\n        sums.Sort();\n        for (int i = 0; i < k; i++) {\n            for (int j = 0; j < nums1.Count; j++) {\n                for (int l = 0; l < nums2.Count; l++) {\n                    if (nums1[j] + nums2[l] == sums[i]) {\n                        result.Add(new List<long>() { nums1[j], nums2[l] });\n                        break;\n                    }\n                }\n            }\n        }\n        return result;",
    "        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        // Sort the first array.\n        nums1.Sort();\n        // Sort the second array.\n        nums2.Sort();\n        // Create a min heap.\n        MinHeap<long> minHeap = new MinHeap<long>();\n        // Add the first pair to the min heap.\n        minHeap.Add(nums1[0] + nums2[0], new List<long>() { nums1[0], nums2[0] });\n        // Create a hash set to store the pairs we have already added to the min heap.\n        HashSet<string> hashSet = new HashSet<string>();\n        hashSet.Add(nums1[0] + \",\" + nums2[0]);\n        // While the min heap is not empty and we have not added k pairs to the result.\n        while (minHeap.Count > 0 && result.Count < k) {\n            // Remove the pair with the smallest sum from the min heap.\n            List<long> pair = minHeap.Remove();\n            // Add the pair to the result.\n            result.Add(pair);\n            // Get the indices of the elements in the pair.\n            long i = pair[0];\n            long j = pair[1];\n            // If the first element in the pair is not the last element in the first array.\n            if (i < nums1[nums1.Count - 1]) {\n                // Get the index of the next element in the first array.\n                long index = nums1.BinarySearch(i + 1);\n                if (index < 0) {\n                    index = ~index;\n                }\n                // Create a new pair with the next element in the first array and the same element in the second array.\n                List<long> newPair = new List<long>() { nums1[index], j };\n                // If the new pair is not in the hash set.\n                if (!hashSet.Contains(nums1[index] + \",\" + j",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        SortedList<long, List<List<long>>> sorted = new SortedList<long, List<List<long>>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                long sum = nums1[i] + nums2[j];\n                if (sorted.ContainsKey(sum)) {\n                    sorted[sum].Add(new List<long>() { nums1[i], nums2[j] });\n                } else {\n                    sorted.Add(sum, new List<List<long>>() { new List<long>() { nums1[i], nums2[j] } });\n                }\n            }\n        }\n        foreach (var item in sorted) {\n            foreach (var pair in item.Value) {\n                result.Add(pair);\n                if (result.Count == k) {\n                    return result;\n                }\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Insert(new Pair(nums1[i], nums2[0], 0));\n        }\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.SecondIndex < nums2.Count - 1) {\n                minHeap.Insert(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n            k--;\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<List<long>> pairs = new List<List<long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                pairs.Add(new List<long> { nums1[i], nums2[j] });\n            }\n        }\n        pairs.Sort((a, b) => (int)(a[0] + a[1] - b[0] - b[1]));\n        for (int i = 0; i < k && i < pairs.Count; i++) {\n            result.Add(pairs[i]);\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var heap = new Heap<long>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                heap.Insert(nums1[i] + nums2[j]);\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            var sum = heap.ExtractMin();\n            var pair = new List<long>();\n            pair.Add(sum);\n            pair.Add(sum);\n            result.Add(pair);\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        var pq = new PriorityQueue<Tuple<long, long, long>>(k);\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                pq.Enqueue(new Tuple<long, long, long>(nums1[i] + nums2[j], nums1[i], nums2[j]));\n            }\n        }\n        for (int i = 0; i < k; i++) {\n            var item = pq.Dequeue();\n            result.Add(new List<long> { item.Item2, item.Item3 });\n        }\n        return result;",
    "        // Write your code here.\n        List<List<long>> result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        List<List<long>> pairs = new List<List<long>>();\n        for (int i = 0; i < nums1.Count; i++) {\n            for (int j = 0; j < nums2.Count; j++) {\n                List<long> pair = new List<long>();\n                pair.Add(nums1[i]);\n                pair.Add(nums2[j]);\n                pairs.Add(pair);\n            }\n        }\n        pairs.Sort((a, b) => {\n            long sumA = a[0] + a[1];\n            long sumB = b[0] + b[1];\n            if (sumA < sumB) {\n                return -1;\n            } else if (sumA > sumB) {\n                return 1;\n            } else {\n                return 0;\n            }\n        });\n        for (int i = 0; i < k && i < pairs.Count; i++) {\n            result.Add(pairs[i]);\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0 || k == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        var visited = new HashSet<string>();\n        minHeap.Insert(new Pair(nums1[0], nums2[0], 0, 0));\n        visited.Add(0 + \"-\" + 0);\n        while (k > 0 && minHeap.Count > 0) {\n            var pair = minHeap.ExtractMin();\n            result.Add(new List<long> { pair.Num1, pair.Num2 });\n            k--;\n            var i = pair.Index1;\n            var j = pair.Index2;\n            if (i + 1 < nums1.Count && !visited.Contains((i + 1) + \"-\" + j)) {\n                minHeap.Insert(new Pair(nums1[i + 1], nums2[j], i + 1, j));\n                visited.Add((i + 1) + \"-\" + j);\n            }\n            if (j + 1 < nums2.Count && !visited.Contains(i + \"-\" + (j + 1))) {\n                minHeap.Insert(new Pair(nums1[i], nums2[j + 1], i, j + 1));\n                visited.Add(i + \"-\" + (j + 1));\n            }\n        }\n        return result;",
    "        var result = new List<List<long>>();\n        if (nums1.Count == 0 || nums2.Count == 0) {\n            return result;\n        }\n        var minHeap = new MinHeap();\n        for (int i = 0; i < nums1.Count; i++) {\n            minHeap.Add(new Pair(nums1[i], nums2[0], 0));\n        }\n        for (int i = 0; i < k && minHeap.Count > 0; i++) {\n            var pair = minHeap.RemoveMin();\n            result.Add(new List<long> { pair.First, pair.Second });\n            if (pair.SecondIndex < nums2.Count - 1) {\n                minHeap.Add(new Pair(pair.First, nums2[pair.SecondIndex + 1], pair.SecondIndex + 1));\n            }\n        }\n        return result;"
  ]
}