{
  "name": "mbpp_721_maxAverageOfPath",
  "language": "cs",
  "prompt": "using System;\nusing System.Numerics;\nusing System.Diagnostics;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Security.Cryptography;\nclass Problem {\n    // Given a square matrix of size N*N given as a list of lists, where each cell is associated with a specific cost. A path is defined as a specific sequence of cells that starts from the top-left cell move only right or down and ends on bottom right cell. We want to find a path with the maximum average over all existing paths. Average is computed as total cost divided by the number of cells visited in the path.\n    public static float Maxaverageofpath(List<List<long>> cost) {\n",
  "doctests": "keep",
  "original": "/home/arjun/repos/MultiPL-E/datasets/../datasets/mbpp-typed/mbpp_721_maxAverageOfPath.py",
  "prompt_terminology": "verbatim",
  "tests": "    }\n    public static void Main(string[] args) {\n    Debug.Assert(Maxaverageofpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L}), (List<long>)new List<long>(new long[]{(long)6L, (long)5L, (long)4L}), (List<long>)new List<long>(new long[]{(long)7L, (long)3L, (long)9L})}))) == (5.2f));\n    Debug.Assert(Maxaverageofpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)2L, (long)3L, (long)4L}), (List<long>)new List<long>(new long[]{(long)7L, (long)6L, (long)5L}), (List<long>)new List<long>(new long[]{(long)8L, (long)4L, (long)10L})}))) == (6.2f));\n    Debug.Assert(Maxaverageofpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)3L, (long)4L, (long)5L}), (List<long>)new List<long>(new long[]{(long)8L, (long)7L, (long)6L}), (List<long>)new List<long>(new long[]{(long)9L, (long)5L, (long)11L})}))) == (7.2f));\n    Debug.Assert(Maxaverageofpath((new List<List<long>>(new List<long>[]{(List<long>)new List<long>(new long[]{(long)1L, (long)2L, (long)3L}), (List<long>)new List<long>(new long[]{(long)4L, (long)5L, (long)6L}), (List<long>)new List<long>(new long[]{(long)7L, (long)8L, (long)9L})}))) == (5.8f));\n    }\n\n}\n",
  "stop_tokens": [
    "\n    }\n"
  ],
  "completions": [
    "        // Write your code here\n        int n = cost.Count;\n        int m = cost[0].Count;\n        float[,] dp = new float[n, m];\n        dp[0, 0] = cost[0][0];\n        for (int i = 1; i < n; i++) {\n            dp[i, 0] = dp[i - 1, 0] + cost[i][0];\n        }\n        for (int j = 1; j < m; j++) {\n            dp[0, j] = dp[0, j - 1] + cost[0][j];\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < m; j++) {\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]) + cost[i][j];\n            }\n        }\n        return dp[n - 1, m - 1] / (n + m - 1);",
    "        // Write your code here\n        return 0;",
    "        int n = cost.Count;\n        var dp = new float[n, n];\n        dp[0, 0] = cost[0][0];\n        for (int i = 1; i < n; i++) {\n            dp[0, i] = dp[0, i - 1] + cost[0][i];\n            dp[i, 0] = dp[i - 1, 0] + cost[i][0];\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]) + cost[i][j];\n            }\n        }\n        return dp[n - 1, n - 1] / (2 * n - 1);",
    "        int n = cost.Count;\n        float[,] dp = new float[n, n];\n        dp[0, 0] = cost[0][0];\n        for (int i = 1; i < n; i++) {\n            dp[0, i] = dp[0, i - 1] + cost[0][i];\n            dp[i, 0] = dp[i - 1, 0] + cost[i][0];\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]) + cost[i][j];\n            }\n        }\n        return dp[n - 1, n - 1] / (2 * n - 1);",
    "        // Write your code here\n        int n = cost.Count;\n        float[,] dp = new float[n, n];\n        dp[0, 0] = cost[0][0];\n        for (int i = 1; i < n; i++) {\n            dp[0, i] = dp[0, i - 1] + cost[0][i];\n            dp[i, 0] = dp[i - 1, 0] + cost[i][0];\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]) + cost[i][j];\n            }\n        }\n        return dp[n - 1, n - 1] / (2 * n - 1);",
    "        int n = cost.Count;\n        float[,] dp = new float[n, n];\n        dp[0, 0] = cost[0][0];\n        for (int i = 1; i < n; i++) {\n            dp[0, i] = dp[0, i - 1] + cost[0][i];\n            dp[i, 0] = dp[i - 1, 0] + cost[i][0];\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]) + cost[i][j];\n            }\n        }\n        return dp[n - 1, n - 1] / (2 * n - 1);",
    "        // Write your code here\n        int m = cost.Count;\n        int n = cost[0].Count;\n        float[,] dp = new float[m, n];\n        dp[0, 0] = cost[0][0];\n        for (int i = 1; i < m; i++) {\n            dp[i, 0] = dp[i - 1, 0] + cost[i][0];\n        }\n        for (int j = 1; j < n; j++) {\n            dp[0, j] = dp[0, j - 1] + cost[0][j];\n        }\n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]) + cost[i][j];\n            }\n        }\n        return dp[m - 1, n - 1] / (m + n - 1);",
    "        // Write your code here\n        int n = cost.Count;\n        float[,] dp = new float[n, n];\n        dp[0, 0] = cost[0][0];\n        for (int i = 1; i < n; i++) {\n            dp[0, i] = dp[0, i - 1] + cost[0][i];\n            dp[i, 0] = dp[i - 1, 0] + cost[i][0];\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]) + cost[i][j];\n            }\n        }\n        return dp[n - 1, n - 1] / (2 * n - 1);",
    "        int n = cost.Count;\n        float[,] dp = new float[n, n];\n        dp[0, 0] = cost[0][0];\n        for (int i = 1; i < n; i++) {\n            dp[0, i] = dp[0, i - 1] + cost[0][i];\n            dp[i, 0] = dp[i - 1, 0] + cost[i][0];\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]) + cost[i][j];\n            }\n        }\n        return dp[n - 1, n - 1] / (2 * n - 1);",
    "        int n = cost.Count;\n        float[,] dp = new float[n, n];\n        dp[0, 0] = cost[0][0];\n        for (int i = 1; i < n; i++) {\n            dp[0, i] = dp[0, i - 1] + cost[0][i];\n            dp[i, 0] = dp[i - 1, 0] + cost[i][0];\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]) + cost[i][j];\n            }\n        }\n        return dp[n - 1, n - 1] / (2 * n - 1);",
    "        int n = cost.Count;\n        float[,] dp = new float[n, n];\n        dp[0, 0] = cost[0][0];\n        for (int i = 1; i < n; i++) {\n            dp[0, i] = dp[0, i - 1] + cost[0][i];\n            dp[i, 0] = dp[i - 1, 0] + cost[i][0];\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]) + cost[i][j];\n            }\n        }\n        return dp[n - 1, n - 1] / (2 * n - 1);",
    "        int n = cost.Count;\n        float[,] dp = new float[n, n];\n        dp[0, 0] = cost[0][0];\n        for (int i = 1; i < n; i++) {\n            dp[0, i] = dp[0, i - 1] + cost[0][i];\n            dp[i, 0] = dp[i - 1, 0] + cost[i][0];\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]) + cost[i][j];\n            }\n        }\n        return dp[n - 1, n - 1] / (2 * n - 2);",
    "        int n = cost.Count;\n        float[,] dp = new float[n, n];\n        dp[0, 0] = cost[0][0];\n        for (int i = 1; i < n; i++) {\n            dp[0, i] = dp[0, i - 1] + cost[0][i];\n            dp[i, 0] = dp[i - 1, 0] + cost[i][0];\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]) + cost[i][j];\n            }\n        }\n        return dp[n - 1, n - 1] / (2 * n - 1);",
    "        int n = cost.Count;\n        float[,] dp = new float[n, n];\n        dp[0, 0] = cost[0][0];\n        for (int i = 1; i < n; i++) {\n            dp[0, i] = dp[0, i - 1] + cost[0][i];\n            dp[i, 0] = dp[i - 1, 0] + cost[i][0];\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]) + cost[i][j];\n            }\n        }\n        return dp[n - 1, n - 1] / (2 * n - 1);",
    "        int n = cost.Count;\n        float[,] dp = new float[n, n];\n        dp[0, 0] = cost[0][0];\n        for (int i = 1; i < n; i++) {\n            dp[0, i] = dp[0, i - 1] + cost[0][i];\n            dp[i, 0] = dp[i - 1, 0] + cost[i][0];\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]) + cost[i][j];\n            }\n        }\n        return dp[n - 1, n - 1] / (2 * n - 1);",
    "        var n = cost.Count;\n        var dp = new float[n, n];\n        dp[0, 0] = cost[0][0];\n        for (var i = 1; i < n; i++) {\n            dp[0, i] = dp[0, i - 1] + cost[0][i];\n            dp[i, 0] = dp[i - 1, 0] + cost[i][0];\n        }\n        for (var i = 1; i < n; i++) {\n            for (var j = 1; j < n; j++) {\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]) + cost[i][j];\n            }\n        }\n        return dp[n - 1, n - 1] / (2 * n - 1);",
    "        // Write your code here\n        int n = cost.Count;\n        long[,] dp = new long[n, n];\n        dp[0, 0] = cost[0][0];\n        for (int i = 1; i < n; i++) {\n            dp[i, 0] = dp[i - 1, 0] + cost[i][0];\n            dp[0, i] = dp[0, i - 1] + cost[0][i];\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]) + cost[i][j];\n            }\n        }\n        return (float)dp[n - 1, n - 1] / (2 * n - 1);",
    "        // Write your code here\n        int n = cost.Count;\n        int m = cost[0].Count;\n        float[,] dp = new float[n, m];\n        dp[0, 0] = cost[0][0];\n        for (int i = 1; i < n; i++) {\n            dp[i, 0] = dp[i - 1, 0] + cost[i][0];\n        }\n        for (int i = 1; i < m; i++) {\n            dp[0, i] = dp[0, i - 1] + cost[0][i];\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < m; j++) {\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]) + cost[i][j];\n            }\n        }\n        return dp[n - 1, m - 1] / (n + m - 1);",
    "        // Write your code here\n        var n = cost.Count;\n        var dp = new float[n, n];\n        dp[0, 0] = cost[0][0];\n        for (int i = 1; i < n; i++) {\n            dp[0, i] = dp[0, i - 1] + cost[0][i];\n            dp[i, 0] = dp[i - 1, 0] + cost[i][0];\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]) + cost[i][j];\n            }\n        }\n        return dp[n - 1, n - 1] / (2 * n - 1);",
    "        var n = cost.Count;\n        var dp = new List<List<float>>();\n        for (int i = 0; i < n; i++) {\n            dp.Add(new List<float>());\n            for (int j = 0; j < n; j++) {\n                dp[i].Add(0);\n            }\n        }\n        dp[0][0] = cost[0][0];\n        for (int i = 1; i < n; i++) {\n            dp[0][i] = dp[0][i - 1] + cost[0][i];\n            dp[i][0] = dp[i - 1][0] + cost[i][0];\n        }\n        for (int i = 1; i < n; i++) {\n            for (int j = 1; j < n; j++) {\n                dp[i][j] = Math.Max(dp[i - 1][j], dp[i][j - 1]) + cost[i][j];\n            }\n        }\n        return dp[n - 1][n - 1] / (2 * n - 1);"
  ]
}