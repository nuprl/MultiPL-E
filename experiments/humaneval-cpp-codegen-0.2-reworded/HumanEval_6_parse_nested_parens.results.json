{
  "name": "HumanEval_6_parse_nested_parens",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n",
  "tests": "}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            long index = stack.top();\n            stack.pop();\n            result.push_back(index - i);\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpbvi1nfwd: /tmp/tmpbvi1nfwd.cpp:24: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else {\n            if (stack.empty()) {\n                result.push_back(i - 1);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292587,
      "stdout": "",
      "stderr": "tmp019akj8l: /tmp/tmp019akj8l.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    long depth = 0;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(depth);\n            depth++;\n        } else if (c == ')') {\n            depth = stack.top();\n            stack.pop();\n        }\n    }\n    result.push_back(depth);\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292587,
      "stdout": "",
      "stderr": "tmp_rjbjtkv: /tmp/tmp_rjbjtkv.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else {\n            if (stack.empty()) {\n                result.push_back(i - 1);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0w6knxaf: /tmp/tmp0w6knxaf.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            long index = stack.top();\n            stack.pop();\n            result.push_back(index - i);\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpd4dsswol: /tmp/tmpd4dsswol.cpp:24: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (stack.empty()) {\n                result.push_back(c);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpnb0nnhuv: /tmp/tmpnb0nnhuv.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto ch : paren_string) {\n        if (ch == '(') {\n            stack.push(ch);\n        } else if (ch == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.top());\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpeo3srj2h: /tmp/tmpeo3srj2h.cpp:27: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto it = paren_string.begin(); it != paren_string.end(); ++it) {\n        if (*it == '(') {\n            stack.push(1);\n        } else if (*it == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                stack.pop();\n                result.push_back(stack.size());\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292587,
      "stdout": "",
      "stderr": "tmpnm486um7: /tmp/tmpnm486um7.cpp:27: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (stack.empty()) {\n                result.push_back(c);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpnb0nnhuv: /tmp/tmpnb0nnhuv.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto ch : paren_string) {\n        if (ch == '(') {\n            stack.push(ch);\n        } else if (ch == ')') {\n            if (stack.empty()) {\n                result.push_back(ch);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    while (!stack.empty()) {\n        result.push_back(stack.top());\n        stack.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp_7i57mzw: /tmp/tmp_7i57mzw.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    while (!stack.empty()) {\n        result.push_back(stack.top());\n        stack.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292587,
      "stdout": "",
      "stderr": "tmpkhol9_v7: /tmp/tmpkhol9_v7.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmprrvszi68: /tmp/tmprrvszi68.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    if (!stack.empty()) {\n        result.push_back(stack.top());\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292587,
      "stdout": "",
      "stderr": "tmpq5q47dt8: /tmp/tmpq5q47dt8.cpp:29: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.size());\n                stack.pop();\n            }\n        }\n    }\n    if (!stack.empty()) {\n        result.push_back(stack.size());\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpbp984_rf: /tmp/tmpbp984_rf.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto it = paren_string.begin(); it != paren_string.end(); ++it) {\n        if (*it == '(') {\n            stack.push(1);\n        } else if (*it == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                stack.pop();\n                result.push_back(stack.size());\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292587,
      "stdout": "",
      "stderr": "tmpnm486um7: /tmp/tmpnm486um7.cpp:27: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.top());\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292587,
      "stdout": "",
      "stderr": "tmpj5f3oq6_: /tmp/tmpj5f3oq6_.cpp:27: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (stack.empty()) {\n                result.push_back(c);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpnb0nnhuv: /tmp/tmpnb0nnhuv.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            long top = stack.top();\n            stack.pop();\n            result.push_back(top - i);\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpln3_8kwz: /tmp/tmpln3_8kwz.cpp:24: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            long index = stack.top();\n            stack.pop();\n            result.push_back(index - i);\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpbvi1nfwd: /tmp/tmpbvi1nfwd.cpp:24: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto ch : paren_string) {\n        if (ch == '(') {\n            stack.push(ch);\n        } else if (ch == ')') {\n            if (stack.empty()) {\n                result.push_back(ch);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpva3tzy4d: /tmp/tmpva3tzy4d.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmprrvszi68: /tmp/tmprrvszi68.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto it = paren_string.begin(); it != paren_string.end(); ++it) {\n        if (*it == '(') {\n            stack.push(1);\n        } else if (*it == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.top());\n                stack.pop();\n            }\n        }\n    }\n    if (!stack.empty()) {\n        result.push_back(stack.top());\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpqvvrw3hk: /tmp/tmpqvvrw3hk.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else {\n            if (stack.empty()) {\n                result.push_back(i - 1);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0w6knxaf: /tmp/tmp0w6knxaf.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto it = paren_string.begin(); it != paren_string.end(); ++it) {\n        if (*it == '(') {\n            stack.push(1);\n        } else if (*it == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                stack.pop();\n                result.push_back(stack.top());\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto ch : paren_string) {\n        if (ch == '(') {\n            stack.push(ch);\n        } else if (ch == ')') {\n            if (stack.empty()) {\n                result.push_back(ch);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    while (!stack.empty()) {\n        result.push_back(stack.top());\n        stack.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp_7i57mzw: /tmp/tmp_7i57mzw.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            long index = stack.top();\n            stack.pop();\n            result.push_back(index - i);\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpbvi1nfwd: /tmp/tmpbvi1nfwd.cpp:24: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            long top = stack.top();\n            stack.pop();\n            result.push_back(top - i);\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpln3_8kwz: /tmp/tmpln3_8kwz.cpp:24: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else {\n            if (stack.empty()) {\n                result.push_back(i - 1);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292587,
      "stdout": "",
      "stderr": "tmp019akj8l: /tmp/tmp019akj8l.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); ++i) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else {\n            if (stack.empty()) {\n                result.push_back(i - 1);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp_u4q0lww: /tmp/tmp_u4q0lww.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (stack.empty()) {\n                result.push_back(c);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpnb0nnhuv: /tmp/tmpnb0nnhuv.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.top());\n                stack.pop();\n            }\n        }\n    }\n    if (!stack.empty()) {\n        result.push_back(stack.top());\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0t6omny4: /tmp/tmp0t6omny4.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        }\n        else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            }\n            else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpz2ym40s9: /tmp/tmpz2ym40s9.cpp:28: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto it = paren_string.begin(); it != paren_string.end(); ++it) {\n        if (*it == '(') {\n            stack.push(1);\n        } else if (*it == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                stack.pop();\n                result.push_back(stack.top());\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto it = paren_string.begin(); it != paren_string.end(); ++it) {\n        if (*it == '(') {\n            stack.push(1);\n        } else if (*it == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                stack.pop();\n                result.push_back(stack.top());\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else {\n            if (stack.empty()) {\n                result.push_back(i - 1);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292587,
      "stdout": "",
      "stderr": "tmp019akj8l: /tmp/tmp019akj8l.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmprrvszi68: /tmp/tmprrvszi68.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        }\n        else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            }\n            else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpxxr1lowk: /tmp/tmpxxr1lowk.cpp:28: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    while (!stack.empty()) {\n        result.push_back(stack.top());\n        stack.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292587,
      "stdout": "",
      "stderr": "tmpkhol9_v7: /tmp/tmpkhol9_v7.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto it = paren_string.begin(); it != paren_string.end(); ++it) {\n        if (*it == '(') {\n            stack.push(1);\n        } else if (*it == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                stack.pop();\n                result.push_back(stack.top());\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmprrvszi68: /tmp/tmprrvszi68.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else {\n            if (!stack.empty()) {\n                stack.pop();\n                result.push_back(stack.size());\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmpbnjxikkk: /tmp/tmpbnjxikkk.cpp:25: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmprrvszi68: /tmp/tmprrvszi68.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); ++i) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmpixwxups9: /tmp/tmpixwxups9.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        }\n        else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            }\n            else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpxxr1lowk: /tmp/tmpxxr1lowk.cpp:28: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto ch : paren_string) {\n        if (ch == '(') {\n            stack.push(ch);\n        } else if (ch == ')') {\n            if (stack.empty()) {\n                result.push_back(ch);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpva3tzy4d: /tmp/tmpva3tzy4d.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        }\n        else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            }\n            else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpxxr1lowk: /tmp/tmpxxr1lowk.cpp:28: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            long level = stack.size();\n            stack.pop();\n            result.push_back(level);\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmpglncibbn: /tmp/tmpglncibbn.cpp:24: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.top());\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmp9_olsdqr: /tmp/tmp9_olsdqr.cpp:27: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.top());\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmpzg4_4ry4: /tmp/tmpzg4_4ry4.cpp:27: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else {\n            if (!stack.empty()) {\n                long top = stack.top();\n                stack.pop();\n                result.push_back(top - i);\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmpkmgwgwz7: /tmp/tmpkmgwgwz7.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto ch : paren_string) {\n        if (ch == '(') {\n            stack.push(ch);\n        } else if (ch == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.top());\n                stack.pop();\n            }\n        }\n    }\n    if (!stack.empty()) {\n        result.push_back(stack.top());\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmpgvj4c5ge: /tmp/tmpgvj4c5ge.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(1);\n        } else if (c == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                stack.pop();\n                result.push_back(stack.top());\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                stack.pop();\n                result.push_back(stack.size());\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmpuy7j9768: /tmp/tmpuy7j9768.cpp:27: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); ++i) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmpixwxups9: /tmp/tmpixwxups9.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto it = paren_string.begin(); it != paren_string.end(); ++it) {\n        if (*it == '(') {\n            stack.push(1);\n        } else if (*it == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                stack.pop();\n                result.push_back(stack.top());\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmprrvszi68: /tmp/tmprrvszi68.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (stack.empty()) {\n                result.push_back(c);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpnb0nnhuv: /tmp/tmpnb0nnhuv.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto it = paren_string.begin(); it != paren_string.end(); ++it) {\n        if (*it == '(') {\n            stack.push(1);\n        } else if (*it == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                stack.pop();\n                result.push_back(stack.top());\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    while (!stack.empty()) {\n        result.push_back(stack.top());\n        stack.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292587,
      "stdout": "",
      "stderr": "tmpkhol9_v7: /tmp/tmpkhol9_v7.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto it = paren_string.begin(); it != paren_string.end(); ++it) {\n        if (*it == '(') {\n            stack.push(1);\n        } else if (*it == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                stack.pop();\n                result.push_back(stack.top());\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.top());\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292587,
      "stdout": "",
      "stderr": "tmpj5f3oq6_: /tmp/tmpj5f3oq6_.cpp:27: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto it = paren_string.begin(); it != paren_string.end(); ++it) {\n        if (*it == '(') {\n            stack.push(1);\n        } else if (*it == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                stack.pop();\n                result.push_back(stack.top());\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmprrvszi68: /tmp/tmprrvszi68.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.top());\n                stack.pop();\n            }\n        }\n    }\n    if (!stack.empty()) {\n        result.push_back(stack.top());\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmpe_o376_o: /tmp/tmpe_o376_o.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            long index = stack.top();\n            stack.pop();\n            result.push_back(index - i);\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpbvi1nfwd: /tmp/tmpbvi1nfwd.cpp:24: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmprrvszi68: /tmp/tmprrvszi68.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmprrvszi68: /tmp/tmprrvszi68.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else {\n            if (stack.empty()) {\n                result.push_back(i - 1);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292587,
      "stdout": "",
      "stderr": "tmp019akj8l: /tmp/tmp019akj8l.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto ch : paren_string) {\n        if (ch == '(') {\n            stack.push(ch);\n        } else if (ch == ')') {\n            if (stack.empty()) {\n                result.push_back(ch);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpva3tzy4d: /tmp/tmpva3tzy4d.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.top());\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmpwiyivct0: /tmp/tmpwiyivct0.cpp:27: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); ++i) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            long top = stack.top();\n            stack.pop();\n            result.push_back(top - i);\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmp29y7yx38: /tmp/tmp29y7yx38.cpp:24: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmprrvszi68: /tmp/tmprrvszi68.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(1);\n        } else if (c == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                stack.pop();\n                result.push_back(stack.top());\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.top());\n                stack.pop();\n            }\n        }\n    }\n    if (!stack.empty()) {\n        result.push_back(stack.top());\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmp23yryqp2: /tmp/tmp23yryqp2.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.top());\n                stack.pop();\n            }\n        }\n    }\n    if (!stack.empty()) {\n        result.push_back(stack.top());\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmp23yryqp2: /tmp/tmp23yryqp2.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto it = paren_string.begin(); it != paren_string.end(); ++it) {\n        if (*it == '(') {\n            stack.push(1);\n        } else if (*it == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                stack.pop();\n                result.push_back(stack.top());\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            long index = stack.top();\n            stack.pop();\n            result.push_back(index - i);\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpd4dsswol: /tmp/tmpd4dsswol.cpp:24: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    long depth = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(depth);\n            depth++;\n        } else if (paren_string[i] == ')') {\n            depth = stack.top();\n            stack.pop();\n        }\n    }\n    result.push_back(depth);\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmpg8_dcsae: /tmp/tmpg8_dcsae.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (stack.empty()) {\n                result.push_back(c);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    while (!stack.empty()) {\n        result.push_back(stack.top());\n        stack.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmpwatgdzlq: /tmp/tmpwatgdzlq.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(1);\n        } else if (c == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                stack.pop();\n                result.push_back(stack.top());\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.size());\n                stack.pop();\n            }\n        }\n    }\n    if (!stack.empty()) {\n        result.push_back(stack.size());\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpbp984_rf: /tmp/tmpbp984_rf.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        }\n        else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            }\n            else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpxxr1lowk: /tmp/tmpxxr1lowk.cpp:28: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        }\n        else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            }\n            else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpz2ym40s9: /tmp/tmpz2ym40s9.cpp:28: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto it = paren_string.begin(); it != paren_string.end(); ++it) {\n        if (*it == '(') {\n            stack.push(1);\n        } else if (*it == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                stack.pop();\n                result.push_back(stack.top());\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        }\n        else if (paren_string[i] == ')') {\n            long index = stack.top();\n            stack.pop();\n            result.push_back(index - i);\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmprhd08p9p: /tmp/tmprhd08p9p.cpp:25: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.top());\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmpwiyivct0: /tmp/tmpwiyivct0.cpp:27: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmprrvszi68: /tmp/tmprrvszi68.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.top());\n                stack.pop();\n            }\n        }\n    }\n    if (!stack.empty()) {\n        result.push_back(stack.top());\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmpo4l75s_o: /tmp/tmpo4l75s_o.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto it = paren_string.begin(); it != paren_string.end(); it++) {\n        if (*it == '(') {\n            stack.push(1);\n        } else if (*it == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.top());\n                stack.pop();\n            }\n        }\n    }\n    if (!stack.empty()) {\n        result.push_back(stack.top());\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmpru9umb9u: /tmp/tmpru9umb9u.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmprrvszi68: /tmp/tmprrvszi68.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(1);\n        } else if (c == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                stack.pop();\n                result.push_back(stack.size());\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmphsb31iqx: /tmp/tmphsb31iqx.cpp:27: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            long last_open_paren = stack.top();\n            stack.pop();\n            result.push_back(last_open_paren - i);\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmpb8xil8hw: /tmp/tmpb8xil8hw.cpp:24: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmprrvszi68: /tmp/tmprrvszi68.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto it = paren_string.begin(); it != paren_string.end(); ++it) {\n        if (*it == '(') {\n            stack.push(1);\n        } else if (*it == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                stack.pop();\n                result.push_back(stack.top());\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (stack.empty()) {\n                result.push_back(c);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpnb0nnhuv: /tmp/tmpnb0nnhuv.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto ch : paren_string) {\n        if (ch == '(') {\n            stack.push(ch);\n        } else if (ch == ')') {\n            if (stack.empty()) {\n                result.push_back(ch);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    while (!stack.empty()) {\n        result.push_back(stack.top());\n        stack.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp_7i57mzw: /tmp/tmp_7i57mzw.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        }\n        else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            }\n            else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpxxr1lowk: /tmp/tmpxxr1lowk.cpp:28: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto it = paren_string.begin(); it != paren_string.end(); ++it) {\n        if (*it == '(') {\n            stack.push(1);\n        } else if (*it == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                stack.pop();\n                result.push_back(stack.top());\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto it = paren_string.begin(); it != paren_string.end(); ++it) {\n        if (*it == '(') {\n            stack.push(1);\n        } else if (*it == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                stack.pop();\n                result.push_back(stack.top());\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        }\n        else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            }\n            else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpz2ym40s9: /tmp/tmpz2ym40s9.cpp:28: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        }\n        else if (paren_string[i] == ')') {\n            long index = stack.top();\n            stack.pop();\n            result.push_back(index - i);\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmprhd08p9p: /tmp/tmprhd08p9p.cpp:25: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    if (!stack.empty()) {\n        result.push_back(stack.top());\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmpirbeqtdt: /tmp/tmpirbeqtdt.cpp:29: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.top());\n                stack.pop();\n            }\n        }\n    }\n    if (!stack.empty()) {\n        result.push_back(stack.top());\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmpw2agvw_9: /tmp/tmpw2agvw_9.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmps_opobg1: /tmp/tmps_opobg1.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.top());\n                stack.pop();\n            }\n        }\n    }\n    if (!stack.empty()) {\n        result.push_back(stack.top());\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmpe_o376_o: /tmp/tmpe_o376_o.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); ++i) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292592,
      "stdout": "",
      "stderr": "tmpiyvte4gg: /tmp/tmpiyvte4gg.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    while (!stack.empty()) {\n        result.push_back(stack.top());\n        stack.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292587,
      "stdout": "",
      "stderr": "tmpkhol9_v7: /tmp/tmpkhol9_v7.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else {\n            if (stack.empty()) {\n                result.push_back(i - 1);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292587,
      "stdout": "",
      "stderr": "tmp019akj8l: /tmp/tmp019akj8l.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else {\n            if (stack.empty()) {\n                result.push_back(i - 1);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292587,
      "stdout": "",
      "stderr": "tmp019akj8l: /tmp/tmp019akj8l.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            long index = stack.top();\n            stack.pop();\n            result.push_back(index - i);\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpbvi1nfwd: /tmp/tmpbvi1nfwd.cpp:24: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); ++i) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else {\n            if (stack.empty()) {\n                result.push_back(i - 1);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp_u4q0lww: /tmp/tmp_u4q0lww.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto ch : paren_string) {\n        if (ch == '(') {\n            stack.push(ch);\n        } else if (ch == ')') {\n            if (stack.empty()) {\n                result.push_back(ch);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    while (!stack.empty()) {\n        result.push_back(stack.top());\n        stack.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp_7i57mzw: /tmp/tmp_7i57mzw.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        }\n        else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            }\n            else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpxxr1lowk: /tmp/tmpxxr1lowk.cpp:28: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        }\n        else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            }\n            else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpxxr1lowk: /tmp/tmpxxr1lowk.cpp:28: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto ch : paren_string) {\n        if (ch == '(') {\n            stack.push(ch);\n        } else if (ch == ')') {\n            if (stack.empty()) {\n                result.push_back(ch);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpva3tzy4d: /tmp/tmpva3tzy4d.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (stack.empty()) {\n                result.push_back(c);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpnb0nnhuv: /tmp/tmpnb0nnhuv.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            long j = stack.top();\n            stack.pop();\n            result.push_back(j - i);\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292592,
      "stdout": "",
      "stderr": "tmpyxout0pn: /tmp/tmpyxout0pn.cpp:24: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); ++i) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmpixwxups9: /tmp/tmpixwxups9.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else {\n            if (stack.empty()) {\n                result.push_back(i - 1);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0w6knxaf: /tmp/tmp0w6knxaf.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.top());\n                stack.pop();\n            }\n        }\n    }\n    if (!stack.empty()) {\n        result.push_back(stack.top());\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmpe_o376_o: /tmp/tmpe_o376_o.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else {\n            if (stack.empty()) {\n                result.push_back(i - stack.size());\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292592,
      "stdout": "",
      "stderr": "tmp7c0q21_p: /tmp/tmp7c0q21_p.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) {\n                result.push_back(c - '0');\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292592,
      "stdout": "",
      "stderr": "tmp2w0m71cn: /tmp/tmp2w0m71cn.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    if (!stack.empty()) {\n        result.push_back(stack.top());\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292587,
      "stdout": "",
      "stderr": "tmpq5q47dt8: /tmp/tmpq5q47dt8.cpp:29: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            long j = stack.top();\n            stack.pop();\n            result.push_back(j - i);\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292592,
      "stdout": "",
      "stderr": "tmp7xy5v7ze: /tmp/tmp7xy5v7ze.cpp:24: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.top());\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmpzg4_4ry4: /tmp/tmpzg4_4ry4.cpp:27: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                long top = stack.top();\n                stack.pop();\n                result.push_back(i - top);\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292592,
      "stdout": "",
      "stderr": "tmp950qkqq9: /tmp/tmp950qkqq9.cpp:28: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmps_opobg1: /tmp/tmps_opobg1.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        }\n        else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            }\n            else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpxxr1lowk: /tmp/tmpxxr1lowk.cpp:28: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                long top = stack.top();\n                stack.pop();\n                result.push_back(top);\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292592,
      "stdout": "",
      "stderr": "tmp1fxy5zxq: /tmp/tmp1fxy5zxq.cpp:28: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    while (!stack.empty()) {\n        result.push_back(stack.top());\n        stack.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292587,
      "stdout": "",
      "stderr": "tmpkhol9_v7: /tmp/tmpkhol9_v7.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.top());\n                stack.pop();\n            }\n        }\n    }\n    if (!stack.empty()) {\n        result.push_back(stack.top());\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmp23yryqp2: /tmp/tmp23yryqp2.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.top());\n                stack.pop();\n            }\n        }\n    }\n    if (!stack.empty()) {\n        result.push_back(stack.top());\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmp23yryqp2: /tmp/tmp23yryqp2.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto ch : paren_string) {\n        if (ch == '(') {\n            stack.push(ch);\n        } else if (ch == ')') {\n            if (stack.empty()) {\n                result.push_back(ch);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpva3tzy4d: /tmp/tmpva3tzy4d.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            long index = stack.top();\n            stack.pop();\n            result.push_back(index - i);\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpbvi1nfwd: /tmp/tmpbvi1nfwd.cpp:24: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            long top = stack.top();\n            stack.pop();\n            result.push_back(top - i);\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpln3_8kwz: /tmp/tmpln3_8kwz.cpp:24: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.size());\n                stack.pop();\n            }\n        }\n    }\n    if (!stack.empty()) {\n        result.push_back(stack.size());\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpbp984_rf: /tmp/tmpbp984_rf.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.size());\n                stack.pop();\n            }\n        }\n    }\n    if (!stack.empty()) {\n        result.push_back(stack.size());\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpbp984_rf: /tmp/tmpbp984_rf.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        }\n        else if (paren_string[i] == ')') {\n            long index = stack.top();\n            stack.pop();\n            result.push_back(index - i);\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmprhd08p9p: /tmp/tmprhd08p9p.cpp:25: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            long j = stack.top();\n            stack.pop();\n            result.push_back(j - i);\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292592,
      "stdout": "",
      "stderr": "tmp7xy5v7ze: /tmp/tmp7xy5v7ze.cpp:24: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292592,
      "stdout": "",
      "stderr": "tmpkpu4jtw9: /tmp/tmpkpu4jtw9.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp0gvray5i: /tmp/tmp0gvray5i.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            long index = stack.top();\n            stack.pop();\n            result.push_back(index - i);\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpbvi1nfwd: /tmp/tmpbvi1nfwd.cpp:24: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto it = paren_string.begin(); it != paren_string.end(); ++it) {\n        if (*it == '(') {\n            stack.push(1);\n        } else if (*it == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                stack.pop();\n                result.push_back(stack.top());\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto ch : paren_string) {\n        if (ch == '(') {\n            stack.push(ch);\n        } else if (ch == ')') {\n            if (stack.empty()) {\n                result.push_back(ch);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpva3tzy4d: /tmp/tmpva3tzy4d.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        }\n        else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            }\n            else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpxxr1lowk: /tmp/tmpxxr1lowk.cpp:28: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (stack.empty()) {\n                result.push_back(c);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpnb0nnhuv: /tmp/tmpnb0nnhuv.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto it = paren_string.begin(); it != paren_string.end(); ++it) {\n        if (*it == '(') {\n            stack.push(1);\n        } else if (*it == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                stack.pop();\n                result.push_back(stack.top());\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else {\n            if (stack.empty()) {\n                result.push_back(i - 1);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292587,
      "stdout": "",
      "stderr": "tmp019akj8l: /tmp/tmp019akj8l.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.top());\n                stack.pop();\n            }\n        }\n    }\n    if (!stack.empty()) {\n        result.push_back(stack.top());\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmpo4l75s_o: /tmp/tmpo4l75s_o.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto it = paren_string.begin(); it != paren_string.end(); ++it) {\n        if (*it == '(') {\n            stack.push(1);\n        } else if (*it == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                stack.pop();\n                result.push_back(stack.top());\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto ch : paren_string) {\n        if (ch == '(') {\n            stack.push(ch);\n        } else if (ch == ')') {\n            if (stack.empty()) {\n                result.push_back(ch);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    while (!stack.empty()) {\n        result.push_back(stack.top());\n        stack.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmp_7i57mzw: /tmp/tmp_7i57mzw.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(c);\n        } else {\n            if (stack.empty()) {\n                result.push_back(c - '0');\n            } else {\n                stack.pop();\n                result.push_back(c - '0');\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292592,
      "stdout": "",
      "stderr": "tmphfkuzbdf: /tmp/tmphfkuzbdf.cpp:27: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmprrvszi68: /tmp/tmprrvszi68.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(1);\n        } else if (c == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.top());\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292592,
      "stdout": "",
      "stderr": "tmp3tolbquf: /tmp/tmp3tolbquf.cpp:27: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(i);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    while (!stack.empty()) {\n        result.push_back(stack.top());\n        stack.pop();\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292587,
      "stdout": "",
      "stderr": "tmpkhol9_v7: /tmp/tmpkhol9_v7.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.top());\n                stack.pop();\n            }\n        }\n    }\n    if (!stack.empty()) {\n        result.push_back(stack.top());\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmpo4l75s_o: /tmp/tmpo4l75s_o.cpp:30: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            long level = stack.size();\n            stack.pop();\n            result.push_back(level);\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292592,
      "stdout": "",
      "stderr": "tmpbpl1kbjj: /tmp/tmpbpl1kbjj.cpp:24: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto ch : paren_string) {\n        if (ch == '(') {\n            stack.push(ch);\n        } else if (ch == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.top());\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpeo3srj2h: /tmp/tmpeo3srj2h.cpp:27: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto it = paren_string.begin(); it != paren_string.end(); ++it) {\n        if (*it == '(') {\n            stack.push(1);\n        } else if (*it == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                stack.pop();\n                result.push_back(stack.top());\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (stack.empty()) {\n                result.push_back(c);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpnb0nnhuv: /tmp/tmpnb0nnhuv.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        } else if (paren_string[i] == ')') {\n            long index = stack.top();\n            stack.pop();\n            result.push_back(index - i);\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpbvi1nfwd: /tmp/tmpbvi1nfwd.cpp:24: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(i);\n        }\n        else if (paren_string[i] == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            }\n            else {\n                result.push_back(stack.top());\n                stack.pop();\n            }\n        }\n    }\n    if (!stack.empty()) {\n        result.push_back(stack.top());\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292592,
      "stdout": "",
      "stderr": "tmpxgr2xrob: /tmp/tmpxgr2xrob.cpp:32: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto it = paren_string.begin(); it != paren_string.end(); ++it) {\n        if (*it == '(') {\n            stack.push(1);\n        } else if (*it == ')') {\n            stack.pop();\n        } else {\n            assert(stack.size() > 0);\n            result.push_back(stack.size());\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292592,
      "stdout": "",
      "stderr": "tmpy1zq6hoe: /tmp/tmpy1zq6hoe.cpp:17: std::vector<long int> parse_nested_parens(std::string): Assertion `stack.size() > 0' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    long level = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n            stack.push(level);\n            level++;\n        } else if (paren_string[i] == ')') {\n            level = stack.top();\n            stack.pop();\n        }\n    }\n    result.push_back(level);\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292592,
      "stdout": "",
      "stderr": "tmpkpuba8um: /tmp/tmpkpuba8um.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (stack.empty()) {\n                result.push_back(c);\n            } else {\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292588,
      "stdout": "",
      "stderr": "tmpnb0nnhuv: /tmp/tmpnb0nnhuv.cpp:26: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto c : paren_string) {\n        if (c == '(') {\n            stack.push(c);\n        } else if (c == ')') {\n            if (stack.empty()) {\n                result.push_back(0);\n            } else {\n                result.push_back(stack.top());\n                stack.pop();\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292590,
      "stdout": "",
      "stderr": "tmpwiyivct0: /tmp/tmpwiyivct0.cpp:27: int main(): Assertion `candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3}))' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function is a string represented multiple groups for nested parentheses separated by spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n// E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>> parse_nested_parens('(()()) ((())) () ((())()())')\n// [2, 3, 1, 3]\nstd::vector<long> parse_nested_parens(std::string paren_string) {\n    std::vector<long> result;\n    std::stack<long> stack;\n    for (auto it = paren_string.begin(); it != paren_string.end(); ++it) {\n        if (*it == '(') {\n            stack.push(1);\n        } else if (*it == ')') {\n            if (stack.empty()) {\n                result.push_back(1);\n            } else {\n                stack.pop();\n                result.push_back(stack.top());\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n",
      "timestamp": 1664292592,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    }
  ]
}