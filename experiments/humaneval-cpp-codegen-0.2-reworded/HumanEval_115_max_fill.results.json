{
  "name": "HumanEval_115_max_fill",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n",
  "tests": "}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j] + 1);\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < buckets.size(); ++i) {\n        if (buckets[i] > capacity) {\n            ans += buckets[i] - capacity;\n            buckets[i] = capacity;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "tmp6ero0gut: /tmp/tmp6ero0gut.cpp:44: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m, 0));\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n                dp[i][j] = 0;\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "tmpjikyr9ec: /tmp/tmpjikyr9ec.cpp:48: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], ans);\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], ans + 1);\n            }\n        }\n    }\n    return dp[0][0];\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "tmp5bqo_5m0: /tmp/tmp5bqo_5m0.cpp:52: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> used(grid.size(), 0);\n    std::vector<long> max_fill(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill[i] = std::max(max_fill[i], used[i]);\n                used[i] += 1;\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        result += max_fill[i] - used[i];\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "tmphkcgg0pn: /tmp/tmphkcgg0pn.cpp:43: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> used(grid.size(), 0);\n    std::vector<long> left(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++used[i];\n            }\n            if (grid[i][j] == 0) {\n                ++left[i];\n            }\n        }\n    }\n    long result = 0;\n    while (true) {\n        long max_left = 0;\n        for (int i = 0; i < grid.size(); ++i) {\n            if (used[i] == 0 && left[i] > max_left) {\n                max_left = left[i];\n            }\n        }\n        if (max_left == 0) {\n            break;\n        }\n        for (int i = 0; i < grid.size(); ++i) {\n            if (used[i] == 0 && left[i] == max_left) {\n                --left[i];\n                ++result;\n                break;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "tmp8iahn2rc: /tmp/tmp8iahn2rc.cpp:60: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], ans);\n            }\n        }\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "tmpfjioy_i_: /tmp/tmpfjioy_i_.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m, 0));\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "tmpkj4czlhb: /tmp/tmpkj4czlhb.cpp:47: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity - dp[i][j]);\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "tmpiahjodxu: /tmp/tmpiahjodxu.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), capacity);\n    std::vector<long> visited(grid.size(), 0);\n    std::vector<long> water_level(grid.size(), 0);\n    std::vector<long> water_level_next(grid.size(), 0);\n    std::vector<long> water_level_prev(grid.size(), 0);\n    std::vector<long> water_level_next_prev(grid.size(), 0);\n    std::vector<long> water_level_prev_next(grid.size(), 0);\n    std::vector<long> water_level_next_next(grid.size(), 0);\n    std::vector<long> water_level_prev_next_next(grid.size(), 0);\n    std::vector<long> water_level_prev_next_prev(grid.size(), 0);\n    std::vector<long> water_level_next_prev_prev(grid.size(), 0);\n    std::vector<long> water_level_next_next_prev(grid.size(), 0);\n    std::vector<long> water_level_prev_next_next_prev(grid.size(), 0);\n    std::vector<long> water_level_next_prev_next_next_prev(grid.size(), 0);\n    std::vector<long> water_level_prev_next_prev_next_next_prev(grid.size(), 0);\n    std::vector<long> water_level_next_prev_prev_next_next_prev_next(grid.size(), 0);\n    std::vector<long> water_level_prev_next_prev_next_next_prev_next_prev(grid.size(), 0);\n    std::vector<long> water_level_next_prev_prev_next_next_prev_next_prev_next(grid.size(), 0);\n    std::vector<long> water_level_prev_next_prev_next_next_prev_next_prev_next_prev(grid.size(), 0);\n    std::vector<long> water_level_next_prev_prev_next_next_prev_next_prev_next_prev_prev(grid.size\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "/tmp/tmptleef3da.cpp: In function \u2018long int max_fill(std::vector<std::vector<long int> >, long int)\u2019:\n/tmp/tmptleef3da.cpp:44:99: error: expected \u2018)\u2019 before \u2018}\u2019 token\n   44 |     std::vector<long> water_level_next_prev_prev_next_next_prev_next_prev_next_prev_prev(grid.size\n      |                                                                                         ~         ^\n      |                                                                                                   )\n   45 | }\n      | ~                                                                                                  \n/tmp/tmptleef3da.cpp:45:1: error: expected \u2018,\u2019 or \u2018;\u2019 before \u2018}\u2019 token\n   45 | }\n      | ^\n/tmp/tmptleef3da.cpp:45:1: warning: no return statement in function returning non-void [-Wreturn-type]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), capacity);\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n                for (int k = 0; k < grid.size(); ++k) {\n                    if (k != i) {\n                        if (grid[k][j] == 1) {\n                            dp[i][j] = std::min(dp[i][j], dp[k][j] + 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                for (int k = 0; k < grid.size(); ++k) {\n                    if (k != i) {\n                        if (grid[k][j] == 1) {\n                            buckets[k] = std::min(buckets[k], dp[i][j] - 1);\n                        }\n                    }\n                }\n                ans = std::max(ans, buckets[i]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "tmpu8ho8ibe: /tmp/tmpu8ho8ibe.cpp:60: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "tmpbawlrryi: /tmp/tmpbawlrryi.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "tmpxmgjjc1l: /tmp/tmpxmgjjc1l.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n                for (int k = 0; k < grid.size(); ++k) {\n                    for (int l = 0; l < grid[0].size(); ++l) {\n                        if (grid[k][l] == 1) {\n                            dp[i][j] = std::max(dp[i][j], dp[k][l] + 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "tmp2nnm19qg: /tmp/tmp2nnm19qg.cpp:52: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n            }\n        }\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long ans = 0;\n    std::vector<long> used(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (used[i] < capacity) {\n                    used[i]++;\n                } else {\n                    ans++;\n                    used[i] = 0;\n                }\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "tmpxn6lqtyv: /tmp/tmpxn6lqtyv.cpp:43: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                std::vector<std::pair<int, int>> well;\n                well.push_back(std::make_pair(i, j));\n                while (!well.empty()) {\n                    auto p = well.back();\n                    well.pop_back();\n                    if (p.first > 0) {\n                        if (grid[p.first - 1][p.second] == 1) {\n                            grid[p.first - 1][p.second] = 0;\n                            well.push_back(std::make_pair(p.first - 1, p.second));\n                        }\n                    }\n                    if (p.first < grid.size() - 1) {\n                        if (grid[p.first + 1][p.second] == 1) {\n                            grid[p.first + 1][p.second] = 0;\n                            well.push_back(std::make_pair(p.first + 1, p.second));\n                        }\n                    }\n                    if (p.second > 0) {\n                        if (grid[p.first][p.second - 1] == 1) {\n                            grid[p.first][p.second - 1] = 0;\n                            well.push_back(std::make_pair(p.first, p.second - 1));\n                        }\n                    }\n                    if (p.second < grid[p.first].size() - 1) {\n                        if (grid[p.first][p.second + 1] == 1) {\n                            grid[p.first][p.second + 1] = 0;\n                            well.push_back(std::make_pair(p.first, p.second + 1));\n                        }\n                    }\n                }\n                max_fill += well.size();\n            }\n        }\n    }\n    return max_fill;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "tmp3916i10f: /tmp/tmp3916i10f.cpp:67: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n            }\n        }\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                result = std::max(result, dp[i][j]);\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "tmp0lm6__65: /tmp/tmp0lm6__65.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long ans = 0;\n    while (true) {\n        for (int i = 0; i < buckets.size(); ++i) {\n            if (buckets[i] > 0) {\n                --buckets[i];\n                ++ans;\n                break;\n            }\n        }\n        if (buckets.empty()) {\n            break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292924,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long ans = 0;\n    while (true) {\n        for (int i = 0; i < grid.size(); ++i) {\n            if (buckets[i] > 0) {\n                --buckets[i];\n                --buckets[i];\n                ++ans;\n            }\n        }\n        if (buckets.empty()) {\n            break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292924,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292911,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity - dp[i][j]);\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "tmpiahjodxu: /tmp/tmpiahjodxu.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> used(grid.size(), 0);\n    std::vector<long> max_fill(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill[i] += capacity;\n                used[i] += capacity;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 0 && used[i] > max_fill[i]) {\n                max_fill[i] = used[i];\n            }\n        }\n    }\n    long max = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        if (max_fill[i] > max) {\n            max = max_fill[i];\n        }\n    }\n    return max;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292911,
      "stdout": "",
      "stderr": "tmpeuj2x5_t: /tmp/tmpeuj2x5_t.cpp:52: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292911,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "tmpbawlrryi: /tmp/tmpbawlrryi.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292911,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                std::vector<std::pair<int, int>> buckets;\n                for (int k = 0; k < grid.size(); ++k) {\n                    for (int l = 0; l < grid[k].size(); ++l) {\n                        if (grid[k][l] == 1) {\n                            buckets.push_back(std::make_pair(k, l));\n                        }\n                    }\n                }\n                std::sort(buckets.begin(), buckets.end(), [](const std::pair<int, int>& a, const std::pair<int, int>& b) {\n                    return a.second < b.second;\n                });\n                for (int k = 0; k < buckets.size(); ++k) {\n                    int i = buckets[k].first;\n                    int j = buckets[k].second;\n                    if (i == j) {\n                        continue;\n                    }\n                    long left = grid[i][j] - 1;\n                    long right = grid[i][j] + 1;\n                    long left_fill = 0;\n                    long right_fill = 0;\n                    for (int m = i - 1; m >= 0; --m) {\n                        if (grid[m][j] == 1) {\n                            left_fill += grid[m][j];\n                        }\n                        if (grid[m][j] == 0) {\n                            break;\n                        }\n                    }\n                    for (int m = i + 1; m < grid.size(); ++m) {\n                        if (grid[m][j] == 1) {\n                            right_fill += grid[m][j];\n                        }\n                        if (grid[m][j] == 0) {\n                            break;\n                        }\n                    }\n                    max_fill = std::max(max_fill, std::max(left_fill, right_fill));\n                    grid[i][j] = 0;\n                }\n                max_fill = std\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292911,
      "stdout": "",
      "stderr": "/tmp/tmp86z6y8ql.cpp: In function \u2018long int max_fill(std::vector<std::vector<long int> >, long int)\u2019:\n/tmp/tmp86z6y8ql.cpp:70:1: error: expected primary-expression before \u2018}\u2019 token\n   70 | }\n      | ^\n/tmp/tmp86z6y8ql.cpp:71:12: error: a function-definition is not allowed here before \u2018{\u2019 token\n   71 | int main() {\n      |            ^\n/tmp/tmp86z6y8ql.cpp:78:1: error: expected \u2018}\u2019 at end of input\n   78 | }\n      | ^\n/tmp/tmp86z6y8ql.cpp:27:50: note: to match this \u2018{\u2019\n   27 |         for (int j = 0; j < grid[i].size(); ++j) {\n      |                                                  ^\n/tmp/tmp86z6y8ql.cpp:78:1: error: expected \u2018}\u2019 at end of input\n   78 | }\n      | ^\n/tmp/tmp86z6y8ql.cpp:26:43: note: to match this \u2018{\u2019\n   26 |     for (int i = 0; i < grid.size(); ++i) {\n      |                                           ^\n/tmp/tmp86z6y8ql.cpp:78:1: error: expected \u2018}\u2019 at end of input\n   78 | }\n      | ^\n/tmp/tmp86z6y8ql.cpp:24:67: note: to match this \u2018{\u2019\n   24 | long max_fill(std::vector<std::vector<long>> grid, long capacity) {\n      |                                                                   ^\n/tmp/tmp86z6y8ql.cpp:78:1: warning: no return statement in function returning non-void [-Wreturn-type]\n   78 | }\n      | ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292911,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), capacity);\n    std::vector<long> max_buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                int cur_bucket = i * grid.size() + j;\n                int max_bucket = max_buckets[i];\n                if (max_bucket < cur_bucket) {\n                    max_buckets[i] = cur_bucket;\n                }\n                buckets[i] -= 1;\n                if (buckets[i] < 0) {\n                    buckets[i] = 0;\n                }\n            }\n        }\n    }\n    long count = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                int cur_bucket = i * grid.size() + j;\n                if (max_buckets[i] == cur_bucket) {\n                    count += 1;\n                }\n            }\n        }\n    }\n    return count;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292911,
      "stdout": "",
      "stderr": "tmpw6594ivh: /tmp/tmpw6594ivh.cpp:57: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> used(grid.size(), 0);\n    std::vector<long> used_row(grid[0].size(), 0);\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (used[i] < capacity) {\n                    used[i] += 1;\n                }\n                if (used_row[j] < capacity) {\n                    used_row[j] += 1;\n                }\n            }\n        }\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (used[i] < capacity) {\n                    used[i] += 1;\n                }\n                if (used_row[j] < capacity) {\n                    used_row[j] += 1;\n                }\n            }\n        }\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (used[i] < capacity) {\n                    used[i] += 1;\n                }\n                if (used_row[j] < capacity) {\n                    used_row[j] += 1;\n                }\n            }\n        }\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (used[i] < capacity) {\n                    used[i] += 1;\n                }\n                if (used_row[j] < capacity) {\n                    used_row[j] += 1;\n                }\n            }\n        }\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (used[i] < capacity) {\n                    used[i] += 1;\n                }\n                if (used_row[j] < capacity) {\n                    used_\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292911,
      "stdout": "",
      "stderr": "/tmp/tmp7q15aiup.cpp: In function \u2018long int max_fill(std::vector<std::vector<long int> >, long int)\u2019:\n/tmp/tmp7q15aiup.cpp:75:21: error: \u2018used_\u2019 was not declared in this scope; did you mean \u2018used\u2019?\n   75 |                     used_\n      |                     ^~~~~\n      |                     used\n/tmp/tmp7q15aiup.cpp:77:12: error: a function-definition is not allowed here before \u2018{\u2019 token\n   77 | int main() {\n      |            ^\n/tmp/tmp7q15aiup.cpp:84:1: error: expected \u2018}\u2019 at end of input\n   84 | }\n      | ^\n/tmp/tmp7q15aiup.cpp:70:34: note: to match this \u2018{\u2019\n   70 |             if (grid[i][j] == 1) {\n      |                                  ^\n/tmp/tmp7q15aiup.cpp:84:1: error: expected \u2018}\u2019 at end of input\n   84 | }\n      | ^\n/tmp/tmp7q15aiup.cpp:69:50: note: to match this \u2018{\u2019\n   69 |         for (int j = 0; j < grid[i].size(); ++j) {\n      |                                                  ^\n/tmp/tmp7q15aiup.cpp:84:1: error: expected \u2018}\u2019 at end of input\n   84 | }\n      | ^\n/tmp/tmp7q15aiup.cpp:28:43: note: to match this \u2018{\u2019\n   28 |     for (int i = 0; i < grid.size(); ++i) {\n      |                                           ^\n/tmp/tmp7q15aiup.cpp:84:1: error: expected \u2018}\u2019 at end of input\n   84 | }\n      | ^\n/tmp/tmp7q15aiup.cpp:24:67: note: to match this \u2018{\u2019\n   24 | long max_fill(std::vector<std::vector<long>> grid, long capacity) {\n      |                                                                   ^\n/tmp/tmp7q15aiup.cpp:84:1: warning: no return statement in function returning non-void [-Wreturn-type]\n   84 | }\n      | ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                std::vector<std::pair<int, int>> buckets;\n                for (int k = 0; k < grid.size(); ++k) {\n                    for (int l = 0; l < grid[k].size(); ++l) {\n                        if (grid[k][l] == 1) {\n                            buckets.push_back(std::make_pair(k, l));\n                        }\n                    }\n                }\n                long fill = 0;\n                while (fill < capacity) {\n                    fill += std::min(buckets.back().first, buckets.back().second);\n                    buckets.pop_back();\n                }\n                max_fill = std::max(max_fill, fill);\n            }\n        }\n    }\n    return max_fill;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292911,
      "stdout": "",
      "stderr": "tmpd9p0p7d2: /tmp/tmpd9p0p7d2.cpp:50: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> used(grid.size(), 0);\n    std::vector<long> buckets(grid.size(), 0);\n    long max_buckets = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++used[i];\n                ++buckets[i];\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1 && used[i] == 0) {\n                --buckets[i];\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1 && buckets[i] == 0) {\n                --buckets[i];\n                --used[i];\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1 && buckets[i] == 0) {\n                --buckets[i];\n                --used[i];\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1 && buckets[i] == 0) {\n                --buckets[i];\n                --used[i];\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1 && buckets[i] == 0)\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292911,
      "stdout": "",
      "stderr": "/tmp/tmpvkk0069o.cpp: In function \u2018long int max_fill(std::vector<std::vector<long int> >, long int)\u2019:\n/tmp/tmpvkk0069o.cpp:70:1: error: expected primary-expression before \u2018}\u2019 token\n   70 | }\n      | ^\n/tmp/tmpvkk0069o.cpp:71:12: error: a function-definition is not allowed here before \u2018{\u2019 token\n   71 | int main() {\n      |            ^\n/tmp/tmpvkk0069o.cpp:78:1: error: expected \u2018}\u2019 at end of input\n   78 | }\n      | ^\n/tmp/tmpvkk0069o.cpp:67:43: note: to match this \u2018{\u2019\n   67 |     for (int i = 0; i < grid.size(); ++i) {\n      |                                           ^\n/tmp/tmpvkk0069o.cpp:78:1: error: expected \u2018}\u2019 at end of input\n   78 | }\n      | ^\n/tmp/tmpvkk0069o.cpp:24:67: note: to match this \u2018{\u2019\n   24 | long max_fill(std::vector<std::vector<long>> grid, long capacity) {\n      |                                                                   ^\n/tmp/tmpvkk0069o.cpp:78:1: warning: no return statement in function returning non-void [-Wreturn-type]\n   78 | }\n      | ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                max_fill = std::max(max_fill, fill(grid, i, j, capacity));\n            }\n        }\n    }\n    return max_fill;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292911,
      "stdout": "",
      "stderr": "/tmp/tmpsy3epm9q.cpp: In function \u2018long int max_fill(std::vector<std::vector<long int> >, long int)\u2019:\n/tmp/tmpsy3epm9q.cpp:29:72: error: no matching function for call to \u2018fill(std::vector<std::vector<long int> >&, int&, int&, long int&)\u2019\n   29 |                 max_fill = std::max(max_fill, fill(grid, i, j, capacity));\n      |                                                                        ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpsy3epm9q.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:742:5: note: candidate: \u2018template<class _ForwardIterator, class _Tp> void std::fill(_ForwardIterator, _ForwardIterator, const _Tp&)\u2019\n  742 |     fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)\n      |     ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:742:5: note:   template argument deduction/substitution failed:\n/tmp/tmpsy3epm9q.cpp:29:72: note:   deduced conflicting types for parameter \u2018_ForwardIterator\u2019 (\u2018std::vector<std::vector<long int> >\u2019 and \u2018int\u2019)\n   29 |                 max_fill = std::max(max_fill, fill(grid, i, j, capacity));\n      |                                                                        ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:68,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/functional:62,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/pstl/glue_algorithm_defs.h:13,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:71,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n                 from /tmp/tmpsy3epm9q.cpp:2:\n/shar",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                result = std::max(result, dp[i][j]);\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292911,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] -= 1;\n                ans += 1;\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292911,
      "stdout": "",
      "stderr": "tmpmueyqgzq: /tmp/tmpmueyqgzq.cpp:47: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                buckets[i] += capacity;\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < buckets.size(); ++i) {\n        if (buckets[i] > 0) {\n            result += buckets[i];\n            buckets[i] = 0;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292911,
      "stdout": "",
      "stderr": "tmpmjgoti3i: /tmp/tmpmjgoti3i.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                result += max_fill(grid, i, j, capacity);\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292911,
      "stdout": "",
      "stderr": "/tmp/tmp0zodpw6b.cpp: In function \u2018long int max_fill(std::vector<std::vector<long int> >, long int)\u2019:\n/tmp/tmp0zodpw6b.cpp:29:56: error: too many arguments to function \u2018long int max_fill(std::vector<std::vector<long int> >, long int)\u2019\n   29 |                 result += max_fill(grid, i, j, capacity);\n      |                                                        ^\n/tmp/tmp0zodpw6b.cpp:24:6: note: declared here\n   24 | long max_fill(std::vector<std::vector<long>> grid, long capacity) {\n      |      ^~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    std::vector<long> used(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long ans = 0;\n    while (true) {\n        for (int i = 0; i < grid.size(); ++i) {\n            for (int j = 0; j < grid[i].size(); ++j) {\n                if (grid[i][j] == 1) {\n                    if (buckets[i] > 0) {\n                        --buckets[i];\n                        ++used[i];\n                        if (--buckets[i] == 0) {\n                            --used[i];\n                        }\n                    }\n                }\n            }\n        }\n        if (std::all_of(used.begin(), used.end(), [](long x) { return x == 0; })) {\n            break;\n        }\n        ++ans;\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292926,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292911,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> used(grid.size(), 0);\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                long cur_fill = 0;\n                while (cur_fill < grid[i].size() && grid[i][j] == 1) {\n                    ++cur_fill;\n                    ++used[i];\n                    --grid[i][j];\n                }\n                max_fill = std::max(max_fill, cur_fill);\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                --used[i];\n            }\n        }\n    }\n    return max_fill;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292911,
      "stdout": "",
      "stderr": "tmp1by5kjve: /tmp/tmp1by5kjve.cpp:51: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    std::vector<long> max_buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n                max_buckets[i] = std::max(max_buckets[i], buckets[i]);\n            }\n        }\n    }\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (buckets[i] < max_buckets[i]) {\n                    --buckets[i];\n                    ++max_fill;\n                }\n            }\n        }\n    }\n    return max_fill;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292911,
      "stdout": "",
      "stderr": "tmpdik4i164: /tmp/tmpdik4i164.cpp:50: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill += capacity;\n                while (max_fill > grid[i][j]) {\n                    max_fill -= grid[i][j];\n                    grid[i][j] = 0;\n                }\n            }\n        }\n    }\n    return max_fill;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292926,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    std::vector<long> well_count(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        well_count[i] = grid[i][0];\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 1; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++well_count[i];\n            }\n            if (well_count[i] > 0) {\n                buckets[i] += capacity;\n                --well_count[i];\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        if (well_count[i] > 0) {\n            result += buckets[i];\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292911,
      "stdout": "",
      "stderr": "tmpntgkhqa4: /tmp/tmpntgkhqa4.cpp:51: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long ans = 0;\n    while (true) {\n        for (int i = 0; i < buckets.size(); ++i) {\n            if (buckets[i] > 0) {\n                --buckets[i];\n                ++ans;\n                break;\n            }\n        }\n        if (buckets.empty()) {\n            break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292924,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n                buckets[i] += 1;\n            }\n        }\n    }\n    while (buckets[0] > 0) {\n        for (int i = 0; i < grid.size(); ++i) {\n            for (int j = 0; j < grid[i].size(); ++j) {\n                if (grid[i][j] == 1) {\n                    if (buckets[i] > 0) {\n                        dp[i][j] = std::max(dp[i][j], dp[i][j - 1] + 1);\n                    }\n                    if (buckets[i] > capacity) {\n                        dp[i][j] = std::max(dp[i][j], dp[i - 1][j] + 1);\n                    }\n                }\n            }\n        }\n        buckets[0] -= 1;\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292913,
      "stdout": "",
      "stderr": "tmp29t0nk8g: /tmp/tmp29t0nk8g.cpp:54: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[i].size(), 0));\n                dp[i][j] = 1;\n                for (int k = i - 1; k >= 0; --k) {\n                    if (grid[k][j] == 1) {\n                        dp[k][j] = 1;\n                    }\n                }\n                for (int k = i + 1; k < grid.size(); ++k) {\n                    if (grid[k][j] == 1) {\n                        dp[k][j] = 1;\n                    }\n                }\n                for (int k = j - 1; k >= 0; --k) {\n                    if (grid[i][k] == 1) {\n                        dp[i][k] = 1;\n                    }\n                }\n                for (int k = j + 1; k < grid[i].size(); ++k) {\n                    if (grid[i][k] == 1) {\n                        dp[i][k] = 1;\n                    }\n                }\n                for (int k = 0; k < dp.size(); ++k) {\n                    for (int l = 0; l < dp[k].size(); ++l) {\n                        if (dp[k][l] == 1) {\n                            dp[k][l] = dp[k][l] + dp[i][j];\n                        }\n                    }\n                }\n                max_fill = std::max(max_fill, dp[0][0]);\n            }\n        }\n    }\n    return max_fill;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292913,
      "stdout": "",
      "stderr": "tmpjyrucs16: /tmp/tmpjyrucs16.cpp:66: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    long count = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    for (int i = 0; i < buckets.size(); ++i) {\n        if (buckets[i] > 0) {\n            count += buckets[i] * capacity;\n            buckets[i] = 0;\n        }\n    }\n    return count;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292913,
      "stdout": "",
      "stderr": "tmphd2xgksf: /tmp/tmphd2xgksf.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> used(grid.size(), 0);\n    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++used[i];\n                ++buckets[i];\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 0 && buckets[i] > 0 && used[i] < capacity) {\n                --buckets[i];\n                --used[i];\n                ++result;\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292913,
      "stdout": "",
      "stderr": "tmp1jr8nehw: /tmp/tmp1jr8nehw.cpp:49: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                for (int k = 0; k < grid.size(); k++) {\n                    for (int l = 0; l < grid[k].size(); l++) {\n                        if (grid[k][l] == 1) {\n                            dp[i][j] = std::max(dp[i][j], dp[k][l] + 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292913,
      "stdout": "",
      "stderr": "tmp7xr8u802: /tmp/tmp7xr8u802.cpp:58: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                result = std::max(result, dp[i][j]);\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292913,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += max_fill(grid, i, j, capacity);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292913,
      "stdout": "",
      "stderr": "/tmp/tmp5fko4ayr.cpp: In function \u2018long int max_fill(std::vector<std::vector<long int> >, long int)\u2019:\n/tmp/tmp5fko4ayr.cpp:29:53: error: too many arguments to function \u2018long int max_fill(std::vector<std::vector<long int> >, long int)\u2019\n   29 |                 ans += max_fill(grid, i, j, capacity);\n      |                                                     ^\n/tmp/tmp5fko4ayr.cpp:24:6: note: declared here\n   24 | long max_fill(std::vector<std::vector<long>> grid, long capacity) {\n      |      ^~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    std::vector<long> max_buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                buckets[i] += capacity;\n            }\n            max_buckets[i] = std::max(max_buckets[i], buckets[i]);\n        }\n    }\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill = std::max(max_fill, max_buckets[i] - buckets[i]);\n            }\n        }\n    }\n    return max_fill;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292913,
      "stdout": "",
      "stderr": "tmpdu5ntrys: /tmp/tmpdu5ntrys.cpp:47: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> used(grid.size(), 0);\n    std::vector<long> max_fill(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill[i] = std::max(max_fill[i], used[i]);\n            }\n            if (grid[i][j] == 0) {\n                used[i]++;\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        ans += std::min(max_fill[i], used[i]) - std::max(max_fill[i], used[i]);\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292913,
      "stdout": "",
      "stderr": "tmp98qlk_h1: /tmp/tmp98qlk_h1.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> used(grid.size(), 0);\n    std::vector<long> max_well(grid.size(), 0);\n    std::vector<long> max_well_index(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_well[i] = std::max(max_well[i], j);\n                max_well_index[i] = i;\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = max_well[i]; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (used[i] < capacity) {\n                    used[i] += 1;\n                    ans += 1;\n                } else {\n                    used[max_well_index[i]] -= 1;\n                    used[i] -= 1;\n                    ans += 1;\n                }\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292913,
      "stdout": "",
      "stderr": "/tmp/tmpnihk7sn3.cpp: In function \u2018long int max_fill(std::vector<std::vector<long int> >, long int)\u2019:\n/tmp/tmpnihk7sn3.cpp:31:54: error: no matching function for call to \u2018max(__gnu_cxx::__alloc_traits<std::allocator<long int>, long int>::value_type&, int&)\u2019\n   31 |                 max_well[i] = std::max(max_well[i], j);\n      |                                                      ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpnihk7sn3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:222:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::max(const _Tp&, const _Tp&)\u2019\n  222 |     max(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:222:5: note:   template argument deduction/substitution failed:\n/tmp/tmpnihk7sn3.cpp:31:54: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   31 |                 max_well[i] = std::max(max_well[i], j);\n      |                                                      ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpnihk7sn3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:268:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::max(const _Tp&, const _Tp&, _Compare)\u2019\n  268 |     max(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n                for (int k = 0; k < grid.size(); ++k) {\n                    if (i != k && grid[k][j] == 1) {\n                        dp[i][j] = std::max(dp[i][j], dp[k][j] + 1);\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292913,
      "stdout": "",
      "stderr": "tmp0l0mka_b: /tmp/tmp0l0mka_b.cpp:50: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), capacity);\n    std::vector<long> well_count(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++well_count[i];\n                buckets[i] -= 1;\n            }\n        }\n    }\n    long max_count = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (well_count[i] > 0 && buckets[i] > 0) {\n                buckets[i] -= 1;\n                --well_count[i];\n                max_count += 1;\n            }\n        }\n    }\n    return max_count;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292913,
      "stdout": "",
      "stderr": "tmpzx0gc_5o: /tmp/tmpzx0gc_5o.cpp:49: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m, 0));\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] -= 1;\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292913,
      "stdout": "",
      "stderr": "tmptn766brg: /tmp/tmptn766brg.cpp:48: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(capacity, 0);\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                buckets[0]++;\n            } else {\n                for (int k = 0; k < capacity; k++) {\n                    if (buckets[k] > 0) {\n                        buckets[k]--;\n                        max_fill++;\n                        break;\n                    }\n                }\n            }\n        }\n    }\n    return max_fill;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292913,
      "stdout": "",
      "stderr": "tmp_osq6gw8: /tmp/tmp_osq6gw8.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n            else {\n                dp[i][j] = 0;\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292913,
      "stdout": "",
      "stderr": "tmpnsoha8__: /tmp/tmpnsoha8__.cpp:48: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m, 0));\n    dp[0][0] = 1;\n    for (int i = 1; i < n; ++i) {\n        for (int j = 1; j < m; ++j) {\n            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j] > capacity ? dp[i][j] - capacity : 0;\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292913,
      "stdout": "",
      "stderr": "tmpktilcwvv: /tmp/tmpktilcwvv.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            for (int k = 0; k < grid.size(); ++k) {\n                for (int l = 0; l < grid[0].size(); ++l) {\n                    if (grid[k][l] == 1) {\n                        dp[i][j] = std::max(dp[i][j], dp[k][l] + 1);\n                    }\n                }\n            }\n        }\n    }\n    return dp[0][0];\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292913,
      "stdout": "",
      "stderr": "tmpp3i611m9: /tmp/tmpp3i611m9.cpp:48: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "tmpxmgjjc1l: /tmp/tmpxmgjjc1l.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long max_buckets = 0;\n    for (int i = 0; i < buckets.size(); ++i) {\n        if (buckets[i] > max_buckets) {\n            max_buckets = buckets[i];\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < buckets.size(); ++i) {\n        if (buckets[i] == max_buckets) {\n            ans += max_buckets;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292913,
      "stdout": "",
      "stderr": "tmpwq5259pd: /tmp/tmpwq5259pd.cpp:49: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    std::vector<long> visited(grid.size(), 0);\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                visited[i] = 1;\n                buckets[i] += 1;\n                if (buckets[i] > capacity) {\n                    max_fill += 1;\n                    buckets[i] -= capacity;\n                }\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        if (visited[i] == 0) {\n            for (int j = 0; j < grid[i].size(); ++j) {\n                if (grid[i][j] == 1) {\n                    buckets[i] += 1;\n                    if (buckets[i] > capacity) {\n                        max_fill += 1;\n                        buckets[i] -= capacity;\n                    }\n                }\n            }\n        }\n    }\n    return max_fill;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292913,
      "stdout": "",
      "stderr": "tmphf19u00e: /tmp/tmphf19u00e.cpp:57: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    std::vector<long> max_buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                buckets[i] += 1;\n                max_buckets[i] += capacity;\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < buckets.size(); ++i) {\n        if (buckets[i] > max_buckets[i]) {\n            result += buckets[i] - max_buckets[i];\n            buckets[i] = max_buckets[i];\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292915,
      "stdout": "",
      "stderr": "tmpepkads0n: /tmp/tmpepkads0n.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    std::vector<long> used(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (buckets[i] > 0) {\n                    --buckets[i];\n                    ++used[i];\n                    if (used[i] == capacity) {\n                        max_fill += capacity;\n                        used[i] = 0;\n                    }\n                }\n            }\n        }\n    }\n    return max_fill;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292915,
      "stdout": "",
      "stderr": "tmpg08qrtr1: /tmp/tmpg08qrtr1.cpp:54: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 0) {\n                for (int k = 0; k < grid.size(); ++k) {\n                    for (int l = 0; l < grid[0].size(); ++l) {\n                        if (grid[k][l] == 1) {\n                            dp[i][j] = std::max(dp[i][j], dp[k][l] + 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 0) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292915,
      "stdout": "",
      "stderr": "tmpz0sn6ny7: /tmp/tmpz0sn6ny7.cpp:58: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> well_capacity(grid.size(), capacity);\n    std::vector<long> well_count(grid.size(), 0);\n    std::vector<long> well_water(grid.size(), 0);\n    std::vector<long> well_water_count(grid.size(), 0);\n    std::vector<long> well_water_capacity(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                well_count[i]++;\n                well_water[i] += well_capacity[i];\n                well_water_count[i] += well_capacity[i];\n                well_water_capacity[i] += well_capacity[i];\n            }\n        }\n    }\n    std::vector<long> well_water_count_new(grid.size(), 0);\n    std::vector<long> well_water_capacity_new(grid.size(), 0);\n    std::vector<long> well_water_count_new_new(grid.size(), 0);\n    std::vector<long> well_water_capacity_new_new(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (well_count[i] > 0) {\n                well_water_count_new[i] += well_water_count[i];\n                well_water_capacity_new[i] += well_water_capacity[i];\n                well_water_count_new_new[i] += well_water_count[i];\n                well_water_capacity_new_new[i] += well_water_capacity[i];\n            }\n        }\n    }\n    long max_well_water_count = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        if (well_water_count_new[i] > max_well_water_count)\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292914,
      "stdout": "",
      "stderr": "/tmp/tmp_irtc1yr.cpp: In function \u2018long int max_fill(std::vector<std::vector<long int> >, long int)\u2019:\n/tmp/tmp_irtc1yr.cpp:57:1: error: expected primary-expression before \u2018}\u2019 token\n   57 | }\n      | ^\n/tmp/tmp_irtc1yr.cpp:58:12: error: a function-definition is not allowed here before \u2018{\u2019 token\n   58 | int main() {\n      |            ^\n/tmp/tmp_irtc1yr.cpp:65:1: error: expected \u2018}\u2019 at end of input\n   65 | }\n      | ^\n/tmp/tmp_irtc1yr.cpp:24:67: note: to match this \u2018{\u2019\n   24 | long max_fill(std::vector<std::vector<long>> grid, long capacity) {\n      |                                                                   ^\n/tmp/tmp_irtc1yr.cpp:65:1: warning: no return statement in function returning non-void [-Wreturn-type]\n   65 | }\n      | ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 0) {\n                continue;\n            }\n            for (int k = 0; k < grid.size(); ++k) {\n                for (int l = 0; l < grid[0].size(); ++l) {\n                    if (grid[k][l] == 1) {\n                        dp[i][j] = std::max(dp[i][j], dp[k][l] + 1);\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 0) {\n                continue;\n            }\n            ans = std::max(ans, dp[i][j]);\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292915,
      "stdout": "",
      "stderr": "tmp3h085ct7: /tmp/tmp3h085ct7.cpp:60: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                for (int k = 0; k < grid.size(); ++k) {\n                    for (int l = 0; l < grid[k].size(); ++l) {\n                        if (grid[k][l] == 1) {\n                            dp[i][j] = std::max(dp[i][j], dp[k][l] + 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                result += dp[i][j];\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292915,
      "stdout": "",
      "stderr": "tmpfqx79poq: /tmp/tmpfqx79poq.cpp:58: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "tmpbawlrryi: /tmp/tmpbawlrryi.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> used(grid.size(), 0);\n    std::vector<long> max_fill(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill[i] = std::max(max_fill[i], used[i]);\n            }\n            if (grid[i][j] == 0) {\n                used[i] = 0;\n            } else {\n                used[i] += 1;\n            }\n        }\n    }\n    long max_fill_count = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        if (max_fill[i] < capacity) {\n            max_fill_count += 1;\n        }\n    }\n    return max_fill_count;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292915,
      "stdout": "",
      "stderr": "tmpdnxsh20j: /tmp/tmpdnxsh20j.cpp:49: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> used(grid.size(), 0);\n    std::vector<long> max_fill(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill[i] += capacity;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                used[i] += max_fill[i];\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                result += max_fill[i] - used[i];\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292915,
      "stdout": "",
      "stderr": "tmp0uwls28h: /tmp/tmp0uwls28h.cpp:53: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292915,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                std::vector<std::pair<int, int>> well;\n                well.push_back(std::make_pair(i, j));\n                while (!well.empty()) {\n                    auto p = well.back();\n                    well.pop_back();\n                    if (grid[p.first][p.second] == 0) {\n                        continue;\n                    }\n                    grid[p.first][p.second] = 0;\n                    max_fill += 1;\n                    if (grid[p.first][p.second] == 0) {\n                        well.push_back(std::make_pair(p.first, p.second));\n                    }\n                    if (grid[p.first][p.second] == 1) {\n                        well.push_back(std::make_pair(p.first, p.second));\n                    }\n                }\n            }\n        }\n    }\n    return max_fill;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292915,
      "stdout": "",
      "stderr": "tmpdxuji0_0: /tmp/tmpdxuji0_0.cpp:54: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> well_capacity(grid.size(), capacity);\n    std::vector<long> well_count(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                well_count[i]++;\n                well_capacity[i]--;\n            }\n        }\n    }\n    std::vector<long> well_count_new(grid.size(), 0);\n    std::vector<long> well_capacity_new(grid.size(), capacity);\n    while (well_count_new != well_count) {\n        for (int i = 0; i < grid.size(); ++i) {\n            if (well_count_new[i] < well_count[i]) {\n                well_count_new[i]++;\n                well_capacity_new[i]--;\n                break;\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        if (well_capacity_new[i] < 0) {\n            result++;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292915,
      "stdout": "",
      "stderr": "tmp0kor3sh_: /tmp/tmp0kor3sh_.cpp:56: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(capacity, 0);\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n                for (int k = 0; k < capacity; ++k) {\n                    if (k < buckets[j]) {\n                        dp[i][j] = std::max(dp[i][j], dp[i][j - 1] + 1);\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                for (int k = 0; k < capacity; ++k) {\n                    if (k < buckets[j]) {\n                        buckets[j]--;\n                        ans = std::max(ans, dp[i][j]);\n                        buckets[j]++;\n                    }\n                }\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292915,
      "stdout": "",
      "stderr": "tmp7t0113y8: /tmp/tmp7t0113y8.cpp:57: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    std::vector<long> visited(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long ans = 0;\n    while (true) {\n        for (int i = 0; i < grid.size(); ++i) {\n            for (int j = 0; j < grid[i].size(); ++j) {\n                if (grid[i][j] == 1 && visited[i] < buckets[i]) {\n                    --buckets[i];\n                    ++visited[i];\n                    if (buckets[i] == 0) {\n                        --ans;\n                    }\n                }\n            }\n        }\n        if (ans == 0) {\n            break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292930,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity - dp[i][j]);\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292915,
      "stdout": "",
      "stderr": "tmpo9nfccb6: /tmp/tmpo9nfccb6.cpp:48: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], ans);\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], ans);\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], ans);\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], ans);\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1)\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292915,
      "stdout": "",
      "stderr": "/tmp/tmpswjhpdn6.cpp: In function \u2018long int max_fill(std::vector<std::vector<long int> >, long int)\u2019:\n/tmp/tmpswjhpdn6.cpp:65:1: error: expected primary-expression before \u2018}\u2019 token\n   65 | }\n      | ^\n/tmp/tmpswjhpdn6.cpp:66:12: error: a function-definition is not allowed here before \u2018{\u2019 token\n   66 | int main() {\n      |            ^\n/tmp/tmpswjhpdn6.cpp:73:1: error: expected \u2018}\u2019 at end of input\n   73 | }\n      | ^\n/tmp/tmpswjhpdn6.cpp:62:43: note: to match this \u2018{\u2019\n   62 |     for (int i = 0; i < grid.size(); ++i) {\n      |                                           ^\n/tmp/tmpswjhpdn6.cpp:73:1: error: expected \u2018}\u2019 at end of input\n   73 | }\n      | ^\n/tmp/tmpswjhpdn6.cpp:24:67: note: to match this \u2018{\u2019\n   24 | long max_fill(std::vector<std::vector<long>> grid, long capacity) {\n      |                                                                   ^\n/tmp/tmpswjhpdn6.cpp:73:1: warning: no return statement in function returning non-void [-Wreturn-type]\n   73 | }\n      | ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<long> dp(m, 0);\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                dp[j] = std::max(dp[j], dp[j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (long i = 0; i < m; ++i) {\n        ans = std::max(ans, dp[i]);\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292915,
      "stdout": "",
      "stderr": "tmpagxmdddc: /tmp/tmpagxmdddc.cpp:43: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m, 0));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == 0) {\n                continue;\n            }\n            for (int k = 0; k < 4; ++k) {\n                int r = i + dp[i][j];\n                int c = j + dp[i][j];\n                if (r >= 0 && r < n && c >= 0 && c < m && grid[r][c] == 1) {\n                    dp[r][c] = std::max(dp[r][c], dp[i][j] + 1);\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292915,
      "stdout": "",
      "stderr": "tmp79xgdvzl: /tmp/tmp79xgdvzl.cpp:61: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity - dp[i][j]);\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292915,
      "stdout": "",
      "stderr": "tmpmoig1she: /tmp/tmpmoig1she.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    for (long i = 0; i < grid.size(); ++i) {\n        for (long j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                buckets[i] += capacity;\n            }\n        }\n    }\n    long ans = 0;\n    for (long i = 0; i < grid.size(); ++i) {\n        for (long j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += buckets[i];\n                buckets[i] = 0;\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292915,
      "stdout": "",
      "stderr": "tmppinhljuf: /tmp/tmppinhljuf.cpp:47: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n                dp[i][j] = 0;\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292917,
      "stdout": "",
      "stderr": "tmpq5rsf64u: /tmp/tmpq5rsf64u.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < buckets.size(); ++i) {\n        if (buckets[i] > 0) {\n            buckets[i]--;\n            result += buckets[i];\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292917,
      "stdout": "",
      "stderr": "tmpqul2wa8n: /tmp/tmpqul2wa8n.cpp:44: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                for (int k = 0; k < grid.size(); ++k) {\n                    for (int l = 0; l < grid[0].size(); ++l) {\n                        if (grid[k][l] == 1) {\n                            dp[i][j] = std::max(dp[i][j], dp[k][l] + 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292917,
      "stdout": "",
      "stderr": "tmpq4o3ckwb: /tmp/tmpq4o3ckwb.cpp:58: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    std::vector<long> max_buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                buckets[i] += 1;\n                max_buckets[i] += capacity;\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        if (buckets[i] > max_buckets[i]) {\n            ans += buckets[i] - max_buckets[i];\n            buckets[i] = max_buckets[i];\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292917,
      "stdout": "",
      "stderr": "tmp8j5w5o9s: /tmp/tmp8j5w5o9s.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(capacity, 0);\n    std::vector<long> used(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++used[i];\n                buckets[grid[i][j]] += 1;\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < buckets.size(); ++i) {\n        if (buckets[i] > used[i]) {\n            result += buckets[i] - used[i];\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292917,
      "stdout": "",
      "stderr": "tmpz2oo7bj4: /tmp/tmpz2oo7bj4.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j] + 1);\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292917,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n                dp[i][j] = 0;\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292917,
      "stdout": "",
      "stderr": "tmpq5rsf64u: /tmp/tmpq5rsf64u.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    long count = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (buckets[i] < capacity) {\n                    ++count;\n                    --buckets[i];\n                }\n            }\n        }\n    }\n    return count;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292917,
      "stdout": "",
      "stderr": "tmp6u0tmhio: /tmp/tmp6u0tmhio.cpp:48: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity - dp[i][j]);\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "tmpiahjodxu: /tmp/tmpiahjodxu.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity - dp[i][j]);\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "tmpiahjodxu: /tmp/tmpiahjodxu.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 0;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292917,
      "stdout": "",
      "stderr": "tmpbl57pzfh: /tmp/tmpbl57pzfh.cpp:52: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    std::vector<long> max_buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_buckets[i] = std::max(max_buckets[i], buckets[i]);\n            }\n        }\n    }\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill = std::max(max_fill, max_buckets[i] - buckets[i]);\n            }\n        }\n    }\n    return max_fill;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292917,
      "stdout": "",
      "stderr": "tmpulsgmn61: /tmp/tmpulsgmn61.cpp:53: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), capacity);\n    std::vector<long> used(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++used[i];\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (--buckets[i] == 0) {\n                    ++ans;\n                    buckets[i] = capacity;\n                }\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292917,
      "stdout": "",
      "stderr": "tmpmkrt0y1z: /tmp/tmpmkrt0y1z.cpp:50: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), capacity);\n    std::vector<long> used(grid.size(), 0);\n    std::vector<long> well_count(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++well_count[i];\n                ++buckets[i];\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (well_count[i] > 0) {\n                    --well_count[i];\n                    --buckets[i];\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (buckets[i] > 0) {\n                    --buckets[i];\n                    ++ans;\n                }\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292917,
      "stdout": "",
      "stderr": "tmpd_4oatwm: /tmp/tmpd_4oatwm.cpp:61: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity - dp[i][j]);\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "tmpiahjodxu: /tmp/tmpiahjodxu.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                std::vector<std::vector<long>> new_grid = grid;\n                new_grid[i][j] = 0;\n                long fill = max_fill_well(new_grid, capacity);\n                max_fill = std::max(max_fill, fill);\n            }\n        }\n    }\n    return max_fill;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292917,
      "stdout": "",
      "stderr": "/tmp/tmp4h33b5f3.cpp: In function \u2018long int max_fill(std::vector<std::vector<long int> >, long int)\u2019:\n/tmp/tmp4h33b5f3.cpp:31:29: error: \u2018max_fill_well\u2019 was not declared in this scope; did you mean \u2018max_fill\u2019?\n   31 |                 long fill = max_fill_well(new_grid, capacity);\n      |                             ^~~~~~~~~~~~~\n      |                             max_fill\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m, 0));\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 0;\n            }\n            ans += dp[i][j];\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292917,
      "stdout": "",
      "stderr": "tmpk5hen_i4: /tmp/tmpk5hen_i4.cpp:48: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n                for (int k = 0; k < grid.size(); k++) {\n                    for (int l = 0; l < grid[0].size(); l++) {\n                        if (grid[k][l] == 1) {\n                            dp[i][j] = std::max(dp[i][j], dp[k][l] + 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292917,
      "stdout": "",
      "stderr": "tmpya3cqv24: /tmp/tmpya3cqv24.cpp:52: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n                for (int k = 0; k < grid.size(); ++k) {\n                    if (i != k && grid[k][j] == 1) {\n                        dp[i][j] = std::max(dp[i][j], dp[k][j] + 1);\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292917,
      "stdout": "",
      "stderr": "tmp8vz6_pv8: /tmp/tmp8vz6_pv8.cpp:50: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    std::vector<long> well_count(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++well_count[i];\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                buckets[i] += well_count[i];\n            }\n        }\n    }\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill = std::max(max_fill, buckets[i] - well_count[i]);\n            }\n        }\n    }\n    return max_fill;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292917,
      "stdout": "",
      "stderr": "tmpmu56d1bp: /tmp/tmpmu56d1bp.cpp:53: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "tmpxmgjjc1l: /tmp/tmpxmgjjc1l.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                result += std::min(dp[i][j], dp[i][j] - 1);\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292917,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            } else {\n                dp[i][j] = std::max(dp[i][j], dp[i][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (dp[i][j] > capacity) {\n                ans += dp[i][j] - capacity;\n                dp[i][j] = capacity;\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292917,
      "stdout": "",
      "stderr": "tmp_6viwmv3: /tmp/tmp_6viwmv3.cpp:48: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += max_fill_helper(grid, i, j, capacity);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292918,
      "stdout": "",
      "stderr": "/tmp/tmpq4jfq99i.cpp: In function \u2018long int max_fill(std::vector<std::vector<long int> >, long int)\u2019:\n/tmp/tmpq4jfq99i.cpp:29:24: error: \u2018max_fill_helper\u2019 was not declared in this scope\n   29 |                 ans += max_fill_helper(grid, i, j, capacity);\n      |                        ^~~~~~~~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m, 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (grid[i][j] == 0) {\n                dp[i][j] = 0;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (dp[i][j] == 0) {\n                continue;\n            }\n            for (int k = 0; k < m; k++) {\n                if (grid[i][k] == 1) {\n                    dp[i][j] = std::max(dp[i][j], dp[i][k] + 1);\n                }\n            }\n            for (int k = 0; k < m; k++) {\n                if (grid[k][j] == 1) {\n                    dp[i][j] = std::max(dp[i][j], dp[k][j] + 1);\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (dp[i][j] > capacity) {\n                ans += dp[i][j] - capacity;\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292919,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill = std::max(max_fill, fill(grid, i, j, capacity));\n            }\n        }\n    }\n    return max_fill;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292919,
      "stdout": "",
      "stderr": "/tmp/tmp9qizdgme.cpp: In function \u2018long int max_fill(std::vector<std::vector<long int> >, long int)\u2019:\n/tmp/tmp9qizdgme.cpp:29:72: error: no matching function for call to \u2018fill(std::vector<std::vector<long int> >&, int&, int&, long int&)\u2019\n   29 |                 max_fill = std::max(max_fill, fill(grid, i, j, capacity));\n      |                                                                        ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmp9qizdgme.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:742:5: note: candidate: \u2018template<class _ForwardIterator, class _Tp> void std::fill(_ForwardIterator, _ForwardIterator, const _Tp&)\u2019\n  742 |     fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value)\n      |     ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:742:5: note:   template argument deduction/substitution failed:\n/tmp/tmp9qizdgme.cpp:29:72: note:   deduced conflicting types for parameter \u2018_ForwardIterator\u2019 (\u2018std::vector<std::vector<long int> >\u2019 and \u2018int\u2019)\n   29 |                 max_fill = std::max(max_fill, fill(grid, i, j, capacity));\n      |                                                                        ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/vector:68,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/functional:62,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/pstl/glue_algorithm_defs.h:13,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:71,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n                 from /tmp/tmp9qizdgme.cpp:2:\n/shar",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                for (int k = 0; k < grid.size(); ++k) {\n                    for (int l = 0; l < grid[k].size(); ++l) {\n                        if (grid[k][l] == 1) {\n                            if (buckets[k] < capacity) {\n                                buckets[k] += dp[i][j];\n                                dp[i][j] = 0;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += buckets[i];\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292919,
      "stdout": "",
      "stderr": "tmp64h6uqoz: /tmp/tmp64h6uqoz.cpp:63: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                for (int k = 0; k < grid.size(); k++) {\n                    for (int l = 0; l < grid[k].size(); l++) {\n                        if (grid[k][l] == 0 && dp[i][j] < dp[i][l] + dp[k][l]) {\n                            dp[i][j] = dp[i][l] + dp[k][l];\n                        }\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j] * capacity;\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292919,
      "stdout": "",
      "stderr": "tmpgdqxdttw: /tmp/tmpgdqxdttw.cpp:59: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> used(grid.size(), 0);\n    std::vector<long> max_fill(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill[i] = std::max(max_fill[i], used[i]);\n            }\n            if (grid[i][j] == 0) {\n                used[i] += capacity;\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        ans += max_fill[i] - used[i];\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292919,
      "stdout": "",
      "stderr": "tmpinvvbgzp: /tmp/tmpinvvbgzp.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292915,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                buckets[i] += capacity;\n            }\n        }\n    }\n    long max = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max = std::max(max, buckets[i] - capacity);\n            }\n        }\n    }\n    return max;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292919,
      "stdout": "",
      "stderr": "tmppa_75l62: /tmp/tmppa_75l62.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    long n = grid.size();\n    long m = grid[0].size();\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                buckets[i] += capacity;\n            }\n        }\n    }\n    long result = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                long cur = buckets[i];\n                long next = buckets[i] + capacity;\n                if (next > cur) {\n                    buckets[i] = next;\n                    result += 1;\n                }\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292919,
      "stdout": "",
      "stderr": "tmplyyfzin9: /tmp/tmplyyfzin9.cpp:53: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    std::vector<long> well_size(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        well_size[i] = grid[i].size();\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (buckets[i] < well_size[i]) {\n                    ++ans;\n                    --buckets[i];\n                }\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292919,
      "stdout": "",
      "stderr": "tmpgg8iok3r: /tmp/tmpgg8iok3r.cpp:52: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "tmpxmgjjc1l: /tmp/tmpxmgjjc1l.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<long> dp(n, 0);\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                dp[i] = std::max(dp[i], dp[i - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (long i = 0; i < n; ++i) {\n        if (dp[i] < capacity) {\n            ans += capacity - dp[i];\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292919,
      "stdout": "",
      "stderr": "tmpkr6q1f0z: /tmp/tmpkr6q1f0z.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292919,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[i].size(), 0));\n                dp[i][j] = 1;\n                for (int k = 0; k < grid.size(); ++k) {\n                    for (int l = 0; l < grid[k].size(); ++l) {\n                        if (k == i && l == j) continue;\n                        if (grid[k][l] == 1) {\n                            dp[k][l] = std::max(dp[k][l], dp[i][j] + 1);\n                        }\n                    }\n                }\n                max_fill = std::max(max_fill, dp[i][j]);\n            }\n        }\n    }\n    return max_fill;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292919,
      "stdout": "",
      "stderr": "tmpnbr4pajc: /tmp/tmpnbr4pajc.cpp:47: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292919,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292919,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292919,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), capacity);\n    std::vector<long> visited(grid.size(), 0);\n    std::vector<long> max_visited(grid.size(), 0);\n    std::vector<long> max_buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                std::vector<std::pair<int, int>> neighbors = {\n                    std::make_pair(i-1, j),\n                    std::make_pair(i, j-1),\n                    std::make_pair(i+1, j),\n                    std::make_pair(i, j+1)\n                };\n                for (auto neighbor : neighbors) {\n                    if (neighbor.first >= 0 && neighbor.first < grid.size() &&\n                        neighbor.second >= 0 && neighbor.second < grid[i].size() &&\n                        grid[neighbor.first][neighbor.second] == 1) {\n                        buckets[i] -= 1;\n                        buckets[neighbor.first] -= 1;\n                        visited[i] += 1;\n                        visited[neighbor.first] += 1;\n                        if (buckets[i] < 0) {\n                            buckets[i] = 0;\n                        }\n                        if (buckets[neighbor.first] < 0) {\n                            buckets[neighbor.first] = 0;\n                        }\n                        if (visited[i] > max_visited[i]) {\n                            max_visited[i] = visited[i];\n                        }\n                        if (visited[neighbor.first] > max_visited[neighbor.first]) {\n                            max_visited[neighbor.first] = visited[neighbor.first];\n                        }\n                        if (buckets[i] > max_buckets[i]) {\n                            max_buckets[i] = buckets[i];\n                        }\n                        if (buckets[neighbor.first\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292919,
      "stdout": "",
      "stderr": "/tmp/tmpbqusn61k.cpp: In function \u2018long int max_fill(std::vector<std::vector<long int> >, long int)\u2019:\n/tmp/tmpbqusn61k.cpp:61:51: error: expected \u2018]\u2019 before \u2018}\u2019 token\n   61 |                         if (buckets[neighbor.first\n      |                                                   ^\n      |                                                   ]\n   62 | }\n      | ~                                                  \n/tmp/tmpbqusn61k.cpp:61:51: error: expected \u2018)\u2019 before \u2018}\u2019 token\n   61 |                         if (buckets[neighbor.first\n      |                            ~                      ^\n      |                                                   )\n   62 | }\n      | ~                                                  \n/tmp/tmpbqusn61k.cpp:62:1: error: expected primary-expression before \u2018}\u2019 token\n   62 | }\n      | ^\n/tmp/tmpbqusn61k.cpp:63:12: error: a function-definition is not allowed here before \u2018{\u2019 token\n   63 | int main() {\n      |            ^\n/tmp/tmpbqusn61k.cpp:70:1: error: expected \u2018}\u2019 at end of input\n   70 | }\n      | ^\n/tmp/tmpbqusn61k.cpp:38:49: note: to match this \u2018{\u2019\n   38 |                 for (auto neighbor : neighbors) {\n      |                                                 ^\n/tmp/tmpbqusn61k.cpp:70:1: error: expected \u2018}\u2019 at end of input\n   70 | }\n      | ^\n/tmp/tmpbqusn61k.cpp:31:34: note: to match this \u2018{\u2019\n   31 |             if (grid[i][j] == 1) {\n      |                                  ^\n/tmp/tmpbqusn61k.cpp:70:1: error: expected \u2018}\u2019 at end of input\n   70 | }\n      | ^\n/tmp/tmpbqusn61k.cpp:30:50: note: to match this \u2018{\u2019\n   30 |         for (int j = 0; j < grid[i].size(); ++j) {\n      |                                                  ^\n/tmp/tmpbqusn61k.cpp:70:1: error: expected \u2018}\u2019 at end of input\n   70 | }\n      | ^\n/tmp/tmpbqusn61k.cpp:29:43: note: to match this \u2018{\u2019\n   29 |     for (int i = 0; i < grid.size(); ++i) {\n      |                                           ^\n/tmp/tmpbqusn61k.cpp:70:1: error: expected \u2018}\u2019 at end o",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < buckets.size(); ++i) {\n        if (buckets[i] > capacity) {\n            result += buckets[i] - capacity;\n            buckets[i] = capacity;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292919,
      "stdout": "",
      "stderr": "tmpja55e9s4: /tmp/tmpja55e9s4.cpp:44: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] -= 1;\n                ans += 1;\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292911,
      "stdout": "",
      "stderr": "tmpmueyqgzq: /tmp/tmpmueyqgzq.cpp:47: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292919,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(capacity + 1, 0);\n    for (auto& row : grid) {\n        for (long i = 0; i < row.size(); ++i) {\n            if (row[i] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long result = 0;\n    for (long i = 0; i < buckets.size(); ++i) {\n        if (buckets[i] > 0) {\n            result += buckets[i] * i;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292919,
      "stdout": "",
      "stderr": "tmpgyz4iz68: /tmp/tmpgyz4iz68.cpp:43: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long result = 0;\n    while (true) {\n        for (int i = 0; i < buckets.size(); ++i) {\n            if (buckets[i] > 0) {\n                --buckets[i];\n                ++result;\n                break;\n            }\n        }\n        if (buckets.empty()) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> used(grid.size(), 0);\n    std::vector<long> max_fill(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill[i] = std::max(max_fill[i], used[i]);\n            }\n            if (grid[i][j] == 0) {\n                used[i] += capacity;\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        ans = std::max(ans, max_fill[i] - used[i]);\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292921,
      "stdout": "",
      "stderr": "tmp8a35g2q_: /tmp/tmp8a35g2q_.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity - dp[i][j]);\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "tmpiahjodxu: /tmp/tmpiahjodxu.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                for (int k = 0; k < grid.size(); ++k) {\n                    for (int l = 0; l < grid[0].size(); ++l) {\n                        if (grid[k][l] == 0) {\n                            dp[k][l] = std::max(dp[k][l], dp[i][j] + 1);\n                        }\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292921,
      "stdout": "",
      "stderr": "tmp4fgya0qe: /tmp/tmp4fgya0qe.cpp:58: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> used(grid.size(), 0);\n    std::vector<long> used_row(grid[0].size(), 0);\n    std::vector<long> used_col(grid[0].size(), 0);\n    std::vector<long> used_well(grid[0].size(), 0);\n    std::vector<long> used_well_row(grid[0].size(), 0);\n    std::vector<long> used_well_col(grid[0].size(), 0);\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                used[i] += 1;\n                used_row[j] += 1;\n                used_col[j] += 1;\n                used_well[j] += 1;\n                used_well_row[i] += 1;\n                used_well_col[i] += 1;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                if (used[i] == capacity) {\n                    max_fill += 1;\n                }\n                if (used_row[j] == capacity) {\n                    max_fill += 1;\n                }\n                if (used_col[j] == capacity) {\n                    max_fill += 1;\n                }\n                if (used_well[j] == capacity) {\n                    max_fill += 1;\n                }\n                if (used_well_row[i] == capacity) {\n                    max_fill += 1;\n                }\n                if (used_well_col[i] == capacity) {\n                    max_fill += 1;\n                }\n            }\n        }\n    }\n    return max_fill;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292921,
      "stdout": "",
      "stderr": "tmpk43a92hc: /tmp/tmpk43a92hc.cpp:72: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity - dp[i][j]);\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "tmpiahjodxu: /tmp/tmpiahjodxu.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292911,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long max_buckets = 0;\n    for (int i = 0; i < buckets.size(); ++i) {\n        if (buckets[i] > max_buckets) {\n            max_buckets = buckets[i];\n        }\n    }\n    long count = 0;\n    for (int i = 0; i < buckets.size(); ++i) {\n        if (buckets[i] == max_buckets) {\n            count += max_buckets;\n            for (int j = 0; j < grid.size(); ++j) {\n                if (grid[j][i] == 1) {\n                    --buckets[j];\n                }\n            }\n        }\n    }\n    return count;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292921,
      "stdout": "",
      "stderr": "tmp7nb83zyp: /tmp/tmp7nb83zyp.cpp:54: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<long> used(m, 0);\n    std::vector<long> used_row(n, 0);\n    std::vector<long> used_col(m, 0);\n    long ans = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                ++used_row[i];\n                ++used_col[j];\n            }\n        }\n    }\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                if (used_row[i] > 0) {\n                    --used_row[i];\n                    ++used[j];\n                }\n                if (used_col[j] > 0) {\n                    --used_col[j];\n                    ++used[j];\n                }\n            }\n        }\n    }\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                if (used[j] > 0) {\n                    --used[j];\n                    ++ans;\n                }\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292921,
      "stdout": "",
      "stderr": "tmpetiaes2_: /tmp/tmpetiaes2_.cpp:68: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292921,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<long> dp(m, 0);\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                dp[j] = std::max(dp[j], 1 + max_fill(grid, capacity - 1));\n            }\n        }\n    }\n    return std::max(dp[m - 1], 0);\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292921,
      "stdout": "",
      "stderr": "/tmp/tmpbkqg_uvf.cpp: In function \u2018long int max_fill(std::vector<std::vector<long int> >, long int)\u2019:\n/tmp/tmpbkqg_uvf.cpp:35:33: error: no matching function for call to \u2018max(__gnu_cxx::__alloc_traits<std::allocator<long int>, long int>::value_type&, int)\u2019\n   35 |     return std::max(dp[m - 1], 0);\n      |                                 ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpbkqg_uvf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:222:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::max(const _Tp&, const _Tp&)\u2019\n  222 |     max(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:222:5: note:   template argument deduction/substitution failed:\n/tmp/tmpbkqg_uvf.cpp:35:33: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018int\u2019)\n   35 |     return std::max(dp[m - 1], 0);\n      |                                 ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmpbkqg_uvf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:268:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::max(const _Tp&, const _Tp&, _Compare)\u2019\n  268 |     max(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:268:5: note:   template argument deduction/substitution failed:\n/tmp/tmpbkqg_uvf.cpp:",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> used(grid.size(), 0);\n    std::vector<long> max_fill(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill[i] += capacity;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                long max_fill_i = max_fill[i];\n                for (int k = j + 1; k < grid[i].size(); ++k) {\n                    if (grid[i][k] == 1) {\n                        max_fill_i += max_fill[k];\n                    }\n                }\n                if (max_fill_i > max_fill[j]) {\n                    max_fill[j] = max_fill_i;\n                }\n            }\n        }\n    }\n    long max_fill_count = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        if (max_fill[i] > 0) {\n            max_fill_count += max_fill[i];\n        }\n    }\n    return max_fill_count;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292921,
      "stdout": "",
      "stderr": "tmpsa_jb9la: /tmp/tmpsa_jb9la.cpp:59: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    std::vector<long> visited(grid.size(), 0);\n    std::vector<long> well_count(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                well_count[i]++;\n                buckets[i]++;\n                if (buckets[i] > capacity) {\n                    buckets[i] = 0;\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        if (well_count[i] > 0) {\n            for (int j = 0; j < grid[i].size(); ++j) {\n                if (grid[i][j] == 1 && visited[i] == 0) {\n                    visited[i] = 1;\n                    ans += well_count[i];\n                    buckets[i]--;\n                    if (buckets[i] < 0) {\n                        buckets[i] = 0;\n                    }\n                    break;\n                }\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292921,
      "stdout": "",
      "stderr": "tmptni86p19: /tmp/tmptni86p19.cpp:60: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                std::vector<std::pair<int, int>> well_pos;\n                well_pos.push_back(std::make_pair(i, j));\n                while (!well_pos.empty()) {\n                    auto pos = well_pos.back();\n                    well_pos.pop_back();\n                    if (grid[pos.first][pos.second] == 0) {\n                        grid[pos.first][pos.second] = -1;\n                    } else {\n                        grid[pos.first][pos.second]--;\n                        if (grid[pos.first][pos.second] == 0) {\n                            well_pos.push_back(std::make_pair(pos.first, pos.second));\n                        }\n                    }\n                }\n                max_fill = std::max(max_fill, well_pos.size());\n            }\n        }\n    }\n    return max_fill;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292921,
      "stdout": "",
      "stderr": "/tmp/tmp10tdlnbe.cpp: In function \u2018long int max_fill(std::vector<std::vector<long int> >, long int)\u2019:\n/tmp/tmp10tdlnbe.cpp:43:62: error: no matching function for call to \u2018max(long int&, std::vector<std::pair<int, int> >::size_type)\u2019\n   43 |                 max_fill = std::max(max_fill, well_pos.size());\n      |                                                              ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmp10tdlnbe.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:222:5: note: candidate: \u2018template<class _Tp> constexpr const _Tp& std::max(const _Tp&, const _Tp&)\u2019\n  222 |     max(const _Tp& __a, const _Tp& __b)\n      |     ^~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:222:5: note:   template argument deduction/substitution failed:\n/tmp/tmp10tdlnbe.cpp:43:62: note:   deduced conflicting types for parameter \u2018const _Tp\u2019 (\u2018long int\u2019 and \u2018std::vector<std::pair<int, int> >::size_type\u2019 {aka \u2018long unsigned int\u2019})\n   43 |                 max_fill = std::max(max_fill, well_pos.size());\n      |                                                              ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmp10tdlnbe.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:268:5: note: candidate: \u2018template<class _Tp, class _Compare> constexpr const _Tp& std::max(const _Tp&, const _Tp&, _Compare)\u2019\n  268 |     max(const _Tp& __a, const _Tp& __b, _Compare __comp)\n      |   ",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<long> dp(m, 0);\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                dp[j] = std::max(dp[j], dp[j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (long i = 0; i < m; ++i) {\n        ans = std::max(ans, dp[i]);\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292915,
      "stdout": "",
      "stderr": "tmpagxmdddc: /tmp/tmpagxmdddc.cpp:43: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m, 0));\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (long i = 0; i < n; i++) {\n        for (long j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292921,
      "stdout": "",
      "stderr": "tmp5oamfkkp: /tmp/tmp5oamfkkp.cpp:47: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "tmpxmgjjc1l: /tmp/tmpxmgjjc1l.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long ans = 0;\n    while (true) {\n        for (int i = 0; i < buckets.size(); ++i) {\n            if (buckets[i] > 0) {\n                --buckets[i];\n                ++ans;\n            }\n        }\n        if (buckets.back() == 0) {\n            break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292921,
      "stdout": "",
      "stderr": "tmp28mgg7t0: /tmp/tmp28mgg7t0.cpp:50: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> well_count(grid.size(), 0);\n    std::vector<long> well_capacity(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            well_count[i] += grid[i][j];\n            well_capacity[i] += capacity;\n        }\n    }\n    std::vector<long> well_remaining(grid.size(), 0);\n    std::vector<long> well_water(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        well_remaining[i] = well_count[i];\n        well_water[i] = 0;\n    }\n    std::vector<std::vector<long>> well_buckets(grid.size(), std::vector<long>(capacity, 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            well_buckets[i][well_water[i]++] = j;\n        }\n    }\n    long result = 0;\n    while (well_remaining.size() > 0) {\n        std::vector<long> next_well_remaining(well_remaining);\n        for (int i = 0; i < well_remaining.size(); ++i) {\n            if (well_remaining[i] > 0) {\n                long bucket = well_buckets[i][well_remaining[i] - 1];\n                well_remaining[i]--;\n                well_water[i]--;\n                well_buckets[i][well_water[i]] = bucket;\n                well_remaining[well_buckets[i][well_water[i]]]++;\n                well_water[well_buckets[i][well_water[i]]]++;\n            }\n        }\n        result += well_remaining.size();\n        well_remaining = next_well_remaining;\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292921,
      "stdout": "",
      "stderr": "*** Error in `/tmp/tmp1d4ebf0s': munmap_chunk(): invalid pointer: 0x0000000001400e10 ***\n======= Backtrace: =========\n/lib64/libc.so.6(+0x7f474)[0x2b8e6d942474]\n/tmp/tmp1d4ebf0s[0x403b0c]\n/tmp/tmp1d4ebf0s[0x403679]\n/tmp/tmp1d4ebf0s[0x402dca]\n/tmp/tmp1d4ebf0s[0x402a3c]\n/tmp/tmp1d4ebf0s[0x402277]\n/tmp/tmp1d4ebf0s[0x4010b0]\n/tmp/tmp1d4ebf0s[0x401432]\n/lib64/libc.so.6(__libc_start_main+0xf5)[0x2b8e6d8e5555]\n/tmp/tmp1d4ebf0s[0x400959]\n======= Memory map: ========\n00400000-00407000 r-xp 00000000 08:02 3611                               /tmp/tmp1d4ebf0s\n00606000-00607000 r--p 00006000 08:02 3611                               /tmp/tmp1d4ebf0s\n00607000-00608000 rw-p 00007000 08:02 3611                               /tmp/tmp1d4ebf0s\n013ef000-01442000 rw-p 00000000 00:00 0                                  [heap]\n2b8e6cdac000-2b8e6cdce000 r-xp 00000000 08:01 50331915                   /usr/lib64/ld-2.17.so\n2b8e6cdce000-2b8e6cdd1000 rw-p 00000000 00:00 0 \n2b8e6cde9000-2b8e6cdee000 rw-p 00000000 00:00 0 \n2b8e6cfcd000-2b8e6",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m, 0));\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292921,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                result = std::max(result, dp[i][j]);\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292921,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292921,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> used(grid.size(), 0);\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                long cur_fill = 0;\n                while (cur_fill < grid[i].size() && grid[i][j] == 1) {\n                    ++cur_fill;\n                    ++used[i];\n                    ++used[j];\n                    if (cur_fill == grid[i].size()) {\n                        break;\n                    }\n                    if (grid[i][j] == 1) {\n                        ++used[i];\n                        ++used[j];\n                    }\n                }\n                max_fill = std::max(max_fill, cur_fill);\n            }\n        }\n    }\n    for (int i = 0; i < used.size(); ++i) {\n        if (used[i] == 0) {\n            return max_fill;\n        }\n    }\n    return max_fill + (capacity - used.size());\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292921,
      "stdout": "",
      "stderr": "tmp84po0j57: /tmp/tmp84po0j57.cpp:56: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            for (int k = 0; k < grid.size(); ++k) {\n                for (int l = 0; l < grid[k].size(); ++l) {\n                    if (grid[k][l] == 1) {\n                        dp[i][j] = std::max(dp[i][j], dp[i][l] + dp[k][j]);\n                    }\n                }\n            }\n        }\n    }\n    return dp[0][0] - 1;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292923,
      "stdout": "",
      "stderr": "tmplhpd_ufa: /tmp/tmplhpd_ufa.cpp:48: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), capacity);\n    std::vector<long> used(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++used[i];\n                buckets[i] -= 1;\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        if (buckets[i] > 0) {\n            result += 1;\n            buckets[i] -= 1;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292923,
      "stdout": "",
      "stderr": "tmpolic8ugw: /tmp/tmpolic8ugw.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long ans = 0;\n    while (true) {\n        for (int i = 0; i < grid.size(); ++i) {\n            if (buckets[i] > 0) {\n                --buckets[i];\n                ++ans;\n            }\n        }\n        if (buckets.empty()) {\n            break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292937,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                max_fill += 1;\n                if (max_fill > capacity) {\n                    max_fill -= 1;\n                    break;\n                }\n            }\n        }\n    }\n    return max_fill;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292923,
      "stdout": "",
      "stderr": "tmp408_5ozl: /tmp/tmp408_5ozl.cpp:41: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292915,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity - dp[i][j]);\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "tmpiahjodxu: /tmp/tmpiahjodxu.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    std::vector<long> visited(grid.size(), 0);\n    std::vector<long> visited_row(grid[0].size(), 0);\n    std::vector<long> visited_col(grid[0].size(), 0);\n    long count = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                count++;\n                visited[i] = 1;\n                visited_row[j] = 1;\n                visited_col[j] = 1;\n                buckets[i]++;\n                if (buckets[i] > capacity) {\n                    buckets[i] = capacity;\n                }\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (visited[i] == 1 && visited_row[j] == 1 && visited_col[j] == 1) {\n                buckets[i]--;\n                if (buckets[i] < 0) {\n                    buckets[i] = 0;\n                }\n            }\n        }\n    }\n    return count;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292923,
      "stdout": "",
      "stderr": "tmp3ayl92lh: /tmp/tmp3ayl92lh.cpp:59: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292911,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long ans = 0;\n    while (true) {\n        for (int i = 0; i < grid.size(); ++i) {\n            if (buckets[i] > 0) {\n                --buckets[i];\n                --ans;\n            }\n        }\n        if (ans == 0) {\n            break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292938,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n                buckets[i] += 1;\n                if (buckets[i] > capacity) {\n                    buckets[i] = 0;\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (dp[i][j] == 1) {\n                ans += 1;\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292923,
      "stdout": "",
      "stderr": "tmp2kmf3kpl: /tmp/tmp2kmf3kpl.cpp:51: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292923,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long result = 0;\n    while (true) {\n        for (int i = 0; i < buckets.size(); ++i) {\n            if (buckets[i] > 0) {\n                --buckets[i];\n                ++result;\n                break;\n            }\n        }\n        if (buckets.empty()) {\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292935,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                std::vector<std::pair<int, int>> buckets;\n                for (int k = 0; k < grid.size(); ++k) {\n                    for (int l = 0; l < grid[k].size(); ++l) {\n                        if (grid[k][l] == 1) {\n                            buckets.push_back(std::make_pair(k, l));\n                        }\n                    }\n                }\n                std::sort(buckets.begin(), buckets.end(), [](const std::pair<int, int>& a, const std::pair<int, int>& b) {\n                    return a.first < b.first || (a.first == b.first && a.second < b.second);\n                });\n                for (int k = 0; k < buckets.size(); ++k) {\n                    if (buckets[k].first == i && buckets[k].second == j) {\n                        continue;\n                    }\n                    std::vector<std::pair<int, int>> new_buckets;\n                    for (int l = 0; l < buckets.size(); ++l) {\n                        if (buckets[l].first == i || buckets[l].second == j) {\n                            continue;\n                        }\n                        new_buckets.push_back(buckets[l]);\n                    }\n                    std::sort(new_buckets.begin(), new_buckets.end(), [](const std::pair<int, int>& a, const std::pair<int, int>& b) {\n                        return a.first < b.first || (a.first == b.first && a.second < b.second);\n                    });\n                    long num_buckets = new_buckets.size();\n                    long num_water = num_buckets * capacity;\n                    if (num_water > buckets[k].first * buckets[k].second) {\n                        result += num_buckets - 1;\n                        break;\n                    }\n\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292923,
      "stdout": "",
      "stderr": "/tmp/tmp4zms5jl7.cpp: In function \u2018long int max_fill(std::vector<std::vector<long int> >, long int)\u2019:\n/tmp/tmp4zms5jl7.cpp:62:12: error: a function-definition is not allowed here before \u2018{\u2019 token\n   62 | int main() {\n      |            ^\n/tmp/tmp4zms5jl7.cpp:69:1: error: expected \u2018}\u2019 at end of input\n   69 | }\n      | ^\n/tmp/tmp4zms5jl7.cpp:28:34: note: to match this \u2018{\u2019\n   28 |             if (grid[i][j] == 1) {\n      |                                  ^\n/tmp/tmp4zms5jl7.cpp:69:1: error: expected \u2018}\u2019 at end of input\n   69 | }\n      | ^\n/tmp/tmp4zms5jl7.cpp:27:50: note: to match this \u2018{\u2019\n   27 |         for (int j = 0; j < grid[i].size(); ++j) {\n      |                                                  ^\n/tmp/tmp4zms5jl7.cpp:69:1: error: expected \u2018}\u2019 at end of input\n   69 | }\n      | ^\n/tmp/tmp4zms5jl7.cpp:26:43: note: to match this \u2018{\u2019\n   26 |     for (int i = 0; i < grid.size(); ++i) {\n      |                                           ^\n/tmp/tmp4zms5jl7.cpp:69:1: error: expected \u2018}\u2019 at end of input\n   69 | }\n      | ^\n/tmp/tmp4zms5jl7.cpp:24:67: note: to match this \u2018{\u2019\n   24 | long max_fill(std::vector<std::vector<long>> grid, long capacity) {\n      |                                                                   ^\n/tmp/tmp4zms5jl7.cpp:69:1: warning: no return statement in function returning non-void [-Wreturn-type]\n   69 | }\n      | ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m, 0));\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 0) {\n                dp[i][j] = 0;\n            }\n        }\n    }\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (dp[i][j] == 1) {\n                for (long k = 0; k < m; ++k) {\n                    if (grid[i][k] == 1) {\n                        dp[i][j] = std::max(dp[i][j], dp[i][k] + 1);\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (dp[i][j] == capacity) {\n                ans += 1;\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292923,
      "stdout": "",
      "stderr": "tmp5gh7t7p1: /tmp/tmp5gh7t7p1.cpp:65: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    std::vector<long> max_buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_buckets[i] = std::max(max_buckets[i], buckets[i]);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (buckets[i] < max_buckets[i]) {\n                    ++ans;\n                    --buckets[i];\n                    --max_buckets[i];\n                }\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292923,
      "stdout": "",
      "stderr": "tmpsmuz9an7: /tmp/tmpsmuz9an7.cpp:57: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292923,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292919,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292909,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> well_size(grid.size(), 0);\n    std::vector<long> well_cap(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            well_size[i] += grid[i][j];\n            well_cap[i] += grid[i][j] * capacity;\n        }\n    }\n    std::vector<long> well_level(grid.size(), 0);\n    std::vector<long> well_flow(grid.size(), 0);\n    std::vector<long> well_flow_count(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            well_level[i] += grid[i][j];\n            well_flow[i] += grid[i][j] * capacity;\n            well_flow_count[i] += grid[i][j];\n        }\n    }\n    std::vector<long> well_level_count(grid.size(), 0);\n    std::vector<long> well_flow_count_count(grid.size(), 0);\n    std::vector<long> well_level_flow(grid.size(), 0);\n    std::vector<long> well_level_flow_count(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            well_level_count[i] += grid[i][j];\n            well_level_flow[i] += grid[i][j] * capacity;\n            well_level_flow_count[i] += grid[i][j];\n        }\n    }\n    std::vector<long> well_level_flow_count_count(grid.size(), 0);\n    std::vector<long> well_level_flow_count_flow(grid.size(), 0);\n    std::vector<long> well_level_\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292923,
      "stdout": "",
      "stderr": "/tmp/tmp948pxi6g.cpp: In function \u2018long int max_fill(std::vector<std::vector<long int> >, long int)\u2019:\n/tmp/tmp948pxi6g.cpp:57:1: error: expected initializer before \u2018}\u2019 token\n   57 | }\n      | ^\n/tmp/tmp948pxi6g.cpp:57:1: warning: no return statement in function returning non-void [-Wreturn-type]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                ans = std::max(ans, dp[i][j]);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292921,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += max_fill_well(grid, i, j, capacity);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292923,
      "stdout": "",
      "stderr": "/tmp/tmpf7y4wygo.cpp: In function \u2018long int max_fill(std::vector<std::vector<long int> >, long int)\u2019:\n/tmp/tmpf7y4wygo.cpp:29:24: error: \u2018max_fill_well\u2019 was not declared in this scope; did you mean \u2018max_fill\u2019?\n   29 |                 ans += max_fill_well(grid, i, j, capacity);\n      |                        ^~~~~~~~~~~~~\n      |                        max_fill\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                result = std::max(result, dp[i][j]);\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292913,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292911,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long ans = 0;\n    while (true) {\n        for (int i = 0; i < buckets.size(); ++i) {\n            if (buckets[i] > 0) {\n                --buckets[i];\n                ++ans;\n                break;\n            }\n        }\n        if (buckets.empty()) {\n            break;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292924,
      "stdout": "",
      "stderr": "",
      "exit_code": -1,
      "status": "Timeout"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], ans);\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], ans + 1);\n            }\n        }\n    }\n    return ans + 1;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292923,
      "stdout": "",
      "stderr": "tmpa8y2nx8x: /tmp/tmpa8y2nx8x.cpp:52: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill += capacity;\n                grid[i][j] = 0;\n            }\n        }\n    }\n    return max_fill;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292923,
      "stdout": "",
      "stderr": "tmpnko5wrl7: /tmp/tmpnko5wrl7.cpp:39: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], ans);\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], ans);\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292923,
      "stdout": "",
      "stderr": "tmp_99e3pan: /tmp/tmp_99e3pan.cpp:52: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), capacity);\n    std::vector<long> count(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++count[i];\n                buckets[i] -= 1;\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        if (count[i] > 0) {\n            result += count[i] * buckets[i];\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292925,
      "stdout": "",
      "stderr": "tmpa_pcakhz: /tmp/tmpa_pcakhz.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[0].size(); j++) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n            }\n        }\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292925,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> used(grid.size(), 0);\n    std::vector<long> max_fill(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                max_fill[i] += capacity;\n            }\n        }\n    }\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                if (used[i] < max_fill[i]) {\n                    used[i] += max_fill[i];\n                }\n                max_fill[i] = 0;\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        if (used[i] < max_fill[i]) {\n            result += max_fill[i] - used[i];\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292925,
      "stdout": "",
      "stderr": "tmptgysg0_f: /tmp/tmptgysg0_f.cpp:54: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                result += dp[i][j];\n            }\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292925,
      "stdout": "",
      "stderr": "tmpavtj4r1o: /tmp/tmpavtj4r1o.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), capacity);\n    std::vector<long> max_buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                buckets[i]--;\n                max_buckets[i] = std::max(max_buckets[i], buckets[i]);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        if (max_buckets[i] < buckets[i]) {\n            ans++;\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292925,
      "stdout": "",
      "stderr": "tmp2re2oi8z: /tmp/tmp2re2oi8z.cpp:45: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long result = 0;\n    for (int i = 0; i < buckets.size(); ++i) {\n        if (buckets[i] > capacity) {\n            result += buckets[i] - capacity;\n            buckets[i] = capacity;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292919,
      "stdout": "",
      "stderr": "tmpja55e9s4: /tmp/tmpja55e9s4.cpp:44: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long max_fill = 0;\n    for (int i = 0; i < grid.size(); i++) {\n        for (int j = 0; j < grid[i].size(); j++) {\n            if (grid[i][j] == 1) {\n                std::vector<std::vector<long>> new_grid = grid;\n                new_grid[i][j] = 0;\n                max_fill += max_fill_well(new_grid, capacity);\n            }\n        }\n    }\n    return max_fill;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292924,
      "stdout": "",
      "stderr": "/tmp/tmpetxfrei0.cpp: In function \u2018long int max_fill(std::vector<std::vector<long int> >, long int)\u2019:\n/tmp/tmpetxfrei0.cpp:31:29: error: \u2018max_fill_well\u2019 was not declared in this scope; did you mean \u2018max_fill\u2019?\n   31 |                 max_fill += max_fill_well(new_grid, capacity);\n      |                             ^~~~~~~~~~~~~\n      |                             max_fill\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ans += dp[i][j];\n                dp[i][j] = 0;\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292917,
      "stdout": "",
      "stderr": "tmpq5rsf64u: /tmp/tmpq5rsf64u.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<long> buckets(grid.size(), 0);\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                ++buckets[i];\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[i].size(); ++j) {\n            if (grid[i][j] == 1) {\n                --buckets[i];\n                if (buckets[i] < 0) {\n                    ++ans;\n                    buckets[i] = capacity;\n                }\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292925,
      "stdout": "",
      "stderr": "tmp_kdny9w2: /tmp/tmp_kdny9w2.cpp:49: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    long ans = 0;\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], ans);\n            }\n        }\n        ans = std::max(ans, dp[i][0]);\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292925,
      "stdout": "",
      "stderr": "tmpmjt51lgq: /tmp/tmpmjt51lgq.cpp:46: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    std::vector<std::vector<long>> dp(grid.size(), std::vector<long>(grid[0].size(), 0));\n    for (int i = 0; i < grid.size(); ++i) {\n        for (int j = 0; j < grid[0].size(); ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = std::min(dp[i][j], dp[i][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j] + 1);\n                dp[i][j] = std::min(dp[i][j], dp[i - 1][j - 1] + 1);\n                dp[i][j] = std::min(dp[i][j], capacity);\n            }\n        }\n    }\n    return dp[grid.size() - 1][grid[0].size() - 1];\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292925,
      "stdout": "",
      "stderr": "",
      "exit_code": -11,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// You are given a rectangular grid of wells. Each row represents a single well,\n// and each 1 in a row represents a single unit of water.\n// Each well has a corresponding bucket that can be used to extract water from it, \n// and all buckets have the same capacity.\n// Your task is to use the buckets to empty the wells.\n// Output the number of times you need to lower the buckets.\n// Example 1:\n// >>> max_fill([[0,0,1,0], [0,1,0,0], [1,1,1,1]], 1)\n// 6\n// Example 2:\n// >>> max_fill([[0,0,1,1], [0,0,0,0], [1,1,1,1], [0,1,1,1]], 2)\n// 5\n// Example 3:\n// >>> max_fill([[0,0,0], [0,0,0]], 5)\n// 0\n// Constraints:\n// * all wells have the same length\n// * 1 <= grid.length <= 10^2\n// * 1 <= grid[:,1].length <= 10^2\n// * grid[i][j] -> 0 | 1\n// * 1 <= capacity <= 10\nlong max_fill(std::vector<std::vector<long>> grid, long capacity) {\n    long n = grid.size();\n    long m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m, 0));\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (grid[i][j] == 1) {\n                dp[i][j] = 1;\n            }\n        }\n    }\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (dp[i][j] == 1) {\n                for (long k = 0; k < m; ++k) {\n                    if (grid[i][k] == 1) {\n                        dp[i][j] = std::max(dp[i][j], dp[i][k] + 1);\n                    }\n                }\n            }\n        }\n    }\n    long ans = 0;\n    for (long i = 0; i < n; ++i) {\n        for (long j = 0; j < m; ++j) {\n            if (dp[i][j] == 1) {\n                ans += capacity;\n            }\n        }\n    }\n    return ans;\n}\nint main() {\n    auto candidate = max_fill;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)1, (long)1})})), (2)) == (5));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)0, (long)0})})), (5)) == (0));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (2)) == (4));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (9)) == (2));\n}\n",
      "timestamp": 1664292925,
      "stdout": "",
      "stderr": "tmpd3fgrn0z: /tmp/tmpd3fgrn0z.cpp:58: int main(): Assertion `candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)0, (long)0, (long)1, (long)0}), (std::vector<long>)std::vector<long>({(long)0, (long)1, (long)0, (long)0}), (std::vector<long>)std::vector<long>({(long)1, (long)1, (long)1, (long)1})})), (1)) == (6)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    }
  ]
}