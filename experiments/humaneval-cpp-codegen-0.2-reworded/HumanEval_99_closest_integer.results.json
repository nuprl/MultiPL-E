{
  "name": "HumanEval_99_closest_integer",
  "language": "cpp",
  "prompt": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n",
  "tests": "}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
  "stop_tokens": [
    "\n}"
  ],
  "results": [
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::string::iterator it = value.begin();\n    while (it != value.end() && *it == ' ') {\n        it++;\n    }\n    if (it == value.end()) {\n        return result;\n    }\n    bool is_negative = false;\n    if (*it == '-') {\n        is_negative = true;\n        it++;\n    }\n    while (it != value.end() && *it >= '0' && *it <= '9') {\n        result = result * 10 + (*it - '0');\n        it++;\n    }\n    if (is_negative) {\n        result = -result;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmp0lz4rrgo: /tmp/tmp0lz4rrgo.cpp:42: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] == '.') {\n            result = sign * (long) std::stod(value.substr(0, i));\n            break;\n        }\n    }\n    if (value.find('.') != std::string::npos) {\n        result = sign * (long) std::stod(value);\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpd1o04n4x: /tmp/tmpd1o04n4x.cpp:36: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::string::size_type pos = 0;\n    std::string::size_type len = value.length();\n    if (len == 0) return result;\n    if (value[0] == '-') {\n        result = -1;\n        pos = 1;\n    }\n    while (pos < len) {\n        if (value[pos] < '0' || value[pos] > '9') break;\n        result = result * 10 + value[pos] - '0';\n        pos++;\n    }\n    if (pos == len) return result;\n    if (value[pos] == '.') {\n        pos++;\n        while (pos < len) {\n            if (value[pos] < '0' || value[pos] > '9') break;\n            result = result * 10 + value[pos] - '0';\n            pos++;\n        }\n        if (pos == len) return result;\n    }\n    if (value[pos] == 'e' || value[pos] == 'E') {\n        pos++;\n        if (value[pos] == '-') {\n            result = -result;\n            pos++;\n        }\n        while (pos < len) {\n            if (value[pos] < '0' || value[pos] > '9') break;\n            result = result * 10 + value[pos] - '0';\n            pos++;\n        }\n        if (pos == len) return result;\n    }\n    if (value[pos] == '-') {\n        result = -result;\n        pos++;\n    }\n    if (value[pos] == '.') {\n        pos++;\n        while (pos < len) {\n            if (value[pos] < '0' || value[pos] > '9') break;\n            result = result * 10 + value[pos] - '0';\n            pos++;\n        }\n        if (pos == len) return result;\n    }\n    if (value[pos] == 'e' || value[pos] == 'E') {\n        pos++;\n        if (value[pos] == '-') {\n            result = -result;\n            pos++;\n\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "/tmp/tmpmkzi2i01.cpp: In function \u2018long int closest_integer(std::string)\u2019:\n/tmp/tmpmkzi2i01.cpp:73:12: error: a function-definition is not allowed here before \u2018{\u2019 token\n   73 | int main() {\n      |            ^\n/tmp/tmpmkzi2i01.cpp:80:1: error: expected \u2018}\u2019 at end of input\n   80 | }\n      | ^\n/tmp/tmpmkzi2i01.cpp:66:49: note: to match this \u2018{\u2019\n   66 |     if (value[pos] == 'e' || value[pos] == 'E') {\n      |                                                 ^\n/tmp/tmpmkzi2i01.cpp:80:1: error: expected \u2018}\u2019 at end of input\n   80 | }\n      | ^\n/tmp/tmpmkzi2i01.cpp:16:41: note: to match this \u2018{\u2019\n   16 | long closest_integer(std::string value) {\n      |                                         ^\n/tmp/tmpmkzi2i01.cpp:80:1: warning: control reaches end of non-void function [-Wreturn-type]\n   80 | }\n      | ^\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long num = 0;\n    long num_sign = 1;\n    long num_abs = 0;\n    long num_abs_sign = 1;\n    long num_abs_sign_diff = 0;\n    long num_abs_sign_diff_sign = 1;\n    long num_abs_sign_diff_sign_diff = 0;\n    long num_abs_sign_diff_sign_diff_sign = 1;\n    long num_abs_sign_diff_sign_diff_sign_diff = 0;\n    long num_abs_sign_diff_sign_diff_sign_diff_sign = 1;\n    long num_abs_sign_diff_sign_diff_sign_diff_sign_diff = 0;\n    long num_abs_sign_diff_sign_diff_sign_diff_sign_diff_sign = 1;\n    long num_abs_sign_diff_sign_diff_sign_diff_sign_diff_sign_diff = 0;\n    long num_abs_sign_diff_sign_diff_sign_diff_sign_diff_sign_diff_sign = 1;\n    long num_abs_sign_diff_sign_diff_sign_diff_sign_diff_sign_diff_sign_diff = 0;\n    long num_abs_sign_diff_sign_diff_sign_diff_sign_diff_sign_diff_sign_diff_sign = 1;\n    long num_abs_sign_diff_sign_diff_sign_diff_sign_diff_sign_diff_sign_diff_sign_diff = 0;\n    long num_abs_sign_diff_sign_diff_sign_diff_sign_diff_sign_diff_sign_diff_sign_diff_sign = 1;\n    long num_abs_sign_diff_sign_diff_sign_diff_sign_diff_sign_diff_sign_diff_sign_diff_sign_diff = 0;\n    long num_abs_sign_diff_sign_diff_sign_diff_sign_diff_sign_diff_sign_diff_sign_diff_sign_diff_sign = 1;\n    long num_abs_sign_diff_sign_diff_\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "/tmp/tmpm8y5ujjz.cpp: In function \u2018long int closest_integer(std::string)\u2019:\n/tmp/tmpm8y5ujjz.cpp:40:1: error: expected initializer before \u2018}\u2019 token\n   40 | }\n      | ^\n/tmp/tmpm8y5ujjz.cpp:40:1: warning: no return statement in function returning non-void [-Wreturn-type]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (auto &c : value) {\n        if (c >= '0' && c <= '9') {\n            result = result * 10 + c - '0';\n        } else {\n            break;\n        }\n    }\n    result = result * sign;\n    if (result == 0) {\n        return 0;\n    }\n    if (result > 0) {\n        result = result + 5;\n    } else {\n        result = result - 5;\n    }\n    result = result / 10;\n    return result * sign;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpjshv5flf: /tmp/tmpjshv5flf.cpp:44: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long num = 0;\n    long num_sign = 1;\n    long num_abs = 0;\n    long num_abs_sign = 1;\n    long num_abs_sign_temp = 1;\n    long num_abs_sign_temp_2 = 1;\n    long num_abs_sign_temp_3 = 1;\n    long num_abs_sign_temp_4 = 1;\n    long num_abs_sign_temp_5 = 1;\n    long num_abs_sign_temp_6 = 1;\n    long num_abs_sign_temp_7 = 1;\n    long num_abs_sign_temp_8 = 1;\n    long num_abs_sign_temp_9 = 1;\n    long num_abs_sign_temp_10 = 1;\n    long num_abs_sign_temp_11 = 1;\n    long num_abs_sign_temp_12 = 1;\n    long num_abs_sign_temp_13 = 1;\n    long num_abs_sign_temp_14 = 1;\n    long num_abs_sign_temp_15 = 1;\n    long num_abs_sign_temp_16 = 1;\n    long num_abs_sign_temp_17 = 1;\n    long num_abs_sign_temp_18 = 1;\n    long num_abs_sign_temp_19 = 1;\n    long num_abs_sign_temp_20 = 1;\n    long num_abs_sign_temp_21 = 1;\n    long num_abs_sign_temp_22 = 1;\n    long num_abs_sign_temp_23 = 1;\n    long num_abs_sign_temp_24 = 1;\n    long num_abs_sign_temp_25 = 1;\n    long num_abs_sign_temp_26 = 1;\n    long num_abs_sign_temp_27 = 1;\n    long num_abs_sign_temp_28 = 1;\n    long num_abs_sign_temp_29 = 1;\n    long num_abs_sign_temp_30 = 1;\n    long num_abs_sign_temp_31 = 1;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmp81pe4bt6: /tmp/tmp81pe4bt6.cpp:57: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (auto i = value.begin(); i != value.end(); ++i) {\n        if (*i == '.') {\n            result += sign * std::stoi(value.substr(0, i - value.begin()));\n            value.erase(0, i - value.begin());\n            break;\n        }\n        result += sign * std::stoi(*i - '0');\n    }\n    if (value.size() > 0) {\n        result += sign * std::stoi(value);\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "/tmp/tmpro4geuhl.cpp: In function \u2018long int closest_integer(std::string)\u2019:\n/tmp/tmpro4geuhl.cpp:29:44: error: no matching function for call to \u2018stoi(int)\u2019\n   29 |         result += sign * std::stoi(*i - '0');\n      |                                            ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n                 from /tmp/tmpro4geuhl.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6503:3: note: candidate: \u2018int std::__cxx11::stoi(const string&, std::size_t*, int)\u2019\n 6503 |   stoi(const string& __str, size_t* __idx = 0, int __base = 10)\n      |   ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6503:22: note:   no known conversion for argument 1 from \u2018int\u2019 to \u2018const string&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n 6503 |   stoi(const string& __str, size_t* __idx = 0, int __base = 10)\n      |        ~~~~~~~~~~~~~~^~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6609:3: note: candidate: \u2018int std::__cxx11::stoi(const wstring&, std::size_t*, int)\u2019\n 6609 |   stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)\n      |   ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6609:23: note:   no known",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long exponent = 0;\n    long fraction = 0;\n    long fraction_sign = 1;\n    long fraction_exponent = 0;\n    long fraction_fraction = 0;\n    long fraction_fraction_sign = 1;\n    long fraction_fraction_exponent = 0;\n    long fraction_fraction_fraction = 0;\n    long fraction_fraction_fraction_sign = 1;\n    long fraction_fraction_fraction_exponent = 0;\n    long fraction_fraction_fraction_fraction = 0;\n    long fraction_fraction_fraction_fraction_sign = 1;\n    long fraction_fraction_fraction_fraction_exponent = 0;\n    long fraction_fraction_fraction_fraction_fraction = 0;\n    long fraction_fraction_fraction_fraction_fraction_sign = 1;\n    long fraction_fraction_fraction_fraction_fraction_exponent = 0;\n    long fraction_fraction_fraction_fraction_fraction_fraction = 0;\n    long fraction_fraction_fraction_fraction_fraction_fraction_sign = 1;\n    long fraction_fraction_fraction_fraction_fraction_fraction_exponent = 0;\n    long fraction_fraction_fraction_fraction_fraction_fraction_fraction = 0;\n    long fraction_fraction_fraction_fraction_fraction_fraction_fraction_sign = 1;\n    long fraction_fraction_fraction_fraction_fraction_fraction_fraction_exponent = 0;\n    long fraction_fraction_fraction_fraction_fraction_fraction_fraction_fraction = 0;\n    long fraction_fraction_fraction_fraction_fraction_fraction_fraction_fraction_sign = 1;\n    long fraction_fraction_fraction_fraction_fraction_fraction_fraction_fraction_exponent = 0;\n    long fraction_fraction_fraction_fraction_fraction_fraction_fraction_fraction_fraction = 0;\n\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmplv_q86np: /tmp/tmplv_q86np.cpp:49: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] == '.') {\n            result = result + (value[i + 1] - '0') * sign * pow(10, value.size() - i - 2);\n            break;\n        }\n        result = result + (value[i] - '0') * sign * pow(10, value.size() - i - 1);\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmp03vu22zf: /tmp/tmp03vu22zf.cpp:35: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = 0; i < value.length(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        } else {\n            break;\n        }\n    }\n    result = result * sign;\n    if (result == 0) {\n        return 0;\n    }\n    if (result % 2 == 0) {\n        return result / 2 * sign;\n    } else {\n        return (result / 2 + 1) * sign;\n    }\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmp49fh40g6: /tmp/tmp49fh40g6.cpp:42: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (auto it = value.begin(); it != value.end(); ++it) {\n        if (*it == '.') {\n            result += sign * std::stoi(value.substr(0, it - value.begin()));\n            value.erase(0, it - value.begin());\n            break;\n        }\n        result += sign * std::stoi(*it - '0');\n    }\n    if (value.size() > 0) {\n        result += sign * std::stoi(value);\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "/tmp/tmpamj39w5q.cpp: In function \u2018long int closest_integer(std::string)\u2019:\n/tmp/tmpamj39w5q.cpp:29:45: error: no matching function for call to \u2018stoi(int)\u2019\n   29 |         result += sign * std::stoi(*it - '0');\n      |                                             ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n                 from /tmp/tmpamj39w5q.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6503:3: note: candidate: \u2018int std::__cxx11::stoi(const string&, std::size_t*, int)\u2019\n 6503 |   stoi(const string& __str, size_t* __idx = 0, int __base = 10)\n      |   ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6503:22: note:   no known conversion for argument 1 from \u2018int\u2019 to \u2018const string&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n 6503 |   stoi(const string& __str, size_t* __idx = 0, int __base = 10)\n      |        ~~~~~~~~~~~~~~^~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6609:3: note: candidate: \u2018int std::__cxx11::stoi(const wstring&, std::size_t*, int)\u2019\n 6609 |   stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)\n      |   ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6609:23: note:   no kno",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        } else {\n            break;\n        }\n    }\n    result = result * sign;\n    if (result == 0) {\n        result = 1;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpqpge0fuv: /tmp/tmpqpge0fuv.cpp:39: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = 0; i < value.length(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    if (result < 0) {\n        result = -result;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpaj08frjt: /tmp/tmpaj08frjt.cpp:37: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.length(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        } else {\n            break;\n        }\n    }\n    result = sign * result;\n    if (result > INT_MAX) {\n        result = INT_MAX;\n    } else if (result < INT_MIN) {\n        result = INT_MIN;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpa10mysgp: /tmp/tmpa10mysgp.cpp:41: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = value.size() - 1; i >= 0; i--) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        } else {\n            break;\n        }\n    }\n    result = sign * result;\n    if (result == 0) {\n        result = 1;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpo6zawi7a: /tmp/tmpo6zawi7a.cpp:38: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = value.length() - 1; i >= 0; i--) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    if (result < 0) {\n        result = -result;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpj2gy7s55: /tmp/tmpj2gy7s55.cpp:36: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmp_fltreji: /tmp/tmp_fltreji.cpp:34: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long power = 1;\n    long temp = 0;\n    long temp_sign = 1;\n    long temp_power = 1;\n    long temp_result = 0;\n    long temp_result_sign = 1;\n    long temp_result_power = 1;\n    long temp_result_temp = 0;\n    long temp_result_temp_sign = 1;\n    long temp_result_temp_power = 1;\n    long temp_result_temp_result = 0;\n    long temp_result_temp_result_sign = 1;\n    long temp_result_temp_result_power = 1;\n    long temp_result_temp_result_temp = 0;\n    long temp_result_temp_result_temp_sign = 1;\n    long temp_result_temp_result_temp_power = 1;\n    long temp_result_temp_result_temp_result = 0;\n    long temp_result_temp_result_temp_result_sign = 1;\n    long temp_result_temp_result_temp_result_power = 1;\n    long temp_result_temp_result_temp_result_temp = 0;\n    long temp_result_temp_result_temp_result_temp_sign = 1;\n    long temp_result_temp_result_temp_result_temp_power = 1;\n    long temp_result_temp_result_temp_result_temp_result = 0;\n    long temp_result_temp_result_temp_result_temp_result_sign = 1;\n    long temp_result_temp_result_temp_result_temp_result_power = 1;\n    long temp_result_temp_result_temp_result_temp_result_temp = 0;\n    long temp_result_temp_result_temp_result_temp_result_temp_sign = 1;\n    long temp_result_temp_result_temp_result_temp_result_temp_power = 1;\n    long temp_result_temp_result_temp_result_temp_result_temp_result = 0;\n    long temp_result_temp_result_temp_result_temp_result_temp_result_sign = 1\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "/tmp/tmpokjcakso.cpp: In function \u2018long int closest_integer(std::string)\u2019:\n/tmp/tmpokjcakso.cpp:49:1: error: expected \u2018,\u2019 or \u2018;\u2019 before \u2018}\u2019 token\n   49 | }\n      | ^\n/tmp/tmpokjcakso.cpp:49:1: warning: no return statement in function returning non-void [-Wreturn-type]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    if (result < 0) {\n        result = result - 1;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpbgj2w347: /tmp/tmpbgj2w347.cpp:37: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long power = 1;\n    long digit = 0;\n    long max_power = 0;\n    long max_digit = 0;\n    long max_value = 0;\n    long min_value = 0;\n    long min_digit = 0;\n    long min_power = 0;\n    long diff = 0;\n    long diff_sign = 0;\n    long diff_power = 0;\n    long diff_digit = 0;\n    long diff_value = 0;\n    long diff_max_value = 0;\n    long diff_min_value = 0;\n    long diff_max_power = 0;\n    long diff_min_power = 0;\n    long diff_max_digit = 0;\n    long diff_min_digit = 0;\n    long diff_max_value_sign = 0;\n    long diff_min_value_sign = 0;\n    long diff_max_value_power = 0;\n    long diff_min_value_power = 0;\n    long diff_max_value_digit = 0;\n    long diff_min_value_digit = 0;\n    long diff_max_value_value = 0;\n    long diff_min_value_value = 0;\n    long diff_max_value_value_sign = 0;\n    long diff_min_value_value_sign = 0;\n    long diff_max_value_value_power = 0;\n    long diff_min_value_value_power = 0;\n    long diff_max_value_value_digit = 0;\n    long diff_min_value_value_digit = 0;\n    long diff_max_value_value_value = 0;\n    long diff_min_value_value_value = 0;\n    long diff_max_value_value_value_sign = 0;\n    long diff_min_value_value_value_sign = 0;\n    long diff_max_value_value_value_power = 0;\n    long diff_min_value_value_value_power = 0;\n    long diff_max_value_value_value_digit = 0;\n    long diff_min_value_value_value_\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "/tmp/tmp8b373t18.cpp: In function \u2018long int closest_integer(std::string)\u2019:\n/tmp/tmp8b373t18.cpp:60:1: error: expected initializer before \u2018}\u2019 token\n   60 | }\n      | ^\n/tmp/tmp8b373t18.cpp:60:1: warning: no return statement in function returning non-void [-Wreturn-type]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    if (result > INT_MAX) {\n        return INT_MAX;\n    }\n    if (result < INT_MIN) {\n        return INT_MIN;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpx1eas_29: /tmp/tmpx1eas_29.cpp:40: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmp_fltreji: /tmp/tmp_fltreji.cpp:34: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::string::iterator it = value.begin();\n    while (it != value.end()) {\n        if (*it == '.') {\n            break;\n        }\n        result = result * 10 + *it - '0';\n        ++it;\n    }\n    if (it != value.end()) {\n        result = result * 10 + *it - '0';\n        ++it;\n    }\n    if (it != value.end()) {\n        result = result * 10 + *it - '0';\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpvi19jomq: /tmp/tmpvi19jomq.cpp:38: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long num = 0;\n    long num_sign = 1;\n    long num_abs = 0;\n    long num_abs_sign = 1;\n    long num_abs_sign_temp = 1;\n    long num_abs_sign_temp_2 = 1;\n    long num_abs_sign_temp_3 = 1;\n    long num_abs_sign_temp_4 = 1;\n    long num_abs_sign_temp_5 = 1;\n    long num_abs_sign_temp_6 = 1;\n    long num_abs_sign_temp_7 = 1;\n    long num_abs_sign_temp_8 = 1;\n    long num_abs_sign_temp_9 = 1;\n    long num_abs_sign_temp_10 = 1;\n    long num_abs_sign_temp_11 = 1;\n    long num_abs_sign_temp_12 = 1;\n    long num_abs_sign_temp_13 = 1;\n    long num_abs_sign_temp_14 = 1;\n    long num_abs_sign_temp_15 = 1;\n    long num_abs_sign_temp_16 = 1;\n    long num_abs_sign_temp_17 = 1;\n    long num_abs_sign_temp_18 = 1;\n    long num_abs_sign_temp_19 = 1;\n    long num_abs_sign_temp_20 = 1;\n    long num_abs_sign_temp_21 = 1;\n    long num_abs_sign_temp_22 = 1;\n    long num_abs_sign_temp_23 = 1;\n    long num_abs_sign_temp_24 = 1;\n    long num_abs_sign_temp_25 = 1;\n    long num_abs_sign_temp_26 = 1;\n    long num_abs_sign_temp_27 = 1;\n    long num_abs_sign_temp_28 = 1;\n    long num_abs_sign_temp_29 = 1;\n    long num_abs_sign_temp_30 = 1;\n    long num_abs_sign_temp_31 = 1;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmp81pe4bt6: /tmp/tmp81pe4bt6.cpp:57: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::string::iterator it = value.begin();\n    while (it != value.end() && *it != '.') {\n        result = result * 10 + *it - '0';\n        ++it;\n    }\n    if (it != value.end()) {\n        result = result * 10 + *it - '0';\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "tmpcmrlj_t1: /tmp/tmpcmrlj_t1.cpp:31: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    if (result > INT_MAX) {\n        return INT_MAX;\n    }\n    if (result < INT_MIN) {\n        return INT_MIN;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpx1eas_29: /tmp/tmpx1eas_29.cpp:40: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.size(); ++i) {\n        if (value[i] == '.') {\n            result += sign * (value[i + 1] - '0') * pow(10, value.size() - i - 1);\n            break;\n        }\n        result += sign * (value[i] - '0') * pow(10, value.size() - i - 1);\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "tmpsmlzl5u_: /tmp/tmpsmlzl5u_.cpp:35: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long power = 1;\n    for (auto c : value) {\n        if (c == '-') {\n            sign = -1;\n        } else if (c == '.') {\n            power = 10;\n        } else {\n            result += sign * (c - '0') * power;\n            power *= 10;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "tmpkpipzc22: /tmp/tmpkpipzc22.cpp:34: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long power = 1;\n    for (int i = value.size() - 1; i >= 0; i--) {\n        if (value[i] == '.') {\n            result += sign * power * (value[i] - '0');\n            sign = -sign;\n            power = 10;\n        } else {\n            result += sign * power * (value[i] - '0');\n            sign = -sign;\n            power = 1;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "tmp7mhk9qwi: /tmp/tmp7mhk9qwi.cpp:35: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::string::iterator it = value.begin();\n    while (it != value.end()) {\n        if (*it == '.') {\n            result = 0;\n            break;\n        }\n        result = result * 10 + *it - '0';\n        ++it;\n    }\n    if (it != value.end()) {\n        if (*it == '.') {\n            result = 0;\n        } else {\n            result = result * 10 + *it - '0';\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "tmpph9q70g0: /tmp/tmpph9q70g0.cpp:39: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long power = 1;\n    long temp = 0;\n    long diff = 0;\n    long diff_sign = 0;\n    long diff_power = 0;\n    long diff_temp = 0;\n    long diff_diff = 0;\n    long diff_diff_sign = 0;\n    long diff_diff_power = 0;\n    long diff_diff_temp = 0;\n    long diff_diff_diff = 0;\n    long diff_diff_diff_sign = 0;\n    long diff_diff_diff_power = 0;\n    long diff_diff_diff_temp = 0;\n    long diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_sign = 0;\n    long diff_diff_diff_diff_power = 0;\n    long diff_diff_diff_diff_temp = 0;\n    long diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_sign = 0;\n    long diff_diff_diff_diff_diff_power = 0;\n    long diff_diff_diff_diff_diff_temp = 0;\n    long diff_diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_diff_sign = 0;\n    long diff_diff_diff_diff_diff_diff_power = 0;\n    long diff_diff_diff_diff_diff_diff_temp = 0;\n    long diff_diff_diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_diff_diff_sign = 0;\n    long diff_diff_diff_diff_diff_diff_diff_power = 0;\n    long diff_diff_diff_diff_diff_diff_diff_temp = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff_sign = 0;\n    long diff_diff_diff_diff_diff_diff_diff_diff_power = 0;\n    long diff_diff_diff_diff_diff\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "/tmp/tmp0_0w_82_.cpp: In function \u2018long int closest_integer(std::string)\u2019:\n/tmp/tmp0_0w_82_.cpp:53:1: error: expected initializer before \u2018}\u2019 token\n   53 | }\n      | ^\n/tmp/tmp0_0w_82_.cpp:53:1: warning: no return statement in function returning non-void [-Wreturn-type]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = value.length() - 1; i >= 0; i--) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "tmpmz4oklgm: /tmp/tmpmz4oklgm.cpp:33: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    if (result > INT_MAX) {\n        result = INT_MAX;\n    } else if (result < INT_MIN) {\n        result = INT_MIN;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "tmp0mmhe97n: /tmp/tmp0mmhe97n.cpp:39: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + (value[i] - '0');\n        }\n    }\n    result = result * sign;\n    if (result < 0) {\n        result = -result;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "tmpppz1jor3: /tmp/tmpppz1jor3.cpp:37: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::string::size_type i = 0;\n    std::string::size_type j = 0;\n    while (i < value.length() && value[i] == '0') {\n        i++;\n    }\n    while (i < value.length() && value[i] >= '0' && value[i] <= '9') {\n        result = result * 10 + value[i] - '0';\n        i++;\n    }\n    if (i < value.length()) {\n        j = i;\n        while (j < value.length() && value[j] >= '0' && value[j] <= '9') {\n            j++;\n        }\n        if (j - i == 1) {\n            result = result * 10 + value[i] - '0';\n        } else {\n            result = result * 10 + value[i] - '0' + value[j] - '0';\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "tmp6o71y_x4: /tmp/tmp6o71y_x4.cpp:43: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (auto it = value.begin(); it != value.end(); ++it) {\n        if (*it == '.') {\n            result = result * 10 + sign * (*it - '0');\n            continue;\n        }\n        result = result * 10 + sign * (*it - '0');\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "tmpkb2xvfij: /tmp/tmpkb2xvfij.cpp:35: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::string::iterator it = value.begin();\n    while (it != value.end() && *it == ' ') {\n        it++;\n    }\n    if (it == value.end()) {\n        return 0;\n    }\n    if (*it == '-') {\n        result = -1;\n        it++;\n    }\n    while (it != value.end() && *it >= '0' && *it <= '9') {\n        result = result * 10 + (*it - '0');\n        it++;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "tmp82rwp4e6: /tmp/tmp82rwp4e6.cpp:38: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::string::iterator it = value.begin();\n    while (it != value.end() && std::isdigit(*it)) {\n        result = result * 10 + *it - '0';\n        ++it;\n    }\n    if (it != value.end()) {\n        result = result * 10 + *it - '0';\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "tmpkud7cs2f: /tmp/tmpkud7cs2f.cpp:31: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = value.length() - 1; i >= 0; i--) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    if (result < 0) {\n        result = -result;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpj2gy7s55: /tmp/tmpj2gy7s55.cpp:36: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = 0; i < value.length(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "tmpprccukb0: /tmp/tmpprccukb0.cpp:34: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    if (result > INT_MAX) {\n        result = INT_MAX;\n    } else if (result < INT_MIN) {\n        result = INT_MIN;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "tmp_rwticny: /tmp/tmp_rwticny.cpp:39: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + (value[i] - '0');\n        }\n    }\n    result = result * sign;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "tmpo1e2bo11: /tmp/tmpo1e2bo11.cpp:34: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = value.size() - 1; i >= 0; i--) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result += (value[i] - '0') * sign * pow(10, i);\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "tmp53zle7jk: /tmp/tmp53zle7jk.cpp:32: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = 0; i < value.length(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "tmpprccukb0: /tmp/tmpprccukb0.cpp:34: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long power = 1;\n    for (int i = value.size() - 1; i >= 0; i--) {\n        if (value[i] == '.') {\n            result += sign * power * (value[i] - '0');\n            power *= 10;\n        } else if (value[i] == '-') {\n            sign = -1;\n        } else {\n            result += sign * power * (value[i] - '0');\n            power *= 10;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "tmpiovblex_: /tmp/tmpiovblex_.cpp:36: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = value.size() - 1; i >= 0; i--) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "tmpmkscbhha: /tmp/tmpmkscbhha.cpp:33: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    if (result < 0) {\n        result = 0;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "tmpji9g7n62: /tmp/tmpji9g7n62.cpp:37: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (auto it = value.begin(); it != value.end(); ++it) {\n        if (*it == '.') {\n            result += sign * std::stoi(value.substr(0, it - value.begin()));\n            value.erase(0, it - value.begin());\n            break;\n        }\n        result += sign * std::stoi(*it - '0');\n    }\n    result += sign * std::stoi(value);\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "/tmp/tmp00i5_eh1.cpp: In function \u2018long int closest_integer(std::string)\u2019:\n/tmp/tmp00i5_eh1.cpp:29:45: error: no matching function for call to \u2018stoi(int)\u2019\n   29 |         result += sign * std::stoi(*it - '0');\n      |                                             ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n                 from /tmp/tmp00i5_eh1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6503:3: note: candidate: \u2018int std::__cxx11::stoi(const string&, std::size_t*, int)\u2019\n 6503 |   stoi(const string& __str, size_t* __idx = 0, int __base = 10)\n      |   ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6503:22: note:   no known conversion for argument 1 from \u2018int\u2019 to \u2018const string&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n 6503 |   stoi(const string& __str, size_t* __idx = 0, int __base = 10)\n      |        ~~~~~~~~~~~~~~^~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6609:3: note: candidate: \u2018int std::__cxx11::stoi(const wstring&, std::size_t*, int)\u2019\n 6609 |   stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)\n      |   ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6609:23: note:   no kno",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::string::size_type i = 0;\n    while (i < value.length() && value[i] == ' ') {\n        i++;\n    }\n    if (i < value.length()) {\n        if (value[i] == '-') {\n            i++;\n        }\n        while (i < value.length() && value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n            i++;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "tmpjzwnc7_n: /tmp/tmpjzwnc7_n.cpp:36: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long power = 1;\n    for (int i = value.size() - 1; i >= 0; i--) {\n        if (value[i] == '.') {\n            result += sign * power * (value[i] - '0');\n            sign = -sign;\n            power = 10;\n        } else {\n            result += sign * power * (value[i] - '0');\n            sign = 1;\n            power = 1;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "tmpw1rkz1v1: /tmp/tmpw1rkz1v1.cpp:35: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::string::size_type i = 0;\n    std::string::size_type j = 0;\n    while (i < value.size() && value[i] == '0') {\n        i++;\n    }\n    if (i == value.size()) {\n        return 0;\n    }\n    while (j < value.size() && value[j] >= '0' && value[j] <= '9') {\n        result = result * 10 + value[j] - '0';\n        j++;\n    }\n    if (i < j) {\n        result = result * 10 + value[i] - '0';\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293166,
      "stdout": "",
      "stderr": "tmpv0ld_yhd: /tmp/tmpv0ld_yhd.cpp:37: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long power = 1;\n    for (int i = value.length() - 1; i >= 0; i--) {\n        if (value[i] == '.') {\n            break;\n        }\n        if (value[i] == '-') {\n            sign = -1;\n        }\n        else {\n            result += sign * (value[i] - '0') * power;\n        }\n        power *= 10;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293166,
      "stdout": "",
      "stderr": "tmpiz3urxfi: /tmp/tmpiz3urxfi.cpp:37: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = 0; i < value.length(); i++) {\n        if (value[i] == '.') {\n            result += sign * (value[i + 1] - '0') * (long)pow(10, value.length() - i - 2);\n            break;\n        }\n        result += sign * (value[i] - '0') * (long)pow(10, value.length() - i - 1);\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293166,
      "stdout": "",
      "stderr": "tmpm4d8ll38: /tmp/tmpm4d8ll38.cpp:35: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = 0; i < value.length(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = sign * result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293166,
      "stdout": "",
      "stderr": "tmpwshbih_y: /tmp/tmpwshbih_y.cpp:34: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long temp = 0;\n    long diff = 0;\n    long max_diff = 0;\n    long max_diff_sign = 0;\n    long max_diff_temp = 0;\n    long max_diff_sign_temp = 0;\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] == '-') {\n            sign = -1;\n        } else if (value[i] >= '0' && value[i] <= '9') {\n            temp = temp * 10 + value[i] - '0';\n        } else {\n            continue;\n        }\n    }\n    if (sign == -1) {\n        temp *= -1;\n    }\n    diff = abs(temp);\n    max_diff = abs(temp);\n    max_diff_sign = sign;\n    max_diff_temp = temp;\n    max_diff_sign_temp = sign;\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] == '-') {\n            sign = -1;\n        } else if (value[i] >= '0' && value[i] <= '9') {\n            temp = temp * 10 + value[i] - '0';\n            diff = abs(temp);\n            if (diff > max_diff) {\n                max_diff = diff;\n                max_diff_sign = sign;\n                max_diff_temp = temp;\n                max_diff_sign_temp = sign;\n            }\n        }\n    }\n    if (max_diff_sign == 1) {\n        result = max_diff_temp;\n    } else {\n        result = max_diff_temp * -1;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293166,
      "stdout": "",
      "stderr": "tmp2pnsfkgt: /tmp/tmp2pnsfkgt.cpp:65: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::string::iterator it = value.begin();\n    while (it != value.end()) {\n        if (*it == '.') {\n            result = 0;\n            break;\n        }\n        result = result * 10 + (*it - '0');\n        ++it;\n    }\n    if (it == value.end()) {\n        return result;\n    }\n    if (result > 0) {\n        result = result + 5;\n    } else {\n        result = result - 5;\n    }\n    if (result < 0) {\n        result = 0;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "tmpdrocq9vd: /tmp/tmpdrocq9vd.cpp:43: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.length(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    if (result > INT_MAX) {\n        return INT_MAX;\n    } else if (result < INT_MIN) {\n        return INT_MIN;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293166,
      "stdout": "",
      "stderr": "tmp77_n574x: /tmp/tmp77_n574x.cpp:39: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (auto &c : value) {\n        if (c == '.') {\n            result = result * 10 + 0;\n        } else {\n            result = result * 10 + c - '0';\n        }\n    }\n    result = result * sign;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "tmp_mrr0794: /tmp/tmp_mrr0794.cpp:36: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long power = 1;\n    long temp = 0;\n    for (int i = value.length() - 1; i >= 0; i--) {\n        if (value[i] == '.') {\n            temp = 0;\n            while (i >= 0) {\n                temp = temp * 10 + value[i] - '0';\n                i--;\n            }\n            result = result + (temp * power);\n            power = power * 10;\n        } else {\n            if (value[i] == '-') {\n                sign = -1;\n            } else {\n                result = result + (value[i] - '0') * power;\n            }\n            power = power * 10;\n        }\n    }\n    result = result * sign;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "tmpfhz9dexn: /tmp/tmpfhz9dexn.cpp:45: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.length(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    if (result > INT_MAX) {\n        return INT_MAX;\n    }\n    if (result < INT_MIN) {\n        return INT_MIN;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "tmpdq1q4t9t: /tmp/tmpdq1q4t9t.cpp:40: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long power = 1;\n    long digit = 0;\n    long max_power = 0;\n    long max_digit = 0;\n    long max_value = 0;\n    long min_value = 0;\n    long min_power = 0;\n    long min_digit = 0;\n    long min_value = 0;\n    for (int i = 0; i < value.length(); i++) {\n        if (value[i] == '-') {\n            sign = -1;\n        } else if (value[i] >= '0' && value[i] <= '9') {\n            digit = value[i] - '0';\n            if (power > max_power) {\n                max_power = power;\n                max_digit = digit;\n                max_value = result;\n            }\n            if (power < min_power) {\n                min_power = power;\n                min_digit = digit;\n                min_value = result;\n            }\n            if (digit > max_digit) {\n                max_digit = digit;\n                max_value = result;\n            }\n            if (digit < min_digit) {\n                min_digit = digit;\n                min_value = result;\n            }\n            result = result * 10 + digit;\n            power = power * 10;\n        }\n    }\n    if (sign == -1) {\n        result = -result;\n    }\n    if (result == max_value) {\n        result = max_value + max_power;\n    } else if (result == min_value) {\n        result = min_value - min_power;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293166,
      "stdout": "",
      "stderr": "/tmp/tmpt2h_v1_m.cpp: In function \u2018long int closest_integer(std::string)\u2019:\n/tmp/tmpt2h_v1_m.cpp:27:10: error: redeclaration of \u2018long int min_value\u2019\n   27 |     long min_value = 0;\n      |          ^~~~~~~~~\n/tmp/tmpt2h_v1_m.cpp:24:10: note: \u2018long int min_value\u2019 previously declared here\n   24 |     long min_value = 0;\n      |          ^~~~~~~~~\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (auto c : value) {\n        if (c >= '0' && c <= '9') {\n            result = result * 10 + (c - '0');\n        }\n    }\n    result = result * sign;\n    if (result > INT_MAX) {\n        return INT_MAX;\n    }\n    if (result < INT_MIN) {\n        return INT_MIN;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "tmpwsfq20y5: /tmp/tmpwsfq20y5.cpp:40: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long temp = 0;\n    long power = 1;\n    long power_sign = 1;\n    long power_sign_temp = 1;\n    long power_sign_temp_2 = 1;\n    long power_sign_temp_3 = 1;\n    long power_sign_temp_4 = 1;\n    long power_sign_temp_5 = 1;\n    long power_sign_temp_6 = 1;\n    long power_sign_temp_7 = 1;\n    long power_sign_temp_8 = 1;\n    long power_sign_temp_9 = 1;\n    long power_sign_temp_10 = 1;\n    long power_sign_temp_11 = 1;\n    long power_sign_temp_12 = 1;\n    long power_sign_temp_13 = 1;\n    long power_sign_temp_14 = 1;\n    long power_sign_temp_15 = 1;\n    long power_sign_temp_16 = 1;\n    long power_sign_temp_17 = 1;\n    long power_sign_temp_18 = 1;\n    long power_sign_temp_19 = 1;\n    long power_sign_temp_20 = 1;\n    long power_sign_temp_21 = 1;\n    long power_sign_temp_22 = 1;\n    long power_sign_temp_23 = 1;\n    long power_sign_temp_24 = 1;\n    long power_sign_temp_25 = 1;\n    long power_sign_temp_26 = 1;\n    long power_sign_temp_27 = 1;\n    long power_sign_temp_28 = 1;\n    long power_sign_temp_29 = 1;\n    long power_sign_temp_30 = 1;\n    long power_sign_temp_31 = 1;\n    long power_sign_temp_32 = 1;\n    long power_sign_temp_33 = 1;\n    long power_sign_temp_34 = 1;\n    long power_sign_temp_35 = 1;\n    long power_sign_temp_36 = 1;\n    long power_sign_temp_37\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "/tmp/tmp7m2s27gf.cpp: In function \u2018long int closest_integer(std::string)\u2019:\n/tmp/tmp7m2s27gf.cpp:59:1: error: expected initializer before \u2018}\u2019 token\n   59 | }\n      | ^\n/tmp/tmp7m2s27gf.cpp:59:1: warning: no return statement in function returning non-void [-Wreturn-type]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (auto i = value.begin(); i != value.end(); ++i) {\n        if (*i == '.') {\n            result += sign * std::stoi(value.substr(0, i - value.begin()));\n            value.erase(0, i - value.begin());\n            break;\n        }\n        result += sign * std::stoi(*i - '0');\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293166,
      "stdout": "",
      "stderr": "/tmp/tmpnl3m4sg0.cpp: In function \u2018long int closest_integer(std::string)\u2019:\n/tmp/tmpnl3m4sg0.cpp:29:44: error: no matching function for call to \u2018stoi(int)\u2019\n   29 |         result += sign * std::stoi(*i - '0');\n      |                                            ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n                 from /tmp/tmpnl3m4sg0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6503:3: note: candidate: \u2018int std::__cxx11::stoi(const string&, std::size_t*, int)\u2019\n 6503 |   stoi(const string& __str, size_t* __idx = 0, int __base = 10)\n      |   ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6503:22: note:   no known conversion for argument 1 from \u2018int\u2019 to \u2018const string&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n 6503 |   stoi(const string& __str, size_t* __idx = 0, int __base = 10)\n      |        ~~~~~~~~~~~~~~^~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6609:3: note: candidate: \u2018int std::__cxx11::stoi(const wstring&, std::size_t*, int)\u2019\n 6609 |   stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)\n      |   ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6609:23: note:   no known",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "tmp664fsprx: /tmp/tmp664fsprx.cpp:34: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::string::size_type pos = 0;\n    while (pos < value.length()) {\n        if (value[pos] == '.') {\n            pos++;\n            while (pos < value.length() && value[pos] >= '0' && value[pos] <= '9') {\n                result = result * 10 + value[pos] - '0';\n                pos++;\n            }\n            break;\n        } else {\n            result = result * 10 + value[pos] - '0';\n            pos++;\n        }\n    }\n    if (pos < value.length()) {\n        if (value[pos] == '.') {\n            pos++;\n            while (pos < value.length() && value[pos] >= '0' && value[pos] <= '9') {\n                result = result * 10 + value[pos] - '0';\n                pos++;\n            }\n        } else {\n            result = result * 10 + value[pos] - '0';\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "tmpgq6cbuq9: /tmp/tmpgq6cbuq9.cpp:48: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] == '.') {\n            result = sign * (value.substr(0, i) - 0);\n            break;\n        }\n        result = sign * (value[i] - '0') * (long)pow(10, value.size() - i - 1);\n        if (result > INT_MAX) {\n            result = INT_MAX;\n            break;\n        }\n        if (result < INT_MIN) {\n            result = INT_MIN;\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293166,
      "stdout": "",
      "stderr": "/tmp/tmp98kergr2.cpp: In function \u2018long int closest_integer(std::string)\u2019:\n/tmp/tmp98kergr2.cpp:25:49: error: no match for \u2018operator-\u2019 (operand types are \u2018std::__cxx11::basic_string<char>\u2019 and \u2018int\u2019)\n   25 |             result = sign * (value.substr(0, i) - 0);\n      |                              ~~~~~~~~~~~~~~~~~~ ^ ~\n      |                                          |        |\n      |                                          |        int\n      |                                          std::__cxx11::basic_string<char>\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:41,\n                 from /tmp/tmp98kergr2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:415:5: note: candidate: \u2018template<class _IteratorL, class _IteratorR> constexpr decltype ((__y.base() - __x.base())) std::operator-(const std::reverse_iterator<_Iterator>&, const std::reverse_iterator<_IteratorR>&)\u2019\n  415 |     operator-(const reverse_iterator<_IteratorL>& __x,\n      |     ^~~~~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_iterator.h:415:5: note:   template argument deduction/substitution failed:\n/tmp/tmp98kergr2.cpp:25:51: note:   \u2018std::__cxx11::basic_string<char>\u2019 is not derived from \u2018const std::reverse_iterator<_Iterator>\u2019\n   25 |             result = sign * (value.substr(0, i) - 0);\n      |                                                   ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:67,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/specfun.h:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/cmath:1927,\n                 fro",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "tmp664fsprx: /tmp/tmp664fsprx.cpp:34: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long power = 1;\n    long digit = 0;\n    long max_power = 0;\n    long max_digit = 0;\n    long max_diff = 0;\n    long diff = 0;\n    long max_diff_power = 0;\n    long max_diff_digit = 0;\n    long diff_power = 0;\n    long diff_digit = 0;\n    long diff_sign = 0;\n    long diff_sign_power = 0;\n    long diff_sign_digit = 0;\n    long diff_sign_sign_power = 0;\n    long diff_sign_sign_digit = 0;\n    long diff_sign_sign_sign_power = 0;\n    long diff_sign_sign_sign_digit = 0;\n    long diff_sign_sign_sign_sign_power = 0;\n    long diff_sign_sign_sign_sign_digit = 0;\n    long diff_sign_sign_sign_sign_sign_power = 0;\n    long diff_sign_sign_sign_sign_sign_digit = 0;\n    long diff_sign_sign_sign_sign_sign_sign_power = 0;\n    long diff_sign_sign_sign_sign_sign_sign_digit = 0;\n    long diff_sign_sign_sign_sign_sign_sign_sign_power = 0;\n    long diff_sign_sign_sign_sign_sign_sign_sign_digit = 0;\n    long diff_sign_sign_sign_sign_sign_sign_sign_sign_power = 0;\n    long diff_sign_sign_sign_sign_sign_sign_sign_sign_digit = 0;\n    long diff_sign_sign_sign_sign_sign_sign_sign_sign_sign_power = 0;\n    long diff_sign_sign_sign_sign_sign_sign_sign_sign_sign_digit = 0;\n    long diff_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_power = 0;\n    long diff_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign_digit = 0;\n    \n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "tmpu4ankk3x: /tmp/tmpu4ankk3x.cpp:54: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long power = 0;\n    long temp = 0;\n    long max = 0;\n    long min = 0;\n    long diff = 0;\n    long diff_sign = 0;\n    long diff_power = 0;\n    long diff_temp = 0;\n    long diff_max = 0;\n    long diff_min = 0;\n    long diff_diff = 0;\n    long diff_diff_sign = 0;\n    long diff_diff_power = 0;\n    long diff_diff_temp = 0;\n    long diff_diff_max = 0;\n    long diff_diff_min = 0;\n    long diff_diff_diff = 0;\n    long diff_diff_diff_sign = 0;\n    long diff_diff_diff_power = 0;\n    long diff_diff_diff_temp = 0;\n    long diff_diff_diff_max = 0;\n    long diff_diff_diff_min = 0;\n    long diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_sign = 0;\n    long diff_diff_diff_diff_power = 0;\n    long diff_diff_diff_diff_temp = 0;\n    long diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_sign = 0;\n    long diff_diff_diff_diff_diff_power = 0;\n    long diff_diff_diff_diff_diff_temp = 0;\n    long diff_diff_diff_diff_diff_max = 0;\n    long diff_diff_diff_diff_diff_min = 0;\n    long diff_diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_diff_sign = 0;\n    long diff_diff_diff_diff_diff_diff_power = 0;\n    long diff_diff_diff_diff_diff_diff_temp = 0;\n    long diff_diff_diff_diff_diff_diff_max =\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293166,
      "stdout": "",
      "stderr": "/tmp/tmpfb57zuxw.cpp: In function \u2018long int closest_integer(std::string)\u2019:\n/tmp/tmpfb57zuxw.cpp:58:1: error: expected primary-expression before \u2018}\u2019 token\n   58 | }\n      | ^\n/tmp/tmpfb57zuxw.cpp:58:1: warning: no return statement in function returning non-void [-Wreturn-type]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long power = 1;\n    for (int i = value.length() - 1; i >= 0; i--) {\n        if (value[i] == '.') {\n            power = 10;\n            break;\n        }\n        if (value[i] == '-') {\n            sign = -1;\n            continue;\n        }\n        result += sign * (value[i] - '0') * power;\n        power *= 10;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "tmpnh8815ly: /tmp/tmpnh8815ly.cpp:37: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = value.size() - 1; i >= 0; i--) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    if (result < 0) {\n        result = -result;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "tmpt0pyc2x3: /tmp/tmpt0pyc2x3.cpp:36: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmp_fltreji: /tmp/tmp_fltreji.cpp:34: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] == '.') {\n            result = sign * (value[i + 1] - '0');\n            break;\n        }\n        result = sign * (value[i] - '0');\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "tmpe3ews7xs: /tmp/tmpe3ews7xs.cpp:34: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = sign * result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "tmp8eayv3of: /tmp/tmp8eayv3of.cpp:34: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long abs_value = 0;\n    long power = 1;\n    for (int i = value.size() - 1; i >= 0; i--) {\n        if (value[i] == '-') {\n            sign = -1;\n        } else if (value[i] >= '0' && value[i] <= '9') {\n            abs_value = abs_value * 10 + value[i] - '0';\n        } else {\n            break;\n        }\n    }\n    if (abs_value == 0) {\n        return 0;\n    }\n    if (abs_value < 0) {\n        abs_value *= -1;\n    }\n    while (abs_value >= power) {\n        result += power;\n        power *= 10;\n    }\n    result += abs_value / power;\n    result *= sign;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293168,
      "stdout": "",
      "stderr": "tmpbh2w0ym6: /tmp/tmpbh2w0ym6.cpp:46: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (auto c : value) {\n        if (c == '.') {\n            result = result * 10 + 0;\n        } else {\n            result = result * 10 + c - '0';\n        }\n    }\n    result = sign * result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293168,
      "stdout": "",
      "stderr": "tmpiew5jwj0: /tmp/tmpiew5jwj0.cpp:36: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (auto &c : value) {\n        if (c == '.') {\n            result += sign * (long) std::stod(value);\n            return result;\n        }\n        result = result * 10 + (long) c - '0';\n    }\n    return result * sign;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293168,
      "stdout": "",
      "stderr": "tmp3mon037k: /tmp/tmp3mon037k.cpp:35: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = 0; i < value.size(); ++i) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    if (result > INT_MAX) {\n        return INT_MAX;\n    }\n    if (result < INT_MIN) {\n        return INT_MIN;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293168,
      "stdout": "",
      "stderr": "tmp0u0cuswu: /tmp/tmp0u0cuswu.cpp:40: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long power = 1;\n    long digit = 0;\n    long max_power = 0;\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] == '-') {\n            sign = -1;\n        } else if (value[i] >= '0' && value[i] <= '9') {\n            digit = value[i] - '0';\n            if (power > max_power) {\n                max_power = power;\n            }\n            result += digit * power;\n            power *= 10;\n        }\n    }\n    result = result + (max_power - power) / 2;\n    result *= sign;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293168,
      "stdout": "",
      "stderr": "tmpka1svr_m: /tmp/tmpka1svr_m.cpp:40: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "tmp664fsprx: /tmp/tmp664fsprx.cpp:34: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = value.length() - 1; i >= 0; i--) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    if (result < 0) {\n        result = 0;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293168,
      "stdout": "",
      "stderr": "tmpzrg_kg2y: /tmp/tmpzrg_kg2y.cpp:36: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] == '.') {\n            result += sign * (value[i + 1] - '0') / 10;\n            i++;\n        } else {\n            result += sign * (value[i] - '0');\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293168,
      "stdout": "",
      "stderr": "tmp3mclx130: /tmp/tmp3mclx130.cpp:35: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (auto it = value.begin(); it != value.end(); ++it) {\n        if (*it == '.') {\n            result = result * 10 + 0;\n        } else {\n            result = result * 10 + *it - '0';\n        }\n    }\n    result = result * sign;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293168,
      "stdout": "",
      "stderr": "tmpjc0eqmxp: /tmp/tmpjc0eqmxp.cpp:36: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = 0; i < value.length(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    if (result < 0) {\n        result = 0;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293168,
      "stdout": "",
      "stderr": "tmphkx130q7: /tmp/tmphkx130q7.cpp:37: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long power = 1;\n    long digit = 0;\n    long max_power = 0;\n    long max_digit = 0;\n    long max_value = 0;\n    long min_value = 0;\n    long min_digit = 0;\n    long min_power = 0;\n    long min_result = 0;\n    long max_result = 0;\n    long min_result_sign = 0;\n    long max_result_sign = 0;\n    long max_result_power = 0;\n    long max_result_digit = 0;\n    long max_result_value = 0;\n    long min_result_value = 0;\n    long min_result_digit = 0;\n    long min_result_power = 0;\n    long min_result_sign = 0;\n    long max_result_sign = 0;\n    long max_result_power = 0;\n    long max_result_digit = 0;\n    long max_result_value = 0;\n    long min_result_value = 0;\n    long min_result_digit = 0;\n    long min_result_power = 0;\n    long min_result_sign = 0;\n    long max_result_sign = 0;\n    long max_result_power = 0;\n    long max_result_digit = 0;\n    long max_result_value = 0;\n    long min_result_value = 0;\n    long min_result_digit = 0;\n    long min_result_power = 0;\n    long min_result_sign = 0;\n    long max_result_sign = 0;\n    long max_result_power = 0;\n    long max_result_digit = 0;\n    long max_result_value = 0;\n    long min_result_value = 0;\n    long min_result_digit = 0;\n    long min_result_power = 0;\n    long min_result_sign = 0;\n    long max_result_sign = 0;\n    long max_result_power = 0;\n    long max_result_digit = 0;\n    long max_result_value = 0;\n    long min_result\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293168,
      "stdout": "",
      "stderr": "/tmp/tmpdppti4br.cpp: In function \u2018long int closest_integer(std::string)\u2019:\n/tmp/tmpdppti4br.cpp:37:10: error: redeclaration of \u2018long int min_result_sign\u2019\n   37 |     long min_result_sign = 0;\n      |          ^~~~~~~~~~~~~~~\n/tmp/tmpdppti4br.cpp:29:10: note: \u2018long int min_result_sign\u2019 previously declared here\n   29 |     long min_result_sign = 0;\n      |          ^~~~~~~~~~~~~~~\n/tmp/tmpdppti4br.cpp:38:10: error: redeclaration of \u2018long int max_result_sign\u2019\n   38 |     long max_result_sign = 0;\n      |          ^~~~~~~~~~~~~~~\n/tmp/tmpdppti4br.cpp:30:10: note: \u2018long int max_result_sign\u2019 previously declared here\n   30 |     long max_result_sign = 0;\n      |          ^~~~~~~~~~~~~~~\n/tmp/tmpdppti4br.cpp:39:10: error: redeclaration of \u2018long int max_result_power\u2019\n   39 |     long max_result_power = 0;\n      |          ^~~~~~~~~~~~~~~~\n/tmp/tmpdppti4br.cpp:31:10: note: \u2018long int max_result_power\u2019 previously declared here\n   31 |     long max_result_power = 0;\n      |          ^~~~~~~~~~~~~~~~\n/tmp/tmpdppti4br.cpp:40:10: error: redeclaration of \u2018long int max_result_digit\u2019\n   40 |     long max_result_digit = 0;\n      |          ^~~~~~~~~~~~~~~~\n/tmp/tmpdppti4br.cpp:32:10: note: \u2018long int max_result_digit\u2019 previously declared here\n   32 |     long max_result_digit = 0;\n      |          ^~~~~~~~~~~~~~~~\n/tmp/tmpdppti4br.cpp:41:10: error: redeclaration of \u2018long int max_result_value\u2019\n   41 |     long max_result_value = 0;\n      |          ^~~~~~~~~~~~~~~~\n/tmp/tmpdppti4br.cpp:33:10: note: \u2018long int max_result_value\u2019 previously declared here\n   33 |     long max_result_value = 0;\n      |          ^~~~~~~~~~~~~~~~\n/tmp/tmpdppti4br.cpp:42:10: error: redeclaration of \u2018long int min_result_value\u2019\n   42 |     long min_result_value = 0;\n      |          ^~~~~~~~~~~~~~~~\n/tmp/tmpdppti4br.cpp:34:10: note: \u2018long int min_result_value\u2019 previously declared here\n   34 |     long min_result_value = 0;\n      |          ^~~~~~~~~~~~~~~~\n/tmp/tmpdppti4br.cpp:43:10: error: redeclaration of \u2018",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = sign * result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "tmp8eayv3of: /tmp/tmp8eayv3of.cpp:34: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::string::iterator it = value.begin();\n    while (it != value.end() && *it == ' ') {\n        it++;\n    }\n    if (it == value.end()) {\n        return result;\n    }\n    if (*it == '-') {\n        result = -1;\n        it++;\n    }\n    while (it != value.end() && *it >= '0' && *it <= '9') {\n        result = result * 10 + (*it - '0');\n        it++;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293168,
      "stdout": "",
      "stderr": "tmpiovrc8_x: /tmp/tmpiovrc8_x.cpp:38: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long power = 1;\n    long digit = 0;\n    long max_power = 0;\n    long max_digit = 0;\n    long max_result = 0;\n    long min_result = 0;\n    long min_power = 0;\n    long min_digit = 0;\n    long max_power_digit = 0;\n    long min_power_digit = 0;\n    long min_power_digit_power = 0;\n    long max_power_digit_power = 0;\n    long min_power_digit_power_digit = 0;\n    long max_power_digit_power_digit = 0;\n    long min_power_digit_power_digit_digit = 0;\n    long max_power_digit_power_digit_digit = 0;\n    long min_power_digit_power_digit_digit_digit = 0;\n    long max_power_digit_power_digit_digit_digit = 0;\n    long min_power_digit_power_digit_digit_digit_digit = 0;\n    long max_power_digit_power_digit_digit_digit_digit = 0;\n    long min_power_digit_power_digit_digit_digit_digit_digit = 0;\n    long max_power_digit_power_digit_digit_digit_digit_digit = 0;\n    long min_power_digit_power_digit_digit_digit_digit_digit_digit = 0;\n    long max_power_digit_power_digit_digit_digit_digit_digit_digit = 0;\n    long min_power_digit_power_digit_digit_digit_digit_digit_digit_digit = 0;\n    long max_power_digit_power_digit_digit_digit_digit_digit_digit_digit = 0;\n    long min_power_digit_power_digit_digit_digit_digit_digit_digit_digit_digit = 0;\n    long max_power_digit_power_digit_digit_digit_digit_digit_digit_digit_digit = 0;\n    long min_power_digit_power_digit_digit_digit_digit_digit_digit_digit_digit_digit = 0;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293168,
      "stdout": "",
      "stderr": "tmpssx96_3o: /tmp/tmpssx96_3o.cpp:51: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long factor = 1;\n    long power = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 =\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293168,
      "stdout": "",
      "stderr": "/tmp/tmp9sv1k8oa.cpp: In function \u2018long int closest_integer(std::string)\u2019:\n/tmp/tmp9sv1k8oa.cpp:82:1: error: expected primary-expression before \u2018}\u2019 token\n   82 | }\n      | ^\n/tmp/tmp9sv1k8oa.cpp:82:1: warning: no return statement in function returning non-void [-Wreturn-type]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.length(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293169,
      "stdout": "",
      "stderr": "tmp3mtdnwel: /tmp/tmp3mtdnwel.cpp:34: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (auto it = value.begin(); it != value.end(); ++it) {\n        if (*it == '.') {\n            result += sign * std::stoi(value.substr(0, it - value.begin()));\n            value.erase(0, it - value.begin());\n            break;\n        }\n        result += sign * std::stoi(*it - '0');\n    }\n    if (value.size() > 0) {\n        result += sign * std::stoi(value);\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "/tmp/tmpamj39w5q.cpp: In function \u2018long int closest_integer(std::string)\u2019:\n/tmp/tmpamj39w5q.cpp:29:45: error: no matching function for call to \u2018stoi(int)\u2019\n   29 |         result += sign * std::stoi(*it - '0');\n      |                                             ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n                 from /tmp/tmpamj39w5q.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6503:3: note: candidate: \u2018int std::__cxx11::stoi(const string&, std::size_t*, int)\u2019\n 6503 |   stoi(const string& __str, size_t* __idx = 0, int __base = 10)\n      |   ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6503:22: note:   no known conversion for argument 1 from \u2018int\u2019 to \u2018const string&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n 6503 |   stoi(const string& __str, size_t* __idx = 0, int __base = 10)\n      |        ~~~~~~~~~~~~~~^~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6609:3: note: candidate: \u2018int std::__cxx11::stoi(const wstring&, std::size_t*, int)\u2019\n 6609 |   stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)\n      |   ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6609:23: note:   no kno",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (auto it = value.begin(); it != value.end(); ++it) {\n        if (*it == '.') {\n            result += sign * std::stoi(value.substr(0, it - value.begin()));\n            value.erase(0, it - value.begin());\n            break;\n        }\n        result += sign * std::stoi(*it - '0');\n    }\n    result += sign * std::stoi(value);\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "/tmp/tmp00i5_eh1.cpp: In function \u2018long int closest_integer(std::string)\u2019:\n/tmp/tmp00i5_eh1.cpp:29:45: error: no matching function for call to \u2018stoi(int)\u2019\n   29 |         result += sign * std::stoi(*it - '0');\n      |                                             ^\nIn file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/string:55,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/locale_classes.h:40,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/ios_base.h:41,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ios:42,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/istream:38,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/sstream:38,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/complex:45,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/ccomplex:39,\n                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:54,\n                 from /tmp/tmp00i5_eh1.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6503:3: note: candidate: \u2018int std::__cxx11::stoi(const string&, std::size_t*, int)\u2019\n 6503 |   stoi(const string& __str, size_t* __idx = 0, int __base = 10)\n      |   ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6503:22: note:   no known conversion for argument 1 from \u2018int\u2019 to \u2018const string&\u2019 {aka \u2018const std::__cxx11::basic_string<char>&\u2019}\n 6503 |   stoi(const string& __str, size_t* __idx = 0, int __base = 10)\n      |        ~~~~~~~~~~~~~~^~~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6609:3: note: candidate: \u2018int std::__cxx11::stoi(const wstring&, std::size_t*, int)\u2019\n 6609 |   stoi(const wstring& __str, size_t* __idx = 0, int __base = 10)\n      |   ^~~~\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/basic_string.h:6609:23: note:   no kno",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::string::iterator it = value.begin();\n    while (it != value.end()) {\n        if (*it == '.') {\n            result = result * 10 + 0;\n        } else {\n            result = result * 10 + (*it - '0');\n        }\n        it++;\n    }\n    if (result > 0) {\n        result = result / 10;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293169,
      "stdout": "",
      "stderr": "tmp8m7w1xhg: /tmp/tmp8m7w1xhg.cpp:34: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    if (result > INT_MAX) {\n        return INT_MAX;\n    }\n    if (result < INT_MIN) {\n        return INT_MIN;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293169,
      "stdout": "",
      "stderr": "tmp6ahnab83: /tmp/tmp6ahnab83.cpp:40: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (char c : value) {\n        if (c == '.') {\n            result = result * 10 + 0;\n        } else {\n            result = result * 10 + (c - '0');\n        }\n    }\n    result = result * sign;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293169,
      "stdout": "",
      "stderr": "tmpn8i07c3e: /tmp/tmpn8i07c3e.cpp:36: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long power = 1;\n    for (int i = value.length() - 1; i >= 0; i--) {\n        if (value[i] == '.') {\n            result += sign * power * (value[i] - '0');\n            sign = -sign;\n            power *= 10;\n        } else {\n            result += sign * power * (value[i] - '0');\n            sign = -sign;\n            power *= 10;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293169,
      "stdout": "",
      "stderr": "tmpsoipngau: /tmp/tmpsoipngau.cpp:35: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long power = 1;\n    long digit = 0;\n    long max_power = 0;\n    long max_digit = 0;\n    long max_digit_power = 0;\n    long max_digit_power_value = 0;\n    long max_digit_power_sign = 0;\n    long max_digit_power_sign_value = 0;\n    long max_digit_power_sign_sign = 0;\n    long max_digit_power_sign_sign_value = 0;\n    long max_digit_power_sign_sign_sign = 0;\n    long max_digit_power_sign_sign_sign_value = 0;\n    long max_digit_power_sign_sign_sign_sign = 0;\n    long max_digit_power_sign_sign_sign_sign_value = 0;\n    long max_digit_power_sign_sign_sign_sign_sign = 0;\n    long max_digit_power_sign_sign_sign_sign_sign_value = 0;\n    long max_digit_power_sign_sign_sign_sign_sign_sign = 0;\n    long max_digit_power_sign_sign_sign_sign_sign_sign_value = 0;\n    long max_digit_power_sign_sign_sign_sign_sign_sign_sign = 0;\n    long max_digit_power_sign_sign_sign_sign_sign_sign_sign_value = 0;\n    long max_digit_power_sign_sign_sign_sign_sign_sign_sign_sign = 0;\n    long max_digit_power_sign_sign_sign_sign_sign_sign_sign_sign_value = 0;\n    long max_digit_power_sign_sign_sign_sign_sign_sign_sign_sign_sign = 0;\n    long max_digit_power_sign_sign_sign_sign_sign_sign_sign_sign_sign_value = 0;\n    long max_digit_power_sign_sign_sign_sign_sign_sign_sign_sign_sign_sign = 0;\n    long max_digit_power_sign_sign_sign_sign\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293168,
      "stdout": "",
      "stderr": "/tmp/tmp59ugafpk.cpp: In function \u2018long int closest_integer(std::string)\u2019:\n/tmp/tmp59ugafpk.cpp:45:1: error: expected initializer before \u2018}\u2019 token\n   45 | }\n      | ^\n/tmp/tmp59ugafpk.cpp:45:1: warning: no return statement in function returning non-void [-Wreturn-type]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.length(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    if (result < 0) {\n        result = 0;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293168,
      "stdout": "",
      "stderr": "tmppzjagzjr: /tmp/tmppzjagzjr.cpp:37: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    if (result > INT_MAX) {\n        return INT_MAX;\n    }\n    if (result < INT_MIN) {\n        return INT_MIN;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpx1eas_29: /tmp/tmpx1eas_29.cpp:40: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::string::size_type i = 0;\n    while (i < value.size() && value[i] == '0') {\n        i++;\n    }\n    if (i < value.size()) {\n        result = std::stol(value.substr(i));\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293168,
      "stdout": "",
      "stderr": "tmp1zset25b: /tmp/tmp1zset25b.cpp:30: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (auto c : value) {\n        if (c >= '0' && c <= '9') {\n            result = result * 10 + (c - '0');\n        }\n    }\n    result = result * sign;\n    if (result > INT_MAX) {\n        return INT_MAX;\n    }\n    if (result < INT_MIN) {\n        return INT_MIN;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "tmpwsfq20y5: /tmp/tmpwsfq20y5.cpp:40: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        } else {\n            break;\n        }\n    }\n    result = result * sign;\n    if (result == 0) {\n        return 0;\n    }\n    if (result < 0) {\n        result = -result;\n    }\n    if (result % 2 == 0) {\n        result = result / 2;\n    } else {\n        result = (result + 1) / 2;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293169,
      "stdout": "",
      "stderr": "tmpo50cq7q_: /tmp/tmpo50cq7q_.cpp:46: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmp_fltreji: /tmp/tmp_fltreji.cpp:34: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long power = 1;\n    long temp = 0;\n    long diff = 0;\n    long max = 0;\n    long min = 0;\n    long temp_diff = 0;\n    long temp_max = 0;\n    long temp_min = 0;\n    long temp_diff_sign = 0;\n    long temp_max_sign = 0;\n    long temp_min_sign = 0;\n    long temp_diff_sign_sign = 0;\n    long temp_max_sign_sign = 0;\n    long temp_min_sign_sign = 0;\n    long temp_diff_sign_sign_sign = 0;\n    long temp_max_sign_sign_sign = 0;\n    long temp_min_sign_sign_sign = 0;\n    long temp_diff_sign_sign_sign_sign = 0;\n    long temp_max_sign_sign_sign_sign = 0;\n    long temp_min_sign_sign_sign_sign = 0;\n    long temp_diff_sign_sign_sign_sign_sign = 0;\n    long temp_max_sign_sign_sign_sign_sign = 0;\n    long temp_min_sign_sign_sign_sign_sign = 0;\n    long temp_diff_sign_sign_sign_sign_sign_sign = 0;\n    long temp_max_sign_sign_sign_sign_sign_sign = 0;\n    long temp_min_sign_sign_sign_sign_sign_sign = 0;\n    long temp_diff_sign_sign_sign_sign_sign_sign_sign = 0;\n    long temp_max_sign_sign_sign_sign_sign_sign_sign = 0;\n    long temp_min_sign_sign_sign_sign_sign_sign_sign = 0;\n    long temp_diff_sign_sign_sign_sign_sign_sign_sign_sign = 0;\n    long temp_max_sign_sign_sign_sign_sign_sign_sign_sign = 0;\n    long temp_min_sign_sign_sign_sign_sign_sign_sign_sign = 0;\n    long temp_\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293169,
      "stdout": "",
      "stderr": "/tmp/tmpykem__u5.cpp: In function \u2018long int closest_integer(std::string)\u2019:\n/tmp/tmpykem__u5.cpp:52:1: error: expected initializer before \u2018}\u2019 token\n   52 | }\n      | ^\n/tmp/tmpykem__u5.cpp:52:1: warning: no return statement in function returning non-void [-Wreturn-type]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long factor = 1;\n    long power = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61 =\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293168,
      "stdout": "",
      "stderr": "/tmp/tmp9sv1k8oa.cpp: In function \u2018long int closest_integer(std::string)\u2019:\n/tmp/tmp9sv1k8oa.cpp:82:1: error: expected primary-expression before \u2018}\u2019 token\n   82 | }\n      | ^\n/tmp/tmp9sv1k8oa.cpp:82:1: warning: no return statement in function returning non-void [-Wreturn-type]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::string::iterator it = value.begin();\n    while (it != value.end()) {\n        if (*it == '.') {\n            it++;\n            while (it != value.end() && *it != '.') {\n                result = result * 10 + (*it - '0');\n                it++;\n            }\n            break;\n        } else {\n            result = result * 10 + (*it - '0');\n            it++;\n        }\n    }\n    if (it != value.end()) {\n        result = result * 10 + (*it - '0');\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293170,
      "stdout": "",
      "stderr": "tmpqb1o2hq2: /tmp/tmpqb1o2hq2.cpp:40: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long num = 0;\n    long num_sign = 1;\n    long num_abs = 0;\n    long num_abs_sign = 1;\n    long num_abs_abs = 0;\n    long num_abs_abs_sign = 1;\n    long num_abs_abs_abs = 0;\n    long num_abs_abs_abs_sign = 1;\n    long num_abs_abs_abs_abs = 0;\n    long num_abs_abs_abs_abs_sign = 1;\n    long num_abs_abs_abs_abs_abs = 0;\n    long num_abs_abs_abs_abs_abs_sign = 1;\n    long num_abs_abs_abs_abs_abs_abs = 0;\n    long num_abs_abs_abs_abs_abs_abs_sign = 1;\n    long num_abs_abs_abs_abs_abs_abs_abs = 0;\n    long num_abs_abs_abs_abs_abs_abs_abs_sign = 1;\n    long num_abs_abs_abs_abs_abs_abs_abs_abs = 0;\n    long num_abs_abs_abs_abs_abs_abs_abs_abs_sign = 1;\n    long num_abs_abs_abs_abs_abs_abs_abs_abs_abs = 0;\n    long num_abs_abs_abs_abs_abs_abs_abs_abs_abs_sign = 1;\n    long num_abs_abs_abs_abs_abs_abs_abs_abs_abs_abs = 0;\n    long num_abs_abs_abs_abs_abs_abs_abs_abs_abs_abs_sign = 1;\n    long num_abs_abs_abs_abs_abs_abs_abs_abs_abs_abs_abs = 0;\n    long num_abs_abs_abs_abs_abs_abs_abs_abs_abs_abs_abs_sign = 1;\n    long num_abs_abs_abs_abs_abs_abs_abs_abs_abs_abs_abs_abs = 0;\n    long num_abs_abs_abs_abs\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293170,
      "stdout": "",
      "stderr": "/tmp/tmpahlc88p7.cpp: In function \u2018long int closest_integer(std::string)\u2019:\n/tmp/tmpahlc88p7.cpp:45:1: error: expected initializer before \u2018}\u2019 token\n   45 | }\n      | ^\n/tmp/tmpahlc88p7.cpp:45:1: warning: no return statement in function returning non-void [-Wreturn-type]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] == '.') {\n            result = result * 10 + sign * (value[i + 1] - '0');\n            i++;\n        } else {\n            result = result * 10 + sign * (value[i] - '0');\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293170,
      "stdout": "",
      "stderr": "tmpz98y3viu: /tmp/tmpz98y3viu.cpp:36: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (auto it = value.begin(); it != value.end(); ++it) {\n        if (*it == '.') {\n            result = result * 10 + sign * (*it - '0');\n        } else {\n            result = result * 10 + sign * (*it - '0');\n            break;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293170,
      "stdout": "",
      "stderr": "tmp7_euz0lk: /tmp/tmp7_euz0lk.cpp:35: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::string::iterator it = value.begin();\n    while (it != value.end() && std::isdigit(*it)) {\n        result = result * 10 + *it - '0';\n        ++it;\n    }\n    if (it != value.end()) {\n        result = result * 10 + *it - '0';\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "tmpkud7cs2f: /tmp/tmpkud7cs2f.cpp:31: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = sign * result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293170,
      "stdout": "",
      "stderr": "tmpjv058an0: /tmp/tmpjv058an0.cpp:34: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long number = 0;\n    long power = 1;\n    for (int i = value.length() - 1; i >= 0; i--) {\n        if (value[i] == '.') {\n            number = 0;\n            power = 1;\n            continue;\n        }\n        number += (value[i] - '0') * power;\n        power *= 10;\n    }\n    if (number < 0) {\n        sign = -1;\n        number *= sign;\n    }\n    result = number / power;\n    if (result * power == number) {\n        result += sign;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293170,
      "stdout": "",
      "stderr": "tmpu89v5add: /tmp/tmpu89v5add.cpp:42: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = value.length() - 1; i >= 0; i--) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    if (result > INT_MAX) {\n        return INT_MAX;\n    }\n    if (result < INT_MIN) {\n        return INT_MIN;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293170,
      "stdout": "",
      "stderr": "tmp943mins1: /tmp/tmp943mins1.cpp:39: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        } else {\n            break;\n        }\n    }\n    result = sign * result;\n    if (result == 0) {\n        result = 1;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293170,
      "stdout": "",
      "stderr": "tmptyf1opze: /tmp/tmptyf1opze.cpp:39: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmp_fltreji: /tmp/tmp_fltreji.cpp:34: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = 0; i < value.size(); ++i) {\n        if (value[i] == '.') {\n            result = sign * (value[i] - '0');\n            break;\n        }\n        result = sign * (value[i] - '0') + result * 10;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293170,
      "stdout": "",
      "stderr": "tmpkb2oqm8t: /tmp/tmpkb2oqm8t.cpp:35: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293167,
      "stdout": "",
      "stderr": "tmp664fsprx: /tmp/tmp664fsprx.cpp:34: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::string::size_type i = 0;\n    while (i < value.length() && value[i] == ' ') {\n        i++;\n    }\n    if (i < value.length()) {\n        if (value[i] == '-') {\n            result = -1;\n            i++;\n        }\n        while (i < value.length() && value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n            i++;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293170,
      "stdout": "",
      "stderr": "tmpx_d6990o: /tmp/tmpx_d6990o.cpp:37: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long power = 1;\n    long max_power = 0;\n    for (auto c : value) {\n        if (c == '-') {\n            sign = -1;\n        } else if (c == '.') {\n            power = 0;\n        } else {\n            if (power == 0) {\n                result = result * 10 + (c - '0');\n            } else {\n                result = result * 10 + (c - '0');\n                max_power = std::max(max_power, power);\n            }\n            power++;\n        }\n    }\n    if (sign == -1) {\n        result = -result;\n    }\n    if (max_power > 0) {\n        result = result / (long)pow(10, max_power);\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293170,
      "stdout": "",
      "stderr": "tmplpvhr271: /tmp/tmplpvhr271.cpp:46: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] == '.') {\n            result += sign * (value[i + 1] - '0') / 10;\n            i++;\n        } else {\n            result += sign * (value[i] - '0');\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293170,
      "stdout": "",
      "stderr": "tmpmw5h0hos: /tmp/tmpmw5h0hos.cpp:35: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long factor = 1;\n    long temp = 0;\n    long temp_sign = 1;\n    long temp_factor = 1;\n    long temp_result = 0;\n    long temp_temp = 0;\n    long temp_temp_sign = 1;\n    long temp_temp_factor = 1;\n    long temp_temp_result = 0;\n    long temp_temp_temp = 0;\n    long temp_temp_temp_sign = 1;\n    long temp_temp_temp_factor = 1;\n    long temp_temp_temp_result = 0;\n    long temp_temp_temp_temp = 0;\n    long temp_temp_temp_temp_sign = 1;\n    long temp_temp_temp_temp_factor = 1;\n    long temp_temp_temp_temp_result = 0;\n    long temp_temp_temp_temp_temp = 0;\n    long temp_temp_temp_temp_temp_sign = 1;\n    long temp_temp_temp_temp_temp_factor = 1;\n    long temp_temp_temp_temp_temp_result = 0;\n    long temp_temp_temp_temp_temp_temp = 0;\n    long temp_temp_temp_temp_temp_temp_sign = 1;\n    long temp_temp_temp_temp_temp_temp_factor = 1;\n    long temp_temp_temp_temp_temp_temp_result = 0;\n    long temp_temp_temp_temp_temp_temp_temp = 0;\n    long temp_temp_temp_temp_temp_temp_temp_sign = 1;\n    long temp_temp_temp_temp_temp_temp_temp_factor = 1;\n    long temp_temp_temp_temp_temp_temp_temp_result = 0;\n    long temp_temp_temp_temp_temp_temp_temp_temp = 0;\n    long temp_temp_temp_temp_temp_temp_temp_temp_sign = 1;\n    long temp_temp_temp_temp_temp_temp_temp_temp_factor = 1;\n    long temp_temp_temp_temp_temp_temp_temp_temp_\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293170,
      "stdout": "",
      "stderr": "/tmp/tmp0ka7xguz.cpp: In function \u2018long int closest_integer(std::string)\u2019:\n/tmp/tmp0ka7xguz.cpp:52:1: error: expected initializer before \u2018}\u2019 token\n   52 | }\n      | ^\n/tmp/tmp0ka7xguz.cpp:52:1: warning: no return statement in function returning non-void [-Wreturn-type]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (char &c : value) {\n        if (c >= '0' && c <= '9') {\n            result = result * 10 + c - '0';\n        }\n    }\n    result = result * sign;\n    if (result > INT_MAX) {\n        return INT_MAX;\n    }\n    if (result < INT_MIN) {\n        return INT_MIN;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293170,
      "stdout": "",
      "stderr": "tmpony4wmzw: /tmp/tmpony4wmzw.cpp:40: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.size(); ++i) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + (value[i] - '0');\n        }\n    }\n    result = result * sign;\n    if (result > INT_MAX) {\n        return INT_MAX;\n    }\n    if (result < INT_MIN) {\n        return INT_MIN;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293170,
      "stdout": "",
      "stderr": "tmpe1z84bcp: /tmp/tmpe1z84bcp.cpp:40: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long power = 1;\n    long temp = 0;\n    long max_power = 0;\n    long max_temp = 0;\n    long min_temp = 0;\n    long min_power = 0;\n    long max_diff = 0;\n    long min_diff = 0;\n    long diff = 0;\n    long temp_diff = 0;\n    long temp_power = 0;\n    long temp_sign = 1;\n    long temp_result = 0;\n    long temp_max_power = 0;\n    long temp_max_temp = 0;\n    long temp_min_temp = 0;\n    long temp_min_power = 0;\n    long temp_max_diff = 0;\n    long temp_min_diff = 0;\n    long temp_diff_sign = 1;\n    long temp_result_sign = 1;\n    long temp_result_power = 0;\n    long temp_result_max_power = 0;\n    long temp_result_max_temp = 0;\n    long temp_result_min_temp = 0;\n    long temp_result_min_power = 0;\n    long temp_result_max_diff = 0;\n    long temp_result_min_diff = 0;\n    long temp_result_diff_sign = 1;\n    long temp_result_result_sign = 1;\n    long temp_result_result_power = 0;\n    long temp_result_result_max_power = 0;\n    long temp_result_result_max_temp = 0;\n    long temp_result_result_min_temp = 0;\n    long temp_result_result_min_power = 0;\n    long temp_result_result_max_diff = 0;\n    long temp_result_result_min_diff = 0;\n    long temp_result_result_diff_sign = 1;\n    long temp_result_result_result_sign = 1;\n    long temp_result_result_result_power = 0;\n    long temp_result_result_result_max_power = 0;\n    long temp_result_result_result_max_temp = 0;\n    long\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293170,
      "stdout": "",
      "stderr": "/tmp/tmpz2iyuaap.cpp: In function \u2018long int closest_integer(std::string)\u2019:\n/tmp/tmpz2iyuaap.cpp:62:1: error: expected unqualified-id before \u2018}\u2019 token\n   62 | }\n      | ^\n/tmp/tmpz2iyuaap.cpp:62:1: warning: no return statement in function returning non-void [-Wreturn-type]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.size(); ++i) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    if (result < 0) {\n        result = -result;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293170,
      "stdout": "",
      "stderr": "tmpjx1b367g: /tmp/tmpjx1b367g.cpp:37: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmp_fltreji: /tmp/tmp_fltreji.cpp:34: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    if (result > INT_MAX) {\n        result = INT_MAX;\n    } else if (result < INT_MIN) {\n        result = INT_MIN;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "tmp_rwticny: /tmp/tmp_rwticny.cpp:39: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::string::iterator it = value.begin();\n    while (it != value.end() && std::isdigit(*it)) {\n        result = result * 10 + *it - '0';\n        it++;\n    }\n    if (it != value.end()) {\n        result = result * 10 + *it - '0';\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293170,
      "stdout": "",
      "stderr": "tmplagj71wo: /tmp/tmplagj71wo.cpp:31: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmp_fltreji: /tmp/tmp_fltreji.cpp:34: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long exponent = 0;\n    long mantissa = 0;\n    long temp = 0;\n    long temp2 = 0;\n    long temp3 = 0;\n    long temp4 = 0;\n    long temp5 = 0;\n    long temp6 = 0;\n    long temp7 = 0;\n    long temp8 = 0;\n    long temp9 = 0;\n    long temp10 = 0;\n    long temp11 = 0;\n    long temp12 = 0;\n    long temp13 = 0;\n    long temp14 = 0;\n    long temp15 = 0;\n    long temp16 = 0;\n    long temp17 = 0;\n    long temp18 = 0;\n    long temp19 = 0;\n    long temp20 = 0;\n    long temp21 = 0;\n    long temp22 = 0;\n    long temp23 = 0;\n    long temp24 = 0;\n    long temp25 = 0;\n    long temp26 = 0;\n    long temp27 = 0;\n    long temp28 = 0;\n    long temp29 = 0;\n    long temp30 = 0;\n    long temp31 = 0;\n    long temp32 = 0;\n    long temp33 = 0;\n    long temp34 = 0;\n    long temp35 = 0;\n    long temp36 = 0;\n    long temp37 = 0;\n    long temp38 = 0;\n    long temp39 = 0;\n    long temp40 = 0;\n    long temp41 = 0;\n    long temp42 = 0;\n    long temp43 = 0;\n    long temp44 = 0;\n    long temp45 = 0;\n    long temp46 = 0;\n    long temp47 = 0;\n    long temp48 = 0;\n    long temp49 = 0;\n    long temp50 = 0;\n    long temp51 = 0;\n    long temp52 = 0;\n    long temp53 = 0;\n    long temp54 = 0;\n    long temp55 = 0;\n    long temp56 = 0;\n    long temp57 = 0;\n    long temp58 = 0;\n    long temp59 = 0;\n    long temp60 = 0;\n    long temp61\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293170,
      "stdout": "",
      "stderr": "/tmp/tmp_b_s12b3.cpp: In function \u2018long int closest_integer(std::string)\u2019:\n/tmp/tmp_b_s12b3.cpp:82:1: error: expected initializer before \u2018}\u2019 token\n   82 | }\n      | ^\n/tmp/tmp_b_s12b3.cpp:82:1: warning: no return statement in function returning non-void [-Wreturn-type]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::string::iterator it = value.begin();\n    while (it != value.end() && std::isdigit(*it)) {\n        result = result * 10 + *it - '0';\n        ++it;\n    }\n    if (it != value.end()) {\n        result = result * 10 + *it - '0';\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "tmpkud7cs2f: /tmp/tmpkud7cs2f.cpp:31: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmp_fltreji: /tmp/tmp_fltreji.cpp:34: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::string::iterator it = value.begin();\n    while (it != value.end() && std::isdigit(*it)) {\n        result = result * 10 + *it - '0';\n        ++it;\n    }\n    if (it != value.end()) {\n        result = result * 10 + *it - '0';\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293165,
      "stdout": "",
      "stderr": "tmpkud7cs2f: /tmp/tmpkud7cs2f.cpp:31: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmp_fltreji: /tmp/tmp_fltreji.cpp:34: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = 0; i < value.size(); i++) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    if (result < 0) {\n        result = -result;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293170,
      "stdout": "",
      "stderr": "tmptm_hmlxa: /tmp/tmptm_hmlxa.cpp:37: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::stringstream ss(value);\n    ss >> result;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293163,
      "stdout": "",
      "stderr": "tmpw4xr02vl: /tmp/tmpw4xr02vl.cpp:25: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::string::size_type i = 0;\n    while (i < value.length() && value[i] == ' ') {\n        i++;\n    }\n    if (i == value.length()) {\n        return result;\n    }\n    while (i < value.length() && value[i] >= '0' && value[i] <= '9') {\n        result = result * 10 + value[i] - '0';\n        i++;\n    }\n    if (i < value.length()) {\n        result = result * 10 + value[i] - '0';\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293170,
      "stdout": "",
      "stderr": "tmplxj6vfll: /tmp/tmplxj6vfll.cpp:37: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = value.length() - 1; i >= 0; i--) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + (value[i] - '0');\n        }\n    }\n    result = result * sign;\n    if (result > INT_MAX) {\n        return INT_MAX;\n    }\n    if (result < INT_MIN) {\n        return INT_MIN;\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293171,
      "stdout": "",
      "stderr": "tmpu56cjsj5: /tmp/tmpu56cjsj5.cpp:39: int main(): Assertion `candidate((\"10\")) == (10)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value.erase(0, 1);\n    }\n    for (int i = 0; i < value.size(); ++i) {\n        if (value[i] >= '0' && value[i] <= '9') {\n            result = result * 10 + value[i] - '0';\n        }\n    }\n    result = result * sign;\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293171,
      "stdout": "",
      "stderr": "tmp29kwkgth: /tmp/tmp29kwkgth.cpp:34: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    if (value[0] == '-') {\n        sign = -1;\n        value = value.substr(1);\n    }\n    for (int i = 0; i < value.size(); ++i) {\n        if (value[i] == '.') {\n            result = sign * (value[i + 1] - '0') + result * 10;\n            i++;\n        } else {\n            result = sign * (value[i] - '0') + result * 10;\n        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293172,
      "stdout": "",
      "stderr": "tmpolbljkjq: /tmp/tmpolbljkjq.cpp:36: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    long sign = 1;\n    long power = 0;\n    long digit = 0;\n    long max_power = 0;\n    long max_digit = 0;\n    long max_value = 0;\n    long min_value = 0;\n    long diff = 0;\n    long diff_sign = 0;\n    long diff_power = 0;\n    long diff_digit = 0;\n    long diff_max_power = 0;\n    long diff_max_digit = 0;\n    long diff_max_value = 0;\n    long diff_min_value = 0;\n    long diff_diff = 0;\n    long diff_diff_sign = 0;\n    long diff_diff_power = 0;\n    long diff_diff_digit = 0;\n    long diff_diff_max_power = 0;\n    long diff_diff_max_digit = 0;\n    long diff_diff_max_value = 0;\n    long diff_diff_min_value = 0;\n    long diff_diff_diff = 0;\n    long diff_diff_diff_sign = 0;\n    long diff_diff_diff_power = 0;\n    long diff_diff_diff_digit = 0;\n    long diff_diff_diff_max_power = 0;\n    long diff_diff_diff_max_digit = 0;\n    long diff_diff_diff_max_value = 0;\n    long diff_diff_diff_min_value = 0;\n    long diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_sign = 0;\n    long diff_diff_diff_diff_power = 0;\n    long diff_diff_diff_diff_digit = 0;\n    long diff_diff_diff_diff_max_power = 0;\n    long diff_diff_diff_diff_max_digit = 0;\n    long diff_diff_diff_diff_max_value = 0;\n    long diff_diff_diff_diff_min_value = 0;\n    long diff_diff_diff_diff_diff = 0;\n    long diff_diff_diff_diff_diff_sign = 0;\n    long diff_diff_diff_\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293172,
      "stdout": "",
      "stderr": "/tmp/tmpqpwbl2bj.cpp: In function \u2018long int closest_integer(std::string)\u2019:\n/tmp/tmpqpwbl2bj.cpp:60:1: error: expected initializer before \u2018}\u2019 token\n   60 | }\n      | ^\n/tmp/tmpqpwbl2bj.cpp:60:1: warning: no return statement in function returning non-void [-Wreturn-type]\n",
      "exit_code": 1,
      "status": "SyntaxError"
    },
    {
      "program": "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that takes a value (string) representing a number\n// and returns the closest integer to it. If the number is equidistant\n// from two integers, round it away from zero.\n// Examples\n// >>> closest_integer(\"10\")\n// 10\n// >>> closest_integer(\"15.3\")\n// 15\n// Note:\n// Rounding away from zero means that if the given number is equidistant\n// from two integers, the one you should return is the one that is the\n// farthest from zero. For example closest_integer(\"14.5\") should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong closest_integer(std::string value) {\n    long result = 0;\n    std::string::iterator it = value.begin();\n    while (it != value.end()) {\n        if (*it == '.') {\n            break;\n        }\n        result = result * 10 + (*it - '0');\n        ++it;\n    }\n    if (it != value.end()) {\n        result = result + (*it - '0');\n    }\n    return result;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n",
      "timestamp": 1664293172,
      "stdout": "",
      "stderr": "tmpqs5hhu67: /tmp/tmpqs5hhu67.cpp:34: int main(): Assertion `candidate((\"14.5\")) == (15)' failed.\n",
      "exit_code": -6,
      "status": "Exception"
    }
  ]
}