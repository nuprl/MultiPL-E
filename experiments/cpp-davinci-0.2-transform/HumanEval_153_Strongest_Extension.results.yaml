language: cpp
name: HumanEval_153_Strongest_Extension
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int max_strength = INT_MIN;\n  \
    \  std::string strongest_extension = \"\";\n    for (auto extension : extensions)\
    \ {\n        int cap = 0, sm = 0;\n        for (auto c : extension) {\n      \
    \      if (isupper(c)) cap++;\n            else sm++;\n        }\n        int\
    \ strength = cap - sm;\n        if (strength > max_strength) {\n            max_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name + \".\" + strongest_extension;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpas673fkp.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpas673fkp.cpp:22:15: error:\
    \ 'extension' does not name a type\n     for (auto extension : extensions) {\n\
    \               ^\n/tmp/tmpas673fkp.cpp:34:5: error: expected ';' before 'return'\n\
    \     return class_name + \".\" + strongest_extension;\n     ^\n/tmp/tmpas673fkp.cpp:34:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpas673fkp.cpp:34:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpas673fkp.cpp:34:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpas673fkp.cpp:34:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpas673fkp.cpp: In function 'int main()':\n/tmp/tmpas673fkp.cpp:37:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpas673fkp.cpp:2:\n/tmp/tmpas673fkp.cpp:38:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpas673fkp.cpp:38:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpas673fkp.cpp:38:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpas673fkp.cpp:38:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclose"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int max_strength = INT_MIN;\n  \
    \  std::string strongest_extension;\n    for (auto extension : extensions) {\n\
    \        int upper_case_count = 0;\n        int lower_case_count = 0;\n      \
    \  for (auto c : extension) {\n            if (isupper(c)) {\n               \
    \ upper_case_count++;\n            } else {\n                lower_case_count++;\n\
    \            }\n        }\n        int strength = upper_case_count - lower_case_count;\n\
    \        if (strength > max_strength) {\n            max_strength = strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpflqkwk88.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpflqkwk88.cpp:22:15: error:\
    \ 'extension' does not name a type\n     for (auto extension : extensions) {\n\
    \               ^\n/tmp/tmpflqkwk88.cpp:38:5: error: expected ';' before 'return'\n\
    \     return class_name + \".\" + strongest_extension;\n     ^\n/tmp/tmpflqkwk88.cpp:38:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpflqkwk88.cpp:38:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpflqkwk88.cpp:38:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpflqkwk88.cpp:38:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpflqkwk88.cpp: In function 'int main()':\n/tmp/tmpflqkwk88.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpflqkwk88.cpp:2:\n/tmp/tmpflqkwk88.cpp:42:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpflqkwk88.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpflqkwk88.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpflqkwk88.cpp:42:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclose"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int max_strength = INT_MIN;\n  \
    \  std::string strongest_extension;\n    for (auto extension : extensions) {\n\
    \        int CAP = 0, SM = 0;\n        for (auto c : extension) {\n          \
    \  if (isupper(c)) {\n                CAP++;\n            } else {\n         \
    \       SM++;\n            }\n        }\n        if (CAP - SM > max_strength)\
    \ {\n            max_strength = CAP - SM;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension;\n}\nint\
    \ main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpezoe60f5.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpezoe60f5.cpp:22:15: error:\
    \ 'extension' does not name a type\n     for (auto extension : extensions) {\n\
    \               ^\n/tmp/tmpezoe60f5.cpp:36:5: error: expected ';' before 'return'\n\
    \     return class_name + \".\" + strongest_extension;\n     ^\n/tmp/tmpezoe60f5.cpp:36:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpezoe60f5.cpp:36:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpezoe60f5.cpp:36:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpezoe60f5.cpp:36:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpezoe60f5.cpp: In function 'int main()':\n/tmp/tmpezoe60f5.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpezoe60f5.cpp:2:\n/tmp/tmpezoe60f5.cpp:40:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpezoe60f5.cpp:40:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpezoe60f5.cpp:40:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpezoe60f5.cpp:40:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclose"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int max_strength = 0;\n    int max_index\
    \ = 0;\n    for (int i = 0; i < extensions.size(); i++) {\n        int upper =\
    \ 0;\n        int lower = 0;\n        for (int j = 0; j < extensions[i].size();\
    \ j++) {\n            if (isupper(extensions[i][j])) {\n                upper++;\n\
    \            } else {\n                lower++;\n            }\n        }\n  \
    \      int strength = upper - lower;\n        if (strength > max_strength) {\n\
    \            max_strength = strength;\n            max_index = i;\n        }\n\
    \    }\n    return class_name + \".\" + extensions[max_index];\n}\nint main()\
    \ {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2l8hkcnc.cpp: In function 'int main()':\n/tmp/tmp2l8hkcnc.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp2l8hkcnc.cpp:2:\n/tmp/tmp2l8hkcnc.cpp:42:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmp2l8hkcnc.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmp2l8hkcnc.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp2l8hkcnc.cpp:42:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmp2l8hkcnc.cpp:42:128: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmp2l8hkcnc.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/subst"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int max_strength = INT_MIN;\n  \
    \  std::string strongest_extension;\n    for (auto extension : extensions) {\n\
    \        int lower_case_count = 0;\n        int upper_case_count = 0;\n      \
    \  for (auto letter : extension) {\n            if (islower(letter)) {\n     \
    \           lower_case_count++;\n            } else {\n                upper_case_count++;\n\
    \            }\n        }\n        int strength = upper_case_count - lower_case_count;\n\
    \        if (strength > max_strength) {\n            max_strength = strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmuic_jku.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpmuic_jku.cpp:22:15: error:\
    \ 'extension' does not name a type\n     for (auto extension : extensions) {\n\
    \               ^\n/tmp/tmpmuic_jku.cpp:38:5: error: expected ';' before 'return'\n\
    \     return class_name + \".\" + strongest_extension;\n     ^\n/tmp/tmpmuic_jku.cpp:38:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpmuic_jku.cpp:38:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpmuic_jku.cpp:38:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpmuic_jku.cpp:38:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpmuic_jku.cpp: In function 'int main()':\n/tmp/tmpmuic_jku.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpmuic_jku.cpp:2:\n/tmp/tmpmuic_jku.cpp:42:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpmuic_jku.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpmuic_jku.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmuic_jku.cpp:42:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclose"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int max_strength = INT_MIN;\n  \
    \  std::string strongest_extension;\n    for (auto extension : extensions) {\n\
    \        int upper_case_count = 0;\n        int lower_case_count = 0;\n      \
    \  for (auto c : extension) {\n            if (isupper(c)) {\n               \
    \ upper_case_count++;\n            } else {\n                lower_case_count++;\n\
    \            }\n        }\n        int strength = upper_case_count - lower_case_count;\n\
    \        if (strength > max_strength) {\n            max_strength = strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpflqkwk88.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpflqkwk88.cpp:22:15: error:\
    \ 'extension' does not name a type\n     for (auto extension : extensions) {\n\
    \               ^\n/tmp/tmpflqkwk88.cpp:38:5: error: expected ';' before 'return'\n\
    \     return class_name + \".\" + strongest_extension;\n     ^\n/tmp/tmpflqkwk88.cpp:38:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpflqkwk88.cpp:38:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpflqkwk88.cpp:38:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpflqkwk88.cpp:38:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpflqkwk88.cpp: In function 'int main()':\n/tmp/tmpflqkwk88.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpflqkwk88.cpp:2:\n/tmp/tmpflqkwk88.cpp:42:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpflqkwk88.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpflqkwk88.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpflqkwk88.cpp:42:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclose"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int max_strength = INT_MIN;\n  \
    \  std::string strongest_extension;\n    for (auto extension : extensions) {\n\
    \        int strength = 0;\n        for (auto c : extension) {\n            if\
    \ (isupper(c)) {\n                strength++;\n            } else {\n        \
    \        strength--;\n            }\n        }\n        if (strength > max_strength)\
    \ {\n            max_strength = strength;\n            strongest_extension = extension;\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension;\n}\nint\
    \ main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpremgx039.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpremgx039.cpp:22:15: error:\
    \ 'extension' does not name a type\n     for (auto extension : extensions) {\n\
    \               ^\n/tmp/tmpremgx039.cpp:36:5: error: expected ';' before 'return'\n\
    \     return class_name + \".\" + strongest_extension;\n     ^\n/tmp/tmpremgx039.cpp:36:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpremgx039.cpp:36:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpremgx039.cpp:36:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpremgx039.cpp:36:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpremgx039.cpp: In function 'int main()':\n/tmp/tmpremgx039.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpremgx039.cpp:2:\n/tmp/tmpremgx039.cpp:40:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpremgx039.cpp:40:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpremgx039.cpp:40:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpremgx039.cpp:40:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclose"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int max_strength = 0;\n    std::string\
    \ strongest_extension;\n    for (int i = 0; i < extensions.size(); i++) {\n  \
    \      int CAP = 0;\n        int SM = 0;\n        for (int j = 0; j < extensions[i].size();\
    \ j++) {\n            if (isupper(extensions[i][j])) {\n                CAP++;\n\
    \            } else {\n                SM++;\n            }\n        }\n     \
    \   int strength = CAP - SM;\n        if (strength > max_strength) {\n       \
    \     max_strength = strength;\n            strongest_extension = extensions[i];\n\
    \        }\n    }\n    return class_name + \".\" + strongest_extension;\n}\nint\
    \ main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpx8d632xo.cpp: In function 'int main()':\n/tmp/tmpx8d632xo.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpx8d632xo.cpp:2:\n/tmp/tmpx8d632xo.cpp:42:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpx8d632xo.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpx8d632xo.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpx8d632xo.cpp:42:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpx8d632xo.cpp:42:128: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmpx8d632xo.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/subst"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string result = class_name;\n\
    \    int max_strength = 0;\n    for (int i = 0; i < extensions.size(); i++) {\n\
    \        int strength = 0;\n        for (int j = 0; j < extensions[i].size();\
    \ j++) {\n            if (isupper(extensions[i][j])) {\n                strength++;\n\
    \            } else {\n                strength--;\n            }\n        }\n\
    \        if (strength > max_strength) {\n            max_strength = strength;\n\
    \            result = class_name + \".\" + extensions[i];\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphezdknmi.cpp: In function 'int main()':\n/tmp/tmphezdknmi.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphezdknmi.cpp:2:\n/tmp/tmphezdknmi.cpp:40:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmphezdknmi.cpp:40:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmphezdknmi.cpp:40:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmphezdknmi.cpp:40:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmphezdknmi.cpp:40:128: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n\
    \                 from /tmp/tmphezdknmi.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         vector(_InputIterator __first,\
    \ _InputIterator __last,\n         ^\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note:   template argument deduction/subst"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension;\n\
    \    double strongest_strength = 0;\n    for (auto extension : extensions) {\n\
    \        int cap = 0;\n        int sm = 0;\n        for (auto c : extension) {\n\
    \            if (isupper(c)) {\n                cap++;\n            } else {\n\
    \                sm++;\n            }\n        }\n        double strength = cap\
    \ - sm;\n        if (strength > strongest_strength) {\n            strongest_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name + \".\" + strongest_extension;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpkvc94hua.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpkvc94hua.cpp:22:15: error:\
    \ 'extension' does not name a type\n     for (auto extension : extensions) {\n\
    \               ^\n/tmp/tmpkvc94hua.cpp:38:5: error: expected ';' before 'return'\n\
    \     return class_name + \".\" + strongest_extension;\n     ^\n/tmp/tmpkvc94hua.cpp:38:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpkvc94hua.cpp:38:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpkvc94hua.cpp:38:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpkvc94hua.cpp:38:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpkvc94hua.cpp: In function 'int main()':\n/tmp/tmpkvc94hua.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpkvc94hua.cpp:2:\n/tmp/tmpkvc94hua.cpp:42:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpkvc94hua.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpkvc94hua.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpkvc94hua.cpp:42:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclose"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension;\n\
    \    double strongest_strength = 0;\n    for (auto extension : extensions) {\n\
    \        int cap = 0;\n        int sm = 0;\n        for (auto ch : extension)\
    \ {\n            if (isupper(ch)) {\n                cap++;\n            } else\
    \ {\n                sm++;\n            }\n        }\n        double strength\
    \ = cap - sm;\n        if (strength > strongest_strength) {\n            strongest_strength\
    \ = strength;\n            strongest_extension = extension;\n        }\n    }\n\
    \    return class_name + \".\" + strongest_extension;\n}\nint main() {\n    auto\
    \ candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpj86tsgu4.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpj86tsgu4.cpp:22:15: error:\
    \ 'extension' does not name a type\n     for (auto extension : extensions) {\n\
    \               ^\n/tmp/tmpj86tsgu4.cpp:38:5: error: expected ';' before 'return'\n\
    \     return class_name + \".\" + strongest_extension;\n     ^\n/tmp/tmpj86tsgu4.cpp:38:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpj86tsgu4.cpp:38:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpj86tsgu4.cpp:38:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpj86tsgu4.cpp:38:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpj86tsgu4.cpp: In function 'int main()':\n/tmp/tmpj86tsgu4.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpj86tsgu4.cpp:2:\n/tmp/tmpj86tsgu4.cpp:42:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpj86tsgu4.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpj86tsgu4.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpj86tsgu4.cpp:42:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclose"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    std::string strongest_extension\
    \ = \"\";\n    float strength = 0;\n    for (auto extension : extensions) {\n\
    \        int cap = 0;\n        int sm = 0;\n        for (auto c : extension) {\n\
    \            if (isupper(c)) {\n                cap++;\n            } else {\n\
    \                sm++;\n            }\n        }\n        float curr_strength\
    \ = (float)cap - sm;\n        if (curr_strength > strength) {\n            strength\
    \ = curr_strength;\n            strongest_extension = extension;\n        }\n\
    \    }\n    return class_name + \".\" + strongest_extension;\n}\nint main() {\n\
    \    auto candidate = Strongest_Extension;\n    assert(candidate((\"Watashi\"\
    ), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\", (std::string)\"\
    eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"Boku123\"\
    ), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"NazeDa\",\
    \ (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpbbt3ococ.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpbbt3ococ.cpp:22:15: error:\
    \ 'extension' does not name a type\n     for (auto extension : extensions) {\n\
    \               ^\n/tmp/tmpbbt3ococ.cpp:38:5: error: expected ';' before 'return'\n\
    \     return class_name + \".\" + strongest_extension;\n     ^\n/tmp/tmpbbt3ococ.cpp:38:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpbbt3ococ.cpp:38:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpbbt3ococ.cpp:38:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpbbt3ococ.cpp:38:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpbbt3ococ.cpp: In function 'int main()':\n/tmp/tmpbbt3ococ.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpbbt3ococ.cpp:2:\n/tmp/tmpbbt3ococ.cpp:42:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpbbt3ococ.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpbbt3ococ.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpbbt3ococ.cpp:42:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclose"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int max_strength = INT_MIN;\n  \
    \  std::string strongest_extension;\n    for (auto extension : extensions) {\n\
    \        int cap = 0, sm = 0;\n        for (auto ch : extension) {\n         \
    \   if (isupper(ch)) {\n                cap++;\n            } else {\n       \
    \         sm++;\n            }\n        }\n        int strength = cap - sm;\n\
    \        if (strength > max_strength) {\n            max_strength = strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpn56skt88.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpn56skt88.cpp:22:15: error:\
    \ 'extension' does not name a type\n     for (auto extension : extensions) {\n\
    \               ^\n/tmp/tmpn56skt88.cpp:37:5: error: expected ';' before 'return'\n\
    \     return class_name + \".\" + strongest_extension;\n     ^\n/tmp/tmpn56skt88.cpp:37:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpn56skt88.cpp:37:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpn56skt88.cpp:37:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpn56skt88.cpp:37:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpn56skt88.cpp: In function 'int main()':\n/tmp/tmpn56skt88.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpn56skt88.cpp:2:\n/tmp/tmpn56skt88.cpp:41:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpn56skt88.cpp:41:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpn56skt88.cpp:41:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpn56skt88.cpp:41:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclose"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int max_strength = 0;\n    std::string\
    \ strongest_extension;\n    for (auto extension : extensions) {\n        int cap\
    \ = 0;\n        int sm = 0;\n        for (auto c : extension) {\n            if\
    \ (isupper(c)) {\n                cap++;\n            } else {\n             \
    \   sm++;\n            }\n        }\n        int strength = cap - sm;\n      \
    \  if (strength > max_strength) {\n            max_strength = strength;\n    \
    \        strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvcws1_wj.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpvcws1_wj.cpp:22:15: error:\
    \ 'extension' does not name a type\n     for (auto extension : extensions) {\n\
    \               ^\n/tmp/tmpvcws1_wj.cpp:38:5: error: expected ';' before 'return'\n\
    \     return class_name + \".\" + strongest_extension;\n     ^\n/tmp/tmpvcws1_wj.cpp:38:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpvcws1_wj.cpp:38:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpvcws1_wj.cpp:38:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpvcws1_wj.cpp:38:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpvcws1_wj.cpp: In function 'int main()':\n/tmp/tmpvcws1_wj.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvcws1_wj.cpp:2:\n/tmp/tmpvcws1_wj.cpp:42:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpvcws1_wj.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpvcws1_wj.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpvcws1_wj.cpp:42:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclose"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int max_strength = INT_MIN;\n  \
    \  std::string strongest_extension;\n    for (auto extension : extensions) {\n\
    \        int cap = 0, sm = 0;\n        for (auto c : extension) {\n          \
    \  if (isupper(c)) {\n                cap++;\n            } else {\n         \
    \       sm++;\n            }\n        }\n        int strength = cap - sm;\n  \
    \      if (strength > max_strength) {\n            max_strength = strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpokec3dbd.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpokec3dbd.cpp:22:15: error:\
    \ 'extension' does not name a type\n     for (auto extension : extensions) {\n\
    \               ^\n/tmp/tmpokec3dbd.cpp:37:5: error: expected ';' before 'return'\n\
    \     return class_name + \".\" + strongest_extension;\n     ^\n/tmp/tmpokec3dbd.cpp:37:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpokec3dbd.cpp:37:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpokec3dbd.cpp:37:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpokec3dbd.cpp:37:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpokec3dbd.cpp: In function 'int main()':\n/tmp/tmpokec3dbd.cpp:40:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpokec3dbd.cpp:2:\n/tmp/tmpokec3dbd.cpp:41:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpokec3dbd.cpp:41:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpokec3dbd.cpp:41:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpokec3dbd.cpp:41:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclose"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int max_strength = 0;\n    std::string\
    \ strongest_extension;\n    for (auto extension : extensions) {\n        int strength\
    \ = 0;\n        for (auto letter : extension) {\n            if (isupper(letter))\
    \ {\n                strength++;\n            } else {\n                strength--;\n\
    \            }\n        }\n        if (strength > max_strength) {\n          \
    \  max_strength = strength;\n            strongest_extension = extension;\n  \
    \      }\n    }\n    return class_name + \".\" + strongest_extension;\n}\nint\
    \ main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpm1lqtewk.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpm1lqtewk.cpp:22:15: error:\
    \ 'extension' does not name a type\n     for (auto extension : extensions) {\n\
    \               ^\n/tmp/tmpm1lqtewk.cpp:36:5: error: expected ';' before 'return'\n\
    \     return class_name + \".\" + strongest_extension;\n     ^\n/tmp/tmpm1lqtewk.cpp:36:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpm1lqtewk.cpp:36:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpm1lqtewk.cpp:36:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpm1lqtewk.cpp:36:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpm1lqtewk.cpp: In function 'int main()':\n/tmp/tmpm1lqtewk.cpp:39:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpm1lqtewk.cpp:2:\n/tmp/tmpm1lqtewk.cpp:40:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpm1lqtewk.cpp:40:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpm1lqtewk.cpp:40:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpm1lqtewk.cpp:40:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclose"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    float max_strength = 0;\n    std::string\
    \ strongest_extension;\n    for (auto extension : extensions) {\n        int cap\
    \ = 0;\n        int sm = 0;\n        for (auto c : extension) {\n            if\
    \ (isupper(c)) {\n                cap++;\n            } else {\n             \
    \   sm++;\n            }\n        }\n        float strength = (float)cap - sm;\n\
    \        if (strength > max_strength) {\n            max_strength = strength;\n\
    \            strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_024tz4u.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmp_024tz4u.cpp:22:15: error:\
    \ 'extension' does not name a type\n     for (auto extension : extensions) {\n\
    \               ^\n/tmp/tmp_024tz4u.cpp:38:5: error: expected ';' before 'return'\n\
    \     return class_name + \".\" + strongest_extension;\n     ^\n/tmp/tmp_024tz4u.cpp:38:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmp_024tz4u.cpp:38:5:\
    \ error: expected ';' before 'return'\n/tmp/tmp_024tz4u.cpp:38:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmp_024tz4u.cpp:38:5: error: expected\
    \ ')' before 'return'\n/tmp/tmp_024tz4u.cpp: In function 'int main()':\n/tmp/tmp_024tz4u.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_024tz4u.cpp:2:\n/tmp/tmp_024tz4u.cpp:42:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmp_024tz4u.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmp_024tz4u.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp_024tz4u.cpp:42:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclose"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int max_strength = 0;\n    std::string\
    \ strongest_extension;\n    for (auto extension : extensions) {\n        int upper_case_count\
    \ = 0;\n        int lower_case_count = 0;\n        for (auto letter : extension)\
    \ {\n            if (isupper(letter)) {\n                upper_case_count++;\n\
    \            } else {\n                lower_case_count++;\n            }\n  \
    \      }\n        int strength = upper_case_count - lower_case_count;\n      \
    \  if (strength > max_strength) {\n            max_strength = strength;\n    \
    \        strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpddajrlm_.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpddajrlm_.cpp:22:15: error:\
    \ 'extension' does not name a type\n     for (auto extension : extensions) {\n\
    \               ^\n/tmp/tmpddajrlm_.cpp:38:5: error: expected ';' before 'return'\n\
    \     return class_name + \".\" + strongest_extension;\n     ^\n/tmp/tmpddajrlm_.cpp:38:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpddajrlm_.cpp:38:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpddajrlm_.cpp:38:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpddajrlm_.cpp:38:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpddajrlm_.cpp: In function 'int main()':\n/tmp/tmpddajrlm_.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpddajrlm_.cpp:2:\n/tmp/tmpddajrlm_.cpp:42:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpddajrlm_.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpddajrlm_.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpddajrlm_.cpp:42:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclose"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int max_strength = 0;\n    std::string\
    \ strongest_extension;\n    for (auto extension : extensions) {\n        int cap\
    \ = 0;\n        int sm = 0;\n        for (auto c : extension) {\n            if\
    \ (isupper(c)) {\n                cap++;\n            } else {\n             \
    \   sm++;\n            }\n        }\n        int strength = cap - sm;\n      \
    \  if (strength > max_strength) {\n            max_strength = strength;\n    \
    \        strongest_extension = extension;\n        }\n    }\n    return class_name\
    \ + \".\" + strongest_extension;\n}\nint main() {\n    auto candidate = Strongest_Extension;\n\
    \    assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n    assert(candidate((\"Boku123\"), (std::vector<std::string>({(std::string)\"\
    nani\", (std::string)\"NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"\
    32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"));\n    assert(candidate((\"__YESIMHERE\"\
    ), (std::vector<std::string>({(std::string)\"t\", (std::string)\"eMptY\", (std::string)\"\
    nothing\", (std::string)\"zeR00\", (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"\
    }))) == (\"__YESIMHERE.NuLl__\"));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpvcws1_wj.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpvcws1_wj.cpp:22:15: error:\
    \ 'extension' does not name a type\n     for (auto extension : extensions) {\n\
    \               ^\n/tmp/tmpvcws1_wj.cpp:38:5: error: expected ';' before 'return'\n\
    \     return class_name + \".\" + strongest_extension;\n     ^\n/tmp/tmpvcws1_wj.cpp:38:5:\
    \ error: expected primary-expression before 'return'\n/tmp/tmpvcws1_wj.cpp:38:5:\
    \ error: expected ';' before 'return'\n/tmp/tmpvcws1_wj.cpp:38:5: error: expected\
    \ primary-expression before 'return'\n/tmp/tmpvcws1_wj.cpp:38:5: error: expected\
    \ ')' before 'return'\n/tmp/tmpvcws1_wj.cpp: In function 'int main()':\n/tmp/tmpvcws1_wj.cpp:41:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = Strongest_Extension;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpvcws1_wj.cpp:2:\n/tmp/tmpvcws1_wj.cpp:42:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpvcws1_wj.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpvcws1_wj.cpp:42:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpvcws1_wj.cpp:42:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclose"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// You will be given the\
    \ name of a class (a string) and a list of extensions.\n// The extensions are\
    \ to be used to load additional classes to the class. The\n// strength of the\
    \ extension is as follows: Let CAP be the number of the uppercase\n// letters\
    \ in the extension's name, and let SM be the number of lowercase letters \n//\
    \ in the extension's name, the strength is given by the fraction CAP - SM. \n\
    // You should find the strongest extension and return a string in this \n// format:\
    \ ClassName.StrongestExtensionName.\n// If there are two or more extensions with\
    \ the same strength, you should\n// choose the one that comes first in the list.\n\
    // For example, if you are given \"Slices\" as the class and a list of the\n//\
    \ extensions: ['SErviNGSliCes', 'Cheese', 'StuFfed'] then you should\n// return\
    \ 'Slices.SErviNGSliCes' since 'SErviNGSliCes' is the strongest extension \n//\
    \ (its strength is -1).\n// Example:\n// >>> Strongest_Extension((\"my_class\"\
    ), (std::vector<std::string>({(std::string)\"AA\", (std::string)\"Be\", (std::string)\"\
    CC\"})))\n// (\"my_class.AA\")\nstd::string Strongest_Extension(std::string class_name,\
    \ std::vector<std::string> extensions) {\n    int max_strength = 0;\n    std::string\
    \ strongest_extension;\n    for (std::string extension : extensions) {\n     \
    \   int strength = 0;\n        for (char c : extension) {\n            if (isupper(c))\
    \ {\n                strength++;\n            } else {\n                strength--;\n\
    \            }\n        }\n        if (strength > max_strength) {\n          \
    \  max_strength = strength;\n            strongest_extension = extension;\n  \
    \      }\n    }\n    return class_name + \".\" + strongest_extension;\n}\nint\
    \ main() {\n    auto candidate = Strongest_Extension;\n    assert(candidate((\"\
    Watashi\"), (std::vector<std::string>({(std::string)\"tEN\", (std::string)\"niNE\"\
    , (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"));\n    assert(candidate((\"\
    Boku123\"), (std::vector<std::string>({(std::string)\"nani\", (std::string)\"\
    NazeDa\", (std::string)\"YEs.WeCaNe\", (std::string)\"32145tggg\"}))) == (\"Boku123.YEs.WeCaNe\"\
    ));\n    assert(candidate((\"__YESIMHERE\"), (std::vector<std::string>({(std::string)\"\
    t\", (std::string)\"eMptY\", (std::string)\"nothing\", (std::string)\"zeR00\"\
    , (std::string)\"NuLl__\", (std::string)\"123NoooneB321\"}))) == (\"__YESIMHERE.NuLl__\"\
    ));\n    assert(candidate((\"K\"), (std::vector<std::string>({(std::string)\"\
    Ta\", (std::string)\"TAR\", (std::string)\"t234An\", (std::string)\"cosSo\"})))\
    \ == (\"K.TAR\"));\n    assert(candidate((\"__HAHA\"), (std::vector<std::string>({(std::string)\"\
    Tab\", (std::string)\"123\", (std::string)\"781345\", (std::string)\"-_-\"})))\
    \ == (\"__HAHA.123\"));\n    assert(candidate((\"YameRore\"), (std::vector<std::string>({(std::string)\"\
    HhAas\", (std::string)\"okIWILL123\", (std::string)\"WorkOut\", (std::string)\"\
    Fails\", (std::string)\"-_-\"}))) == (\"YameRore.okIWILL123\"));\n    assert(candidate((\"\
    finNNalLLly\"), (std::vector<std::string>({(std::string)\"Die\", (std::string)\"\
    NowW\", (std::string)\"Wow\", (std::string)\"WoW\"}))) == (\"finNNalLLly.WoW\"\
    ));\n    assert(candidate((\"_\"), (std::vector<std::string>({(std::string)\"\
    Bb\", (std::string)\"91245\"}))) == (\"_.Bb\"));\n    assert(candidate((\"Sp\"\
    ), (std::vector<std::string>({(std::string)\"671235\", (std::string)\"Bb\"})))\
    \ == (\"Sp.671235\"));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpq6vvg54z.cpp: In function 'std::string Strongest_Extension(std::string,\
    \ std::vector<std::basic_string<char> >)':\n/tmp/tmpq6vvg54z.cpp:22:34: error:\
    \ range-based 'for' loops are not allowed in C++98 mode\n     for (std::string\
    \ extension : extensions) {\n                                  ^\n/tmp/tmpq6vvg54z.cpp:24:23:\
    \ error: range-based 'for' loops are not allowed in C++98 mode\n         for (char\
    \ c : extension) {\n                       ^\n/tmp/tmpq6vvg54z.cpp: In function\
    \ 'int main()':\n/tmp/tmpq6vvg54z.cpp:39:10: error: 'candidate' does not name\
    \ a type\n     auto candidate = Strongest_Extension;\n          ^\nIn file included\
    \ from /usr/include/c++/4.8.2/cassert:43:0,\n                 from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpq6vvg54z.cpp:2:\n/tmp/tmpq6vvg54z.cpp:40:60: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                            ^\n/tmp/tmpq6vvg54z.cpp:40:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"Watashi\"), (std::vector<std::string>({(std::string)\"\
    tEN\", (std::string)\"niNE\", (std::string)\"eIGHt8OKe\"}))) == (\"Watashi.eIGHt8OKe\"\
    ));\n                                                                        \
    \                                                        ^\n/tmp/tmpq6vvg54z.cpp:40:128:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpq6vvg54z.cpp:40:128: error: no matching function\
    \ for call to 'std::vector<std::basic_string<char> >::vector(<brace-enclosed initializer\
    \ list>)'\n/tmp/tmpq6vvg54z.cpp:40:128: note: candidates are:\nIn file included\
    \ from /usr/include/c++/4.8.2/vector:64:0,\n                 from /usr/include/c++/4.8.2/queue:61,\n\
    \                 from"
  stdout: ''
