language: cpp
name: HumanEval_132_is_nested
results:
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (stack.empty()) {\n                return false;\n       \
    \     } else {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpm6_l8gjc: /tmp/tmpm6_l8gjc.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else if(s.top()=='['){\n\
    \                s.pop();\n            }\n            else{\n                return\
    \ false;\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpveu6t5us: /tmp/tmpveu6t5us.cpp:47: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n         \
    \   st.push(string[i]);\n        }\n        else if(string[i]==']'){\n       \
    \     if(st.empty()){\n                return false;\n            }\n        \
    \    else{\n                st.pop();\n            }\n        }\n    }\n    if(st.empty()){\n\
    \        return true;\n    }\n    else{\n        return false;\n    }\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpd66rg2k_: /tmp/tmpd66rg2k_.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else if(s.top()=='['){\n\
    \                s.pop();\n            }\n            else{\n                return\
    \ false;\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpveu6t5us: /tmp/tmpveu6t5us.cpp:47: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (stack.empty()) {\n                return false;\n       \
    \     } else {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return !stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0a4qmugk: /tmp/tmp0a4qmugk.cpp:35: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (stack.empty()) {\n                return false;\n       \
    \     } else {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return !stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0a4qmugk: /tmp/tmp0a4qmugk.cpp:35: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(auto c : string) {\n        if(c == '[') {\n            st.push(c);\n  \
    \      } else if(c == ']') {\n            if(st.empty()) {\n                return\
    \ false;\n            } else {\n                st.pop();\n            }\n   \
    \     }\n    }\n    return st.empty();\n}\nint main() {\n    auto candidate =\
    \ is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpxa1m08r5: /tmp/tmpxa1m08r5.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (stack.empty()) {\n                return false;\n       \
    \     } else {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpm6_l8gjc: /tmp/tmpm6_l8gjc.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n         \
    \   st.push(string[i]);\n        }\n        else if(string[i]==']'){\n       \
    \     if(st.empty()){\n                return false;\n            }\n        \
    \    else{\n                st.pop();\n            }\n        }\n    }\n    if(st.empty()){\n\
    \        return true;\n    }\n    else{\n        return false;\n    }\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpd66rg2k_: /tmp/tmpd66rg2k_.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (stack.empty()) {\n                return false;\n       \
    \     } else {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpm6_l8gjc: /tmp/tmpm6_l8gjc.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n         \
    \   st.push(string[i]);\n        }\n        else if(string[i]==']'){\n       \
    \     if(st.empty()){\n                return false;\n            }\n        \
    \    else{\n                st.pop();\n            }\n        }\n    }\n    if(st.empty()){\n\
    \        return true;\n    }\n    else{\n        return false;\n    }\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpd66rg2k_: /tmp/tmpd66rg2k_.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else if(s.top()=='['){\n\
    \                s.pop();\n            }\n            else{\n                return\
    \ false;\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpveu6t5us: /tmp/tmpveu6t5us.cpp:47: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else if(s.top()=='['){\n\
    \                s.pop();\n            }\n            else{\n                return\
    \ false;\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpveu6t5us: /tmp/tmpveu6t5us.cpp:47: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (stack.empty()) {\n                return false;\n       \
    \     } else {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpm6_l8gjc: /tmp/tmpm6_l8gjc.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (stack.empty()) {\n                return false;\n       \
    \     } else {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpm6_l8gjc: /tmp/tmpm6_l8gjc.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n         \
    \   st.push(string[i]);\n        }\n        else if(string[i]==']'){\n       \
    \     if(st.empty()){\n                return false;\n            }\n        \
    \    else{\n                st.pop();\n            }\n        }\n    }\n    if(st.empty()){\n\
    \        return true;\n    }\n    else{\n        return false;\n    }\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpd66rg2k_: /tmp/tmpd66rg2k_.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (char c : string) {\n        if (c == '[') {\n            stack.push(c);\n\
    \        } else if (c == ']') {\n            if (stack.empty()) {\n          \
    \      return false;\n            }\n            stack.pop();\n        }\n   \
    \ }\n    return !stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0jsmpy87: /tmp/tmp0jsmpy87.cpp:34: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (char c : string) {\n        if (c == '[') {\n            stack.push(c);\n\
    \        } else if (c == ']') {\n            if (stack.empty()) {\n          \
    \      return false;\n            }\n            stack.pop();\n        }\n   \
    \ }\n    return !stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0jsmpy87: /tmp/tmp0jsmpy87.cpp:34: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='[')\n            s.push(string[i]);\n\
    \        else if(string[i]==']'){\n            if(s.empty())\n               \
    \ return false;\n            else\n                s.pop();\n        }\n    }\n\
    \    if(s.empty())\n        return true;\n    else\n        return false;\n}\n\
    int main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmp1in4f07p: /tmp/tmp1in4f07p.cpp:39: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstd::stack<char> st;\n\tfor\
    \ (int i = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[') {\n\t\t\t\
    st.push(string[i]);\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tif (st.empty())\
    \ {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tst.pop();\n\t\t\t}\n\
    \t\t}\n\t}\n\tif (st.empty()) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp5h_6j1gt: /tmp/tmp5h_6j1gt.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else if(s.top()=='['){\n\
    \                s.pop();\n            }\n            else{\n                return\
    \ false;\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpveu6t5us: /tmp/tmpveu6t5us.cpp:47: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (stack.empty()) {\n                return false;\n       \
    \     } else {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpm6_l8gjc: /tmp/tmpm6_l8gjc.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (stack.empty()) {\n                return false;\n       \
    \     } else {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return true;\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp22djpxxc: /tmp/tmp22djpxxc.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (stack.empty()) {\n                return false;\n       \
    \     } else {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpm6_l8gjc: /tmp/tmpm6_l8gjc.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstd::stack<char> s;\n\tfor (int\
    \ i = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\
    \t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t\ts.pop();\n\t\t}\n\t}\n\tif (s.empty()) {\n\t\treturn\
    \ true;\n\t}\n\treturn false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmphsj0kv5s: /tmp/tmphsj0kv5s.cpp:40: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (stack.empty()) {\n                return false;\n       \
    \     } else {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpm6_l8gjc: /tmp/tmpm6_l8gjc.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n         \
    \   st.push(string[i]);\n        }\n        else if(string[i]==']'){\n       \
    \     if(st.empty()){\n                return false;\n            }\n        \
    \    st.pop();\n        }\n    }\n    if(st.empty()){\n        return true;\n\
    \    }\n    return false;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpjxludltr: /tmp/tmpjxludltr.cpp:40: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (stack.empty()) {\n                return false;\n       \
    \     } else {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpm6_l8gjc: /tmp/tmpm6_l8gjc.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n         \
    \   st.push(string[i]);\n        }\n        else if(string[i]==']'){\n       \
    \     if(st.empty()){\n                return false;\n            }\n        \
    \    else{\n                st.pop();\n            }\n        }\n    }\n    if(st.empty()){\n\
    \        return true;\n    }\n    else{\n        return false;\n    }\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpd66rg2k_: /tmp/tmpd66rg2k_.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (stack.empty()) {\n                return false;\n       \
    \     } else {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpm6_l8gjc: /tmp/tmpm6_l8gjc.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n         \
    \   st.push(string[i]);\n        }\n        else if(string[i]==']'){\n       \
    \     if(st.empty()){\n                return false;\n            }\n        \
    \    else if(st.top()=='['){\n                st.pop();\n            }\n     \
    \       else{\n                return false;\n            }\n        }\n    }\n\
    \    if(st.empty()){\n        return true;\n    }\n    else{\n        return false;\n\
    \    }\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp74_t8uye: /tmp/tmp74_t8uye.cpp:47: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstd::stack<char> s;\n\tfor (int\
    \ i = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\
    \t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty())\
    \ {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmppfj28q_n: /tmp/tmppfj28q_n.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (stack.empty()) {\n                return false;\n       \
    \     } else {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpm6_l8gjc: /tmp/tmpm6_l8gjc.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (auto c : string) {\n        if (c == '[') {\n            stack.push(c);\n\
    \        } else if (c == ']') {\n            if (stack.empty()) {\n          \
    \      return false;\n            }\n            stack.pop();\n        }\n   \
    \ }\n    return !stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp5n_e8zr_: /tmp/tmp5n_e8zr_.cpp:34: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n         \
    \   st.push(string[i]);\n        }\n        else if(string[i]==']'){\n       \
    \     if(st.empty()){\n                return false;\n            }\n        \
    \    else{\n                st.pop();\n            }\n        }\n    }\n    if(st.empty()){\n\
    \        return true;\n    }\n    else{\n        return false;\n    }\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpd66rg2k_: /tmp/tmpd66rg2k_.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (stack.empty()) {\n                return false;\n       \
    \     } else {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpm6_l8gjc: /tmp/tmpm6_l8gjc.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (stack.empty()) {\n                return false;\n       \
    \     } else {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpm6_l8gjc: /tmp/tmpm6_l8gjc.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n         \
    \   st.push(string[i]);\n        }\n        else if(string[i]==']'){\n       \
    \     if(st.empty()){\n                return false;\n            }\n        \
    \    else if(st.top()=='['){\n                st.pop();\n            }\n     \
    \       else{\n                return false;\n            }\n        }\n    }\n\
    \    if(st.empty()){\n        return true;\n    }\n    else{\n        return false;\n\
    \    }\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp74_t8uye: /tmp/tmp74_t8uye.cpp:47: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    // Your code here\n    std::stack<char>\
    \ s;\n    for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n \
    \           s.push(string[i]);\n        }\n        else if(string[i]==']'){\n\
    \            if(s.empty()){\n                return false;\n            }\n  \
    \          else if(s.top()=='['){\n                s.pop();\n            }\n \
    \           else{\n                return false;\n            }\n        }\n \
    \   }\n    if(s.empty()){\n        return true;\n    }\n    else{\n        return\
    \ false;\n    }\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp9z051zgi: /tmp/tmp9z051zgi.cpp:48: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (stack.empty()) {\n                return false;\n       \
    \     } else {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return !stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0a4qmugk: /tmp/tmp0a4qmugk.cpp:35: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n         \
    \   st.push(string[i]);\n        }\n        else if(string[i]==']'){\n       \
    \     if(st.empty()){\n                return false;\n            }\n        \
    \    else{\n                st.pop();\n            }\n        }\n    }\n    if(st.empty()){\n\
    \        return true;\n    }\n    else{\n        return false;\n    }\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpd66rg2k_: /tmp/tmpd66rg2k_.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (char c : string) {\n        if (c == '[') {\n            stack.push(c);\n\
    \        } else if (c == ']') {\n            if (stack.empty()) {\n          \
    \      return false;\n            }\n            stack.pop();\n        }\n   \
    \ }\n    return !stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0jsmpy87: /tmp/tmp0jsmpy87.cpp:34: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (stack.empty()) {\n                return false;\n       \
    \     } else {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpm6_l8gjc: /tmp/tmpm6_l8gjc.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n         \
    \   st.push(string[i]);\n        }\n        else if(string[i]==']'){\n       \
    \     if(st.empty()){\n                return false;\n            }\n        \
    \    else{\n                st.pop();\n            }\n        }\n    }\n    if(st.empty()){\n\
    \        return true;\n    }\n    else{\n        return false;\n    }\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpd66rg2k_: /tmp/tmpd66rg2k_.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (stack.empty()) {\n                return false;\n       \
    \     } else {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return !stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0a4qmugk: /tmp/tmp0a4qmugk.cpp:35: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstd::stack<char> st;\n\tfor\
    \ (int i = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[') {\n\t\t\t\
    st.push(string[i]);\n\t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tif (st.empty())\
    \ {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tst.pop();\n\t\t\t}\n\
    \t\t}\n\t}\n\tif (st.empty()) {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\
    \t}\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp5h_6j1gt: /tmp/tmp5h_6j1gt.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (stack.empty()) {\n                return false;\n       \
    \     } else {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return !stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0a4qmugk: /tmp/tmp0a4qmugk.cpp:35: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (auto c : string) {\n        if (c == '[') {\n            stack.push(c);\n\
    \        } else if (c == ']') {\n            if (stack.empty()) {\n          \
    \      return false;\n            }\n            stack.pop();\n        }\n   \
    \ }\n    return !stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp5n_e8zr_: /tmp/tmp5n_e8zr_.cpp:34: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (char c : string) {\n        if (c == '[') {\n            stack.push(c);\n\
    \        } else if (c == ']') {\n            if (stack.empty()) {\n          \
    \      return false;\n            }\n            stack.pop();\n        }\n   \
    \ }\n    return !stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0jsmpy87: /tmp/tmp0jsmpy87.cpp:34: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n         \
    \   st.push(string[i]);\n        }\n        else if(string[i]==']'){\n       \
    \     if(st.empty()){\n                return false;\n            }\n        \
    \    else{\n                st.pop();\n            }\n        }\n    }\n    if(st.empty()){\n\
    \        return true;\n    }\n    else{\n        return false;\n    }\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpd66rg2k_: /tmp/tmpd66rg2k_.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n         \
    \   st.push(string[i]);\n        }\n        else if(string[i]==']'){\n       \
    \     if(st.empty()){\n                return false;\n            }\n        \
    \    else{\n                st.pop();\n            }\n        }\n    }\n    if(st.empty()){\n\
    \        return true;\n    }\n    else{\n        return false;\n    }\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpd66rg2k_: /tmp/tmpd66rg2k_.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n         \
    \   st.push(string[i]);\n        }\n        else if(string[i]==']'){\n       \
    \     if(st.empty()){\n                return false;\n            }\n        \
    \    else if(st.top()=='['){\n                st.pop();\n            }\n     \
    \       else{\n                return false;\n            }\n        }\n    }\n\
    \    if(st.empty()){\n        return true;\n    }\n    else{\n        return false;\n\
    \    }\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp74_t8uye: /tmp/tmp74_t8uye.cpp:47: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    // your code here\n    int\
    \ count = 0;\n    for(int i = 0; i < string.length(); i++){\n        if(string[i]\
    \ == '['){\n            count++;\n        }\n        else if(string[i] == ']'){\n\
    \            count--;\n        }\n        if(count < 0){\n            return false;\n\
    \        }\n    }\n    return count == 0;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp7wi9ptz0: /tmp/tmp7wi9ptz0.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (stack.empty()) {\n                return false;\n       \
    \     } else {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return !stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0a4qmugk: /tmp/tmp0a4qmugk.cpp:35: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (char c : string) {\n        if (c == '[') {\n            stack.push(c);\n\
    \        } else if (c == ']') {\n            if (stack.empty()) {\n          \
    \      return false;\n            }\n            stack.pop();\n        }\n   \
    \ }\n    return !stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0jsmpy87: /tmp/tmp0jsmpy87.cpp:34: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='[')\n            s.push(string[i]);\n\
    \        else if(string[i]==']'){\n            if(s.empty())\n               \
    \ return false;\n            else if(s.top()=='[')\n                s.pop();\n\
    \            else\n                return false;\n        }\n    }\n    if(s.empty())\n\
    \        return true;\n    else\n        return false;\n}\nint main() {\n    auto\
    \ candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp06iy7yca: /tmp/tmp06iy7yca.cpp:41: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (char c : string) {\n        if (c == '[') {\n            stack.push(c);\n\
    \        } else if (c == ']') {\n            if (stack.empty()) {\n          \
    \      return false;\n            }\n            stack.pop();\n        }\n   \
    \ }\n    return !stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0jsmpy87: /tmp/tmp0jsmpy87.cpp:34: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else if(s.top()=='['){\n\
    \                s.pop();\n            }\n            else{\n                return\
    \ false;\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpveu6t5us: /tmp/tmpveu6t5us.cpp:47: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else if(s.top()=='['){\n\
    \                s.pop();\n            }\n            else{\n                return\
    \ false;\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpveu6t5us: /tmp/tmpveu6t5us.cpp:47: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n         \
    \   st.push(string[i]);\n        }\n        else if(string[i]==']'){\n       \
    \     if(st.empty()){\n                return false;\n            }\n        \
    \    else{\n                st.pop();\n            }\n        }\n    }\n    if(st.empty()){\n\
    \        return true;\n    }\n    else{\n        return false;\n    }\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpd66rg2k_: /tmp/tmpd66rg2k_.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n         \
    \   st.push(string[i]);\n        }\n        else if(string[i]==']'){\n       \
    \     if(st.empty()){\n                return false;\n            }\n        \
    \    else{\n                st.pop();\n            }\n        }\n    }\n    if(st.empty()){\n\
    \        return true;\n    }\n    else{\n        return false;\n    }\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpd66rg2k_: /tmp/tmpd66rg2k_.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n         \
    \   st.push(string[i]);\n        }\n        else if(string[i]==']'){\n       \
    \     if(st.empty()){\n                return false;\n            }\n        \
    \    else{\n                st.pop();\n            }\n        }\n    }\n    if(st.empty()){\n\
    \        return true;\n    }\n    else{\n        return false;\n    }\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpd66rg2k_: /tmp/tmpd66rg2k_.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(auto\
    \ c : string) {\n        if(c == '[') {\n            s.push(c);\n        } else\
    \ if(c == ']') {\n            if(s.empty()) {\n                return false;\n\
    \            } else {\n                s.pop();\n            }\n        }\n  \
    \  }\n    return !s.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpljvfmwq_: /tmp/tmpljvfmwq_.cpp:35: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    // your code here\n    int\
    \ count = 0;\n    for(int i = 0; i < string.length(); i++){\n        if(string[i]\
    \ == '['){\n            count++;\n        }\n        else if(string[i] == ']'){\n\
    \            count--;\n        }\n        if(count < 0){\n            return false;\n\
    \        }\n    }\n    return count == 0;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp7wi9ptz0: /tmp/tmp7wi9ptz0.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (stack.empty()) {\n                return false;\n       \
    \     } else {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return !stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp0a4qmugk: /tmp/tmp0a4qmugk.cpp:35: int main(): Assertion `candidate(("[[]]"))
    == (true)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    // Your code here\n    int\
    \ count = 0;\n    for(int i = 0; i < string.length(); i++){\n        if(string[i]\
    \ == '['){\n            count++;\n        }\n        else if(string[i] == ']'){\n\
    \            count--;\n        }\n        if(count < 0){\n            return false;\n\
    \        }\n    }\n    return count == 0;\n}\nint main() {\n    auto candidate\
    \ = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpk0q2hsls: /tmp/tmpk0q2hsls.cpp:38: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstd::stack<char> s;\n\tfor (int\
    \ i = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\
    \t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty())\
    \ {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmppfj28q_n: /tmp/tmppfj28q_n.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else if(s.top()=='['){\n\
    \                s.pop();\n            }\n            else{\n                return\
    \ false;\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpveu6t5us: /tmp/tmpveu6t5us.cpp:47: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (stack.empty()) {\n                return false;\n       \
    \     } else {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpm6_l8gjc: /tmp/tmpm6_l8gjc.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    // Your code here\n    std::stack<char>\
    \ s;\n    for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n \
    \           s.push(string[i]);\n        }\n        else if(string[i]==']'){\n\
    \            if(s.empty()){\n                return false;\n            }\n  \
    \          else{\n                s.pop();\n            }\n        }\n    }\n\
    \    if(s.empty()){\n        return true;\n    }\n    else{\n        return false;\n\
    \    }\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp6e5yr8lu: /tmp/tmp6e5yr8lu.cpp:45: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n         \
    \   st.push(string[i]);\n        }\n        else if(string[i]==']'){\n       \
    \     if(st.empty()){\n                return false;\n            }\n        \
    \    else{\n                st.pop();\n            }\n        }\n    }\n    if(st.empty()){\n\
    \        return true;\n    }\n    else{\n        return false;\n    }\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpd66rg2k_: /tmp/tmpd66rg2k_.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (stack.empty()) {\n                return false;\n       \
    \     } else {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpm6_l8gjc: /tmp/tmpm6_l8gjc.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n\tstd::stack<char> s;\n\tfor (int\
    \ i = 0; i < string.length(); i++) {\n\t\tif (string[i] == '[') {\n\t\t\ts.push(string[i]);\n\
    \t\t}\n\t\telse if (string[i] == ']') {\n\t\t\tif (s.empty()) {\n\t\t\t\treturn\
    \ false;\n\t\t\t}\n\t\t\telse {\n\t\t\t\ts.pop();\n\t\t\t}\n\t\t}\n\t}\n\tif (s.empty())\
    \ {\n\t\treturn true;\n\t}\n\telse {\n\t\treturn false;\n\t}\n}\nint main() {\n\
    \    auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmppfj28q_n: /tmp/tmppfj28q_n.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(char c : string) {\n        if(c == '[') {\n            st.push(c);\n  \
    \      } else if(c == ']') {\n            if(st.empty()) {\n                return\
    \ false;\n            } else {\n                st.pop();\n            }\n   \
    \     }\n    }\n    return st.empty();\n}\nint main() {\n    auto candidate =\
    \ is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"[][]\")) == (false));\n\
    \    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"[[[[]]]]\"\
    )) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n    assert(candidate((\"\
    [][][[]]\")) == (true));\n    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"\
    []]\")) == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp72puaa55: /tmp/tmp72puaa55.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n         \
    \   st.push(string[i]);\n        }\n        else if(string[i]==']'){\n       \
    \     if(st.empty()){\n                return false;\n            }\n        \
    \    else{\n                st.pop();\n            }\n        }\n    }\n    if(st.empty()){\n\
    \        return true;\n    }\n    else{\n        return false;\n    }\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpd66rg2k_: /tmp/tmpd66rg2k_.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else if(s.top()=='['){\n\
    \                s.pop();\n            }\n            else{\n                return\
    \ false;\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpveu6t5us: /tmp/tmpveu6t5us.cpp:47: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n         \
    \   st.push(string[i]);\n        }\n        else if(string[i]==']'){\n       \
    \     if(st.empty()){\n                return false;\n            }\n        \
    \    else{\n                st.pop();\n            }\n        }\n    }\n    if(st.empty()){\n\
    \        return true;\n    }\n    else{\n        return false;\n    }\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpd66rg2k_: /tmp/tmpd66rg2k_.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (stack.empty()) {\n                return false;\n       \
    \     } else {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpm6_l8gjc: /tmp/tmpm6_l8gjc.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else if(s.top()=='['){\n\
    \                s.pop();\n            }\n            else{\n                return\
    \ false;\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpveu6t5us: /tmp/tmpveu6t5us.cpp:47: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n         \
    \   st.push(string[i]);\n        }\n        else if(string[i]==']'){\n       \
    \     if(st.empty()){\n                return false;\n            }\n        \
    \    else if(st.top()=='['){\n                st.pop();\n            }\n     \
    \       else{\n                return false;\n            }\n        }\n    }\n\
    \    if(st.empty()){\n        return true;\n    }\n    else{\n        return false;\n\
    \    }\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmp74_t8uye: /tmp/tmp74_t8uye.cpp:47: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    // your code here\n    std::stack<char>\
    \ s;\n    for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n \
    \           s.push(string[i]);\n        }\n        else if(string[i]==']'){\n\
    \            if(s.empty()){\n                return false;\n            }\n  \
    \          else{\n                s.pop();\n            }\n        }\n    }\n\
    \    if(s.empty()){\n        return true;\n    }\n    else{\n        return false;\n\
    \    }\n}\nint main() {\n    auto candidate = is_nested;\n    assert(candidate((\"\
    [[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n\
    \    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"[]\"))\
    \ == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpwjt9nueq: /tmp/tmpwjt9nueq.cpp:45: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061599
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> stack;\n\
    \    for (int i = 0; i < string.length(); i++) {\n        if (string[i] == '[')\
    \ {\n            stack.push(string[i]);\n        } else if (string[i] == ']')\
    \ {\n            if (stack.empty()) {\n                return false;\n       \
    \     } else {\n                stack.pop();\n            }\n        }\n    }\n\
    \    return stack.empty();\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmpm6_l8gjc: /tmp/tmpm6_l8gjc.cpp:37: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n         \
    \   st.push(string[i]);\n        }\n        else if(string[i]==']'){\n       \
    \     if(st.empty()){\n                return false;\n            }\n        \
    \    else{\n                st.pop();\n            }\n        }\n    }\n    if(st.empty()){\n\
    \        return true;\n    }\n    else{\n        return false;\n    }\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpd66rg2k_: /tmp/tmpd66rg2k_.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n         \
    \   st.push(string[i]);\n        }\n        else if(string[i]==']'){\n       \
    \     if(st.empty()){\n                return false;\n            }\n        \
    \    else{\n                st.pop();\n            }\n        }\n    }\n    if(st.empty()){\n\
    \        return true;\n    }\n    else{\n        return false;\n    }\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpd66rg2k_: /tmp/tmpd66rg2k_.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n         \
    \   st.push(string[i]);\n        }\n        else if(string[i]==']'){\n       \
    \     if(st.empty()){\n                return false;\n            }\n        \
    \    else{\n                st.pop();\n            }\n        }\n    }\n    if(st.empty()){\n\
    \        return true;\n    }\n    else{\n        return false;\n    }\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpd66rg2k_: /tmp/tmpd66rg2k_.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> st;\n   \
    \ for(int i=0;i<string.length();i++){\n        if(string[i]=='['){\n         \
    \   st.push(string[i]);\n        }\n        else if(string[i]==']'){\n       \
    \     if(st.empty()){\n                return false;\n            }\n        \
    \    else{\n                st.pop();\n            }\n        }\n    }\n    if(st.empty()){\n\
    \        return true;\n    }\n    else{\n        return false;\n    }\n}\nint\
    \ main() {\n    auto candidate = is_nested;\n    assert(candidate((\"[[]]\"))\
    \ == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpd66rg2k_: /tmp/tmpd66rg2k_.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    std::stack<char> s;\n    for(int\
    \ i=0;i<string.length();i++){\n        if(string[i]=='['){\n            s.push(string[i]);\n\
    \        }\n        else if(string[i]==']'){\n            if(s.empty()){\n   \
    \             return false;\n            }\n            else{\n              \
    \  s.pop();\n            }\n        }\n    }\n    if(s.empty()){\n        return\
    \ true;\n    }\n    else{\n        return false;\n    }\n}\nint main() {\n   \
    \ auto candidate = is_nested;\n    assert(candidate((\"[[]]\")) == (true));\n\
    \    assert(candidate((\"[]]]]]]][[[[[]\")) == (false));\n    assert(candidate((\"\
    [][]\")) == (false));\n    assert(candidate((\"[]\")) == (false));\n    assert(candidate((\"\
    [[[[]]]]\")) == (true));\n    assert(candidate((\"[]]]]]]]]]]\")) == (false));\n\
    \    assert(candidate((\"[][][[]]\")) == (true));\n    assert(candidate((\"[[]\"\
    )) == (false));\n    assert(candidate((\"[]]\")) == (false));\n    assert(candidate((\"\
    [[]][[\")) == (true));\n    assert(candidate((\"[[][]]\")) == (true));\n    assert(candidate((\"\
    \")) == (false));\n    assert(candidate((\"[[[[[[[[\")) == (false));\n    assert(candidate((\"\
    ]]]]]]]]\")) == (false));\n}\n"
  status: Exception
  stderr: 'tmpa4t0gn6y: /tmp/tmpa4t0gn6y.cpp:44: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a string as input which contains only square brackets.\n// The function\
    \ should return True if and only if there is a valid subsequence of brackets \n\
    // where at least one bracket in the subsequence is nested.\n// >>> is_nested((\"\
    [[]]\"))\n// (true)\n// >>> is_nested((\"[]]]]]]][[[[[]\"))\n// (false)\n// >>>\
    \ is_nested((\"[][]\"))\n// (false)\n// >>> is_nested((\"[]\"))\n// (false)\n\
    // >>> is_nested((\"[[][]]\"))\n// (true)\n// >>> is_nested((\"[[]][[\"))\n//\
    \ (true)\nbool is_nested(std::string string) {\n    int count = 0;\n    for (int\
    \ i = 0; i < string.length(); i++) {\n        if (string[i] == '[') {\n      \
    \      count++;\n        } else if (string[i] == ']') {\n            count--;\n\
    \        }\n        if (count < 0) {\n            return false;\n        }\n \
    \   }\n    return count == 0;\n}\nint main() {\n    auto candidate = is_nested;\n\
    \    assert(candidate((\"[[]]\")) == (true));\n    assert(candidate((\"[]]]]]]][[[[[]\"\
    )) == (false));\n    assert(candidate((\"[][]\")) == (false));\n    assert(candidate((\"\
    []\")) == (false));\n    assert(candidate((\"[[[[]]]]\")) == (true));\n    assert(candidate((\"\
    []]]]]]]]]]\")) == (false));\n    assert(candidate((\"[][][[]]\")) == (true));\n\
    \    assert(candidate((\"[[]\")) == (false));\n    assert(candidate((\"[]]\"))\
    \ == (false));\n    assert(candidate((\"[[]][[\")) == (true));\n    assert(candidate((\"\
    [[][]]\")) == (true));\n    assert(candidate((\"\")) == (false));\n    assert(candidate((\"\
    [[[[[[[[\")) == (false));\n    assert(candidate((\"]]]]]]]]\")) == (false));\n\
    }\n"
  status: Exception
  stderr: 'tmppz8cwc_x: /tmp/tmppz8cwc_x.cpp:36: int main(): Assertion `candidate(("[][]"))
    == (false)'' failed.

    '
  stdout: ''
  timestamp: 1660061598
