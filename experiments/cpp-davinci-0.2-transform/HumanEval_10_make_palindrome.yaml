name: HumanEval_10_make_palindrome
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Find the shortest palindrome\
  \ that begins with a supplied string.\n// Algorithm idea is simple:\n// - Find the\
  \ longest postfix of supplied string that is a palindrome.\n// - Append to the end\
  \ of the string reverse of a string prefix that comes before the palindromic suffix.\n\
  // >>> make_palindrome((\"\"))\n// (\"\")\n// >>> make_palindrome((\"cat\"))\n//\
  \ (\"catac\")\n// >>> make_palindrome((\"cata\"))\n// (\"catac\")\nstd::string make_palindrome(std::string\
  \ string) {\n"
tests: "}\nint main() {\n    auto candidate = make_palindrome;\n    assert(candidate((\"\
  \")) == (\"\"));\n    assert(candidate((\"x\")) == (\"x\"));\n    assert(candidate((\"\
  xyz\")) == (\"xyzyx\"));\n    assert(candidate((\"xyx\")) == (\"xyx\"));\n    assert(candidate((\"\
  jerry\")) == (\"jerryrrej\"));\n}\n"
completions: ["    std::string rev_string = string;\n    std::reverse(rev_string.begin(),\
    \ rev_string.end());\n    std::string lps = longest_palindromic_substring(string);\n\
    \    int lps_len = lps.length();\n    if (lps_len == string.length()) {\n    \
    \    return string;\n    }\n    return string + rev_string.substr(lps_len);",
  "    std::string result = string;\n    std::string reverse = string;\n    std::reverse(reverse.begin(),\
    \ reverse.end());\n    std::string::size_type suffix_length = 0;\n    for (std::string::size_type\
    \ i = 1; i <= string.size(); ++i) {\n        if (string.substr(string.size() -\
    \ i) == reverse.substr(0, i)) {\n            suffix_length = i;\n        }\n \
    \   }\n    result += reverse.substr(suffix_length);\n    return result;", "  \
    \  std::string result = string;\n    std::string::iterator it = string.begin();\n\
    \    std::string::iterator rit = string.rbegin();\n    std::string::iterator it_end\
    \ = string.end();\n    std::string::iterator rit_end = string.rend();\n    while\
    \ (it != it_end && rit != rit_end) {\n        if (*it == *rit) {\n           \
    \ ++it;\n            ++rit;\n        } else {\n            break;\n        }\n\
    \    }\n    if (it != it_end) {\n        std::string prefix(it, it_end);\n   \
    \     std::reverse(prefix.begin(), prefix.end());\n        result += prefix;\n\
    \    }\n    return result;", "    std::string result = string;\n    std::string\
    \ reverse = string;\n    std::reverse(reverse.begin(), reverse.end());\n    int\
    \ n = string.size();\n    int i = 0;\n    for (; i < n; ++i) {\n        if (string.substr(i)\
    \ == reverse.substr(0, n - i)) {\n            break;\n        }\n    }\n    result\
    \ += reverse.substr(n - i);\n    return result;", "    // Find the longest postfix\
    \ that is a palindrome.\n    std::string postfix;\n    for (int i = string.size()\
    \ - 1; i >= 0; --i) {\n        if (string.substr(i) == std::string(postfix.rbegin(),\
    \ postfix.rend())) {\n            break;\n        }\n        postfix += string[i];\n\
    \    }\n    // Append to the end of the string reverse of a string prefix that\
    \ comes before the palindromic suffix.\n    return string + std::string(postfix.rbegin(),\
    \ postfix.rend());", "    std::string result;\n    std::string reverse_string\
    \ = string;\n    std::reverse(reverse_string.begin(), reverse_string.end());\n\
    \    std::string concatenated_string = string + reverse_string;\n    std::vector<int>\
    \ prefix_function = prefix_function_kmp(concatenated_string);\n    int longest_palindromic_suffix_length\
    \ = prefix_function.back();\n    std::string prefix = string.substr(0, string.size()\
    \ - longest_palindromic_suffix_length);\n    std::reverse(prefix.begin(), prefix.end());\n\
    \    result = string + prefix;\n    return result;", "    std::string result =\
    \ string;\n    std::string::iterator it = result.begin();\n    std::string::iterator\
    \ it_end = result.end();\n    std::string::iterator it_mid = result.begin() +\
    \ result.size() / 2;\n    std::string::iterator it_mid_end = result.begin() +\
    \ result.size() / 2 + result.size() % 2;\n    std::string::iterator it_mid_rev\
    \ = result.end();\n    while (it != it_mid) {\n        if (*it == *(it_mid_rev\
    \ - 1)) {\n            it++;\n            it_mid_rev--;\n        } else {\n  \
    \          it_mid_rev = result.end();\n            it = ++it_mid;\n        }\n\
    \    }\n    std::reverse(it_mid_rev, it_end);\n    result.insert(it_end, it_mid_rev,\
    \ result.end());\n    return result;", "    std::string result = string;\n   \
    \ std::string::iterator it = string.begin();\n    std::string::iterator it_end\
    \ = string.end();\n    std::string::iterator it_rev = string.rbegin();\n    std::string::iterator\
    \ it_rev_end = string.rend();\n    std::string::iterator it_rev_begin = string.rbegin();\n\
    \    std::string::iterator it_begin = string.begin();\n    while (it != it_end)\
    \ {\n        if (*it == *it_rev) {\n            it++;\n            it_rev++;\n\
    \        } else {\n            it_rev = it_rev_begin;\n            it_begin++;\n\
    \            it = it_begin;\n        }\n    }\n    it_rev_end = it_rev;\n    while\
    \ (it_rev_end != it_rev_begin) {\n        result.push_back(*it_rev_end);\n   \
    \     it_rev_end++;\n    }\n    return result;", "    std::string result = string;\n\
    \    std::string reverse = string;\n    std::reverse(reverse.begin(), reverse.end());\n\
    \    size_t length = string.length();\n    for (size_t i = 0; i < length; i++)\
    \ {\n        if (string.substr(0, length - i) == reverse.substr(i)) {\n      \
    \      result.append(reverse.substr(0, i));\n            break;\n        }\n \
    \   }\n    return result;", "    std::string reversed_string = string;\n    std::reverse(reversed_string.begin(),\
    \ reversed_string.end());\n    std::string concatenated_string = string + reversed_string;\n\
    \    std::vector<int> prefix_function = prefix_function_kmp(concatenated_string);\n\
    \    int longest_palindromic_suffix_length = prefix_function.back();\n    std::string\
    \ prefix = string.substr(0, string.size() - longest_palindromic_suffix_length);\n\
    \    std::reverse(prefix.begin(), prefix.end());\n    return string + prefix;",
  "    std::string palindrome;\n    std::string prefix;\n    std::string suffix;\n\
    \    std::string::iterator it;\n    std::string::reverse_iterator rit;\n    //\
    \ Find the longest palindromic suffix.\n    for (it = string.begin(); it != string.end();\
    \ ++it) {\n        suffix.push_back(*it);\n        if (suffix == std::string(suffix.rbegin(),\
    \ suffix.rend())) {\n            break;\n        }\n    }\n    // Find the prefix\
    \ that comes before the palindromic suffix.\n    for (rit = string.rbegin(); rit\
    \ != string.rend(); ++rit) {\n        if (rit == string.rbegin() + suffix.size())\
    \ {\n            break;\n        }\n        prefix.push_back(*rit);\n    }\n \
    \   // Append reverse of the prefix to the end of the string.\n    palindrome\
    \ = string + std::string(prefix.rbegin(), prefix.rend());\n    return palindrome;",
  "    std::string result;\n    if (string.empty()) {\n        return result;\n  \
    \  }\n    // Find the longest postfix that is a palindrome.\n    size_t palindrome_length\
    \ = 0;\n    for (size_t i = 0; i < string.size(); ++i) {\n        size_t j = 0;\n\
    \        while (i - j >= 0 && i + j < string.size() && string[i - j] == string[i\
    \ + j]) {\n            ++j;\n        }\n        if (j > palindrome_length) {\n\
    \            palindrome_length = j;\n        }\n    }\n    // Append the reverse\
    \ of the prefix to the end of the string.\n    result = string;\n    for (size_t\
    \ i = 0; i < string.size() - palindrome_length; ++i) {\n        result += string[string.size()\
    \ - i - 1];\n    }\n    return result;", "    std::string result;\n    std::string::iterator\
    \ it;\n    std::string::reverse_iterator rit;\n    std::string::iterator it_end;\n\
    \    std::string::reverse_iterator rit_end;\n    std::string::iterator it_begin;\n\
    \    std::string::reverse_iterator rit_begin;\n    std::string::iterator it_mid;\n\
    \    std::string::reverse_iterator rit_mid;\n    std::string::iterator it_mid_end;\n\
    \    std::string::reverse_iterator rit_mid_end;\n    std::string::iterator it_mid_begin;\n\
    \    std::string::reverse_iterator rit_mid_begin;\n    std::string::iterator it_mid_mid;\n\
    \    std::string::reverse_iterator rit_mid_mid;\n    std::string::iterator it_mid_mid_end;\n\
    \    std::string::reverse_iterator rit_mid_mid_end;\n    std::string::iterator\
    \ it_mid_mid_begin;\n    std::string::reverse_iterator rit_mid_mid_begin;\n  \
    \  std::string::iterator it_mid_mid_mid;\n    std::string::reverse_iterator rit_mid_mid_mid;\n\
    \    std::string::iterator it_mid_mid_mid_end;\n    std::string::reverse_iterator\
    \ rit_mid_mid_mid_end;\n    std::string::iterator it_mid_mid_mid_begin;\n    std::string::reverse_iterator\
    \ rit_mid_mid_mid_begin;\n    std::string::iterator it_mid_mid_mid_mid;\n    std::string::reverse_iterator\
    \ rit_mid_mid_mid_mid;\n    std::string::iterator it_mid_mid_mid_mid_end;\n  \
    \  std::string::reverse_iterator rit_mid_mid_mid_mid_end;\n    std::string::iterator\
    \ it_mid_mid_mid_mid_begin;\n    std::string::reverse_iterator rit_mid_mid_mid_mid_begin;\n\
    \    std::string::iterator it_mid_mid_mid_mid_mid;\n    std::string::reverse_iterator\
    \ rit", "    std::string result = string;\n    std::string::iterator it = string.begin();\n\
    \    std::string::iterator rit = string.rbegin();\n    while (it != string.end()\
    \ && rit != string.rend()) {\n        if (*it == *rit) {\n            ++it;\n\
    \            ++rit;\n        } else {\n            break;\n        }\n    }\n\
    \    std::string prefix(it, string.end());\n    std::reverse(prefix.begin(), prefix.end());\n\
    \    result += prefix;\n    return result;", "    std::string reversed_string\
    \ = string;\n    std::reverse(reversed_string.begin(), reversed_string.end());\n\
    \    std::string concatenated_string = string + reversed_string;\n    std::vector<int>\
    \ prefix_function = prefix_function_kmp(concatenated_string);\n    int palindrome_length\
    \ = prefix_function.back();\n    std::string prefix = string.substr(0, string.size()\
    \ - palindrome_length);\n    std::string reversed_prefix = prefix;\n    std::reverse(reversed_prefix.begin(),\
    \ reversed_prefix.end());\n    return string + reversed_prefix;", "    std::string\
    \ result;\n    std::string reversed_string = string;\n    std::reverse(reversed_string.begin(),\
    \ reversed_string.end());\n    std::string concatenated_string = string + reversed_string;\n\
    \    std::vector<int> z_function = z_function_naive(concatenated_string);\n  \
    \  int length = z_function.size();\n    int max_z_function_value = 0;\n    int\
    \ max_z_function_value_index = 0;\n    for (int i = length / 2; i < length; i++)\
    \ {\n        if (z_function[i] > max_z_function_value) {\n            max_z_function_value\
    \ = z_function[i];\n            max_z_function_value_index = i;\n        }\n \
    \   }\n    result = string + reversed_string.substr(max_z_function_value_index\
    \ + 1);\n    return result;", "    std::string rev_string = string;\n    std::reverse(rev_string.begin(),\
    \ rev_string.end());\n    std::string lrs = longest_repeated_substring(string\
    \ + \"#\" + rev_string);\n    return string.substr(0, string.size() - lrs.size())\
    \ + rev_string;", "    std::string result;\n    std::string::iterator it = string.begin();\n\
    \    std::string::iterator rit = string.rbegin();\n    while (it < string.end()\
    \ && rit < string.rend()) {\n        if (*it == *rit) {\n            ++it;\n \
    \           ++rit;\n        } else {\n            break;\n        }\n    }\n \
    \   std::string prefix(it, string.end());\n    std::string suffix(string.begin(),\
    \ it);\n    std::reverse(prefix.begin(), prefix.end());\n    result = string +\
    \ prefix;\n    return result;", "    std::string result;\n    int length = string.length();\n\
    \    int i = length - 1;\n    while (i >= 0) {\n        if (string[i] == string[0])\
    \ {\n            int j = 0;\n            while (j < i && string[j] == string[i\
    \ - j]) {\n                j++;\n            }\n            if (j == i) {\n  \
    \              break;\n            }\n        }\n        i--;\n    }\n    result\
    \ = string;\n    for (int j = i - 1; j >= 0; j--) {\n        result += string[j];\n\
    \    }\n    return result;", "    // Find the longest postfix of supplied string\
    \ that is a palindrome.\n    std::string postfix = string;\n    std::reverse(postfix.begin(),\
    \ postfix.end());\n    std::string::size_type suffix_length = 0;\n    for (std::string::size_type\
    \ i = 0; i < postfix.size(); ++i) {\n        if (postfix.substr(i) == string.substr(0,\
    \ postfix.size() - i)) {\n            suffix_length = postfix.size() - i;\n  \
    \          break;\n        }\n    }\n    // Append to the end of the string reverse\
    \ of a string prefix that comes before the palindromic suffix.\n    std::string\
    \ prefix = string.substr(0, string.size() - suffix_length);\n    std::reverse(prefix.begin(),\
    \ prefix.end());\n    return string + prefix;"]
stop_tokens:
- "\n}"
