language: cpp
name: HumanEval_6_parse_nested_parens
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        std::stack<char>\
    \ stk;\n        long max_depth = 0;\n        for (char c : token) {\n        \
    \    if (c == '(') {\n                stk.push(c);\n                max_depth\
    \ = std::max(max_depth, (long)stk.size());\n            } else if (c == ')') {\n\
    \                stk.pop();\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqcflkae3.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpqcflkae3.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpqcflkae3.cpp:\
    \ In function 'int main()':\n/tmp/tmpqcflkae3.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpqcflkae3.cpp:2:\n/tmp/tmpqcflkae3.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpqcflkae3.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpqcflkae3.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpqcflkae3.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpqcflkae3.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpqcflkae3.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_nesting = 0;\n        long current_nesting = 0;\n        for (char c : token)\
    \ {\n            if (c == '(') {\n                current_nesting++;\n       \
    \         max_nesting = std::max(max_nesting, current_nesting);\n            }\
    \ else if (c == ')') {\n                current_nesting--;\n            }\n  \
    \      }\n        result.push_back(max_nesting);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp37m28p9u.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp37m28p9u.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmp37m28p9u.cpp:\
    \ In function 'int main()':\n/tmp/tmp37m28p9u.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmp37m28p9u.cpp:2:\n/tmp/tmp37m28p9u.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmp37m28p9u.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmp37m28p9u.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmp37m28p9u.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp37m28p9u.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp37m28p9u.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmha832am.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpmha832am.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpmha832am.cpp:\
    \ In function 'int main()':\n/tmp/tmpmha832am.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpmha832am.cpp:2:\n/tmp/tmpmha832am.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpmha832am.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpmha832am.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpmha832am.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmha832am.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpmha832am.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_level = 0;\n        long level = 0;\n        for (auto c : item) {\n   \
    \         if (c == '(') {\n                level++;\n                max_level\
    \ = std::max(max_level, level);\n            } else if (c == ')') {\n        \
    \        level--;\n            }\n        }\n        result.push_back(max_level);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp60rej9eo.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp60rej9eo.cpp:15:19: error: 'c' does not name a type\n         for (auto\
    \ c : item) {\n                   ^\n/tmp/tmp60rej9eo.cpp:23:9: error: expected\
    \ ';' before 'result'\n         result.push_back(max_level);\n         ^\n/tmp/tmp60rej9eo.cpp:23:35:\
    \ error: could not convert 'result.std::vector<_Tp, _Alloc>::push_back<long int,\
    \ std::allocator<long int> >((*(const value_type*)(& max_level)))' from 'void'\
    \ to 'bool'\n         result.push_back(max_level);\n                         \
    \          ^\n/tmp/tmp60rej9eo.cpp:24:5: error: expected primary-expression before\
    \ '}' token\n     }\n     ^\n/tmp/tmp60rej9eo.cpp:24:5: error: expected ')' before\
    \ '}' token\n/tmp/tmp60rej9eo.cpp:24:5: error: expected primary-expression before\
    \ '}' token\n/tmp/tmp60rej9eo.cpp:24:5: error: expected ';' before '}' token\n\
    /tmp/tmp60rej9eo.cpp: In function 'int main()':\n/tmp/tmp60rej9eo.cpp:28:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp60rej9eo.cpp:2:\n/tmp/tmp60rej9eo.cpp:29:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmp60rej9eo.cpp:29:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmp60rej9eo.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmha832am.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpmha832am.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpmha832am.cpp:\
    \ In function 'int main()':\n/tmp/tmpmha832am.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpmha832am.cpp:2:\n/tmp/tmpmha832am.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpmha832am.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpmha832am.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpmha832am.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmha832am.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpmha832am.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : item) {\n   \
    \         if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph3_4gyos.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmph3_4gyos.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : item) {\n                       ^\n/tmp/tmph3_4gyos.cpp:\
    \ In function 'int main()':\n/tmp/tmph3_4gyos.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmph3_4gyos.cpp:2:\n/tmp/tmph3_4gyos.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmph3_4gyos.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmph3_4gyos.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmph3_4gyos.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmph3_4gyos.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmph3_4gyos.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> result;\n  std::stringstream ss(paren_string);\n\
    \  std::string token;\n  while (std::getline(ss, token, ' ')) {\n    long max_depth\
    \ = 0;\n    long depth = 0;\n    for (char c : token) {\n      if (c == '(') {\n\
    \        depth++;\n        max_depth = std::max(max_depth, depth);\n      } else\
    \ if (c == ')') {\n        depth--;\n      }\n    }\n    result.push_back(max_depth);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpig77wk1e.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpig77wk1e.cpp:15:19: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n     for (char c : token) {\n                   ^\n/tmp/tmpig77wk1e.cpp:\
    \ In function 'int main()':\n/tmp/tmpig77wk1e.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpig77wk1e.cpp:2:\n/tmp/tmpig77wk1e.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpig77wk1e.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpig77wk1e.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpig77wk1e.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpig77wk1e.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpig77wk1e.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        result.push_back(parse_nested_parens_helper(item));\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph59orni9.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmph59orni9.cpp:13:57: error: 'parse_nested_parens_helper' was not declared\
    \ in this scope\n         result.push_back(parse_nested_parens_helper(item));\n\
    \                                                         ^\n/tmp/tmph59orni9.cpp:\
    \ In function 'int main()':\n/tmp/tmph59orni9.cpp:18:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmph59orni9.cpp:2:\n/tmp/tmph59orni9.cpp:19:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmph59orni9.cpp:19:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmph59orni9.cpp:19:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmph59orni9.cpp:19:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmph59orni9.cpp:19:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmph59orni9.cpp:19:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n    "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        std::stack<char>\
    \ st;\n        long max_depth = 0;\n        for (char c : item) {\n          \
    \  if (c == '(') {\n                st.push(c);\n                max_depth = std::max(max_depth,\
    \ (long)st.size());\n            } else if (c == ')') {\n                st.pop();\n\
    \            }\n        }\n        result.push_back(max_depth);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpu1b16fv9.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpu1b16fv9.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : item) {\n                       ^\n/tmp/tmpu1b16fv9.cpp:\
    \ In function 'int main()':\n/tmp/tmpu1b16fv9.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpu1b16fv9.cpp:2:\n/tmp/tmpu1b16fv9.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpu1b16fv9.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpu1b16fv9.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpu1b16fv9.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpu1b16fv9.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpu1b16fv9.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string paren;\n    while (std::getline(ss, paren, ' ')) {\n        long\
    \ max_level = 0;\n        long level = 0;\n        for (char c : paren) {\n  \
    \          if (c == '(') {\n                level++;\n                max_level\
    \ = std::max(max_level, level);\n            } else if (c == ')') {\n        \
    \        level--;\n            }\n        }\n        result.push_back(max_level);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpuw6_65es.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpuw6_65es.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : paren) {\n                       ^\n/tmp/tmpuw6_65es.cpp:\
    \ In function 'int main()':\n/tmp/tmpuw6_65es.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpuw6_65es.cpp:2:\n/tmp/tmpuw6_65es.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpuw6_65es.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpuw6_65es.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpuw6_65es.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpuw6_65es.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpuw6_65es.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (int i = 0; i < token.size();\
    \ i++) {\n            if (token[i] == '(') {\n                depth++;\n     \
    \           max_depth = std::max(max_depth, depth);\n            } else if (token[i]\
    \ == ')') {\n                depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpenmd0d0i.cpp: In function 'int main()':\n/tmp/tmpenmd0d0i.cpp:28:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpenmd0d0i.cpp:2:\n/tmp/tmpenmd0d0i.cpp:29:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpenmd0d0i.cpp:29:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpenmd0d0i.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpenmd0d0i.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpenmd0d0i.cpp:29:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpenmd0d0i.cpp:29:113:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpenmd0d0i.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        std::stack<char>\
    \ st;\n        long max_depth = 0;\n        for (char c : token) {\n         \
    \   if (c == '(') {\n                st.push(c);\n                max_depth =\
    \ std::max(max_depth, (long)st.size());\n            } else if (c == ')') {\n\
    \                st.pop();\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph2ruzfn4.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmph2ruzfn4.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmph2ruzfn4.cpp:\
    \ In function 'int main()':\n/tmp/tmph2ruzfn4.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmph2ruzfn4.cpp:2:\n/tmp/tmph2ruzfn4.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmph2ruzfn4.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmph2ruzfn4.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmph2ruzfn4.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmph2ruzfn4.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmph2ruzfn4.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> max_depth;\n    int depth = 0;\n    int\
    \ max = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n        if\
    \ (paren_string[i] == '(') {\n            depth++;\n            if (depth > max)\
    \ {\n                max = depth;\n            }\n        } else if (paren_string[i]\
    \ == ')') {\n            depth--;\n        } else if (paren_string[i] == ' ')\
    \ {\n            max_depth.push_back(max);\n            max = 0;\n           \
    \ depth = 0;\n        }\n    }\n    max_depth.push_back(max);\n    return max_depth;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpve_g7e7b.cpp: In function 'int main()':\n/tmp/tmpve_g7e7b.cpp:30:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpve_g7e7b.cpp:2:\n/tmp/tmpve_g7e7b.cpp:31:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpve_g7e7b.cpp:31:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpve_g7e7b.cpp:31:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpve_g7e7b.cpp:31:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpve_g7e7b.cpp:31:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpve_g7e7b.cpp:31:113:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:85,\n             \
    \    from /tmp/tmpve_g7e7b.cpp:2:\n/usr/include/c++/4.8.2/bits/stl_vector.h:398:9:\
    \ note: template<class _InputIterator> std::vector<_Tp, _Alloc>::vector(_InputIterator,\
    \ _InputIterator, const allocator_type&)\n         "
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> max_nesting_levels;\n    std::stringstream\
    \ ss(paren_string);\n    std::string paren_group;\n    while (std::getline(ss,\
    \ paren_group, ' ')) {\n        long max_nesting_level = 0;\n        long current_nesting_level\
    \ = 0;\n        for (char c : paren_group) {\n            if (c == '(') {\n  \
    \              current_nesting_level++;\n                max_nesting_level = std::max(max_nesting_level,\
    \ current_nesting_level);\n            } else if (c == ')') {\n              \
    \  current_nesting_level--;\n            }\n        }\n        max_nesting_levels.push_back(max_nesting_level);\n\
    \    }\n    return max_nesting_levels;\n}\nint main() {\n    auto candidate =\
    \ parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpsorod6p0.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpsorod6p0.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : paren_group) {\n                       ^\n\
    /tmp/tmpsorod6p0.cpp: In function 'int main()':\n/tmp/tmpsorod6p0.cpp:28:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsorod6p0.cpp:2:\n/tmp/tmpsorod6p0.cpp:29:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpsorod6p0.cpp:29:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpsorod6p0.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpsorod6p0.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpsorod6p0.cpp:29:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpsorod6p0.cpp:29:113:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bi"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> res;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        int\
    \ max_depth = 0;\n        int depth = 0;\n        for (char c : token) {\n   \
    \         if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        res.push_back(max_depth);\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyf6corv0.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpyf6corv0.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpyf6corv0.cpp:\
    \ In function 'int main()':\n/tmp/tmpyf6corv0.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpyf6corv0.cpp:2:\n/tmp/tmpyf6corv0.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpyf6corv0.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpyf6corv0.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpyf6corv0.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpyf6corv0.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpyf6corv0.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        std::stack<char>\
    \ st;\n        long max_depth = 0;\n        for (char c : item) {\n          \
    \  if (c == '(') {\n                st.push(c);\n                max_depth = std::max(max_depth,\
    \ (long)st.size());\n            } else if (c == ')') {\n                st.pop();\n\
    \            }\n        }\n        result.push_back(max_depth);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpu1b16fv9.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpu1b16fv9.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : item) {\n                       ^\n/tmp/tmpu1b16fv9.cpp:\
    \ In function 'int main()':\n/tmp/tmpu1b16fv9.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpu1b16fv9.cpp:2:\n/tmp/tmpu1b16fv9.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpu1b16fv9.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpu1b16fv9.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpu1b16fv9.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpu1b16fv9.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpu1b16fv9.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string paren_group;\n    while (std::getline(ss, paren_group, ' '))\
    \ {\n        long max_nesting = 0;\n        long current_nesting = 0;\n      \
    \  for (char c : paren_group) {\n            if (c == '(') {\n               \
    \ current_nesting++;\n                max_nesting = std::max(max_nesting, current_nesting);\n\
    \            } else if (c == ')') {\n                current_nesting--;\n    \
    \        }\n        }\n        result.push_back(max_nesting);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpi0e8ijz5.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpi0e8ijz5.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : paren_group) {\n                       ^\n\
    /tmp/tmpi0e8ijz5.cpp: In function 'int main()':\n/tmp/tmpi0e8ijz5.cpp:28:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpi0e8ijz5.cpp:2:\n/tmp/tmpi0e8ijz5.cpp:29:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpi0e8ijz5.cpp:29:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpi0e8ijz5.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpi0e8ijz5.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpi0e8ijz5.cpp:29:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpi0e8ijz5.cpp:29:113:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bi"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long current_depth = 0;\n        for (char c : token)\
    \ {\n            if (c == '(') {\n                current_depth++;\n         \
    \       max_depth = std::max(max_depth, current_depth);\n            } else if\
    \ (c == ')') {\n                current_depth--;\n            }\n        }\n \
    \       result.push_back(max_depth);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyocbr9px.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpyocbr9px.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpyocbr9px.cpp:\
    \ In function 'int main()':\n/tmp/tmpyocbr9px.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpyocbr9px.cpp:2:\n/tmp/tmpyocbr9px.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpyocbr9px.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpyocbr9px.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpyocbr9px.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpyocbr9px.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpyocbr9px.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_depth = 0;\n        long current_depth = 0;\n        for (char c : item)\
    \ {\n            if (c == '(') {\n                current_depth++;\n         \
    \       max_depth = std::max(max_depth, current_depth);\n            } else if\
    \ (c == ')') {\n                current_depth--;\n            }\n        }\n \
    \       result.push_back(max_depth);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp33vnoo_0.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp33vnoo_0.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : item) {\n                       ^\n/tmp/tmp33vnoo_0.cpp:\
    \ In function 'int main()':\n/tmp/tmp33vnoo_0.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmp33vnoo_0.cpp:2:\n/tmp/tmp33vnoo_0.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmp33vnoo_0.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmp33vnoo_0.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmp33vnoo_0.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp33vnoo_0.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp33vnoo_0.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmha832am.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpmha832am.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpmha832am.cpp:\
    \ In function 'int main()':\n/tmp/tmpmha832am.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpmha832am.cpp:2:\n/tmp/tmpmha832am.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpmha832am.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpmha832am.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpmha832am.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmha832am.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpmha832am.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : item) {\n   \
    \         if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph3_4gyos.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmph3_4gyos.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : item) {\n                       ^\n/tmp/tmph3_4gyos.cpp:\
    \ In function 'int main()':\n/tmp/tmph3_4gyos.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmph3_4gyos.cpp:2:\n/tmp/tmph3_4gyos.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmph3_4gyos.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmph3_4gyos.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmph3_4gyos.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmph3_4gyos.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmph3_4gyos.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_count = 0;\n        long count = 0;\n        for (char c : item) {\n   \
    \         if (c == '(') {\n                count++;\n                max_count\
    \ = std::max(max_count, count);\n            } else if (c == ')') {\n        \
    \        count--;\n            }\n        }\n        result.push_back(max_count);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp78ms4318.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string paren_group;\n    while (ss >> paren_group) {\n        long max_depth\
    \ = 0;\n        long depth = 0;\n        for (auto c : paren_group) {\n      \
    \      if (c == '(') {\n                depth++;\n                max_depth =\
    \ std::max(max_depth, depth);\n            } else if (c == ')') {\n          \
    \      depth--;\n            }\n        }\n        assert(depth == 0);\n     \
    \   result.push_back(max_depth);\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqygkn3d2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // Write your code here\n    std::vector<long> result;\n\
    \    std::stringstream ss(paren_string);\n    std::string token;\n    while(std::getline(ss,\
    \ token, ' ')) {\n        std::stack<char> s;\n        long max_depth = 0;\n \
    \       long depth = 0;\n        for(char c : token) {\n            if(c == '(')\
    \ {\n                depth++;\n                if(depth > max_depth) {\n     \
    \               max_depth = depth;\n                }\n            } else if(c\
    \ == ')') {\n                depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_gnwhioo.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_nesting = 0;\n        long current_nesting = 0;\n        for (int i = 0;\
    \ i < token.length(); i++) {\n            if (token[i] == '(') {\n           \
    \     current_nesting++;\n                max_nesting = std::max(max_nesting,\
    \ current_nesting);\n            } else if (token[i] == ')') {\n             \
    \   current_nesting--;\n            }\n        }\n        result.push_back(max_nesting);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpn_fww_54.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        std::stack<char>\
    \ stk;\n        long max_depth = 0;\n        for (char c : item) {\n         \
    \   if (c == '(') {\n                stk.push(c);\n                max_depth =\
    \ std::max(max_depth, (long)stk.size());\n            } else if (c == ')') {\n\
    \                assert(!stk.empty());\n                stk.pop();\n         \
    \   }\n        }\n        assert(stk.empty());\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmeb4l15n.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> res;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (getline(ss, token, ' ')) {\n        long max_depth\
    \ = 0;\n        long depth = 0;\n        for (char c : token) {\n            if\
    \ (c == '(') {\n                depth++;\n                max_depth = std::max(max_depth,\
    \ depth);\n            } else if (c == ')') {\n                depth--;\n    \
    \        }\n        }\n        res.push_back(max_depth);\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp57fb0yfj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        std::stack<char>\
    \ s;\n        long max_depth = 0;\n        for (char c : token) {\n          \
    \  if (c == '(') {\n                s.push(c);\n                max_depth = std::max(max_depth,\
    \ (long)s.size());\n            } else if (c == ')') {\n                s.pop();\n\
    \            }\n        }\n        result.push_back(max_depth);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpnbtdptbs.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (auto c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqnw8hebt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (auto c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqnw8hebt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        std::stack<char>\
    \ s;\n        long max_depth = 0;\n        long curr_depth = 0;\n        for (char\
    \ c : item) {\n            if (c == '(') {\n                s.push(c);\n     \
    \           curr_depth++;\n                max_depth = std::max(max_depth, curr_depth);\n\
    \            } else if (c == ')') {\n                s.pop();\n              \
    \  curr_depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpytzfzh_9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> max_depth;\n    std::stringstream ss(paren_string);\n\
    \    std::string group;\n    while (std::getline(ss, group, ' ')) {\n        long\
    \ depth = 0;\n        long max_depth_so_far = 0;\n        for (auto c : group)\
    \ {\n            if (c == '(') {\n                depth++;\n                max_depth_so_far\
    \ = std::max(max_depth_so_far, depth);\n            } else if (c == ')') {\n \
    \               depth--;\n            }\n        }\n        max_depth.push_back(max_depth_so_far);\n\
    \    }\n    return max_depth;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpahr5qvyj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        if\
    \ (item.size() == 0) {\n            continue;\n        }\n        long max_depth\
    \ = 0;\n        long depth = 0;\n        for (int i = 0; i < item.size(); i++)\
    \ {\n            if (item[i] == '(') {\n                depth++;\n           \
    \     max_depth = std::max(max_depth, depth);\n            } else if (item[i]\
    \ == ')') {\n                depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpx861b5jw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_level = 0;\n        long level = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                level++;\n                max_level\
    \ = std::max(max_level, level);\n            } else if (c == ')') {\n        \
    \        level--;\n            }\n        }\n        result.push_back(max_level);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpj_yiwm1n.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmha832am.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpmha832am.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpmha832am.cpp:\
    \ In function 'int main()':\n/tmp/tmpmha832am.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpmha832am.cpp:2:\n/tmp/tmpmha832am.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpmha832am.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpmha832am.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpmha832am.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmha832am.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpmha832am.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> result;\n  std::stringstream ss(paren_string);\n\
    \  std::string token;\n  while (std::getline(ss, token, ' ')) {\n    long max_nesting\
    \ = 0;\n    long current_nesting = 0;\n    for (auto c : token) {\n      if (c\
    \ == '(') {\n        current_nesting++;\n        max_nesting = std::max(max_nesting,\
    \ current_nesting);\n      } else if (c == ')') {\n        current_nesting--;\n\
    \      }\n    }\n    result.push_back(max_nesting);\n  }\n  return result;\n}\n\
    int main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpuml255r3.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string paren_group;\n    while (std::getline(ss, paren_group, ' '))\
    \ {\n        long max_depth = 0;\n        long current_depth = 0;\n        for\
    \ (char c : paren_group) {\n            if (c == '(') {\n                current_depth++;\n\
    \                max_depth = std::max(max_depth, current_depth);\n           \
    \ } else if (c == ')') {\n                current_depth--;\n            }\n  \
    \      }\n        result.push_back(max_depth);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8lg5mio2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> res;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_level = 0;\n        long level = 0;\n        for (auto c : token) {\n  \
    \          if (c == '(') {\n                ++level;\n                max_level\
    \ = std::max(max_level, level);\n            } else if (c == ')') {\n        \
    \        --level;\n            }\n        }\n        res.push_back(max_level);\n\
    \    }\n    return res;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_p7oc1on.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        std::stack<char>\
    \ st;\n        long max_depth = 0;\n        for (auto c : item) {\n          \
    \  if (c == '(') {\n                st.push(c);\n                max_depth = std::max(max_depth,\
    \ (long)st.size());\n            } else if (c == ')') {\n                st.pop();\n\
    \            }\n        }\n        result.push_back(max_depth);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxl89nnae.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : item) {\n   \
    \         if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph3_4gyos.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmph3_4gyos.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : item) {\n                       ^\n/tmp/tmph3_4gyos.cpp:\
    \ In function 'int main()':\n/tmp/tmph3_4gyos.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmph3_4gyos.cpp:2:\n/tmp/tmph3_4gyos.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmph3_4gyos.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmph3_4gyos.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmph3_4gyos.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmph3_4gyos.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmph3_4gyos.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmha832am.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpmha832am.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpmha832am.cpp:\
    \ In function 'int main()':\n/tmp/tmpmha832am.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpmha832am.cpp:2:\n/tmp/tmpmha832am.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpmha832am.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpmha832am.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpmha832am.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmha832am.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpmha832am.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        std::stack<char>\
    \ st;\n        long max_depth = 0;\n        for (char c : token) {\n         \
    \   if (c == '(') {\n                st.push(c);\n                max_depth =\
    \ std::max(max_depth, (long)st.size());\n            } else if (c == ')') {\n\
    \                st.pop();\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph2ruzfn4.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmph2ruzfn4.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmph2ruzfn4.cpp:\
    \ In function 'int main()':\n/tmp/tmph2ruzfn4.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmph2ruzfn4.cpp:2:\n/tmp/tmph2ruzfn4.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmph2ruzfn4.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmph2ruzfn4.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmph2ruzfn4.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmph2ruzfn4.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmph2ruzfn4.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string paren;\n    while (ss >> paren) {\n        long max_depth = 0;\n\
    \        long depth = 0;\n        for (char c : paren) {\n            if (c ==\
    \ '(') {\n                depth++;\n                max_depth = std::max(max_depth,\
    \ depth);\n            } else if (c == ')') {\n                depth--;\n    \
    \        }\n        }\n        result.push_back(max_depth);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp2497lu7k.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        std::stack<char>\
    \ st;\n        long max_depth = 0;\n        for (char c : item) {\n          \
    \  if (c == '(') {\n                st.push(c);\n                max_depth = std::max(max_depth,\
    \ (long)st.size());\n            } else if (c == ')') {\n                assert(!st.empty());\n\
    \                st.pop();\n            }\n        }\n        assert(st.empty());\n\
    \        result.push_back(max_depth);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqujkijjg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : item) {\n   \
    \         if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph3_4gyos.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmph3_4gyos.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : item) {\n                       ^\n/tmp/tmph3_4gyos.cpp:\
    \ In function 'int main()':\n/tmp/tmph3_4gyos.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmph3_4gyos.cpp:2:\n/tmp/tmph3_4gyos.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmph3_4gyos.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmph3_4gyos.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmph3_4gyos.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmph3_4gyos.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmph3_4gyos.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string paren_group;\n    while (std::getline(ss, paren_group, ' '))\
    \ {\n        long max_level = 0;\n        long level = 0;\n        for (char c\
    \ : paren_group) {\n            if (c == '(') {\n                level++;\n  \
    \              max_level = std::max(max_level, level);\n            } else if\
    \ (c == ')') {\n                level--;\n            }\n        }\n        result.push_back(max_level);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmphs5d0am9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::istringstream iss(paren_string);\n\
    \    std::string token;\n    while (std::getline(iss, token, ' ')) {\n       \
    \ long max_nesting = 0;\n        long current_nesting = 0;\n        for (char\
    \ c : token) {\n            if (c == '(') {\n                current_nesting++;\n\
    \                max_nesting = std::max(max_nesting, current_nesting);\n     \
    \       } else if (c == ')') {\n                current_nesting--;\n         \
    \   }\n        }\n        result.push_back(max_nesting);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpyjzh34z_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_nesting = 0;\n        long current_nesting = 0;\n        for (char c : item)\
    \ {\n            if (c == '(') {\n                current_nesting++;\n       \
    \         max_nesting = std::max(max_nesting, current_nesting);\n            }\
    \ else if (c == ')') {\n                current_nesting--;\n            }\n  \
    \      }\n        result.push_back(max_nesting);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpd3lnh4c7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmha832am.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpmha832am.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpmha832am.cpp:\
    \ In function 'int main()':\n/tmp/tmpmha832am.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpmha832am.cpp:2:\n/tmp/tmpmha832am.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpmha832am.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpmha832am.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpmha832am.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmha832am.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpmha832am.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        int\
    \ max_depth = 0;\n        int current_depth = 0;\n        for (int i = 0; i <\
    \ token.length(); i++) {\n            if (token[i] == '(') {\n               \
    \ current_depth++;\n                max_depth = std::max(max_depth, current_depth);\n\
    \            } else if (token[i] == ')') {\n                current_depth--;\n\
    \            }\n        }\n        result.push_back(max_depth);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpnhf_u7_v.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_nesting = 0;\n        long current_nesting = 0;\n        for (char c : item)\
    \ {\n            if (c == '(') {\n                current_nesting++;\n       \
    \         max_nesting = std::max(max_nesting, current_nesting);\n            }\
    \ else if (c == ')') {\n                current_nesting--;\n            }\n  \
    \      }\n        result.push_back(max_nesting);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpd3lnh4c7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_depth = 0;\n        long current_depth = 0;\n        for (char c : item)\
    \ {\n            if (c == '(') {\n                current_depth++;\n         \
    \       max_depth = std::max(max_depth, current_depth);\n            } else if\
    \ (c == ')') {\n                current_depth--;\n            }\n        }\n \
    \       result.push_back(max_depth);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp33vnoo_0.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp33vnoo_0.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : item) {\n                       ^\n/tmp/tmp33vnoo_0.cpp:\
    \ In function 'int main()':\n/tmp/tmp33vnoo_0.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmp33vnoo_0.cpp:2:\n/tmp/tmp33vnoo_0.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmp33vnoo_0.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmp33vnoo_0.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmp33vnoo_0.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp33vnoo_0.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp33vnoo_0.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_nesting = 0;\n        long current_nesting = 0;\n        for (char c : item)\
    \ {\n            if (c == '(') {\n                current_nesting++;\n       \
    \         max_nesting = std::max(max_nesting, current_nesting);\n            }\
    \ else if (c == ')') {\n                current_nesting--;\n            }\n  \
    \      }\n        result.push_back(max_nesting);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpd3lnh4c7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> max_depth;\n    std::stringstream ss(paren_string);\n\
    \    std::string group;\n    while (std::getline(ss, group, ' ')) {\n        std::stack<char>\
    \ st;\n        long max = 0;\n        for (char c : group) {\n            if (c\
    \ == '(') {\n                st.push(c);\n                max = std::max(max,\
    \ (long)st.size());\n            } else if (c == ')') {\n                st.pop();\n\
    \            }\n        }\n        max_depth.push_back(max);\n    }\n    return\
    \ max_depth;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n   \
    \ assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpuixour_l.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long current_depth = 0;\n        for (char c : token)\
    \ {\n            if (c == '(') {\n                current_depth++;\n         \
    \       max_depth = std::max(max_depth, current_depth);\n            } else if\
    \ (c == ')') {\n                current_depth--;\n            }\n        }\n \
    \       result.push_back(max_depth);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyocbr9px.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpyocbr9px.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpyocbr9px.cpp:\
    \ In function 'int main()':\n/tmp/tmpyocbr9px.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpyocbr9px.cpp:2:\n/tmp/tmpyocbr9px.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpyocbr9px.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpyocbr9px.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpyocbr9px.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpyocbr9px.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpyocbr9px.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long current_depth = 0;\n        for (char c : token)\
    \ {\n            if (c == '(') {\n                current_depth++;\n         \
    \       max_depth = std::max(max_depth, current_depth);\n            } else if\
    \ (c == ')') {\n                current_depth--;\n            }\n        }\n \
    \       result.push_back(max_depth);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyocbr9px.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpyocbr9px.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpyocbr9px.cpp:\
    \ In function 'int main()':\n/tmp/tmpyocbr9px.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpyocbr9px.cpp:2:\n/tmp/tmpyocbr9px.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpyocbr9px.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpyocbr9px.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpyocbr9px.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpyocbr9px.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpyocbr9px.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        std::stack<char>\
    \ st;\n        long max_depth = 0;\n        for (char c : token) {\n         \
    \   if (c == '(') {\n                st.push(c);\n                max_depth =\
    \ std::max(max_depth, (long)st.size());\n            } else if (c == ')') {\n\
    \                st.pop();\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph2ruzfn4.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmph2ruzfn4.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmph2ruzfn4.cpp:\
    \ In function 'int main()':\n/tmp/tmph2ruzfn4.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmph2ruzfn4.cpp:2:\n/tmp/tmph2ruzfn4.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmph2ruzfn4.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmph2ruzfn4.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmph2ruzfn4.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmph2ruzfn4.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmph2ruzfn4.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_nesting = 0;\n        long current_nesting = 0;\n        for (char c : token)\
    \ {\n            if (c == '(') {\n                ++current_nesting;\n       \
    \         max_nesting = std::max(max_nesting, current_nesting);\n            }\
    \ else if (c == ')') {\n                --current_nesting;\n            }\n  \
    \      }\n        result.push_back(max_nesting);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpen6nlkvz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmha832am.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpmha832am.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpmha832am.cpp:\
    \ In function 'int main()':\n/tmp/tmpmha832am.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpmha832am.cpp:2:\n/tmp/tmpmha832am.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpmha832am.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpmha832am.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpmha832am.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmha832am.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpmha832am.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        std::stack<char>\
    \ st;\n        long max_depth = 0;\n        for (char c : token) {\n         \
    \   if (c == '(') {\n                st.push(c);\n                max_depth =\
    \ std::max(max_depth, (long)st.size());\n            } else if (c == ')') {\n\
    \                st.pop();\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph2ruzfn4.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmph2ruzfn4.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmph2ruzfn4.cpp:\
    \ In function 'int main()':\n/tmp/tmph2ruzfn4.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmph2ruzfn4.cpp:2:\n/tmp/tmph2ruzfn4.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmph2ruzfn4.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmph2ruzfn4.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmph2ruzfn4.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmph2ruzfn4.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmph2ruzfn4.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // write your code here\n    std::vector<long> v;\n   \
    \ std::stringstream ss(paren_string);\n    std::string s;\n    while(ss >> s)\
    \ {\n        long max_depth = 0;\n        long depth = 0;\n        for(int i =\
    \ 0; i < s.length(); i++) {\n            if(s[i] == '(') {\n                depth++;\n\
    \                max_depth = std::max(max_depth, depth);\n            } else if(s[i]\
    \ == ')') {\n                depth--;\n            }\n        }\n        v.push_back(max_depth);\n\
    \    }\n    return v;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp1w9e_ti0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> result;\n  std::stringstream ss(paren_string);\n\
    \  std::string paren_group;\n  while (std::getline(ss, paren_group, ' ')) {\n\
    \    std::stack<char> paren_stack;\n    long max_depth = 0;\n    for (char c :\
    \ paren_group) {\n      if (c == '(') {\n        paren_stack.push(c);\n      \
    \  max_depth = std::max(max_depth, (long)paren_stack.size());\n      } else if\
    \ (c == ')') {\n        assert(!paren_stack.empty());\n        paren_stack.pop();\n\
    \      }\n    }\n    assert(paren_stack.empty());\n    result.push_back(max_depth);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpt5bh5xu6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        std::stack<char>\
    \ st;\n        long max_depth = 0;\n        for (char c : token) {\n         \
    \   if (c == '(') {\n                st.push(c);\n                max_depth =\
    \ std::max(max_depth, (long)st.size());\n            } else if (c == ')') {\n\
    \                st.pop();\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph2ruzfn4.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmph2ruzfn4.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmph2ruzfn4.cpp:\
    \ In function 'int main()':\n/tmp/tmph2ruzfn4.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmph2ruzfn4.cpp:2:\n/tmp/tmph2ruzfn4.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmph2ruzfn4.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmph2ruzfn4.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmph2ruzfn4.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmph2ruzfn4.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmph2ruzfn4.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        std::stack<char>\
    \ stk;\n        long max_depth = 0;\n        for (auto c : token) {\n        \
    \    if (c == '(') {\n                stk.push(c);\n                max_depth\
    \ = std::max(max_depth, (long)stk.size());\n            } else if (c == ')') {\n\
    \                stk.pop();\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5enz3mcp.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : item) {\n   \
    \         if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph3_4gyos.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmph3_4gyos.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : item) {\n                       ^\n/tmp/tmph3_4gyos.cpp:\
    \ In function 'int main()':\n/tmp/tmph3_4gyos.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmph3_4gyos.cpp:2:\n/tmp/tmph3_4gyos.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmph3_4gyos.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmph3_4gyos.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmph3_4gyos.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmph3_4gyos.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmph3_4gyos.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (auto c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqnw8hebt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string paren_group;\n    while (std::getline(ss, paren_group, ' '))\
    \ {\n        long max_depth = 0;\n        long depth = 0;\n        for (char c\
    \ : paren_group) {\n            if (c == '(') {\n                depth++;\n  \
    \              max_depth = std::max(max_depth, depth);\n            } else if\
    \ (c == ')') {\n                depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpj7maq4ck.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_nesting = 0;\n        long nesting = 0;\n        for (char c : token) {\n\
    \            if (c == '(') {\n                nesting++;\n                max_nesting\
    \ = std::max(max_nesting, nesting);\n            } else if (c == ')') {\n    \
    \            nesting--;\n            }\n        }\n        assert(nesting == 0);\n\
    \        result.push_back(max_nesting);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmptko4y9jg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_nesting = 0;\n        long current_nesting = 0;\n        for (char c : token)\
    \ {\n            if (c == '(') {\n                current_nesting++;\n       \
    \         max_nesting = std::max(max_nesting, current_nesting);\n            }\
    \ else if (c == ')') {\n                current_nesting--;\n            }\n  \
    \      }\n        result.push_back(max_nesting);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp37m28p9u.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp37m28p9u.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmp37m28p9u.cpp:\
    \ In function 'int main()':\n/tmp/tmp37m28p9u.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmp37m28p9u.cpp:2:\n/tmp/tmp37m28p9u.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmp37m28p9u.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmp37m28p9u.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmp37m28p9u.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp37m28p9u.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp37m28p9u.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string paren_group;\n    while (std::getline(ss, paren_group, ' '))\
    \ {\n        long max_level = 0;\n        long current_level = 0;\n        for\
    \ (char c : paren_group) {\n            if (c == '(') {\n                current_level++;\n\
    \                max_level = std::max(max_level, current_level);\n           \
    \ } else if (c == ')') {\n                current_level--;\n            }\n  \
    \      }\n        result.push_back(max_level);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpkjcdazdl.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmha832am.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpmha832am.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpmha832am.cpp:\
    \ In function 'int main()':\n/tmp/tmpmha832am.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpmha832am.cpp:2:\n/tmp/tmpmha832am.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpmha832am.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpmha832am.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpmha832am.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmha832am.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpmha832am.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        std::stack<char>\
    \ st;\n        long max_depth = 0;\n        for (char c : item) {\n          \
    \  if (c == '(') {\n                st.push(c);\n                max_depth = std::max(max_depth,\
    \ (long)st.size());\n            } else if (c == ')') {\n                st.pop();\n\
    \            }\n        }\n        result.push_back(max_depth);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpu1b16fv9.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpu1b16fv9.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : item) {\n                       ^\n/tmp/tmpu1b16fv9.cpp:\
    \ In function 'int main()':\n/tmp/tmpu1b16fv9.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpu1b16fv9.cpp:2:\n/tmp/tmpu1b16fv9.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpu1b16fv9.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpu1b16fv9.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpu1b16fv9.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpu1b16fv9.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpu1b16fv9.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        std::stack<char>\
    \ stk;\n        long max_nesting = 0;\n        for (char c : token) {\n      \
    \      if (c == '(') {\n                stk.push(c);\n                max_nesting\
    \ = std::max(max_nesting, (long)stk.size());\n            } else if (c == ')')\
    \ {\n                stk.pop();\n            }\n        }\n        result.push_back(max_nesting);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpy3dvc8mz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmha832am.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpmha832am.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpmha832am.cpp:\
    \ In function 'int main()':\n/tmp/tmpmha832am.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpmha832am.cpp:2:\n/tmp/tmpmha832am.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpmha832am.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpmha832am.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpmha832am.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmha832am.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpmha832am.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmha832am.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpmha832am.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpmha832am.cpp:\
    \ In function 'int main()':\n/tmp/tmpmha832am.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpmha832am.cpp:2:\n/tmp/tmpmha832am.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpmha832am.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpmha832am.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpmha832am.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmha832am.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpmha832am.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long curr_depth = 0;\n        for (auto c : token) {\n\
    \            if (c == '(') {\n                curr_depth++;\n                max_depth\
    \ = std::max(max_depth, curr_depth);\n            } else if (c == ')') {\n   \
    \             curr_depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmptx8x3qi5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        std::stack<char>\
    \ st;\n        long max_depth = 0;\n        long curr_depth = 0;\n        for\
    \ (char c : item) {\n            if (c == '(') {\n                curr_depth++;\n\
    \                max_depth = std::max(max_depth, curr_depth);\n              \
    \  st.push(c);\n            } else if (c == ')') {\n                if (st.empty())\
    \ {\n                    std::cout << \"Invalid input\" << std::endl;\n      \
    \              return result;\n                }\n                st.pop();\n\
    \                curr_depth--;\n            }\n        }\n        if (!st.empty())\
    \ {\n            std::cout << \"Invalid input\" << std::endl;\n            return\
    \ result;\n        }\n        result.push_back(max_depth);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp7yc1i_z4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string paren_group;\n    while (std::getline(ss, paren_group, ' '))\
    \ {\n        long max_depth = 0;\n        long depth = 0;\n        for (char c\
    \ : paren_group) {\n            if (c == '(') {\n                depth++;\n  \
    \              max_depth = std::max(max_depth, depth);\n            } else if\
    \ (c == ')') {\n                depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpj7maq4ck.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmha832am.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpmha832am.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpmha832am.cpp:\
    \ In function 'int main()':\n/tmp/tmpmha832am.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpmha832am.cpp:2:\n/tmp/tmpmha832am.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpmha832am.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpmha832am.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpmha832am.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmha832am.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpmha832am.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmha832am.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpmha832am.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpmha832am.cpp:\
    \ In function 'int main()':\n/tmp/tmpmha832am.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpmha832am.cpp:2:\n/tmp/tmpmha832am.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpmha832am.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpmha832am.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpmha832am.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmha832am.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpmha832am.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_depth = 0;\n        long current_depth = 0;\n        for (char c : item)\
    \ {\n            if (c == '(') {\n                current_depth++;\n         \
    \       max_depth = std::max(max_depth, current_depth);\n            } else if\
    \ (c == ')') {\n                current_depth--;\n            }\n        }\n \
    \       result.push_back(max_depth);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp33vnoo_0.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp33vnoo_0.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : item) {\n                       ^\n/tmp/tmp33vnoo_0.cpp:\
    \ In function 'int main()':\n/tmp/tmp33vnoo_0.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmp33vnoo_0.cpp:2:\n/tmp/tmp33vnoo_0.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmp33vnoo_0.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmp33vnoo_0.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmp33vnoo_0.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp33vnoo_0.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp33vnoo_0.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (auto c : item) {\n   \
    \         if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp4mfh9s06.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        int\
    \ max_depth = 0;\n        int depth = 0;\n        for (int i = 0; i < token.size();\
    \ i++) {\n            if (token[i] == '(') {\n                depth++;\n     \
    \           max_depth = std::max(max_depth, depth);\n            } else if (token[i]\
    \ == ')') {\n                depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpau26hvg_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (auto c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        assert(depth == 0);\n   \
    \     result.push_back(max_depth);\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpljoqenks.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        std::stack<char>\
    \ s;\n        long max_depth = 0;\n        for (char c : token) {\n          \
    \  if (c == '(') {\n                s.push(c);\n                max_depth = std::max(max_depth,\
    \ (long)s.size());\n            } else if (c == ')') {\n                assert(!s.empty());\n\
    \                s.pop();\n            }\n        }\n        assert(s.empty());\n\
    \        result.push_back(max_depth);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpl6yg8u_4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmha832am.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpmha832am.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpmha832am.cpp:\
    \ In function 'int main()':\n/tmp/tmpmha832am.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpmha832am.cpp:2:\n/tmp/tmpmha832am.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpmha832am.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpmha832am.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpmha832am.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmha832am.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpmha832am.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n\tstd::vector<long> result;\n\tstd::stringstream ss(paren_string);\n\
    \tstd::string paren_group;\n\twhile (std::getline(ss, paren_group, ' ')) {\n\t\
    \tlong max_level = 0;\n\t\tlong level = 0;\n\t\tfor (char c : paren_group) {\n\
    \t\t\tif (c == '(') {\n\t\t\t\tlevel++;\n\t\t\t\tmax_level = std::max(max_level,\
    \ level);\n\t\t\t}\n\t\t\telse if (c == ')') {\n\t\t\t\tlevel--;\n\t\t\t}\n\t\t\
    }\n\t\tresult.push_back(max_level);\n\t}\n\treturn result;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpgxv67ao4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string paren_group;\n    while (std::getline(ss, paren_group, ' '))\
    \ {\n        long max_nesting = 0;\n        long current_nesting = 0;\n      \
    \  for (char c : paren_group) {\n            if (c == '(') {\n               \
    \ current_nesting++;\n                max_nesting = std::max(max_nesting, current_nesting);\n\
    \            } else if (c == ')') {\n                current_nesting--;\n    \
    \        }\n        }\n        result.push_back(max_nesting);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpi0e8ijz5.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpi0e8ijz5.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : paren_group) {\n                       ^\n\
    /tmp/tmpi0e8ijz5.cpp: In function 'int main()':\n/tmp/tmpi0e8ijz5.cpp:28:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpi0e8ijz5.cpp:2:\n/tmp/tmpi0e8ijz5.cpp:29:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpi0e8ijz5.cpp:29:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpi0e8ijz5.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpi0e8ijz5.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpi0e8ijz5.cpp:29:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpi0e8ijz5.cpp:29:113:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bi"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> max_nesting_levels;\n    std::stringstream\
    \ ss(paren_string);\n    std::string paren_group;\n    while (std::getline(ss,\
    \ paren_group, ' ')) {\n        long max_nesting_level = 0;\n        long current_nesting_level\
    \ = 0;\n        for (char c : paren_group) {\n            if (c == '(') {\n  \
    \              current_nesting_level++;\n                max_nesting_level = std::max(max_nesting_level,\
    \ current_nesting_level);\n            } else if (c == ')') {\n              \
    \  current_nesting_level--;\n            }\n        }\n        max_nesting_levels.push_back(max_nesting_level);\n\
    \    }\n    return max_nesting_levels;\n}\nint main() {\n    auto candidate =\
    \ parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "/tmp/tmpsorod6p0.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpsorod6p0.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : paren_group) {\n                       ^\n\
    /tmp/tmpsorod6p0.cpp: In function 'int main()':\n/tmp/tmpsorod6p0.cpp:28:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpsorod6p0.cpp:2:\n/tmp/tmpsorod6p0.cpp:29:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpsorod6p0.cpp:29:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpsorod6p0.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpsorod6p0.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpsorod6p0.cpp:29:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpsorod6p0.cpp:29:113:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bi"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_nesting = 0;\n        long current_nesting = 0;\n        for (char c : token)\
    \ {\n            if (c == '(') {\n                current_nesting++;\n       \
    \         max_nesting = std::max(max_nesting, current_nesting);\n            }\
    \ else if (c == ')') {\n                current_nesting--;\n            }\n  \
    \      }\n        result.push_back(max_nesting);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp37m28p9u.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp37m28p9u.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmp37m28p9u.cpp:\
    \ In function 'int main()':\n/tmp/tmp37m28p9u.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmp37m28p9u.cpp:2:\n/tmp/tmp37m28p9u.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmp37m28p9u.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmp37m28p9u.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmp37m28p9u.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp37m28p9u.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp37m28p9u.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ depth = 0;\n        long max_depth = 0;\n        for (char c : item) {\n   \
    \         if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmply8h0wn6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        std::stack<char>\
    \ st;\n        long max_depth = 0;\n        for (auto c : item) {\n          \
    \  if (c == '(') {\n                st.push(c);\n                max_depth = std::max(max_depth,\
    \ (long)st.size());\n            } else if (c == ')') {\n                st.pop();\n\
    \            }\n        }\n        result.push_back(max_depth);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxl89nnae.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        std::stack<char>\
    \ st;\n        long max_depth = 0;\n        for (char c : item) {\n          \
    \  if (c == '(') {\n                st.push(c);\n                max_depth = std::max(max_depth,\
    \ (long)st.size());\n            } else if (c == ')') {\n                st.pop();\n\
    \            }\n        }\n        result.push_back(max_depth);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpu1b16fv9.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpu1b16fv9.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : item) {\n                       ^\n/tmp/tmpu1b16fv9.cpp:\
    \ In function 'int main()':\n/tmp/tmpu1b16fv9.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpu1b16fv9.cpp:2:\n/tmp/tmpu1b16fv9.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpu1b16fv9.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpu1b16fv9.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpu1b16fv9.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpu1b16fv9.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpu1b16fv9.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : item) {\n   \
    \         if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph3_4gyos.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmph3_4gyos.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : item) {\n                       ^\n/tmp/tmph3_4gyos.cpp:\
    \ In function 'int main()':\n/tmp/tmph3_4gyos.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmph3_4gyos.cpp:2:\n/tmp/tmph3_4gyos.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmph3_4gyos.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmph3_4gyos.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmph3_4gyos.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmph3_4gyos.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmph3_4gyos.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmha832am.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpmha832am.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpmha832am.cpp:\
    \ In function 'int main()':\n/tmp/tmpmha832am.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpmha832am.cpp:2:\n/tmp/tmpmha832am.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpmha832am.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpmha832am.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpmha832am.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmha832am.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpmha832am.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string paren_group;\n    while (std::getline(ss, paren_group, ' '))\
    \ {\n        long max_nesting = 0;\n        long current_nesting = 0;\n      \
    \  for (char c : paren_group) {\n            if (c == '(') {\n               \
    \ current_nesting++;\n                max_nesting = std::max(max_nesting, current_nesting);\n\
    \            } else if (c == ')') {\n                current_nesting--;\n    \
    \        }\n        }\n        result.push_back(max_nesting);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpi0e8ijz5.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpi0e8ijz5.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : paren_group) {\n                       ^\n\
    /tmp/tmpi0e8ijz5.cpp: In function 'int main()':\n/tmp/tmpi0e8ijz5.cpp:28:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpi0e8ijz5.cpp:2:\n/tmp/tmpi0e8ijz5.cpp:29:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmpi0e8ijz5.cpp:29:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmpi0e8ijz5.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                            \
    \                           ^\n/tmp/tmpi0e8ijz5.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n/tmp/tmpi0e8ijz5.cpp:29:113: error: no matching function for call\
    \ to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n/tmp/tmpi0e8ijz5.cpp:29:113:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bi"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        std::stack<char>\
    \ stk;\n        long max_depth = 0;\n        for (char c : item) {\n         \
    \   if (c == '(') {\n                stk.push(c);\n                max_depth =\
    \ std::max(max_depth, (long)stk.size());\n            } else if (c == ')') {\n\
    \                assert(!stk.empty());\n                stk.pop();\n         \
    \   }\n        }\n        assert(stk.empty());\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpmeb4l15n.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_level = 0;\n        long current_level = 0;\n        for (char c : token)\
    \ {\n            if (c == '(') {\n                current_level++;\n         \
    \       max_level = std::max(max_level, current_level);\n            } else if\
    \ (c == ')') {\n                current_level--;\n            }\n        }\n \
    \       result.push_back(max_level);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5qv2d4tz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string group;\n    while (std::getline(ss, group, ' ')) {\n        long\
    \ max_nesting = 0;\n        long current_nesting = 0;\n        for (char c : group)\
    \ {\n            if (c == '(') {\n                current_nesting++;\n       \
    \         max_nesting = std::max(max_nesting, current_nesting);\n            }\
    \ else if (c == ')') {\n                current_nesting--;\n            }\n  \
    \      }\n        result.push_back(max_nesting);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp4brazfel.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_level = 0;\n        long level = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                level++;\n                max_level\
    \ = std::max(max_level, level);\n            } else if (c == ')') {\n        \
    \        level--;\n            }\n        }\n        result.push_back(max_level);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpj_yiwm1n.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        std::stack<char>\
    \ stack;\n        long max_depth = 0;\n        for (char c : item) {\n       \
    \     if (c == '(') {\n                stack.push(c);\n                max_depth\
    \ = std::max(max_depth, (long)stack.size());\n            } else if (c == ')')\
    \ {\n                stack.pop();\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmphp668gki.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> res;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : item) {\n   \
    \         if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        assert(depth == 0);\n   \
    \     res.push_back(max_depth);\n    }\n    return res;\n}\nint main() {\n   \
    \ auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpgtx2ehjw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_nesting = 0;\n        long current_nesting = 0;\n        for (char c : item)\
    \ {\n            if (c == '(') {\n                current_nesting++;\n       \
    \         max_nesting = std::max(max_nesting, current_nesting);\n            }\
    \ else if (c == ')') {\n                current_nesting--;\n            }\n  \
    \      }\n        result.push_back(max_nesting);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpd3lnh4c7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        std::stack<char>\
    \ st;\n        long max_depth = 0;\n        for (char c : token) {\n         \
    \   if (c == '(') {\n                st.push(c);\n                max_depth =\
    \ std::max(max_depth, (long)st.size());\n            } else if (c == ')') {\n\
    \                st.pop();\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph2ruzfn4.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmph2ruzfn4.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmph2ruzfn4.cpp:\
    \ In function 'int main()':\n/tmp/tmph2ruzfn4.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmph2ruzfn4.cpp:2:\n/tmp/tmph2ruzfn4.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmph2ruzfn4.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmph2ruzfn4.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmph2ruzfn4.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmph2ruzfn4.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmph2ruzfn4.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long current_depth = 0;\n        for (char c : token)\
    \ {\n            if (c == '(') {\n                current_depth++;\n         \
    \       max_depth = std::max(max_depth, current_depth);\n            } else if\
    \ (c == ')') {\n                current_depth--;\n            }\n        }\n \
    \       result.push_back(max_depth);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyocbr9px.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpyocbr9px.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpyocbr9px.cpp:\
    \ In function 'int main()':\n/tmp/tmpyocbr9px.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpyocbr9px.cpp:2:\n/tmp/tmpyocbr9px.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpyocbr9px.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpyocbr9px.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpyocbr9px.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpyocbr9px.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpyocbr9px.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        std::stack<char>\
    \ st;\n        long max_depth = 0;\n        for (char c : item) {\n          \
    \  if (c == '(') {\n                st.push(c);\n                max_depth = std::max(max_depth,\
    \ (long)st.size());\n            } else if (c == ')') {\n                st.pop();\n\
    \            }\n        }\n        result.push_back(max_depth);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpu1b16fv9.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpu1b16fv9.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : item) {\n                       ^\n/tmp/tmpu1b16fv9.cpp:\
    \ In function 'int main()':\n/tmp/tmpu1b16fv9.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpu1b16fv9.cpp:2:\n/tmp/tmpu1b16fv9.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpu1b16fv9.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpu1b16fv9.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpu1b16fv9.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpu1b16fv9.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpu1b16fv9.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        std::stack<char>\
    \ st;\n        long max_depth = 0;\n        for (auto c : item) {\n          \
    \  if (c == '(') {\n                st.push(c);\n                max_depth = std::max(max_depth,\
    \ (long)st.size());\n            } else if (c == ')') {\n                st.pop();\n\
    \            }\n        }\n        result.push_back(max_depth);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxl89nnae.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string paren_group;\n    while (ss >> paren_group) {\n        long max_nesting\
    \ = 0;\n        long curr_nesting = 0;\n        for (char c : paren_group) {\n\
    \            if (c == '(') {\n                curr_nesting++;\n              \
    \  max_nesting = std::max(max_nesting, curr_nesting);\n            } else if (c\
    \ == ')') {\n                curr_nesting--;\n            }\n        }\n     \
    \   result.push_back(max_nesting);\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpb46e2nqy.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        std::stack<char>\
    \ stk;\n        long max_depth = 0;\n        for (char c : item) {\n         \
    \   if (c == '(') {\n                stk.push(c);\n                max_depth =\
    \ std::max(max_depth, (long)stk.size());\n            } else if (c == ')') {\n\
    \                stk.pop();\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpsnavbg3r.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string paren_group;\n    while (std::getline(ss, paren_group, ' '))\
    \ {\n        long max_depth = 0;\n        long depth = 0;\n        for (char c\
    \ : paren_group) {\n            if (c == '(') {\n                depth++;\n  \
    \              max_depth = std::max(max_depth, depth);\n            } else if\
    \ (c == ')') {\n                depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpj7maq4ck.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (auto c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqnw8hebt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmha832am.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpmha832am.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpmha832am.cpp:\
    \ In function 'int main()':\n/tmp/tmpmha832am.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpmha832am.cpp:2:\n/tmp/tmpmha832am.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpmha832am.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpmha832am.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpmha832am.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmha832am.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpmha832am.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string s;\n    while (ss >> s) {\n        long max_depth = 0;\n    \
    \    long depth = 0;\n        for (char c : s) {\n            if (c == '(') {\n\
    \                depth++;\n                max_depth = std::max(max_depth, depth);\n\
    \            } else if (c == ')') {\n                depth--;\n            }\n\
    \        }\n        result.push_back(max_depth);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmps9iba2e4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        if\
    \ (item.empty()) {\n            continue;\n        }\n        std::stack<char>\
    \ stack;\n        long max_depth = 0;\n        long depth = 0;\n        for (char\
    \ c : item) {\n            if (c == '(') {\n                depth++;\n       \
    \         max_depth = std::max(max_depth, depth);\n                stack.push(c);\n\
    \            } else if (c == ')') {\n                depth--;\n              \
    \  stack.pop();\n            }\n        }\n        assert(stack.empty());\n  \
    \      result.push_back(max_depth);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpeqw5mrke.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long curr_depth = 0;\n        for (char c : token) {\n\
    \            if (c == '(') {\n                curr_depth++;\n                max_depth\
    \ = std::max(max_depth, curr_depth);\n            } else if (c == ')') {\n   \
    \             curr_depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmphiw2j7xa.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_nesting = 0;\n        long current_nesting = 0;\n        for (char c : token)\
    \ {\n            if (c == '(') {\n                current_nesting++;\n       \
    \         max_nesting = std::max(max_nesting, current_nesting);\n            }\
    \ else if (c == ')') {\n                current_nesting--;\n            }\n  \
    \      }\n        result.push_back(max_nesting);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp37m28p9u.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp37m28p9u.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmp37m28p9u.cpp:\
    \ In function 'int main()':\n/tmp/tmp37m28p9u.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmp37m28p9u.cpp:2:\n/tmp/tmp37m28p9u.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmp37m28p9u.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmp37m28p9u.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmp37m28p9u.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp37m28p9u.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp37m28p9u.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_level = 0;\n        long level = 0;\n        for (char c : item) {\n   \
    \         if (c == '(') {\n                level++;\n                max_level\
    \ = std::max(max_level, level);\n            } else if (c == ')') {\n        \
    \        level--;\n            }\n        }\n        result.push_back(max_level);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9vhbdgbn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        std::stack<char>\
    \ st;\n        long max_depth = 0;\n        for (char c : token) {\n         \
    \   if (c == '(') {\n                st.push(c);\n                max_depth =\
    \ std::max(max_depth, (long)st.size());\n            } else if (c == ')') {\n\
    \                st.pop();\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph2ruzfn4.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmph2ruzfn4.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmph2ruzfn4.cpp:\
    \ In function 'int main()':\n/tmp/tmph2ruzfn4.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmph2ruzfn4.cpp:2:\n/tmp/tmph2ruzfn4.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmph2ruzfn4.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmph2ruzfn4.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmph2ruzfn4.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmph2ruzfn4.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmph2ruzfn4.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        std::stack<char>\
    \ stk;\n        long max_depth = 0;\n        for (char c : token) {\n        \
    \    if (c == '(') {\n                stk.push(c);\n                max_depth\
    \ = std::max(max_depth, (long)stk.size());\n            } else if (c == ')') {\n\
    \                stk.pop();\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqcflkae3.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpqcflkae3.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpqcflkae3.cpp:\
    \ In function 'int main()':\n/tmp/tmpqcflkae3.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpqcflkae3.cpp:2:\n/tmp/tmpqcflkae3.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpqcflkae3.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpqcflkae3.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpqcflkae3.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpqcflkae3.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpqcflkae3.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_nesting = 0;\n        long current_nesting = 0;\n        for (char c : token)\
    \ {\n            if (c == '(') {\n                current_nesting++;\n       \
    \         max_nesting = std::max(max_nesting, current_nesting);\n            }\
    \ else if (c == ')') {\n                current_nesting--;\n            }\n  \
    \      }\n        result.push_back(max_nesting);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp37m28p9u.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp37m28p9u.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmp37m28p9u.cpp:\
    \ In function 'int main()':\n/tmp/tmp37m28p9u.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmp37m28p9u.cpp:2:\n/tmp/tmp37m28p9u.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmp37m28p9u.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmp37m28p9u.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmp37m28p9u.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp37m28p9u.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp37m28p9u.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long current_depth = 0;\n        for (char c : token)\
    \ {\n            if (c == '(') {\n                current_depth++;\n         \
    \       max_depth = std::max(max_depth, current_depth);\n            } else if\
    \ (c == ')') {\n                current_depth--;\n            }\n        }\n \
    \       result.push_back(max_depth);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyocbr9px.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpyocbr9px.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpyocbr9px.cpp:\
    \ In function 'int main()':\n/tmp/tmpyocbr9px.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpyocbr9px.cpp:2:\n/tmp/tmpyocbr9px.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpyocbr9px.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpyocbr9px.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpyocbr9px.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpyocbr9px.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpyocbr9px.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string paren_group;\n    while (std::getline(ss, paren_group, ' '))\
    \ {\n        long max_level = 0;\n        long cur_level = 0;\n        for (char\
    \ c : paren_group) {\n            if (c == '(') {\n                cur_level++;\n\
    \                max_level = std::max(max_level, cur_level);\n            } else\
    \ if (c == ')') {\n                cur_level--;\n            }\n        }\n  \
    \      result.push_back(max_level);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpk8z01h_g.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        std::stack<char>\
    \ stk;\n        long max_depth = 0;\n        for (auto c : item) {\n         \
    \   if (c == '(') {\n                stk.push(c);\n                max_depth =\
    \ std::max(max_depth, (long)stk.size());\n            } else if (c == ')') {\n\
    \                stk.pop();\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmppy6373ai.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        std::stack<char>\
    \ stk;\n        long max_depth = 0;\n        for (char c : token) {\n        \
    \    if (c == '(') {\n                stk.push(c);\n                max_depth\
    \ = std::max(max_depth, (long)stk.size());\n            } else if (c == ')') {\n\
    \                stk.pop();\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpqcflkae3.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpqcflkae3.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpqcflkae3.cpp:\
    \ In function 'int main()':\n/tmp/tmpqcflkae3.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpqcflkae3.cpp:2:\n/tmp/tmpqcflkae3.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpqcflkae3.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpqcflkae3.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpqcflkae3.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpqcflkae3.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpqcflkae3.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : item) {\n   \
    \         if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph3_4gyos.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmph3_4gyos.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : item) {\n                       ^\n/tmp/tmph3_4gyos.cpp:\
    \ In function 'int main()':\n/tmp/tmph3_4gyos.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmph3_4gyos.cpp:2:\n/tmp/tmph3_4gyos.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmph3_4gyos.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmph3_4gyos.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmph3_4gyos.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmph3_4gyos.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmph3_4gyos.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> result;\n  std::stringstream ss(paren_string);\n\
    \  std::string token;\n  while (std::getline(ss, token, ' ')) {\n    int max_level\
    \ = 0;\n    int level = 0;\n    for (int i = 0; i < token.size(); i++) {\n   \
    \   if (token[i] == '(') {\n        level++;\n        max_level = std::max(max_level,\
    \ level);\n      } else if (token[i] == ')') {\n        level--;\n      }\n  \
    \  }\n    result.push_back(max_level);\n  }\n  return result;\n}\nint main() {\n\
    \    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmplymoo0u0.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        std::stack<char>\
    \ st;\n        long max_depth = 0;\n        long depth = 0;\n        for (char\
    \ c : item) {\n            if (c == '(') {\n                depth++;\n       \
    \         max_depth = std::max(max_depth, depth);\n            } else if (c ==\
    \ ')') {\n                depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9gjvfuog.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_nesting = 0;\n        long current_nesting = 0;\n        for (char c : token)\
    \ {\n            if (c == '(') {\n                current_nesting++;\n       \
    \         max_nesting = std::max(max_nesting, current_nesting);\n            }\
    \ else if (c == ')') {\n                current_nesting--;\n            }\n  \
    \      }\n        result.push_back(max_nesting);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp37m28p9u.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp37m28p9u.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmp37m28p9u.cpp:\
    \ In function 'int main()':\n/tmp/tmp37m28p9u.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmp37m28p9u.cpp:2:\n/tmp/tmp37m28p9u.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmp37m28p9u.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmp37m28p9u.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmp37m28p9u.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp37m28p9u.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp37m28p9u.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmha832am.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpmha832am.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpmha832am.cpp:\
    \ In function 'int main()':\n/tmp/tmpmha832am.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpmha832am.cpp:2:\n/tmp/tmpmha832am.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpmha832am.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpmha832am.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpmha832am.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmha832am.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpmha832am.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_level = 0;\n        long level = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                level++;\n                max_level\
    \ = std::max(max_level, level);\n            } else if (c == ')') {\n        \
    \        level--;\n            }\n        }\n        result.push_back(max_level);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpj_yiwm1n.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        std::stack<char>\
    \ st;\n        long max_depth = 0;\n        for (char c : token) {\n         \
    \   if (c == '(') {\n                st.push(c);\n                max_depth =\
    \ std::max(max_depth, (long)st.size());\n            } else if (c == ')') {\n\
    \                st.pop();\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph2ruzfn4.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmph2ruzfn4.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmph2ruzfn4.cpp:\
    \ In function 'int main()':\n/tmp/tmph2ruzfn4.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmph2ruzfn4.cpp:2:\n/tmp/tmph2ruzfn4.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmph2ruzfn4.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmph2ruzfn4.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmph2ruzfn4.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmph2ruzfn4.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmph2ruzfn4.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmha832am.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpmha832am.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpmha832am.cpp:\
    \ In function 'int main()':\n/tmp/tmpmha832am.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpmha832am.cpp:2:\n/tmp/tmpmha832am.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpmha832am.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpmha832am.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpmha832am.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmha832am.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpmha832am.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string paren_group;\n    while (std::getline(ss, paren_group, ' '))\
    \ {\n        long max_depth = 0;\n        long depth = 0;\n        for (char c\
    \ : paren_group) {\n            if (c == '(') {\n                depth++;\n  \
    \              max_depth = std::max(max_depth, depth);\n            } else if\
    \ (c == ')') {\n                depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpj7maq4ck.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        std::stack<char>\
    \ stk;\n        long max_depth = 0;\n        long curr_depth = 0;\n        for\
    \ (char c : item) {\n            if (c == '(') {\n                stk.push(c);\n\
    \                curr_depth++;\n                max_depth = std::max(max_depth,\
    \ curr_depth);\n            } else if (c == ')') {\n                if (stk.empty())\
    \ {\n                    assert(false);\n                }\n                stk.pop();\n\
    \                curr_depth--;\n            }\n        }\n        if (!stk.empty())\
    \ {\n            assert(false);\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpcsulk_5b.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string paren_group;\n    while (std::getline(ss, paren_group, ' '))\
    \ {\n        long max_level = 0;\n        long level = 0;\n        for (char c\
    \ : paren_group) {\n            if (c == '(') {\n                level++;\n  \
    \              max_level = std::max(max_level, level);\n            } else if\
    \ (c == ')') {\n                level--;\n            }\n        }\n        result.push_back(max_level);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmphs5d0am9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_nesting = 0;\n        long current_nesting = 0;\n        for (char c : item)\
    \ {\n            if (c == '(') {\n                current_nesting++;\n       \
    \         max_nesting = std::max(max_nesting, current_nesting);\n            }\
    \ else if (c == ')') {\n                current_nesting--;\n            }\n  \
    \      }\n        result.push_back(max_nesting);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpd3lnh4c7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_nesting = 0;\n        long current_nesting = 0;\n        for (long i = 0;\
    \ i < token.size(); i++) {\n            if (token[i] == '(') {\n             \
    \   current_nesting++;\n                max_nesting = std::max(max_nesting, current_nesting);\n\
    \            } else if (token[i] == ')') {\n                current_nesting--;\n\
    \            }\n        }\n        result.push_back(max_nesting);\n    }\n   \
    \ return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5wf3d23q.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (auto c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqnw8hebt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string group;\n    while (ss >> group) {\n        long max_depth = 0;\n\
    \        long depth = 0;\n        for (char c : group) {\n            if (c ==\
    \ '(') {\n                depth++;\n                max_depth = std::max(max_depth,\
    \ depth);\n            } else if (c == ')') {\n                depth--;\n    \
    \        }\n        }\n        result.push_back(max_depth);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp3pazybt4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string group;\n    while (std::getline(ss, group, ' ')) {\n        long\
    \ count = 0;\n        long max_count = 0;\n        for (char c : group) {\n  \
    \          if (c == '(') {\n                count++;\n                max_count\
    \ = std::max(max_count, count);\n            } else if (c == ')') {\n        \
    \        count--;\n            }\n        }\n        result.push_back(max_count);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpt4y9b_sq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_nesting = 0;\n        long current_nesting = 0;\n        for (char c : item)\
    \ {\n            if (c == '(') {\n                current_nesting++;\n       \
    \         max_nesting = std::max(max_nesting, current_nesting);\n            }\
    \ else if (c == ')') {\n                current_nesting--;\n            }\n  \
    \      }\n        result.push_back(max_nesting);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpd3lnh4c7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_level = 0;\n        long level = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                level++;\n                max_level\
    \ = std::max(max_level, level);\n            } else if (c == ')') {\n        \
    \        level--;\n            }\n        }\n        result.push_back(max_level);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpj_yiwm1n.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ count = 0;\n        long max_count = 0;\n        for (int i = 0; i < item.length();\
    \ i++) {\n            if (item[i] == '(') {\n                count++;\n      \
    \          if (count > max_count) {\n                    max_count = count;\n\
    \                }\n            } else if (item[i] == ')') {\n               \
    \ count--;\n            }\n        }\n        result.push_back(max_count);\n \
    \   }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpipx_7lrh.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_nesting = 0;\n        long current_nesting = 0;\n        for (char c : token)\
    \ {\n            if (c == '(') {\n                current_nesting++;\n       \
    \         max_nesting = std::max(max_nesting, current_nesting);\n            }\
    \ else if (c == ')') {\n                current_nesting--;\n            }\n  \
    \      }\n        result.push_back(max_nesting);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp37m28p9u.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp37m28p9u.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmp37m28p9u.cpp:\
    \ In function 'int main()':\n/tmp/tmp37m28p9u.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmp37m28p9u.cpp:2:\n/tmp/tmp37m28p9u.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmp37m28p9u.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmp37m28p9u.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmp37m28p9u.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp37m28p9u.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp37m28p9u.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        std::stack<char>\
    \ paren_stack;\n        long max_depth = 0;\n        for (char c : token) {\n\
    \            if (c == '(') {\n                paren_stack.push(c);\n         \
    \       max_depth = std::max(max_depth, (long)paren_stack.size());\n         \
    \   } else if (c == ')') {\n                paren_stack.pop();\n            }\n\
    \        }\n        result.push_back(max_depth);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmphnxr6d4a.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    // TODO: Implement this function\n    std::vector<long>\
    \ result;\n    std::stringstream ss(paren_string);\n    std::string token;\n \
    \   while(std::getline(ss, token, ' ')){\n        std::stack<char> st;\n     \
    \   long max_depth = 0;\n        long curr_depth = 0;\n        for(int i = 0;\
    \ i < token.length(); i++){\n            if(token[i] == '('){\n              \
    \  st.push(token[i]);\n                curr_depth++;\n                max_depth\
    \ = std::max(max_depth, curr_depth);\n            }\n            else if(token[i]\
    \ == ')'){\n                st.pop();\n                curr_depth--;\n       \
    \     }\n        }\n        result.push_back(max_depth);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp_t30kwe9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        std::stack<char>\
    \ st;\n        long max_depth = 0;\n        for (auto c : item) {\n          \
    \  if (c == '(') {\n                st.push(c);\n                max_depth = std::max(max_depth,\
    \ (long)st.size());\n            } else if (c == ')') {\n                st.pop();\n\
    \            }\n        }\n        result.push_back(max_depth);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxl89nnae.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> result;\n  std::stringstream ss(paren_string);\n\
    \  std::string paren_group;\n  while (std::getline(ss, paren_group, ' ')) {\n\
    \    long max_depth = 0;\n    long depth = 0;\n    for (char c : paren_group)\
    \ {\n      if (c == '(') {\n        depth++;\n        max_depth = std::max(max_depth,\
    \ depth);\n      } else if (c == ')') {\n        depth--;\n      }\n    }\n  \
    \  result.push_back(max_depth);\n  }\n  return result;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmph44bvfr9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : item) {\n   \
    \         if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph3_4gyos.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmph3_4gyos.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : item) {\n                       ^\n/tmp/tmph3_4gyos.cpp:\
    \ In function 'int main()':\n/tmp/tmph3_4gyos.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmph3_4gyos.cpp:2:\n/tmp/tmph3_4gyos.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmph3_4gyos.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmph3_4gyos.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmph3_4gyos.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmph3_4gyos.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmph3_4gyos.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> ans;\n    std::stringstream ss(paren_string);\n\
    \    std::string s;\n    while (ss >> s) {\n        long max_depth = 0;\n    \
    \    long depth = 0;\n        for (char c : s) {\n            if (c == '(') {\n\
    \                depth++;\n                max_depth = std::max(max_depth, depth);\n\
    \            } else if (c == ')') {\n                depth--;\n            }\n\
    \        }\n        ans.push_back(max_depth);\n    }\n    return ans;\n}\nint\
    \ main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpsiu4yh6b.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        std::stack<char>\
    \ st;\n        long max_depth = 0;\n        for (auto c : token) {\n         \
    \   if (c == '(') {\n                st.push(c);\n                max_depth =\
    \ std::max(max_depth, (long)st.size());\n            } else if (c == ')') {\n\
    \                st.pop();\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp6x1hscps.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_nesting = 0;\n        long current_nesting = 0;\n        for (char c : token)\
    \ {\n            if (c == '(') {\n                current_nesting++;\n       \
    \         max_nesting = std::max(max_nesting, current_nesting);\n            }\
    \ else if (c == ')') {\n                current_nesting--;\n            }\n  \
    \      }\n        result.push_back(max_nesting);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp37m28p9u.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp37m28p9u.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmp37m28p9u.cpp:\
    \ In function 'int main()':\n/tmp/tmp37m28p9u.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmp37m28p9u.cpp:2:\n/tmp/tmp37m28p9u.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmp37m28p9u.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmp37m28p9u.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmp37m28p9u.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp37m28p9u.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp37m28p9u.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        std::stack<char>\
    \ st;\n        long max_depth = 0;\n        for (char c : item) {\n          \
    \  if (c == '(') {\n                st.push(c);\n                max_depth = std::max(max_depth,\
    \ (long)st.size());\n            } else if (c == ')') {\n                st.pop();\n\
    \            }\n        }\n        result.push_back(max_depth);\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpu1b16fv9.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpu1b16fv9.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : item) {\n                       ^\n/tmp/tmpu1b16fv9.cpp:\
    \ In function 'int main()':\n/tmp/tmpu1b16fv9.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpu1b16fv9.cpp:2:\n/tmp/tmpu1b16fv9.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpu1b16fv9.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpu1b16fv9.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpu1b16fv9.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpu1b16fv9.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpu1b16fv9.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : item) {\n   \
    \         if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph3_4gyos.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmph3_4gyos.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : item) {\n                       ^\n/tmp/tmph3_4gyos.cpp:\
    \ In function 'int main()':\n/tmp/tmph3_4gyos.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmph3_4gyos.cpp:2:\n/tmp/tmph3_4gyos.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmph3_4gyos.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmph3_4gyos.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmph3_4gyos.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmph3_4gyos.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmph3_4gyos.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : item) {\n   \
    \         if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph3_4gyos.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmph3_4gyos.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : item) {\n                       ^\n/tmp/tmph3_4gyos.cpp:\
    \ In function 'int main()':\n/tmp/tmph3_4gyos.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmph3_4gyos.cpp:2:\n/tmp/tmph3_4gyos.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmph3_4gyos.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmph3_4gyos.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmph3_4gyos.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmph3_4gyos.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmph3_4gyos.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_nesting = 0;\n        long current_nesting = 0;\n        for (char c : item)\
    \ {\n            if (c == '(') {\n                current_nesting++;\n       \
    \         max_nesting = std::max(max_nesting, current_nesting);\n            }\
    \ else if (c == ')') {\n                current_nesting--;\n            }\n  \
    \      }\n        result.push_back(max_nesting);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpd3lnh4c7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_level = 0;\n        long level = 0;\n        for (auto c : token) {\n  \
    \          if (c == '(') {\n                level++;\n                max_level\
    \ = std::max(max_level, level);\n            } else if (c == ')') {\n        \
    \        level--;\n            }\n        }\n        result.push_back(max_level);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpez_uzjjj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n  std::vector<long> result;\n  std::stringstream ss(paren_string);\n\
    \  std::string paren_group;\n  while (std::getline(ss, paren_group, ' ')) {\n\
    \    long max_depth = 0;\n    long depth = 0;\n    for (char c : paren_group)\
    \ {\n      if (c == '(') {\n        depth++;\n        max_depth = std::max(max_depth,\
    \ depth);\n      } else if (c == ')') {\n        depth--;\n      }\n    }\n  \
    \  result.push_back(max_depth);\n  }\n  return result;\n}\nint main() {\n    auto\
    \ candidate = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmph44bvfr9.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> max_nest_levels;\n    std::stringstream\
    \ ss(paren_string);\n    std::string paren_group;\n    while (std::getline(ss,\
    \ paren_group, ' ')) {\n        long max_nest_level = 0;\n        long curr_nest_level\
    \ = 0;\n        for (auto c : paren_group) {\n            if (c == '(') {\n  \
    \              curr_nest_level++;\n                max_nest_level = std::max(max_nest_level,\
    \ curr_nest_level);\n            } else if (c == ')') {\n                curr_nest_level--;\n\
    \            }\n        }\n        max_nest_levels.push_back(max_nest_level);\n\
    \    }\n    return max_nest_levels;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5k3hg98h.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmha832am.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpmha832am.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpmha832am.cpp:\
    \ In function 'int main()':\n/tmp/tmpmha832am.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpmha832am.cpp:2:\n/tmp/tmpmha832am.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpmha832am.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpmha832am.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpmha832am.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmha832am.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpmha832am.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (auto c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqnw8hebt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmha832am.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpmha832am.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpmha832am.cpp:\
    \ In function 'int main()':\n/tmp/tmpmha832am.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpmha832am.cpp:2:\n/tmp/tmpmha832am.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpmha832am.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpmha832am.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpmha832am.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmha832am.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpmha832am.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : item) {\n   \
    \         if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph3_4gyos.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmph3_4gyos.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : item) {\n                       ^\n/tmp/tmph3_4gyos.cpp:\
    \ In function 'int main()':\n/tmp/tmph3_4gyos.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmph3_4gyos.cpp:2:\n/tmp/tmph3_4gyos.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmph3_4gyos.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmph3_4gyos.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmph3_4gyos.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmph3_4gyos.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmph3_4gyos.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string paren_group;\n    while (std::getline(ss, paren_group, ' '))\
    \ {\n        long max_nesting = 0;\n        long curr_nesting = 0;\n        for\
    \ (char c : paren_group) {\n            if (c == '(') {\n                curr_nesting++;\n\
    \                max_nesting = std::max(max_nesting, curr_nesting);\n        \
    \    } else if (c == ')') {\n                curr_nesting--;\n            }\n\
    \        }\n        result.push_back(max_nesting);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp3jp2pwiw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        std::stack<char>\
    \ st;\n        long max_depth = 0;\n        for (char c : token) {\n         \
    \   if (c == '(') {\n                st.push(c);\n                max_depth =\
    \ std::max(max_depth, (long)st.size());\n            } else if (c == ')') {\n\
    \                st.pop();\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph2ruzfn4.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmph2ruzfn4.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmph2ruzfn4.cpp:\
    \ In function 'int main()':\n/tmp/tmph2ruzfn4.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmph2ruzfn4.cpp:2:\n/tmp/tmph2ruzfn4.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmph2ruzfn4.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmph2ruzfn4.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmph2ruzfn4.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmph2ruzfn4.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmph2ruzfn4.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_nesting = 0;\n        long current_nesting = 0;\n        for (char c : token)\
    \ {\n            if (c == '(') {\n                current_nesting++;\n       \
    \         max_nesting = std::max(max_nesting, current_nesting);\n            }\
    \ else if (c == ')') {\n                current_nesting--;\n            }\n  \
    \      }\n        result.push_back(max_nesting);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp37m28p9u.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp37m28p9u.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmp37m28p9u.cpp:\
    \ In function 'int main()':\n/tmp/tmp37m28p9u.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmp37m28p9u.cpp:2:\n/tmp/tmp37m28p9u.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmp37m28p9u.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmp37m28p9u.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmp37m28p9u.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmp37m28p9u.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmp37m28p9u.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long current_depth = 0;\n        for (auto c : token)\
    \ {\n            if (c == '(') {\n                current_depth++;\n         \
    \       max_depth = std::max(max_depth, current_depth);\n            } else if\
    \ (c == ')') {\n                current_depth--;\n            }\n        }\n \
    \       result.push_back(max_depth);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp2ron63ay.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (auto c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqnw8hebt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long current_depth = 0;\n        for (auto c : token)\
    \ {\n            if (c == '(') {\n                current_depth++;\n         \
    \       max_depth = std::max(max_depth, current_depth);\n            } else if\
    \ (c == ')') {\n                current_depth--;\n            }\n        }\n \
    \       result.push_back(max_depth);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp2ron63ay.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : item) {\n   \
    \         if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph3_4gyos.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmph3_4gyos.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : item) {\n                       ^\n/tmp/tmph3_4gyos.cpp:\
    \ In function 'int main()':\n/tmp/tmph3_4gyos.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmph3_4gyos.cpp:2:\n/tmp/tmph3_4gyos.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmph3_4gyos.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmph3_4gyos.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmph3_4gyos.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmph3_4gyos.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmph3_4gyos.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string paren_group;\n    while (std::getline(ss, paren_group, ' '))\
    \ {\n        long max_depth = 0;\n        long current_depth = 0;\n        for\
    \ (char c : paren_group) {\n            if (c == '(') {\n                current_depth++;\n\
    \                max_depth = std::max(max_depth, current_depth);\n           \
    \ } else if (c == ')') {\n                current_depth--;\n            }\n  \
    \      }\n        result.push_back(max_depth);\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8lg5mio2.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmha832am.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpmha832am.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpmha832am.cpp:\
    \ In function 'int main()':\n/tmp/tmpmha832am.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpmha832am.cpp:2:\n/tmp/tmpmha832am.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpmha832am.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpmha832am.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpmha832am.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmha832am.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpmha832am.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmha832am.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpmha832am.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpmha832am.cpp:\
    \ In function 'int main()':\n/tmp/tmpmha832am.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpmha832am.cpp:2:\n/tmp/tmpmha832am.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpmha832am.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpmha832am.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpmha832am.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmha832am.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpmha832am.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        std::stack<char>\
    \ st;\n        long max_depth = 0;\n        for (char c : token) {\n         \
    \   if (c == '(') {\n                st.push(c);\n                max_depth =\
    \ std::max(max_depth, (long)st.size());\n            } else if (c == ')') {\n\
    \                st.pop();\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph2ruzfn4.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmph2ruzfn4.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmph2ruzfn4.cpp:\
    \ In function 'int main()':\n/tmp/tmph2ruzfn4.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmph2ruzfn4.cpp:2:\n/tmp/tmph2ruzfn4.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmph2ruzfn4.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmph2ruzfn4.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmph2ruzfn4.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmph2ruzfn4.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmph2ruzfn4.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_level = 0;\n        long level = 0;\n        for (char c : item) {\n   \
    \         if (c == '(') {\n                level++;\n                max_level\
    \ = std::max(max_level, level);\n            } else if (c == ')') {\n        \
    \        level--;\n            }\n        }\n        result.push_back(max_level);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9vhbdgbn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmha832am.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpmha832am.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpmha832am.cpp:\
    \ In function 'int main()':\n/tmp/tmpmha832am.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpmha832am.cpp:2:\n/tmp/tmpmha832am.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpmha832am.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpmha832am.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpmha832am.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmha832am.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpmha832am.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmha832am.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpmha832am.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpmha832am.cpp:\
    \ In function 'int main()':\n/tmp/tmpmha832am.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpmha832am.cpp:2:\n/tmp/tmpmha832am.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpmha832am.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpmha832am.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpmha832am.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmha832am.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpmha832am.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_level = 0;\n        long level = 0;\n        for (char c : item) {\n   \
    \         if (c == '(') {\n                level++;\n                max_level\
    \ = std::max(max_level, level);\n            } else if (c == ')') {\n        \
    \        level--;\n            }\n        }\n        result.push_back(max_level);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9vhbdgbn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_level = 0;\n        long level = 0;\n        for (auto c : item) {\n   \
    \         if (c == '(') {\n                level++;\n                max_level\
    \ = std::max(max_level, level);\n            } else if (c == ')') {\n        \
    \        level--;\n            }\n        }\n        result.push_back(max_level);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp60rej9eo.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmp60rej9eo.cpp:15:19: error: 'c' does not name a type\n         for (auto\
    \ c : item) {\n                   ^\n/tmp/tmp60rej9eo.cpp:23:9: error: expected\
    \ ';' before 'result'\n         result.push_back(max_level);\n         ^\n/tmp/tmp60rej9eo.cpp:23:35:\
    \ error: could not convert 'result.std::vector<_Tp, _Alloc>::push_back<long int,\
    \ std::allocator<long int> >((*(const value_type*)(& max_level)))' from 'void'\
    \ to 'bool'\n         result.push_back(max_level);\n                         \
    \          ^\n/tmp/tmp60rej9eo.cpp:24:5: error: expected primary-expression before\
    \ '}' token\n     }\n     ^\n/tmp/tmp60rej9eo.cpp:24:5: error: expected ')' before\
    \ '}' token\n/tmp/tmp60rej9eo.cpp:24:5: error: expected primary-expression before\
    \ '}' token\n/tmp/tmp60rej9eo.cpp:24:5: error: expected ';' before '}' token\n\
    /tmp/tmp60rej9eo.cpp: In function 'int main()':\n/tmp/tmp60rej9eo.cpp:28:10: error:\
    \ 'candidate' does not name a type\n     auto candidate = parse_nested_parens;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp60rej9eo.cpp:2:\n/tmp/tmp60rej9eo.cpp:29:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \                                                     ^\n/tmp/tmp60rej9eo.cpp:29:76:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                                                  ^\n/tmp/tmp60rej9eo.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string paren_group;\n    while (std::getline(ss, paren_group, ' '))\
    \ {\n        long max_depth = 0;\n        long depth = 0;\n        for (auto c\
    \ : paren_group) {\n            if (c == '(') {\n                depth++;\n  \
    \              max_depth = std::max(max_depth, depth);\n            } else if\
    \ (c == ')') {\n                depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpxbig6mer.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string paren_group;\n    while (std::getline(ss, paren_group, ' '))\
    \ {\n        long max_level = 0;\n        long level = 0;\n        for (auto c\
    \ : paren_group) {\n            if (c == '(') {\n                level++;\n  \
    \              max_level = std::max(max_level, level);\n            } else if\
    \ (c == ')') {\n                level--;\n            }\n        }\n        result.push_back(max_level);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpjmhlw3pk.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string group;\n    while (std::getline(ss, group, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : group) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp4j9cf20k.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        std::stack<char>\
    \ stk;\n        long max_depth = 0;\n        for (auto c : item) {\n         \
    \   if (c == '(') {\n                stk.push(c);\n                max_depth =\
    \ std::max(max_depth, (long)stk.size());\n            } else if (c == ')') {\n\
    \                stk.pop();\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmppy6373ai.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string group;\n    while (std::getline(ss, group, ' ')) {\n        long\
    \ max_level = 0;\n        long level = 0;\n        for (char c : group) {\n  \
    \          if (c == '(') {\n                level++;\n                max_level\
    \ = std::max(max_level, level);\n            } else if (c == ')') {\n        \
    \        level--;\n            }\n        }\n        result.push_back(max_level);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmprdf6uro6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        std::stack<char>\
    \ st;\n        long max_depth = 0;\n        long depth = 0;\n        for (char\
    \ c : item) {\n            if (c == '(') {\n                st.push(c);\n    \
    \            depth++;\n                max_depth = std::max(max_depth, depth);\n\
    \            } else if (c == ')') {\n                st.pop();\n             \
    \   depth--;\n            }\n        }\n        assert(st.empty());\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp6xka22rw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (auto c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqnw8hebt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : item) {\n   \
    \         if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmph3_4gyos.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmph3_4gyos.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : item) {\n                       ^\n/tmp/tmph3_4gyos.cpp:\
    \ In function 'int main()':\n/tmp/tmph3_4gyos.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmph3_4gyos.cpp:2:\n/tmp/tmph3_4gyos.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmph3_4gyos.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmph3_4gyos.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmph3_4gyos.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmph3_4gyos.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmph3_4gyos.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long current_depth = 0;\n        for (char c : token)\
    \ {\n            if (c == '(') {\n                current_depth++;\n         \
    \       max_depth = std::max(max_depth, current_depth);\n            } else if\
    \ (c == ')') {\n                current_depth--;\n            }\n        }\n \
    \       result.push_back(max_depth);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpyocbr9px.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpyocbr9px.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpyocbr9px.cpp:\
    \ In function 'int main()':\n/tmp/tmpyocbr9px.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpyocbr9px.cpp:2:\n/tmp/tmpyocbr9px.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpyocbr9px.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpyocbr9px.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpyocbr9px.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpyocbr9px.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpyocbr9px.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> v;\n    std::stringstream ss(paren_string);\n\
    \    std::string s;\n    while(ss >> s) {\n        long count = 0;\n        long\
    \ max = 0;\n        for(int i = 0; i < s.length(); i++) {\n            if(s[i]\
    \ == '(') {\n                count++;\n                if(count > max) {\n   \
    \                 max = count;\n                }\n            }\n           \
    \ else if(s[i] == ')') {\n                count--;\n            }\n        }\n\
    \        v.push_back(max);\n    }\n    return v;\n}\nint main() {\n    auto candidate\
    \ = parse_nested_parens;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<long>({(long)1, (long)2, (long)3,\
    \ (long)4})));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<long>({(long)4})));\n\
    }\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpdkj6pdis.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        std::stack<char>\
    \ stk;\n        long max_depth = 0;\n        for (auto c : token) {\n        \
    \    if (c == '(') {\n                stk.push(c);\n                max_depth\
    \ = std::max(max_depth, (long)stk.size());\n            } else if (c == ')') {\n\
    \                stk.pop();\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5enz3mcp.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        std::stack<char>\
    \ st;\n        long max_depth = 0;\n        long depth = 0;\n        for (char\
    \ c : item) {\n            if (c == '(') {\n                st.push(c);\n    \
    \            depth++;\n                max_depth = std::max(max_depth, depth);\n\
    \            } else if (c == ')') {\n                assert(!st.empty());\n  \
    \              st.pop();\n                depth--;\n            }\n        }\n\
    \        assert(st.empty());\n        result.push_back(max_depth);\n    }\n  \
    \  return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpet_o3q71.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> ret;\n    std::stringstream ss(paren_string);\n\
    \    std::string item;\n    while (std::getline(ss, item, ' ')) {\n        int\
    \ max_level = 0;\n        int level = 0;\n        for (char c : item) {\n    \
    \        if (c == '(') {\n                level++;\n                max_level\
    \ = std::max(max_level, level);\n            } else if (c == ')') {\n        \
    \        level--;\n            }\n        }\n        ret.push_back(max_level);\n\
    \    }\n    return ret;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp5y3p28up.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (auto c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqnw8hebt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string paren_group;\n    while (std::getline(ss, paren_group, ' '))\
    \ {\n        long max_nesting = 0;\n        long curr_nesting = 0;\n        for\
    \ (char c : paren_group) {\n            if (c == '(') {\n                curr_nesting++;\n\
    \                max_nesting = std::max(max_nesting, curr_nesting);\n        \
    \    } else if (c == ')') {\n                curr_nesting--;\n            }\n\
    \        }\n        result.push_back(max_nesting);\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1,\
    \ (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp3jp2pwiw.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long current_depth = 0;\n        for (auto c : token)\
    \ {\n            if (c == '(') {\n                current_depth++;\n         \
    \       max_depth = std::max(max_depth, current_depth);\n            } else if\
    \ (c == ')') {\n                current_depth--;\n            }\n        }\n \
    \       result.push_back(max_depth);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp2ron63ay.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmha832am.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpmha832am.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpmha832am.cpp:\
    \ In function 'int main()':\n/tmp/tmpmha832am.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpmha832am.cpp:2:\n/tmp/tmpmha832am.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpmha832am.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpmha832am.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpmha832am.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmha832am.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpmha832am.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (auto c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpqnw8hebt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821816
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long current_depth = 0;\n        for (auto c : token)\
    \ {\n            if (c == '(') {\n                current_depth++;\n         \
    \       max_depth = std::max(max_depth, current_depth);\n            } else if\
    \ (c == ')') {\n                current_depth--;\n            }\n        }\n \
    \       result.push_back(max_depth);\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = parse_nested_parens;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<long>({(long)1,\
    \ (long)2, (long)3, (long)4})));\n    assert(candidate((\"(()(())((())))\")) ==\
    \ (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp2ron63ay.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659821817
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmha832am.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpmha832am.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpmha832am.cpp:\
    \ In function 'int main()':\n/tmp/tmpmha832am.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpmha832am.cpp:2:\n/tmp/tmpmha832am.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpmha832am.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpmha832am.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpmha832am.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmha832am.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpmha832am.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string represented multiple groups for nested parentheses separated by\
    \ spaces.\n// For each of the group, output the deepest level of nesting of parentheses.\n\
    // E.g. (()()) has maximum two levels of nesting while ((())) has three.\n// >>>\
    \ parse_nested_parens((\"(()()) ((())) () ((())()())\"))\n// (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3}))\nstd::vector<long> parse_nested_parens(std::string\
    \ paren_string) {\n    std::vector<long> result;\n    std::stringstream ss(paren_string);\n\
    \    std::string token;\n    while (std::getline(ss, token, ' ')) {\n        long\
    \ max_depth = 0;\n        long depth = 0;\n        for (char c : token) {\n  \
    \          if (c == '(') {\n                depth++;\n                max_depth\
    \ = std::max(max_depth, depth);\n            } else if (c == ')') {\n        \
    \        depth--;\n            }\n        }\n        result.push_back(max_depth);\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = parse_nested_parens;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n    assert(candidate((\"() (()) ((())) (((())))\"\
    )) == (std::vector<long>({(long)1, (long)2, (long)3, (long)4})));\n    assert(candidate((\"\
    (()(())((())))\")) == (std::vector<long>({(long)4})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpmha832am.cpp: In function 'std::vector<long int> parse_nested_parens(std::string)':\n\
    /tmp/tmpmha832am.cpp:15:23: error: range-based 'for' loops are not allowed in\
    \ C++98 mode\n         for (char c : token) {\n                       ^\n/tmp/tmpmha832am.cpp:\
    \ In function 'int main()':\n/tmp/tmpmha832am.cpp:28:10: error: 'candidate' does\
    \ not name a type\n     auto candidate = parse_nested_parens;\n          ^\nIn\
    \ file included from /usr/include/c++/4.8.2/cassert:43:0,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n             \
    \    from /tmp/tmpmha832am.cpp:2:\n/tmp/tmpmha832am.cpp:29:53: error: 'candidate'\
    \ was not declared in this scope\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<long>({(long)2, (long)3, (long)1, (long)3})));\n          \
    \                                           ^\n/tmp/tmpmha832am.cpp:29:76: warning:\
    \ extended initializer lists only available with -std=c++11 or -std=gnu++11 [enabled\
    \ by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                 ^\n/tmp/tmpmha832am.cpp:29:113: warning: extended\
    \ initializer lists only available with -std=c++11 or -std=gnu++11 [enabled by\
    \ default]\n     assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<long>({(long)2,\
    \ (long)3, (long)1, (long)3})));\n                                           \
    \                                                                      ^\n/tmp/tmpmha832am.cpp:29:113:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n/tmp/tmpmha832am.cpp:29:113: error: no matching function\
    \ for call to 'std::vector<long int>::vector(<brace-enclosed initializer list>)'\n\
    /tmp/tmpmha832am.cpp:29:113: note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/std"
  stdout: ''
