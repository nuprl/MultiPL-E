name: HumanEval_129_minPath
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows\
  \ and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains\
  \ a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once\
  \ on the cells of the grid.\n// You have to find the minimum path of length k in\
  \ the grid. You can start\n// from any cell, and in each step you can move to any\
  \ of the neighbor cells,\n// in other words, you can go to cells which share an\
  \ edge with you current\n// cell.\n// Please note that a path of length k means\
  \ visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off\
  \ the grid.\n// A path A (of length k) is considered less than a path B (of length\
  \ k) if\n// after making the ordered lists of the values on the cells that A and\
  \ B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically\
  \ less\n// than lst_B, in other words, there exist an integer index i (1 <= i <=\
  \ k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j]\
  \ = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered\
  \ list of the values on the cells that the minimum path go through.\n// Examples:\
  \    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}),\
  \ (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n//\
  \ (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5,\
  \ (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}),\
  \ (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n//\
  \ (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>>\
  \ grid, long k) {\n"
tests: "}\nint main() {\n    auto candidate = minPath;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}),\
  \ (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3)) ==\
  \ (std::vector<long>({(long)1, (long)2, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5,\
  \ (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}),\
  \ (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1)) ==\
  \ (std::vector<long>({(long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6,\
  \ (long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)9, (long)10, (long)11,\
  \ (long)12}), (std::vector<long>)std::vector<long>({(long)13, (long)14, (long)15,\
  \ (long)16})})), (4)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2})));\n\
  \    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6,\
  \ (long)4, (long)13, (long)10}), (std::vector<long>)std::vector<long>({(long)5,\
  \ (long)7, (long)12, (long)1}), (std::vector<long>)std::vector<long>({(long)3, (long)16,\
  \ (long)11, (long)15}), (std::vector<long>)std::vector<long>({(long)8, (long)14,\
  \ (long)9, (long)2})})), (7)) == (std::vector<long>({(long)1, (long)10, (long)1,\
  \ (long)10, (long)1, (long)10, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)8,\
  \ (long)14, (long)9, (long)2}), (std::vector<long>)std::vector<long>({(long)6, (long)4,\
  \ (long)13, (long)15}), (std::vector<long>)std::vector<long>({(long)5, (long)7,\
  \ (long)1, (long)12}), (std::vector<long>)std::vector<long>({(long)3, (long)10,\
  \ (long)11, (long)16})})), (5)) == (std::vector<long>({(long)1, (long)7, (long)1,\
  \ (long)7, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)11,\
  \ (long)8, (long)7, (long)2}), (std::vector<long>)std::vector<long>({(long)5, (long)16,\
  \ (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15,\
  \ (long)6}), (std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10,\
  \ (long)1})})), (9)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6,\
  \ (long)1, (long)6, (long)1, (long)6, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)12,\
  \ (long)13, (long)10, (long)1}), (std::vector<long>)std::vector<long>({(long)9,\
  \ (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)5, (long)16,\
  \ (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)11, (long)8,\
  \ (long)7, (long)2})})), (12)) == (std::vector<long>({(long)1, (long)6, (long)1,\
  \ (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6})));\n\
  \    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2,\
  \ (long)7, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)1, (long)5}),\
  \ (std::vector<long>)std::vector<long>({(long)6, (long)8, (long)9})})), (8)) ==\
  \ (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1,\
  \ (long)3})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6,\
  \ (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)3, (long)8, (long)9}),\
  \ (std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4})})), (8)) ==\
  \ (std::vector<long>({(long)1, (long)5, (long)1, (long)5, (long)1, (long)5, (long)1,\
  \ (long)5})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)4})})), (10))\
  \ == (std::vector<long>({(long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1,\
  \ (long)2, (long)1, (long)2})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
  \ (long)3}), (std::vector<long>)std::vector<long>({(long)3, (long)2})})), (10))\
  \ == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1,\
  \ (long)3, (long)1, (long)3})));\n}\n"
completions: ["    // Write your code here\n    int n = grid.size();\n    int m =\
    \ grid[0].size();\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, 0)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < m; j++) {\n            for (int l = 0; l <= k; l++) {\n    \
    \            dp[i][j][l] = INT_MAX;\n            }\n        }\n    }\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n         \
    \   dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int l = 2; l <= k; l++)\
    \ {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m;\
    \ j++) {\n                if (i > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i - 1][j][l - 1]);\n                }\n                if (i < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n\
    \                }\n                if (j > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n                }\n         \
    \       if (j < m - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j + 1][l - 1]);\n                }\n                dp[i][j][l] += grid[i][j];\n\
    \            }\n        }\n    }\n    std::vector<long> ans;\n    long min_val\
    \ = INT_MAX;\n    for (int i = 0; i < n;", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    for (int\
    \ i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dp[i][j][1]\
    \ = grid[i][j];\n            path[i][j][1].push_back(grid[i][j]);\n        }\n\
    \    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++)\
    \ {\n            for (int l = 2; l <= k; l++) {\n                for (int x =\
    \ 0; x < n; x++) {\n                    for (int y = 0; y < n; y++) {\n      \
    \                  if (dp[x][y][l - 1] != -1) {\n                            if\
    \ (i == x && j == y) {\n                                continue;\n          \
    \                  }\n                            if (std::abs(i - x) + std::abs(j\
    \ - y) != 1) {\n                                continue;\n                  \
    \          }\n                            if (dp[i][j][l] == -1 || dp[i][j][l]\
    \ > dp[x][y][l - 1] + grid[i][j]) {\n                                dp[i][j][l]\
    \ = dp[x][y][l - 1] + grid[i][j];\n                                path[i][j][l]\
    \ = path[x][y][l - 1];\n                                path[i][j][l].push_back(grid[i][j]);\n\
    \                            }\n                        }\n                  \
    \  }\n                }\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    for (int", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k, 0)));\n    dp[0][0]\
    \ = grid[0][0];\n    path[0][0][0] = grid[0][0];\n    for (int i = 0; i < n; i++)\
    \ {\n        for (int j = 0; j < n; j++) {\n            if (i > 0) {\n       \
    \         if (dp[i][j] > dp[i - 1][j] + grid[i][j]) {\n                    dp[i][j]\
    \ = dp[i - 1][j] + grid[i][j];\n                    path[i][j] = path[i - 1][j];\n\
    \                    path[i][j][0] = grid[i][j];\n                } else if (dp[i][j]\
    \ == dp[i - 1][j] + grid[i][j]) {\n                    if (path[i][j] > path[i\
    \ - 1][j]) {\n                        path[i][j] = path[i - 1][j];\n         \
    \               path[i][j][0] = grid[i][j];\n                    }\n         \
    \       }\n            }\n            if (j > 0) {\n                if (dp[i][j]\
    \ > dp[i][j - 1] + grid[i][j]) {\n                    dp[i][j] = dp[i][j - 1]\
    \ + grid[i][j];\n                    path[i][j] = path[i][j - 1];\n          \
    \          path[i][j][0] = grid[i][j];\n                } else if (dp[i][j] ==\
    \ dp[i][j - 1] + grid[i][j]) {\n                    if (path[i][j] > path[i][j\
    \ - 1]) {\n                        path[i][j] = path[i][j - 1];\n            \
    \            path[i][j][0] =", "    int n = grid.size();\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ dp(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(k + 1, INT_MAX))));\n    for (int i = 0; i < n; i++)\
    \ {\n        for (int j = 0; j < n; j++) {\n            dp[i][j][1][grid[i][j]]\
    \ = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n; i++) {\n       \
    \ for (int j = 0; j < n; j++) {\n            for (int l = 1; l <= k; l++) {\n\
    \                for (int m = 1; m <= k; m++) {\n                    if (i > 0)\
    \ {\n                        if (dp[i - 1][j][l][m] != INT_MAX) {\n          \
    \                  dp[i][j][l][m] = std::min(dp[i][j][l][m], dp[i - 1][j][l][m]);\n\
    \                        }\n                    }\n                    if (j >\
    \ 0) {\n                        if (dp[i][j - 1][l][m] != INT_MAX) {\n       \
    \                     dp[i][j][l][m] = std::min(dp[i][j][l][m], dp[i][j - 1][l][m]);\n\
    \                        }\n                    }\n                    if (i <\
    \ n - 1) {\n                        if (dp[i + 1][j][l][m] != INT_MAX) {\n   \
    \                         dp[i][j][l][m] = std::min(dp[i][j][l][m], dp[i + 1][j][l][m]);\n\
    \                        }\n                    }\n                    if (j <\
    \ n - 1) {\n                        if (dp[i][j + 1][l][m] != INT_MAX) {\n   \
    \                         dp[i][j][l][m] = std::min(dp[i][j][l][m], dp[i", " \
    \   int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(m,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    std::vector<std::vector<long>>\
    \ dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    std::function<long(int, int,\
    \ int)> dfs = [&](int x, int y, int k) {\n        if (k == 0) return 0;\n    \
    \    if (dp[x][y][k] != -1) return dp[x][y][k];\n        long ans = INT_MAX;\n\
    \        for (int i = 0; i < 4; i++) {\n            int nx = x + dir[i][0];\n\
    \            int ny = y + dir[i][1];\n            if (nx < 0 || nx >= n || ny\
    \ < 0 || ny >= m) continue;\n            long tmp = dfs(nx, ny, k - 1);\n    \
    \        if (tmp < ans) {\n                ans = tmp;\n                path[x][y][k]\
    \ = path[nx][ny][k - 1];\n                path[x][y][k].push_back(grid[x][y]);\n\
    \            }\n        }\n        dp[x][y][k] = ans + grid[x][y];\n        return\
    \ dp[x][y][k];\n    };\n    long ans = INT_MAX;\n    std::vector<long> res;\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          long tmp = dfs(i, j, k);\n            if (tmp < ans) {\n          \
    \      ans = tmp;", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n \
    \   std::vector<long> ans;\n    std::function<long(int, int, int)> dfs = [&](int\
    \ x, int y, int step) {\n        if (step == 0) return 0;\n        if (dp[x][y][step]\
    \ != -1) return dp[x][y][step];\n        long res = INT_MAX;\n        for (auto\
    \ d : dir) {\n            int nx = x + d[0], ny = y + d[1];\n            if (nx\
    \ < 0 || nx >= n || ny < 0 || ny >= n) continue;\n            res = std::min(res,\
    \ dfs(nx, ny, step - 1) + grid[nx][ny]);\n        }\n        return dp[x][y][step]\
    \ = res;\n    };\n    long min_val = INT_MAX;\n    for (int i = 0; i < n; ++i)\
    \ {\n        for (int j = 0; j < n; ++j) {\n            min_val = std::min(min_val,\
    \ dfs(i, j, k));\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n      \
    \  for (int j = 0; j < n; ++j) {\n            if (dp[i][j][k] == min_val) {\n\
    \                ans.push_back(grid[i][j]);\n                k--;\n          \
    \      if (k == 0) return ans;\n                for (auto d : dir) {\n       \
    \             int nx = i + d[0], ny = j + d[1];\n                    if (nx <\
    \ 0 || nx >= n || ny < 0 || ny >= n) continue;\n                    if (dp[nx][ny",
  "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>> dp(n,\
    \ std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n   \
    \ for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n     \
    \       dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int l = 2; l <=\
    \ k; l++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0;\
    \ j < n; j++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    std::vector<long>\
    \ res(k);\n    res[k - 1] = dp[0][0][k];\n    int i = 0, j = 0;\n    for (int\
    \ l = k - 1; l >= 1; l--) {\n        if (i > 0 && dp[i - 1][j][l] == res[l] -\
    \ grid[i][j]) {\n            res[l - 1] = dp[i - 1][j][l];\n            i--;\n\
    \        } else if (", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    std::vector<std::vector<long>>\
    \ dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    for (int i = 0; i < n; i++) {\n\
    \        for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \            path[i][j][1].push_back(grid[i][j]);\n        }\n    }\n    for (int\
    \ l = 2; l <= k; l++) {\n        for (int i = 0; i < n; i++) {\n            for\
    \ (int j = 0; j < n; j++) {\n                for (int d = 0; d < 4; d++) {\n \
    \                   int x = i + dir[d][0];\n                    int y = j + dir[d][1];\n\
    \                    if (x < 0 || x >= n || y < 0 || y >= n) continue;\n     \
    \               if (dp[x][y][l - 1] == -1) continue;\n                    if (dp[i][j][l]\
    \ == -1 || dp[x][y][l - 1] < dp[i][j][l]) {\n                        dp[i][j][l]\
    \ = dp[x][y][l - 1];\n                        path[i][j][l] = path[x][y][l - 1];\n\
    \                        path[i][j][l].push_back(grid[i][j]);\n              \
    \      }\n                }\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    for (int i = 0; i < n; i++) {\n       ", "    int n = grid.size();\n\
    \    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>()));\n    for (int\
    \ i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if\
    \ (i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n             \
    \   path[i][j].push_back(grid[i][j]);\n            } else if (i == 0) {\n    \
    \            dp[i][j] = dp[i][j - 1] + grid[i][j];\n                path[i][j]\
    \ = path[i][j - 1];\n                path[i][j].push_back(grid[i][j]);\n     \
    \       } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                path[i][j] = path[i - 1][j];\n                path[i][j].push_back(grid[i][j]);\n\
    \            } else {\n                if (dp[i - 1][j] < dp[i][j - 1]) {\n  \
    \                  dp[i][j] = dp[i - 1][j] + grid[i][j];\n                   \
    \ path[i][j] = path[i - 1][j];\n                    path[i][j].push_back(grid[i][j]);\n\
    \                } else if (dp[i - 1][j] > dp[i][j - 1]) {\n                 \
    \   dp[i][j] = dp[i][j - 1] + grid[i][j];\n                    path[i][j] = path[i][j\
    \ - 1];\n                    path[i][j].push_back(grid[i][j]);\n             \
    \   } else {\n                    dp", "    int n = grid.size();\n    assert(n\
    \ >= 2);\n    assert(n == grid[0].size());\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    std::vector<std::vector<long>>\
    \ dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    for (int i = 0; i < n; ++i) {\n\
    \        for (int j = 0; j < n; ++j) {\n            dp[i][j][1] = grid[i][j];\n\
    \            path[i][j][1].push_back(grid[i][j]);\n        }\n    }\n    for (int\
    \ l = 2; l <= k; ++l) {\n        for (int i = 0; i < n; ++i) {\n            for\
    \ (int j = 0; j < n; ++j) {\n                for (int d = 0; d < 4; ++d) {\n \
    \                   int x = i + dir[d][0];\n                    int y = j + dir[d][1];\n\
    \                    if (x < 0 || x >= n || y < 0 || y >= n) continue;\n     \
    \               if (dp[x][y][l - 1] == -1) continue;\n                    if (dp[i][j][l]\
    \ == -1 || dp[x][y][l - 1] < dp[i][j][l]) {\n                        dp[i][j][l]\
    \ = dp[x][y][l - 1];\n                        path[i][j][l] = path[x][y][l - 1];\n\
    \                        path[i][j][l].push_back(grid[i][j]);\n              \
    \      }\n                }\n            }\n        }\n    }\n   ", "    int n\
    \ = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n\
    \ * n);\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, -1));\n\
    \    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>()));\n    std::vector<std::vector<std::vector<long>>> path_grid(n,\
    \ std::vector<std::vector<long>>(n, std::vector<long>()));\n    for (int i = 0;\
    \ i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            path_grid[i][j].push_back(grid[i][j]);\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < n; j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j]\
    \ = 0;\n                path[i][j] = path_grid[i][j];\n            } else if (i\
    \ == 0) {\n                dp[i][j] = dp[i][j - 1] + 1;\n                path[i][j]\
    \ = path[i][j - 1];\n                path[i][j].insert(path[i][j].end(), path_grid[i][j].begin(),\
    \ path_grid[i][j].end());\n            } else if (j == 0) {\n                dp[i][j]\
    \ = dp[i - 1][j] + 1;\n                path[i][j] = path[i - 1][j];\n        \
    \        path[i][j].insert(path[i][j].end(), path_grid[i][j].begin(), path_grid[i][j].end());\n\
    \            } else {\n                if (dp[i - 1][j] < dp[i][j - 1]) {\n  \
    \                  dp[i][j] = dp[i - 1][j] + 1;\n                    path[i][j",
  "    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(m, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(m, std::vector<long>(k, 0)));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n         \
    \   if (i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n        \
    \        path[i][j][0] = grid[i][j];\n            } else if (i == 0) {\n     \
    \           dp[i][j] = dp[i][j - 1] + grid[i][j];\n                path[i][j]\
    \ = path[i][j - 1];\n                path[i][j][0] = grid[i][j];\n           \
    \ } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                path[i][j] = path[i - 1][j];\n                path[i][j][0] =\
    \ grid[i][j];\n            } else {\n                if (dp[i - 1][j] < dp[i][j\
    \ - 1]) {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n       \
    \             path[i][j] = path[i - 1][j];\n                    path[i][j][0]\
    \ = grid[i][j];\n                } else if (dp[i - 1][j] > dp[i][j - 1]) {\n \
    \                   dp[i][j] = dp[i][j - 1] + grid[i][j];\n                  \
    \  path[i][j] = path[i][j - 1];\n                    path[i][j][0] = grid[i][j];\n\
    \                } else {\n                    dp[i][j] = dp[i - 1][j] + grid",
  "    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (i < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n\
    \                }\n                if (j < m - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    long\
    \ min = INT_MAX;\n    int min_i = -1;\n    int min_j = -1;\n    for (int i = 0;\
    \ i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (dp[i][j][k]\
    \ < min) {\n                min = dp[i][j][k];\n                min_i = i;\n \
    \               min_j = j;\n            }\n        }", "    int n = grid.size();\n\
    \    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<long>\
    \ ans;\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n\
    \    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, -1)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n           \
    \     dp[i][j] = 0;\n                path[i][j][0] = grid[i][j];\n           \
    \ } else if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + 1;\n       \
    \         path[i][j] = path[i][j - 1];\n                path[i][j][dp[i][j]] =\
    \ grid[i][j];\n            } else if (j == 0) {\n                dp[i][j] = dp[i\
    \ - 1][j] + 1;\n                path[i][j] = path[i - 1][j];\n               \
    \ path[i][j][dp[i][j]] = grid[i][j];\n            } else {\n                if\
    \ (dp[i - 1][j] < dp[i][j - 1]) {\n                    dp[i][j] = dp[i - 1][j]\
    \ + 1;\n                    path[i][j] = path[i - 1][j];\n                   \
    \ path[i][j][dp[i][j]] = grid[i][j];\n                } else if (dp[i - 1][j]\
    \ > dp[i][j - 1]) {\n                    dp[i][j] = dp[i][j - 1] + 1;\n      \
    \              path[i][j] = path[i][j - 1];\n                    path[i][j][dp[i][j]]\
    \ = grid[i][j];\n                } else", "    // Write your code here\n    int\
    \ n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ dp(n, std::vector<std::vector<std::vector<long>>>(m, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(2, INT_MAX))));\n    for (int i = 0; i < n; i++) {\n\
    \        for (int j = 0; j < m; j++) {\n            dp[i][j][1][0] = grid[i][j];\n\
    \            dp[i][j][1][1] = grid[i][j];\n        }\n    }\n    for (int i =\
    \ 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int\
    \ l = 2; l <= k; l++) {\n                if (i - 1 >= 0) {\n                 \
    \   if (dp[i - 1][j][l - 1][0] < dp[i][j][l][0]) {\n                        dp[i][j][l][0]\
    \ = dp[i - 1][j][l - 1][0];\n                    }\n                    if (dp[i\
    \ - 1][j][l - 1][1] > dp[i][j][l][1]) {\n                        dp[i][j][l][1]\
    \ = dp[i - 1][j][l - 1][1];\n                    }\n                }\n      \
    \          if (i + 1 < n) {\n                    if (dp[i + 1][j][l - 1][0] <\
    \ dp[i][j][l][0]) {\n                        dp[i][j][l][0] = dp[i + 1][j][l -\
    \ 1][0];\n                    }\n                    if (dp[i + 1][j][l - 1][1]\
    \ > dp[i][j][l][1]) {\n                        dp[i][j][l][1] = dp[i + 1][j][l\
    \ - 1][1];\n                    }\n                }\n                if (j -\
    \ 1 >= 0", "    int n = grid.size();\n    assert(n >= 2);\n    assert(n == grid[0].size());\n\
    \    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> parent(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>(2, -1))));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ path(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(2, -1))));\n    for (int i = 0; i < n; i++) {\n     \
    \   for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n   \
    \         parent[i][j][1][0] = i;\n            parent[i][j][1][1] = j;\n     \
    \   }\n    }\n    for (int l = 2; l <= k; l++) {\n        for (int i = 0; i <\
    \ n; i++) {\n            for (int j = 0; j < n; j++) {\n                for (int\
    \ x = 0; x < n; x++) {\n                    for (int y = 0; y < n; y++) {\n  \
    \                      if (dp[x][y][l - 1] != -1) {\n                        \
    \    if (x == i && y == j) {\n                                continue;\n    \
    \                        }\n                            if (x == i && abs(y -\
    \ j) == 1) {\n                                if (dp[i][j][l] == -1 || dp[x][y][l\
    \ - 1] < dp[i][j][l]) {\n                                    dp[i][j][l] = dp",
  "    int n = grid.size();\n    std::vector<long> ans;\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    long min_val = INT_MAX;\n    for (int i = 0; i <\
    \ n; i++) {\n        for (int j = 0; j < n; j++) {\n            min_val = std::min(min_val,\
    \ dp[i][j][k]);\n        }\n    }\n    for (int i = 0; i < n; i++) {\n       \
    \ for (int j = 0; j < n; j++) {\n            if (dp[i][j][k] == min_val) {\n \
    \               ans.push_back(grid", "    int n = grid.size();\n    assert(n >=\
    \ 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> prev(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>(2, -1))));\n    for\
    \ (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n         \
    \   dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int len = 2; len <=\
    \ k; ++len) {\n        for (int i = 0; i < n; ++i) {\n            for (int j =\
    \ 0; j < n; ++j) {\n                for (int di = -1; di <= 1; ++di) {\n     \
    \               for (int dj = -1; dj <= 1; ++dj) {\n                        if\
    \ (di == 0 && dj == 0) {\n                            continue;\n            \
    \            }\n                        int ni = i + di;\n                   \
    \     int nj = j + dj;\n                        if (ni < 0 || ni >= n || nj <\
    \ 0 || nj >= n) {\n                            continue;\n                   \
    \     }\n                        if (dp[ni][nj][len - 1] == -1) {\n          \
    \                  continue;\n                        }\n                    \
    \    if (dp[i][j][len] == -1 || dp[ni][nj][len - 1] < dp[i][j][len]) {\n     \
    \                       dp[i][j][len] = dp[ni][nj][len - 1];\n               \
    \             prev[i][j][len][0] = ni;\n                            prev[i][j][len][1]\
    \ = nj;\n                        }\n                    }\n                }\n\
    \            }\n        }\n    }\n   ", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    std::vector<std::vector<long>>\
    \ dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    std::function<long(int, int,\
    \ int)> dfs = [&](int x, int y, int step) {\n        if (step == 0) return 0;\n\
    \        if (dp[x][y][step] != -1) return dp[x][y][step];\n        long res =\
    \ INT_MAX;\n        for (auto d : dir) {\n            int nx = x + d[0], ny =\
    \ y + d[1];\n            if (nx < 0 || nx >= n || ny < 0 || ny >= n) continue;\n\
    \            long tmp = dfs(nx, ny, step - 1) + grid[x][y];\n            if (tmp\
    \ < res) {\n                res = tmp;\n                path[x][y][step] = path[nx][ny][step\
    \ - 1];\n                path[x][y][step].push_back(grid[x][y]);\n           \
    \ }\n        }\n        return dp[x][y][step] = res;\n    };\n    long res = INT_MAX;\n\
    \    std::vector<long> ans;\n    for (int i = 0; i < n; ++i) {\n        for (int\
    \ j = 0; j < n; ++j) {\n            long tmp = dfs(i, j, k);\n            if (tmp\
    \ < res) {\n                res = tmp;\n                ans = path[i][j][k];\n\
    \            }\n        }\n    }\n    return ans;", "    int n = grid.size();\n\
    \    int m = grid[0].size();\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ dp(n, std::vector<std::vector<std::vector<long>>>(m, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(2, -1))));\n    std::vector<std::vector<long>> path(n,\
    \ std::vector<long>(m, -1));\n    std::vector<std::vector<long>> dir = {{0, 1},\
    \ {0, -1}, {1, 0}, {-1, 0}};\n    std::vector<long> res;\n    for (int i = 0;\
    \ i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            dp[i][j][1][0]\
    \ = grid[i][j];\n            dp[i][j][1][1] = grid[i][j];\n        }\n    }\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          for (int l = 2; l <= k; l++) {\n                for (int d = 0; d <\
    \ 4; d++) {\n                    int x = i + dir[d][0];\n                    int\
    \ y = j + dir[d][1];\n                    if (x >= 0 && x < n && y >= 0 && y <\
    \ m) {\n                        if (dp[x][y][l - 1][0] != -1) {\n            \
    \                if (dp[i][j][l][0] == -1 || dp[i][j][l][0] > dp[x][y][l - 1][0]\
    \ + grid[i][j]) {\n                                dp[i][j][l][0] = dp[x][y][l\
    \ - 1][0] + grid[i][j];\n                                dp[i][j][l][1] = dp[x][y][l\
    \ - 1][1] + grid[i][j];\n                                path[i][j] = d;\n   \
    \                         } else", "    std::vector<long> result;\n    return\
    \ result;", "    int n = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n\
    \    assert(k <= n * n);\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ -1));\n    std::vector<std::vector<long>> parent(n, std::vector<long>(n, -1));\n\
    \    std::vector<std::vector<long>> path;\n    std::vector<long> ans;\n    std::vector<std::vector<int>>\
    \ dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    std::queue<std::pair<int, int>>\
    \ q;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n\
    \            dp[i][j] = grid[i][j];\n            q.push({i, j});\n        }\n\
    \    }\n    while (!q.empty()) {\n        auto p = q.front();\n        q.pop();\n\
    \        int i = p.first;\n        int j = p.second;\n        for (auto d : dir)\
    \ {\n            int x = i + d[0];\n            int y = j + d[1];\n          \
    \  if (x >= 0 && x < n && y >= 0 && y < n) {\n                if (dp[x][y] ==\
    \ -1 || dp[x][y] > dp[i][j]) {\n                    dp[x][y] = dp[i][j];\n   \
    \                 parent[x][y] = i * n + j;\n                    q.push({x, y});\n\
    \                }\n            }\n        }\n    }\n    for (int i = 0; i < n;\
    \ i++) {\n        for (int j = 0; j < n; j++) {\n            if (dp[i][j] == grid[i][j])\
    \ {\n                path.push_back({i, j});\n            }\n        }\n    }\n\
    \    std::sort(path.begin(), path.end(), [&](std::vector<int> a, std::vector<int>\
    \ b", "    int n = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n  \
    \  assert(k <= n * n);\n    std::vector<long> ans;\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> dp2(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    std::function<long(int,\
    \ int, int)> dfs = [&](int i, int j, int k) {\n        if (k == 0) return 0;\n\
    \        if (dp[i][j][k] != -1) return dp[i][j][k];\n        long ret = 1e18;\n\
    \        if (i > 0) {\n            long tmp = dfs(i - 1, j, k - 1) + grid[i][j];\n\
    \            if (tmp < ret) {\n                ret = tmp;\n                dp2[i][j][k]\
    \ = dp2[i - 1][j][k - 1];\n                dp2[i][j][k].push_back(grid[i][j]);\n\
    \            }\n        }\n        if (i < n - 1) {\n            long tmp = dfs(i\
    \ + 1, j, k - 1) + grid[i][j];\n            if (tmp < ret) {\n               \
    \ ret = tmp;\n                dp2[i][j][k] = dp2[i + 1][j][k - 1];\n         \
    \       dp2[i][j][k].push_back(grid[i][j]);\n            }\n        }\n      \
    \  if (j > 0) {\n            long tmp = dfs(i, j - 1, k - 1) + grid[i][j];\n \
    \           if (tmp < ret) {\n                ret = tmp;\n                dp2[i][j][k]\
    \ = dp2[", "    int n = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n\
    \    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>> dp(n,\
    \ std::vector<std::vector<long>>(n, std::vector<long>(k, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ dp_path(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k,\
    \ std::vector<long>())));\n    for (int i = 0; i < n; ++i) {\n        for (int\
    \ j = 0; j < n; ++j) {\n            dp[i][j][0] = grid[i][j];\n            dp_path[i][j][0].push_back(grid[i][j]);\n\
    \        }\n    }\n    for (int l = 1; l < k; ++l) {\n        for (int i = 0;\
    \ i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if\
    \ (i > 0 && dp[i - 1][j][l - 1] != -1) {\n                    if (dp[i][j][l]\
    \ == -1 || dp[i - 1][j][l - 1] < dp[i][j][l]) {\n                        dp[i][j][l]\
    \ = dp[i - 1][j][l - 1];\n                        dp_path[i][j][l] = dp_path[i\
    \ - 1][j][l - 1];\n                        dp_path[i][j][l].push_back(grid[i][j]);\n\
    \                    }\n                }\n                if (i < n - 1 && dp[i\
    \ + 1][j][l - 1] != -1) {\n                    if (dp[i][j][l] == -1 || dp[i +\
    \ 1][j][l - 1] < dp[i][j][l]) {\n                        dp[i][j][l] = dp[i",
  "    int n = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n    assert(k\
    \ <= n * n);\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n\
    \    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>()));\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j]\
    \ = grid[i][j];\n                path[i][j].push_back(grid[i][j]);\n         \
    \   } else if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + grid[i][j];\n\
    \                path[i][j] = path[i][j - 1];\n                path[i][j].push_back(grid[i][j]);\n\
    \            } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                path[i][j] = path[i - 1][j];\n                path[i][j].push_back(grid[i][j]);\n\
    \            } else {\n                if (dp[i - 1][j] < dp[i][j - 1]) {\n  \
    \                  dp[i][j] = dp[i - 1][j] + grid[i][j];\n                   \
    \ path[i][j] = path[i - 1][j];\n                    path[i][j].push_back(grid[i][j]);\n\
    \                } else if (dp[i - 1][j] > dp[i][j - 1]) {\n                 \
    \   dp[i][j] = dp[i][j - 1] + grid[i][j];\n                    path[i][j] = path[i][j\
    \ - 1];\n                    path[i][j].push_back(grid[i][j]);\n             \
    \   } else {\n                    dp", "    std::vector<long> res;\n    int n\
    \ = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ dp(n, std::vector<std::vector<std::vector<long>>>(m, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(2, 0))));\n    for (int i = 0; i < n; i++) {\n      \
    \  for (int j = 0; j < m; j++) {\n            dp[i][j][1][0] = grid[i][j];\n \
    \           dp[i][j][1][1] = grid[i][j];\n        }\n    }\n    for (int i = 2;\
    \ i <= k; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int\
    \ l = 0; l < m; l++) {\n                dp[j][l][i][0] = INT_MAX;\n          \
    \      dp[j][l][i][1] = INT_MAX;\n                if (j > 0) {\n             \
    \       if (dp[j - 1][l][i - 1][0] < dp[j][l][i][0]) {\n                     \
    \   dp[j][l][i][0] = dp[j - 1][l][i - 1][0];\n                        dp[j][l][i][1]\
    \ = dp[j - 1][l][i - 1][1];\n                    } else if (dp[j - 1][l][i - 1][0]\
    \ == dp[j][l][i][0]) {\n                        dp[j][l][i][1] = std::min(dp[j\
    \ - 1][l][i - 1][1], dp[j][l][i][1]);\n                    }\n               \
    \ }\n                if (j < n - 1) {\n                    if (dp[j + 1][l][i\
    \ - 1][0] < dp[j][l][i][0]) {\n                        dp[j][l][i][0] = dp[j +\
    \ 1][l][i - 1][0];\n", "    int n = grid.size();\n    assert(n >= 2);\n    assert(n\
    \ == grid[0].size());\n    std::vector<long> ans;\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(n * n + 1, -1)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j] = grid[i][j];\n            path[i][j][grid[i][j]] = grid[i][j];\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < n; j++) {\n            for (int l = 1; l <= n * n; l++) {\n            \
    \    if (path[i][j][l] != -1) {\n                    if (i - 1 >= 0 && path[i\
    \ - 1][j][l + 1] == -1) {\n                        path[i - 1][j][l + 1] = path[i][j][l];\n\
    \                    }\n                    if (i + 1 < n && path[i + 1][j][l\
    \ + 1] == -1) {\n                        path[i + 1][j][l + 1] = path[i][j][l];\n\
    \                    }\n                    if (j - 1 >= 0 && path[i][j - 1][l\
    \ + 1] == -1) {\n                        path[i][j - 1][l + 1] = path[i][j][l];\n\
    \                    }\n                    if (j + 1 < n && path[i][j + 1][l\
    \ + 1] == -1) {\n                        path[i][j + 1][l + 1] = path[i][j][l];\n\
    \                    }\n                }\n            }\n        }\n    }\n \
    \   for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n;", "    int n\
    \ = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(m,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    for (int\
    \ i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            dp[i][j][1]\
    \ = grid[i][j];\n            path[i][j][1].push_back(grid[i][j]);\n        }\n\
    \    }\n    for (int len = 2; len <= k; len++) {\n        for (int i = 0; i <\
    \ n; i++) {\n            for (int j = 0; j < m; j++) {\n                std::vector<long>\
    \ cur_path;\n                long cur_min = -1;\n                if (i > 0) {\n\
    \                    if (dp[i - 1][j][len - 1] != -1) {\n                    \
    \    if (cur_min == -1 || cur_min > dp[i - 1][j][len - 1]) {\n               \
    \             cur_min = dp[i - 1][j][len - 1];\n                            cur_path\
    \ = path[i - 1][j][len - 1];\n                        }\n                    }\n\
    \                }\n                if (i < n - 1) {\n                    if (dp[i\
    \ + 1][j][len - 1] != -1) {\n                        if (cur_min == -1 || cur_min\
    \ > dp[i + 1][j][len - 1]) {\n                            cur_min = dp[i + 1][j][len\
    \ - 1];\n                            cur_path = path[i + 1][j][len - 1];\n   \
    \                     }\n                    }\n                }\n          \
    \      if (j > 0) {\n                    if (dp[i][", "    // Write your code\
    \ here\n    int n = grid.size();\n    std::vector<long> res;\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<long>> path(n,\
    \ std::vector<long>(n, -1));\n    dp[0][0] = grid[0][0];\n    for (int i = 0;\
    \ i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i > 0\
    \ && dp[i][j] > dp[i - 1][j] + grid[i][j]) {\n                dp[i][j] = dp[i\
    \ - 1][j] + grid[i][j];\n                path[i][j] = 0;\n            }\n    \
    \        if (j > 0 && dp[i][j] > dp[i][j - 1] + grid[i][j]) {\n              \
    \  dp[i][j] = dp[i][j - 1] + grid[i][j];\n                path[i][j] = 1;\n  \
    \          }\n            if (i < n - 1 && dp[i][j] > dp[i + 1][j] + grid[i][j])\
    \ {\n                dp[i][j] = dp[i + 1][j] + grid[i][j];\n                path[i][j]\
    \ = 2;\n            }\n            if (j < n - 1 && dp[i][j] > dp[i][j + 1] +\
    \ grid[i][j]) {\n                dp[i][j] = dp[i][j + 1] + grid[i][j];\n     \
    \           path[i][j] = 3;\n            }\n        }\n    }\n    int i = n -\
    \ 1, j = n - 1;\n    while (k > 0) {\n        res.push_back(grid[i][j]);\n   \
    \     if (path[i][j] == 0) {\n            i--;\n        } else if (path[i][j]\
    \ == 1) {\n            j--;\n       ", "    int n = grid.size();\n    assert(n\
    \ >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<long>\
    \ ans;\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n\
    \    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, 0)));\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            dp[i][j] = grid[i][j];\n            path[i][j][0]\
    \ = grid[i][j];\n        }\n    }\n    for (int i = 1; i < k; i++) {\n       \
    \ for (int j = 0; j < n; j++) {\n            for (int l = 0; l < n; l++) {\n \
    \               if (j > 0) {\n                    if (dp[j][l] > dp[j - 1][l]\
    \ + grid[j][l]) {\n                        dp[j][l] = dp[j - 1][l] + grid[j][l];\n\
    \                        path[j][l] = path[j - 1][l];\n                      \
    \  path[j][l][i] = grid[j][l];\n                    } else if (dp[j][l] == dp[j\
    \ - 1][l] + grid[j][l]) {\n                        std::vector<long> tmp = path[j\
    \ - 1][l];\n                        tmp[i] = grid[j][l];\n                   \
    \     if (tmp < path[j][l]) {\n                            path[j][l] = tmp;\n\
    \                        }\n                    }\n                }\n       \
    \         if (j < n - 1) {\n                    if (dp[j][l] > dp[j + 1][l] +\
    \ grid[j][l]) {\n                        dp[j][l] = dp[j + 1][l] + grid[j][l];\n\
    \                        path[j][l] = path[j + 1][l];\n", "    // Your code here\n\
    \    return std::vector<long>();", "    int n = grid.size();\n    int m = grid[0].size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ path(n, std::vector<std::vector<std::vector<long>>>(m, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>())));\n    std::vector<long> ans;\n    for (int i = 0;\
    \ i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            dp[i][j][1]\
    \ = grid[i][j];\n            path[i][j][1].push_back(grid[i][j]);\n        }\n\
    \    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++)\
    \ {\n            for (int l = 2; l <= k; l++) {\n                if (i - 1 >=\
    \ 0 && dp[i - 1][j][l - 1] != -1) {\n                    if (dp[i][j][l] == -1\
    \ || dp[i - 1][j][l - 1] < dp[i][j][l]) {\n                        dp[i][j][l]\
    \ = dp[i - 1][j][l - 1];\n                        path[i][j][l] = path[i - 1][j][l\
    \ - 1];\n                        path[i][j][l].push_back(grid[i][j]);\n      \
    \              }\n                }\n                if (i + 1 < n && dp[i + 1][j][l\
    \ - 1] != -1) {\n                    if (dp[i][j][l] == -1 || dp[i + 1][j][l -\
    \ 1] < dp[i][j][l]) {\n                        dp[i][j][l] = dp[i + 1][j][l -\
    \ 1];\n                        path[i][j][l]", "    int n = grid.size();\n   \
    \ std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, 0)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n        }\n\
    \    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++)\
    \ {\n            for (int l = 2; l <= k; l++) {\n                std::vector<long>\
    \ tmp;\n                if (i > 0) {\n                    tmp.push_back(dp[i -\
    \ 1][j][l - 1]);\n                }\n                if (i < n - 1) {\n      \
    \              tmp.push_back(dp[i + 1][j][l - 1]);\n                }\n      \
    \          if (j > 0) {\n                    tmp.push_back(dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    tmp.push_back(dp[i][j\
    \ + 1][l - 1]);\n                }\n                if (tmp.size() > 0) {\n  \
    \                  std::sort(tmp.begin(), tmp.end());\n                    dp[i][j][l]\
    \ = tmp[0];\n                }\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    ans.push_back(grid[0][0]);\n    for (int i = 1; i < k; i++) {\n  \
    \      ans.push_back(dp[0][0][i + 1]);\n    }\n    return ans;", "    int n =\
    \ grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n *\
    \ n);\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ path(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>())));\n    std::vector<std::vector<long>> dirs = {{0,\
    \ 1}, {0, -1}, {1, 0}, {-1, 0}};\n    for (int i = 0; i < n; ++i) {\n        for\
    \ (int j = 0; j < n; ++j) {\n            dp[i][j][1] = grid[i][j];\n         \
    \   path[i][j][1].push_back(grid[i][j]);\n        }\n    }\n    for (int l = 2;\
    \ l <= k; ++l) {\n        for (int i = 0; i < n; ++i) {\n            for (int\
    \ j = 0; j < n; ++j) {\n                for (int d = 0; d < 4; ++d) {\n      \
    \              int x = i + dirs[d][0];\n                    int y = j + dirs[d][1];\n\
    \                    if (x < 0 || x >= n || y < 0 || y >= n) continue;\n     \
    \               if (dp[x][y][l - 1] == -1) continue;\n                    if (dp[i][j][l]\
    \ == -1 || dp[x][y][l - 1] < dp[i][j][l]) {\n                        dp[i][j][l]\
    \ = dp[x][y][l - 1];\n                        path[i][j][l] = path[x][y][l - 1];\n\
    \                        path[i][j][l].push_back(grid[i][j]);\n              \
    \      }\n                }\n           ", "    int n = grid.size();\n    assert(n\
    \ >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> prev(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>(2, -1))));\n    for\
    \ (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n         \
    \   dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int l = 2; l <= k; ++l)\
    \ {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < n;\
    \ ++j) {\n                std::vector<long> cur = {-1, -1};\n                if\
    \ (i > 0) {\n                    if (dp[i - 1][j][l - 1] != -1) {\n          \
    \              if (cur[0] == -1 || dp[i - 1][j][l - 1] < cur[0]) {\n         \
    \                   cur = {dp[i - 1][j][l - 1], 0};\n                        }\n\
    \                    }\n                }\n                if (i < n - 1) {\n\
    \                    if (dp[i + 1][j][l - 1] != -1) {\n                      \
    \  if (cur[0] == -1 || dp[i + 1][j][l - 1] < cur[0]) {\n                     \
    \       cur = {dp[i + 1][j][l - 1], 1};\n                        }\n         \
    \           }\n                }\n                if (j > 0) {\n             \
    \       if (dp[i][j - 1][l - 1] != -1) {\n                        if (cur[0] ==\
    \ -1 || dp[i][j - 1][l -", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    long\
    \ min_val = INT_MAX;\n    std::vector<long> ans;\n    for (int i = 0; i < n; i++)\
    \ {\n        for (int j = 0; j < n; j++) {\n            if (dp[i][j][k] < min_val)\
    \ {\n                min_val = dp[i][j][k];\n                ans = std::vector<long>({grid[i][j]});\n\
    \            }\n        }\n    }\n    for (int l = 2; l", "\tint n = grid.size();\n\
    \tassert(n >= 2);\n\tassert(n == grid[0].size());\n\tassert(k >= 1);\n\tassert(k\
    \ <= n * n);\n\tstd::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, 0)));\n\tfor (int i = 0; i < n; ++i) {\n\t\tfor (int\
    \ j = 0; j < n; ++j) {\n\t\t\tdp[i][j][1] = grid[i][j];\n\t\t}\n\t}\n\tfor (int\
    \ l = 2; l <= k; ++l) {\n\t\tfor (int i = 0; i < n; ++i) {\n\t\t\tfor (int j =\
    \ 0; j < n; ++j) {\n\t\t\t\tdp[i][j][l] = INT_MAX;\n\t\t\t\tif (i > 0) {\n\t\t\
    \t\t\tdp[i][j][l] = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n\t\t\t\t}\n\t\
    \t\t\tif (i < n - 1) {\n\t\t\t\t\tdp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l\
    \ - 1]);\n\t\t\t\t}\n\t\t\t\tif (j > 0) {\n\t\t\t\t\tdp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n\t\t\t\t}\n\t\t\t\tif (j < n - 1) {\n\t\t\t\t\tdp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n\t\t\t\t}\n\t\t\t\tdp[i][j][l]\
    \ += grid[i][j];\n\t\t\t}\n\t\t}\n\t}\n\tstd::vector<long> ans;\n\tlong min_val\
    \ =", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int len = 2;\
    \ len <= k; len++) {\n        for (int i = 0; i < n; i++) {\n            for (int\
    \ j = 0; j < n; j++) {\n                if (i > 0) {\n                    dp[i][j][len]\
    \ = std::min(dp[i][j][len], dp[i - 1][j][len - 1]);\n                }\n     \
    \           if (i < n - 1) {\n                    dp[i][j][len] = std::min(dp[i][j][len],\
    \ dp[i + 1][j][len - 1]);\n                }\n                if (j > 0) {\n \
    \                   dp[i][j][len] = std::min(dp[i][j][len], dp[i][j - 1][len -\
    \ 1]);\n                }\n                if (j < n - 1) {\n                \
    \    dp[i][j][len] = std::min(dp[i][j][len], dp[i][j + 1][len - 1]);\n       \
    \         }\n                dp[i][j][len] += grid[i][j];\n            }\n   \
    \     }\n    }\n    std::vector<long> ans;\n    long min_val = INT_MAX;\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   if (dp[i][j][k] < min_val) {\n                min_val = dp[i][j][k];\n   \
    \             ans = std::vector<long>({grid[i][j]});\n            }\n        }\n\
    \    }\n    for (int len = k - 1", "    int n = grid.size();\n    int m = grid[0].size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ parent(n, std::vector<std::vector<std::vector<long>>>(m, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(2, -1))));\n    for (int i = 0; i < n; i++) {\n     \
    \   for (int j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n   \
    \     }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <\
    \ m; j++) {\n            for (int l = 2; l <= k; l++) {\n                if (i\
    \ > 0) {\n                    if (dp[i - 1][j][l - 1] != -1) {\n             \
    \           if (dp[i][j][l] == -1 || dp[i][j][l] > dp[i - 1][j][l - 1]) {\n  \
    \                          dp[i][j][l] = dp[i - 1][j][l - 1];\n              \
    \              parent[i][j][l][0] = i - 1;\n                            parent[i][j][l][1]\
    \ = j;\n                        }\n                    }\n                }\n\
    \                if (i < n - 1) {\n                    if (dp[i + 1][j][l - 1]\
    \ != -1) {\n                        if (dp[i][j][l] == -1 || dp[i][j][l] > dp[i\
    \ + 1][j][l - 1]) {\n                            dp[i][j][l] = dp[i + 1][j][l\
    \ - 1];\n                            parent[i][j][l][0] = i + 1;\n           \
    \                 parent[i][j][l][1] = j;\n", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k+1, 0)));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int l = 2; l <= k; l++)\
    \ {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n;\
    \ j++) {\n                dp[i][j][l] = INT_MAX;\n                if (i > 0) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i-1][j][l-1]);\n \
    \               }\n                if (i < n-1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i+1][j][l-1]);\n                }\n             \
    \   if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j-1][l-1]);\n\
    \                }\n                if (j < n-1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j+1][l-1]);\n                }\n             \
    \   dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    std::vector<long>\
    \ res;\n    long min_val = INT_MAX;\n    for (int i = 0; i < n; i++) {\n     \
    \   for (int j = 0; j < n; j++) {\n            if (dp[i][j][k] < min_val) {\n\
    \                min_val = dp[i][j][k];\n                res = {grid[i][j]};\n\
    \            }\n        }\n    }\n   ", "    int n = grid.size();\n    int m =\
    \ grid[0].size();\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ parent(n, std::vector<std::vector<std::vector<long>>>(m, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(2, -1))));\n    std::vector<std::vector<long>> dir =\
    \ {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    for (int i = 0; i < n; i++) {\n   \
    \     for (int j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n \
    \       }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j\
    \ < m; j++) {\n            for (int l = 2; l <= k; l++) {\n                for\
    \ (int d = 0; d < 4; d++) {\n                    int x = i + dir[d][0];\n    \
    \                int y = j + dir[d][1];\n                    if (x >= 0 && x <\
    \ n && y >= 0 && y < m && dp[x][y][l - 1] != -1) {\n                        if\
    \ (dp[i][j][l] == -1 || dp[i][j][l] > dp[x][y][l - 1] + grid[i][j]) {\n      \
    \                      dp[i][j][l] = dp[x][y][l - 1] + grid[i][j];\n         \
    \                   parent[i][j][l][0] = x;\n                            parent[i][j][l][1]\
    \ = y;\n                        }\n                    }\n                }\n\
    \            }\n        }\n    }\n    int x = 0, y = 0;\n    for (int i = 0; i\
    \ < n; i++) {\n        for (", "    // Write your code here\n    // To print results\
    \ to the standard output you can use std::cout\n    // Example: std::cout << \"\
    Hello world!\";\n    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k+1, INT_MAX)));\n\
    \    for(int i = 0; i < n; i++)\n    {\n        for(int j = 0; j < n; j++)\n \
    \       {\n            dp[i][j][1] = grid[i][j];\n        }\n    }\n    for(int\
    \ i = 0; i < n; i++)\n    {\n        for(int j = 0; j < n; j++)\n        {\n \
    \           for(int l = 2; l <= k; l++)\n            {\n                if(i >\
    \ 0)\n                {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i-1][j][l-1]);\n                }\n                if(j > 0)\n          \
    \      {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j-1][l-1]);\n\
    \                }\n                if(i < n-1)\n                {\n         \
    \           dp[i][j][l] = std::min(dp[i][j][l], dp[i+1][j][l-1]);\n          \
    \      }\n                if(j < n-1)\n                {\n                   \
    \ dp[i][j][l] = std::min(dp[i][j][l], dp[i][j+1][l-1]);\n                }\n \
    \               dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n\
    \    long min = INT_MAX;\n    int min_i, min_j;\n    for(int i = 0; i < n; i++)\n\
    \    {\n        for(int j = 0; j < n; j++)\n        {\n            if(dp[i][j][",
  "    int n = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n    assert(k\
    \ <= n * n);\n    std::vector<long> ans;\n    std::vector<std::vector<long>> dp(n,\
    \ std::vector<long>(n, INT_MAX));\n    for (int i = 0; i < n; i++) {\n       \
    \ for (int j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n       \
    \         dp[i][j] = 0;\n            } else if (i == 0) {\n                dp[i][j]\
    \ = dp[i][j - 1] + 1;\n            } else if (j == 0) {\n                dp[i][j]\
    \ = dp[i - 1][j] + 1;\n            } else {\n                dp[i][j] = std::min(dp[i\
    \ - 1][j], dp[i][j - 1]) + 1;\n            }\n        }\n    }\n    int x = 0,\
    \ y = 0;\n    for (int i = 0; i < k; i++) {\n        ans.push_back(grid[x][y]);\n\
    \        if (x == n - 1 && y == n - 1) {\n            break;\n        }\n    \
    \    if (x == n - 1) {\n            y++;\n        } else if (y == n - 1) {\n \
    \           x++;\n        } else {\n            if (dp[x + 1][y] < dp[x][y + 1])\
    \ {\n                x++;\n            } else {\n                y++;\n      \
    \      }\n        }\n    }\n    return ans;", "    // Your code here\n    int\
    \ n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k, INT_MAX)));\n \
    \   for(int i = 0; i < n; i++) {\n        for(int j = 0; j < m; j++) {\n     \
    \       dp[i][j][0] = grid[i][j];\n        }\n    }\n    for(int i = 0; i < n;\
    \ i++) {\n        for(int j = 0; j < m; j++) {\n            for(int l = 1; l <\
    \ k; l++) {\n                if(i - 1 >= 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if(i + 1 < n) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if(j - 1 >= 0) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if(j + 1 < m) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    std::vector<long> ans;\n    ans.push_back(grid[0][0]);\n\
    \    int i = 0, j = 0;\n    for(int l = 1; l < k; l++) {\n        if(i - 1 >=\
    \ 0 && dp[i][j][l] == dp[i - 1][j][l - 1]) {\n            ans.push_back(grid[i\
    \ - 1][j]);\n            i--;\n        }\n        else if(i + 1 < n && dp", " \
    \   int n = grid.size();\n    // dp[i][j][l] = the minimum path of length l starting\
    \ from cell (i, j)\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; ++i) {\n  \
    \      for (int j = 0; j < n; ++j) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int l = 2; l <= k; ++l) {\n        for (int i = 0;\
    \ i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if\
    \ (i > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i - 1][j][l\
    \ - 1]);\n                }\n                if (i < n - 1) {\n              \
    \      dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n           \
    \     }\n                if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (j < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n\
    \                }\n                dp[i][j][l] += grid[i][j];\n            }\n\
    \        }\n    }\n    long min_val = INT_MAX;\n    int min_i = -1, min_j = -1;\n\
    \    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n  \
    \          if (dp[i][j][k] < min_val) {\n                min_val = dp[i][", " \
    \   int n = grid.size();\n    std::vector<std::vector<std::vector<long>>> dp(n,\
    \ std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<int>>\
    \ dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    std::function<long(int, int,\
    \ int)> dfs = [&](int x, int y, int step) {\n        if (step == 0) return 0;\n\
    \        if (dp[x][y][step] != -1) return dp[x][y][step];\n        long res =\
    \ INT_MAX;\n        for (auto d : dir) {\n            int nx = x + d[0], ny =\
    \ y + d[1];\n            if (nx < 0 || nx >= n || ny < 0 || ny >= n) continue;\n\
    \            res = std::min(res, grid[nx][ny] + dfs(nx, ny, step - 1));\n    \
    \    }\n        return dp[x][y][step] = res;\n    };\n    std::vector<long> ans;\n\
    \    long min_val = INT_MAX;\n    for (int i = 0; i < n; ++i) {\n        for (int\
    \ j = 0; j < n; ++j) {\n            if (dfs(i, j, k) < min_val) {\n          \
    \      min_val = dfs(i, j, k);\n                ans = {grid[i][j]};\n        \
    \    } else if (dfs(i, j, k) == min_val) {\n                ans.push_back(grid[i][j]);\n\
    \            }\n        }\n    }\n    return ans;", "    int n = grid.size();\n\
    \    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>()));\n    for (int\
    \ i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if\
    \ (i == 0 && j == 0) {\n                dp[i][j] = 0;\n                path[i][j].push_back(grid[i][j]);\n\
    \            } else {\n                if (i > 0) {\n                    if (dp[i\
    \ - 1][j] + 1 < dp[i][j]) {\n                        dp[i][j] = dp[i - 1][j] +\
    \ 1;\n                        path[i][j] = path[i - 1][j];\n                 \
    \       path[i][j].push_back(grid[i][j]);\n                    } else if (dp[i\
    \ - 1][j] + 1 == dp[i][j]) {\n                        std::vector<long> tmp =\
    \ path[i - 1][j];\n                        tmp.push_back(grid[i][j]);\n      \
    \                  if (tmp < path[i][j]) {\n                            path[i][j]\
    \ = tmp;\n                        }\n                    }\n                }\n\
    \                if (j > 0) {\n                    if (dp[i][j - 1] + 1 < dp[i][j])\
    \ {\n                        dp[i][j] = dp[i][j - 1] + 1;\n                  \
    \      path[i][j] = path[i][j - 1];\n                        path[i][j].push_back(grid[i][j]);\n\
    \                    } else if (dp[i][j - 1] + 1 == dp[i][j]) {\n            \
    \            std::vector<long> tmp = path[i][j - 1];\n                       \
    \ tmp.push_back(grid[i][j]);\n", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> prev(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>(2, -1))));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n; i++)\
    \ {\n        for (int j = 0; j < n; j++) {\n            for (int l = 2; l <= k;\
    \ l++) {\n                if (i > 0 && dp[i - 1][j][l - 1] != -1) {\n        \
    \            if (dp[i][j][l] == -1 || dp[i - 1][j][l - 1] < dp[i][j][l]) {\n \
    \                       dp[i][j][l] = dp[i - 1][j][l - 1];\n                 \
    \       prev[i][j][l][0] = i - 1;\n                        prev[i][j][l][1] =\
    \ j;\n                    }\n                }\n                if (i < n - 1\
    \ && dp[i + 1][j][l - 1] != -1) {\n                    if (dp[i][j][l] == -1 ||\
    \ dp[i + 1][j][l - 1] < dp[i][j][l]) {\n                        dp[i][j][l] =\
    \ dp[i + 1][j][l - 1];\n                        prev[i][j][l][0] = i + 1;\n  \
    \                      prev[i][j][l][1] = j;\n                    }\n        \
    \        }\n                if (j > 0 && dp[i][j - 1][l - 1] != -", "    int n\
    \ = grid.size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ -1));\n    std::vector<std::vector<long>> prev(n, std::vector<long>(n, -1));\n\
    \    std::vector<std::vector<long>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\
    \    std::vector<long> ans;\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j]\
    \ = grid[i][j];\n            } else {\n                long min_val = INT_MAX;\n\
    \                for (int d = 0; d < 4; d++) {\n                    int x = i\
    \ + dir[d][0];\n                    int y = j + dir[d][1];\n                 \
    \   if (x >= 0 && x < n && y >= 0 && y < n) {\n                        if (dp[x][y]\
    \ != -1 && dp[x][y] < min_val) {\n                            min_val = dp[x][y];\n\
    \                            prev[i][j] = d;\n                        }\n    \
    \                }\n                }\n                dp[i][j] = min_val + grid[i][j];\n\
    \            }\n        }\n    }\n    int x = n - 1;\n    int y = n - 1;\n   \
    \ while (k > 0) {\n        ans.push_back(grid[x][y]);\n        int d = prev[x][y];\n\
    \        x += dir[d][0];\n        y += dir[d][1];\n        k--;\n    }\n    return\
    \ ans;", "    int n = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n\
    \    assert(k <= n * n);\n    std::vector<long> ans;\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, -1));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>()));\n    std::vector<std::vector<long>>\
    \ dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    std::vector<std::vector<bool>>\
    \ vis(n, std::vector<bool>(n, false));\n    std::vector<long> curr;\n    std::queue<std::vector<long>>\
    \ q;\n    q.push({0, 0, 0});\n    vis[0][0] = true;\n    while (!q.empty()) {\n\
    \        curr = q.front();\n        q.pop();\n        int x = curr[0], y = curr[1],\
    \ cnt = curr[2];\n        if (cnt == k) {\n            ans = path[x][y];\n   \
    \         break;\n        }\n        for (int i = 0; i < 4; i++) {\n         \
    \   int nx = x + dir[i][0], ny = y + dir[i][1];\n            if (nx < 0 || nx\
    \ >= n || ny < 0 || ny >= n || vis[nx][ny]) continue;\n            vis[nx][ny]\
    \ = true;\n            path[nx][ny] = path[x][y];\n            path[nx][ny].push_back(grid[nx][ny]);\n\
    \            q.push({nx, ny, cnt + 1});\n        }\n    }\n    return ans;", " \
    \   int n = grid.size();\n    std::vector<std::vector<std::vector<long>>> dp(n,\
    \ std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ parent(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(2, -1))));\n    for (int i = 0; i < n; i++) {\n     \
    \   for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n   \
    \     }\n    }\n    for (int l = 2; l <= k; l++) {\n        for (int i = 0; i\
    \ < n; i++) {\n            for (int j = 0; j < n; j++) {\n                for\
    \ (int p = 0; p < n; p++) {\n                    for (int q = 0; q < n; q++) {\n\
    \                        if (dp[p][q][l - 1] != -1) {\n                      \
    \      if (i == p && abs(j - q) == 1) {\n                                if (dp[i][j][l]\
    \ == -1 || dp[i][j][l] > dp[p][q][l - 1] + grid[i][j]) {\n                   \
    \                 dp[i][j][l] = dp[p][q][l - 1] + grid[i][j];\n              \
    \                      parent[i][j][l][0] = p;\n                             \
    \       parent[i][j][l][1] = q;\n                                }\n         \
    \                   }\n                            if (j == q && abs(i - p) ==\
    \ 1) {\n                                if (dp[i][j][l] == -1 || dp[i][j][l] >\
    \ dp[p][q][l - 1] + grid[i][j]) {\n                                    dp[i][j][l]\
    \ = dp[p][q][l - 1] + grid[i][j];", "    int n = grid.size();\n    assert(n >=\
    \ 2);\n    assert(n == grid[0].size());\n    assert(k >= 1);\n    assert(k <=\
    \ n * n);\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<long>> path(n,\
    \ std::vector<long>(n, -1));\n    for (int i = 0; i < n; ++i) {\n        for (int\
    \ j = 0; j < n; ++j) {\n            dp[i][j][1] = grid[i][j];\n        }\n   \
    \ }\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n\
    \            for (int l = 2; l <= k; ++l) {\n                if (i > 0 && dp[i\
    \ - 1][j][l - 1] != -1) {\n                    if (dp[i][j][l] == -1 || dp[i -\
    \ 1][j][l - 1] < dp[i][j][l]) {\n                        dp[i][j][l] = dp[i -\
    \ 1][j][l - 1];\n                        path[i][j] = 0;\n                   \
    \ }\n                }\n                if (i < n - 1 && dp[i + 1][j][l - 1] !=\
    \ -1) {\n                    if (dp[i][j][l] == -1 || dp[i + 1][j][l - 1] < dp[i][j][l])\
    \ {\n                        dp[i][j][l] = dp[i + 1][j][l - 1];\n            \
    \            path[i][j] = 1;\n                    }\n                }\n     \
    \           if (j > 0 && dp[i][j - 1][l - 1] != -1) {\n                    if\
    \ (dp[i][j][l] == -1 || dp[i][j - 1][l - 1] < dp[i][j][", "    int n = grid.size();\n\
    \    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    for (int\
    \ i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            dp[i][j][1]\
    \ = grid[i][j];\n            path[i][j][1].push_back(grid[i][j]);\n        }\n\
    \    }\n    for (int l = 2; l <= k; ++l) {\n        for (int i = 0; i < n; ++i)\
    \ {\n            for (int j = 0; j < n; ++j) {\n                for (int x = 0;\
    \ x < n; ++x) {\n                    for (int y = 0; y < n; ++y) {\n         \
    \               if (abs(x - i) + abs(y - j) == 1 && dp[x][y][l - 1] != -1) {\n\
    \                            if (dp[i][j][l] == -1 || dp[i][j][l] > dp[x][y][l\
    \ - 1] * 10 + grid[i][j]) {\n                                dp[i][j][l] = dp[x][y][l\
    \ - 1] * 10 + grid[i][j];\n                                path[i][j][l] = path[x][y][l\
    \ - 1];\n                                path[i][j][l].push_back(grid[i][j]);\n\
    \                            }\n                        }\n                  \
    \  }\n                }\n            }\n        }\n    }\n    long min_val = -1;\n\
    \    std::vector<long> ans", "    int n = grid.size();\n    assert(n >= 2);\n\
    \    assert(n == grid[0].size());\n    assert(k >= 1);\n    assert(k <= n * n);\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ parent(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(2, -1))));\n    std::vector<std::vector<long>> dir =\
    \ {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    for (int i = 0; i < n; ++i) {\n   \
    \     for (int j = 0; j < n; ++j) {\n            dp[i][j][1] = grid[i][j];\n \
    \       }\n    }\n    for (int len = 2; len <= k; ++len) {\n        for (int i\
    \ = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n            \
    \    for (int d = 0; d < 4; ++d) {\n                    int x = i + dir[d][0];\n\
    \                    int y = j + dir[d][1];\n                    if (x >= 0 &&\
    \ x < n && y >= 0 && y < n && dp[x][y][len - 1] != -1) {\n                   \
    \     if (dp[i][j][len] == -1 || dp[i][j][len] > dp[x][y][len - 1] * 10 + grid[i][j])\
    \ {\n                            dp[i][j][len] = dp[x][y][len - 1] * 10 + grid[i][j];\n\
    \                            parent[i][j][len][0] = x;\n                     \
    \       parent[i][j][len][1] = y;\n                        }\n               \
    \     }\n                }\n            }", "    int n = grid.size();\n    assert(n\
    \ >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    std::vector<long> ans;\n    ans.push_back(grid[0][0]);\n\
    \    int i = 0, j = 0;\n    for (int l = 2; l <= k; l++) {\n        if (i > 0\
    \ && dp[i][j][l] == dp[i - 1][j][l - 1]) {\n            ans.push_back(grid[i -\
    \ 1][j]);\n            i--;\n        } else if (i < n - 1", "    int n = grid.size();\n\
    \    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < m - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    long\
    \ min_val = INT_MAX;\n    int min_i = -1;\n    int min_j = -1;\n    for (int i\
    \ = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (dp[i][j][k]\
    \ < min_val) {\n                min_val = dp[i][j][k];\n                min_i\
    \ = i;\n                min_j = j;", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<long> ans;\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n        }\n   \
    \ }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n\
    \            for (int l = 2; l <= k; l++) {\n                if (i > 0) {\n  \
    \                  if (dp[i - 1][j][l - 1] != -1) {\n                        if\
    \ (dp[i][j][l] == -1) {\n                            dp[i][j][l] = dp[i - 1][j][l\
    \ - 1] + grid[i][j];\n                        } else {\n                     \
    \       dp[i][j][l] = std::min(dp[i][j][l], dp[i - 1][j][l - 1] + grid[i][j]);\n\
    \                        }\n                    }\n                }\n       \
    \         if (i < n - 1) {\n                    if (dp[i + 1][j][l - 1] != -1)\
    \ {\n                        if (dp[i][j][l] == -1) {\n                      \
    \      dp[i][j][l] = dp[i + 1][j][l - 1] + grid[i][j];\n                     \
    \   } else {\n                            dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1] + grid[i][j]);\n                        }\n            \
    \        }\n                }\n                if (j > 0) {\n                \
    \    if (dp[i][j - 1][l - 1] != -1) {\n                        if (dp[i][j][l]\
    \ == -1) {\n                            dp[i][j][l] = d", "    std::vector<long>\
    \ ans;\n    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (i < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n\
    \                }\n                if (j < m - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    int x = 0, y = 0;\n    for (int i = 0; i < n; i++)\
    \ {\n        for (int j = 0; j < m; j++) {\n            if (dp[i][j][k] < dp[x][y][k])\
    \ {\n                x = i;\n                y = j;\n            }\n        }\n\
    \    }\n    ans.push_back(grid[x][y]);\n    for (int i = k - 1; i >= 1; i--) {",
  "    int n = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n    assert(k\
    \ <= n * n);\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n\
    \    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>()));\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j]\
    \ = grid[i][j];\n                path[i][j].push_back(grid[i][j]);\n         \
    \   } else if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + grid[i][j];\n\
    \                path[i][j] = path[i][j - 1];\n                path[i][j].push_back(grid[i][j]);\n\
    \            } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                path[i][j] = path[i - 1][j];\n                path[i][j].push_back(grid[i][j]);\n\
    \            } else {\n                if (dp[i - 1][j] < dp[i][j - 1]) {\n  \
    \                  dp[i][j] = dp[i - 1][j] + grid[i][j];\n                   \
    \ path[i][j] = path[i - 1][j];\n                    path[i][j].push_back(grid[i][j]);\n\
    \                } else if (dp[i - 1][j] > dp[i][j - 1]) {\n                 \
    \   dp[i][j] = dp[i][j - 1] + grid[i][j];\n                    path[i][j] = path[i][j\
    \ - 1];\n                    path[i][j].push_back(grid[i][j]);\n             \
    \   } else {\n                    dp", "    int n = grid.size();\n    int m =\
    \ grid[0].size();\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int l = 2; l <= k; l++) {\n        for (int i = 0;\
    \ i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if\
    \ (i > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i - 1][j][l\
    \ - 1]);\n                }\n                if (i < n - 1) {\n              \
    \      dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n           \
    \     }\n                if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (j < m - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n\
    \                }\n                dp[i][j][l] += grid[i][j];\n            }\n\
    \        }\n    }\n    int x = 0, y = 0;\n    for (int i = 0; i < n; i++) {\n\
    \        for (int j = 0; j < m; j++) {\n            if (dp[i][j][k] < dp[x][y][k])\
    \ {\n                x = i;\n                y = j;\n            }\n        }\n\
    \    }\n    std::vector<long> res;\n    res.push_back(grid[x][y]);\n", "    int\
    \ n = grid.size();\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int l = 2; l <= k; l++) {\n        for (int i = 0;\
    \ i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if\
    \ (i > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i - 1][j][l\
    \ - 1]);\n                }\n                if (i < n - 1) {\n              \
    \      dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n           \
    \     }\n                if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (j < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n\
    \                }\n                dp[i][j][l] += grid[i][j];\n            }\n\
    \        }\n    }\n    std::vector<long> ans;\n    ans.push_back(grid[0][0]);\n\
    \    int i = 0, j = 0;\n    for (int l = 2; l <= k; l++) {\n        if (i > 0\
    \ && dp[i][j][l] == dp[i - 1][j][l - 1] + grid[i][j]) {\n            ans.push_back(grid[i\
    \ - 1][j]);\n            i--;\n        } else if (i < n - 1 &&", "    std::vector<long>\
    \ result;\n    // your code here\n    return result;", "    int n = grid.size();\n\
    \    assert(n >= 2);\n    assert(n == grid[0].size());\n    assert(k >= 1);\n\
    \    assert(k <= n * n);\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ 0));\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++)\
    \ {\n            dp[i][j] = grid[i][j];\n        }\n    }\n    for (int i = 1;\
    \ i < k; i++) {\n        std::vector<std::vector<long>> next(n, std::vector<long>(n,\
    \ 0));\n        for (int j = 0; j < n; j++) {\n            for (int k = 0; k <\
    \ n; k++) {\n                long min = dp[j][k];\n                if (j > 0 &&\
    \ dp[j - 1][k] < min) {\n                    min = dp[j - 1][k];\n           \
    \     }\n                if (j < n - 1 && dp[j + 1][k] < min) {\n            \
    \        min = dp[j + 1][k];\n                }\n                if (k > 0 &&\
    \ dp[j][k - 1] < min) {\n                    min = dp[j][k - 1];\n           \
    \     }\n                if (k < n - 1 && dp[j][k + 1] < min) {\n            \
    \        min = dp[j][k + 1];\n                }\n                next[j][k] =\
    \ min;\n            }\n        }\n        dp = next;\n    }\n    std::vector<long>\
    \ ans;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++)\
    \ {\n            ans.push_back(dp[i][j]);\n        }\n    }\n    std::sort(ans.begin(),\
    \ ans.end());\n    return ans;", "    int n = grid.size();\n    assert(n >= 2);\n\
    \    assert(n == grid[0].size());\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> parent(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>(2, -1))));\n    for\
    \ (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n         \
    \   dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int len = 2; len <=\
    \ k; ++len) {\n        for (int i = 0; i < n; ++i) {\n            for (int j =\
    \ 0; j < n; ++j) {\n                for (int di = -1; di <= 1; ++di) {\n     \
    \               for (int dj = -1; dj <= 1; ++dj) {\n                        if\
    \ (std::abs(di) + std::abs(dj) != 1) {\n                            continue;\n\
    \                        }\n                        int ni = i + di;\n       \
    \                 int nj = j + dj;\n                        if (ni < 0 || ni >=\
    \ n || nj < 0 || nj >= n) {\n                            continue;\n         \
    \               }\n                        if (dp[ni][nj][len - 1] == -1) {\n\
    \                            continue;\n                        }\n          \
    \              if (dp[i][j][len] == -1 || dp[ni][nj][len - 1] < dp[i][j][len])\
    \ {\n                            dp[i][j][len] = dp[ni][nj][len - 1];\n      \
    \                      parent[i][j][len][0] = ni;\n                          \
    \  parent[i][j][len][1] = nj;\n                        }\n                   \
    \ }\n                }\n            }\n        }\n    }", "    int n = grid.size();\n\
    \    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    for (int i = 0; i < n; ++i) {\n       \
    \ for (int j = 0; j < n; ++j) {\n            dp[i][j][1] = grid[i][j];\n     \
    \   }\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n;\
    \ ++j) {\n            for (int l = 2; l <= k; ++l) {\n                for (int\
    \ x = -1; x <= 1; ++x) {\n                    for (int y = -1; y <= 1; ++y) {\n\
    \                        if (x == 0 && y == 0) continue;\n                   \
    \     int nx = i + x;\n                        int ny = j + y;\n             \
    \           if (nx < 0 || nx >= n || ny < 0 || ny >= n) continue;\n          \
    \              if (dp[nx][ny][l - 1] == -1) continue;\n                      \
    \  if (dp[i][j][l] == -1 || dp[i][j][l] > dp[nx][ny][l - 1]) {\n             \
    \               dp[i][j][l] = dp[nx][ny][l - 1];\n                           \
    \ path[i][j][l] = nx * n + ny;\n                        }\n                  \
    \  }\n                }\n            }\n        }\n    }\n    int min_i = -1;\n\
    \    int min_j = -1;\n    for (int i = 0; i < n; ++i) {\n        for (int j =\
    \ 0; j < n; ++j) {", "    int n = grid.size();\n    assert(n >= 2);\n    assert(k\
    \ >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<int>> path(n, std::vector<int>(n, -1));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          if (i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n \
    \           } else if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + grid[i][j];\n\
    \                path[i][j] = 1;\n            } else if (j == 0) {\n         \
    \       dp[i][j] = dp[i - 1][j] + grid[i][j];\n                path[i][j] = 0;\n\
    \            } else {\n                if (dp[i - 1][j] < dp[i][j - 1]) {\n  \
    \                  dp[i][j] = dp[i - 1][j] + grid[i][j];\n                   \
    \ path[i][j] = 0;\n                } else {\n                    dp[i][j] = dp[i][j\
    \ - 1] + grid[i][j];\n                    path[i][j] = 1;\n                }\n\
    \            }\n        }\n    }\n    std::vector<long> ans;\n    int i = n -\
    \ 1, j = n - 1;\n    while (k--) {\n        ans.push_back(grid[i][j]);\n     \
    \   if (path[i][j] == 0) {\n            i--;\n        } else {\n            j--;\n\
    \        }\n    }\n    return ans;", "    int n = grid.size();\n    int m = grid[0].size();\n\
    \    int sx = 0, sy = 0;\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < m; j++) {\n            if (grid[i][j] == 1) {\n                sx\
    \ = i;\n                sy = j;\n                break;\n            }\n     \
    \   }\n    }\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, 0)));\n    std::vector<std::vector<std::vector<long>>>\
    \ par(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, 0)));\n  \
    \  for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n    \
    \        dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int len = 2; len\
    \ <= k; len++) {\n        for (int i = 0; i < n; i++) {\n            for (int\
    \ j = 0; j < m; j++) {\n                long mn = 1e9;\n                for (int\
    \ dx = -1; dx <= 1; dx++) {\n                    for (int dy = -1; dy <= 1; dy++)\
    \ {\n                        if (dx * dx + dy * dy != 1) {\n                 \
    \           continue;\n                        }\n                        int\
    \ x = i + dx;\n                        int y = j + dy;\n                     \
    \   if (x < 0 || x >= n || y < 0 || y >= m) {\n                            continue;\n\
    \                        }\n                        if (dp[x][y][len - 1] + grid[i][j]\
    \ < mn) {\n                            mn = dp[x][y][len - 1] + grid[i][j];\n\
    \                            par[i][j][len] = (x * m + y) * (k + 1) + len - 1;\n\
    \                        }\n                    }\n                }\n       \
    \         dp[i][j", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    std::vector<std::vector<std::vector<std::vector<long>>>> parent(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>(2, -1))));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n; i++)\
    \ {\n        for (int j = 0; j < n; j++) {\n            for (int l = 2; l <= k;\
    \ l++) {\n                if (i > 0) {\n                    if (dp[i - 1][j][l\
    \ - 1] < dp[i][j][l]) {\n                        dp[i][j][l] = dp[i - 1][j][l\
    \ - 1];\n                        parent[i][j][l][0] = i - 1;\n               \
    \         parent[i][j][l][1] = j;\n                    }\n                }\n\
    \                if (i < n - 1) {\n                    if (dp[i + 1][j][l - 1]\
    \ < dp[i][j][l]) {\n                        dp[i][j][l] = dp[i + 1][j][l - 1];\n\
    \                        parent[i][j][l][0] = i + 1;\n                       \
    \ parent[i][j][l][1] = j;\n                    }\n                }\n        \
    \        if (j > 0) {\n                    if (dp[i][j - 1][l - 1] < dp[i][j][l])\
    \ {\n                        dp[i][j][l] = dp[i][j - 1][l - 1];\n            \
    \            parent[i][j][l][0] = i;\n                        parent[i][", " \
    \   int n = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n    assert(k\
    \ <= n * n);\n    std::vector<long> ans;\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> prev(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>(2, -1))));\n    std::vector<std::vector<long>>\
    \ dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    std::function<long(int, int,\
    \ int)> dfs = [&](int x, int y, int steps) {\n        if (steps == 0) {\n    \
    \        return 0;\n        }\n        if (dp[x][y][steps] != -1) {\n        \
    \    return dp[x][y][steps];\n        }\n        long mn = LONG_MAX;\n       \
    \ for (auto dir : dirs) {\n            int nx = x + dir[0];\n            int ny\
    \ = y + dir[1];\n            if (nx < 0 || nx >= n || ny < 0 || ny >= n) {\n \
    \               continue;\n            }\n            long cur = dfs(nx, ny, steps\
    \ - 1);\n            if (cur < mn) {\n                mn = cur;\n            \
    \    prev[x][y][steps][0] = nx;\n                prev[x][y][steps][1] = ny;\n\
    \            }\n        }\n        dp[x][y][steps] = mn + grid[x][y];\n      \
    \  return dp[x][y][steps];\n    };\n    long mn = LONG_MAX;\n    int x = -1, y\
    \ = -1;\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0", "    // Your\
    \ code here\n    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int len\
    \ = 2; len <= k; len++) {\n                if (i > 0) {\n                    dp[i][j][len]\
    \ = std::min(dp[i][j][len], dp[i - 1][j][len - 1]);\n                }\n     \
    \           if (j > 0) {\n                    dp[i][j][len] = std::min(dp[i][j][len],\
    \ dp[i][j - 1][len - 1]);\n                }\n                if (i < n - 1) {\n\
    \                    dp[i][j][len] = std::min(dp[i][j][len], dp[i + 1][j][len\
    \ - 1]);\n                }\n                if (j < m - 1) {\n              \
    \      dp[i][j][len] = std::min(dp[i][j][len], dp[i][j + 1][len - 1]);\n     \
    \           }\n            }\n        }\n    }\n    std::vector<long> ans;\n \
    \   int i = 0, j = 0;\n    for (int len = 1; len <= k; len++) {\n        ans.push_back(grid[i][j]);\n\
    \        if (i > 0 && dp[i][j][len] == dp[i - 1][j][len - 1]) {\n            i--;\n\
    \        } else if (j > 0 && dp[i][j][len] == dp[i][j - 1][len - 1]) {\n     \
    \      ", "    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n \
    \   std::vector<long> ans;\n    std::function<void(int, int, int)> dfs = [&](int\
    \ x, int y, int cnt) {\n        if (cnt == k) {\n            ans.push_back(grid[x][y]);\n\
    \            return;\n        }\n        for (auto &d : dir) {\n            int\
    \ nx = x + d[0];\n            int ny = y + d[1];\n            if (nx < 0 || nx\
    \ >= n || ny < 0 || ny >= m) continue;\n            if (dp[nx][ny][cnt + 1] ==\
    \ -1) {\n                dp[nx][ny][cnt + 1] = grid[nx][ny];\n               \
    \ dfs(nx, ny, cnt + 1);\n            } else if (dp[nx][ny][cnt + 1] > grid[nx][ny])\
    \ {\n                dp[nx][ny][cnt + 1] = grid[nx][ny];\n                ans.clear();\n\
    \                dfs(nx, ny, cnt + 1);\n            } else if (dp[nx][ny][cnt\
    \ + 1] == grid[nx][ny]) {\n                dfs(nx, ny, cnt + 1);\n           \
    \ }\n        }\n    };\n    dp[0][0][1] = grid[0][0];\n    dfs(0, 0, 1);\n   \
    \ return ans;", "    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> prev(n, std::vector<std::vector<std::vector<long>>>(m,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>(2, -1))));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n         \
    \   dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int len = 2; len <=\
    \ k; len++) {\n        for (int i = 0; i < n; i++) {\n            for (int j =\
    \ 0; j < m; j++) {\n                for (int di = -1; di <= 1; di++) {\n     \
    \               for (int dj = -1; dj <= 1; dj++) {\n                        if\
    \ (di == 0 && dj == 0) continue;\n                        int ni = i + di;\n \
    \                       int nj = j + dj;\n                        if (ni < 0 ||\
    \ ni >= n || nj < 0 || nj >= m) continue;\n                        if (dp[ni][nj][len\
    \ - 1] == -1) continue;\n                        if (dp[i][j][len] == -1 || dp[i][j][len]\
    \ > dp[ni][nj][len - 1] * 10 + grid[i][j]) {\n                            dp[i][j][len]\
    \ = dp[ni][nj][len - 1] * 10 + grid[i][j];\n                            prev[i][j][len][0]\
    \ = ni;\n                            prev[i][j][len][1] = nj;\n              \
    \          }\n                    }\n                }\n            }\n      \
    \  }\n    }\n    long min_val = -1;\n    int min_i = -1;\n    int min_j =", " \
    \   int n = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n    assert(k\
    \ <= n * n);\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n\
    \    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>()));\n    std::vector<std::vector<std::vector<long>>> path_grid(n,\
    \ std::vector<std::vector<long>>(n, std::vector<long>()));\n    for (int i = 0;\
    \ i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            path_grid[i][j].push_back(grid[i][j]);\n\
    \        }\n    }\n    dp[0][0] = 0;\n    path[0][0].push_back(grid[0][0]);\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          if (i > 0) {\n                if (dp[i - 1][j] + 1 < dp[i][j]) {\n\
    \                    dp[i][j] = dp[i - 1][j] + 1;\n                    path[i][j]\
    \ = path[i - 1][j];\n                    path[i][j].push_back(grid[i][j]);\n \
    \                   path_grid[i][j] = path_grid[i - 1][j];\n                 \
    \   path_grid[i][j].push_back(grid[i][j]);\n                } else if (dp[i -\
    \ 1][j] + 1 == dp[i][j]) {\n                    if (path_grid[i - 1][j] < path_grid[i][j])\
    \ {\n                        path[i][j] = path[i - 1][j];\n                  \
    \      path[i][j].push_back(grid[i][j]);\n                        path_grid[i][j]\
    \ = path_grid[i - 1][j];\n                        path_grid[i][j", "    int n\
    \ = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<long>>>\
    \ path_val(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, -1)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n            path[i][j][1] = 0;\n       \
    \     path_val[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                long min_val = -1;\n                int min_path\
    \ = -1;\n                int min_path_val = -1;\n                if (i > 0) {\n\
    \                    if (dp[i - 1][j][l - 1] != -1) {\n                      \
    \  if (min_val == -1 || dp[i - 1][j][l - 1] < min_val) {\n                   \
    \         min_val = dp[i - 1][j][l - 1];\n                            min_path\
    \ = 0;\n                            min_path_val = path_val[i - 1][j][l - 1];\n\
    \                        }\n                    }\n                }\n       \
    \         if (i < n - 1) {\n                    if (dp[i + 1][j][l - 1] != -1)\
    \ {\n                        if (min_val == -1 || dp[i + 1][j][l - 1] < min_",
  "    int n = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n    assert(k\
    \ <= n * n);\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n\
    \    std::vector<std::vector<long>> path(n, std::vector<long>(n, -1));\n    std::vector<std::vector<long>>\
    \ parent(n, std::vector<long>(n, -1));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n  \
    \              dp[i][j] = grid[i][j];\n            } else if (i == 0) {\n    \
    \            dp[i][j] = dp[i][j - 1] + grid[i][j];\n                parent[i][j]\
    \ = 1;\n            } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j]\
    \ + grid[i][j];\n                parent[i][j] = 0;\n            } else {\n   \
    \             if (dp[i - 1][j] < dp[i][j - 1]) {\n                    dp[i][j]\
    \ = dp[i - 1][j] + grid[i][j];\n                    parent[i][j] = 0;\n      \
    \          } else {\n                    dp[i][j] = dp[i][j - 1] + grid[i][j];\n\
    \                    parent[i][j] = 1;\n                }\n            }\n   \
    \     }\n    }\n    int i = n - 1, j = n - 1;\n    while (k > 0) {\n        path[i][j]\
    \ = grid[i][j];\n        if (parent[i][j] == 0) {\n            i--;\n        }\
    \ else {\n            j--;\n        }\n        k--;\n    }\n    std::vector<long>\
    \ ans;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n;", " \
    \   int n = grid.size();\n    int m = grid[0].size();\n    int sx, sy;\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n         \
    \   if (grid[i][j] == 1) {\n                sx = i;\n                sy = j;\n\
    \            }\n        }\n    }\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(m,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    std::vector<std::vector<int>>\
    \ dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    std::queue<std::vector<int>>\
    \ q;\n    q.push({sx, sy, 0});\n    dp[sx][sy][0] = grid[sx][sy];\n    path[sx][sy][0].push_back(grid[sx][sy]);\n\
    \    while (!q.empty()) {\n        auto cur = q.front();\n        q.pop();\n \
    \       int x = cur[0];\n        int y = cur[1];\n        int step = cur[2];\n\
    \        for (int i = 0; i < 4; i++) {\n            int nx = x + dir[i][0];\n\
    \            int ny = y + dir[i][1];\n            if (nx < 0 || nx >= n || ny\
    \ < 0 || ny >= m) continue;\n            if (dp[nx][ny][step + 1] == -1) {\n \
    \               dp[nx][ny][step + 1] = dp[x][y][step] + grid[nx][ny];\n      \
    \          path[nx][ny][step + 1] = path[x][y][step];\n               ", "   \
    \ int n = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n    assert(k\
    \ <= n * n);\n    std::vector<long> ans;\n    std::vector<std::vector<long>> dp(n,\
    \ std::vector<long>(n, 0));\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            dp[i][j] = grid[i][j];\n        }\n    }\n\
    \    for (int i = 1; i < n; i++) {\n        dp[0][i] += dp[0][i - 1];\n      \
    \  dp[i][0] += dp[i - 1][0];\n    }\n    for (int i = 1; i < n; i++) {\n     \
    \   for (int j = 1; j < n; j++) {\n            dp[i][j] += std::min(dp[i - 1][j],\
    \ dp[i][j - 1]);\n        }\n    }\n    int i = 0, j = 0;\n    for (int cnt =\
    \ 0; cnt < k; cnt++) {\n        ans.push_back(grid[i][j]);\n        if (i == n\
    \ - 1) {\n            j++;\n        } else if (j == n - 1) {\n            i++;\n\
    \        } else if (dp[i + 1][j] < dp[i][j + 1]) {\n            i++;\n       \
    \ } else {\n            j++;\n        }\n    }\n    return ans;", "    int n =\
    \ grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, 0)));\n   \
    \ std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(m,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    for (int\
    \ i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            dp[i][j][1]\
    \ = grid[i][j];\n            path[i][j][1].push_back(grid[i][j]);\n        }\n\
    \    }\n    for (int len = 2; len <= k; len++) {\n        for (int i = 0; i <\
    \ n; i++) {\n            for (int j = 0; j < m; j++) {\n                dp[i][j][len]\
    \ = INT_MAX;\n                for (int x = 0; x < n; x++) {\n                \
    \    for (int y = 0; y < m; y++) {\n                        if (abs(x - i) + abs(y\
    \ - j) == 1) {\n                            if (dp[x][y][len - 1] < dp[i][j][len])\
    \ {\n                                dp[i][j][len] = dp[x][y][len - 1];\n    \
    \                            path[i][j][len] = path[x][y][len - 1];\n        \
    \                        path[i][j][len].push_back(grid[i][j]);\n            \
    \                }\n                        }\n                    }\n       \
    \         }\n            }\n        }\n    }\n    long min = INT_MAX;\n    std::vector<long>\
    \ ans;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++)\
    \ {\n            if (dp[i][j][k] < min) {\n                min = d", "    int\
    \ n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < m - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    long\
    \ min_val = INT_MAX;\n    int min_i = -1;\n    int min_j = -1;\n    for (int i\
    \ = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (dp[i][j][k]\
    \ < min_val) {\n                min_val = dp[i][j][k];\n                min_i\
    \ = i;\n                min_j = j;", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    std::vector<std::vector<int>>\
    \ dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    std::function<long(int, int,\
    \ int)> dfs = [&](int x, int y, int steps) {\n        if (steps == 0) return 0;\n\
    \        if (dp[x][y][steps] != -1) return dp[x][y][steps];\n        long ans\
    \ = INT_MAX;\n        for (auto dir : dirs) {\n            int nx = x + dir[0],\
    \ ny = y + dir[1];\n            if (nx < 0 || nx >= n || ny < 0 || ny >= n) continue;\n\
    \            long cur = dfs(nx, ny, steps - 1) + grid[x][y];\n            if (cur\
    \ < ans) {\n                ans = cur;\n                path[x][y][steps] = path[nx][ny][steps\
    \ - 1];\n                path[x][y][steps].push_back(grid[x][y]);\n          \
    \  }\n        }\n        return dp[x][y][steps] = ans;\n    };\n    long ans =\
    \ INT_MAX;\n    std::vector<long> res;\n    for (int i = 0; i < n; ++i) {\n  \
    \      for (int j = 0; j < n; ++j) {\n            long cur = dfs(i, j, k);\n \
    \           if (cur < ans) {\n                ans = cur;\n                res\
    \ = path[i][j][k];\n            }\n        }\n    }\n    return res;", "    std::vector<long>\
    \ ans;\n    return ans;", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ path_grid(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>())));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            for (int l = 0; l <= k; l++) {\n    \
    \            if (l == 0) {\n                    dp[i][j][l] = 0;\n           \
    \         path[i][j][l].push_back(grid[i][j]);\n                    path_grid[i][j][l].push_back(grid[i][j]);\n\
    \                } else {\n                    std::vector<long> min_path;\n \
    \                   std::vector<long> min_path_grid;\n                    long\
    \ min_val = INT_MAX;\n                    if (i > 0) {\n                     \
    \   if (dp[i - 1][j][l - 1] < min_val) {\n                            min_val\
    \ = dp[i - 1][j][l - 1];\n                            min_path = path[i - 1][j][l\
    \ - 1];\n                            min_path_grid = path_grid[i - 1][j][l - 1];\n\
    \                        }\n                    }\n                    if (i <\
    \ n - 1) {\n                        if (dp[i + 1][j][l - 1] < min_val) {\n   \
    \                         min_val = dp[i + 1][j][l - 1];\n                   \
    \         min_path = path[i + 1][j][l", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, 0)));\n   \
    \ for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n     \
    \       dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n;\
    \ i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l = 2; l\
    \ <= k; l++) {\n                std::vector<long> vals;\n                if (i\
    \ > 0) {\n                    vals.push_back(dp[i - 1][j][l - 1]);\n         \
    \       }\n                if (i < n - 1) {\n                    vals.push_back(dp[i\
    \ + 1][j][l - 1]);\n                }\n                if (j > 0) {\n        \
    \            vals.push_back(dp[i][j - 1][l - 1]);\n                }\n       \
    \         if (j < n - 1) {\n                    vals.push_back(dp[i][j + 1][l\
    \ - 1]);\n                }\n                std::sort(vals.begin(), vals.end());\n\
    \                dp[i][j][l] = vals[0];\n            }\n        }\n    }\n   \
    \ std::vector<long> ans;\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            if (dp[i][j][k] == dp[0][0][k]) {\n      \
    \          ans.push_back(grid[i][j]);\n                break;\n            }\n\
    \        }\n    }\n    return ans;", "    int n = grid.size();\n    int m = grid[0].size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ path(n, std::vector<std::vector<std::vector<long>>>(m, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>())));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n         \
    \   path[i][j][1].push_back(grid[i][j]);\n        }\n    }\n    for (int l = 2;\
    \ l <= k; l++) {\n        for (int i = 0; i < n; i++) {\n            for (int\
    \ j = 0; j < m; j++) {\n                std::vector<long> curr;\n            \
    \    if (i > 0) {\n                    if (dp[i - 1][j][l - 1] != -1) {\n    \
    \                    curr = path[i - 1][j][l - 1];\n                        curr.push_back(grid[i][j]);\n\
    \                    }\n                }\n                if (i < n - 1) {\n\
    \                    if (dp[i + 1][j][l - 1] != -1) {\n                      \
    \  std::vector<long> tmp = path[i + 1][j][l - 1];\n                        tmp.push_back(grid[i][j]);\n\
    \                        if (curr.size() == 0 || tmp < curr) {\n             \
    \               curr = tmp;\n                        }\n                    }\n\
    \                }\n                if (j > 0) {\n                    if (dp[i][j\
    \ - 1][l - 1] != -1) {\n                        std::vector<long> tmp = path[i][j\
    \ - 1][l - 1];\n                        tmp.push_back(grid[i][j]);\n         \
    \               if (curr.", "    // Write your code here\n    std::vector<long>\
    \ res;\n    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(m, INT_MAX));\n    std::vector<std::vector<int>> parent(n,\
    \ std::vector<int>(m, -1));\n    std::vector<std::vector<int>> dir = {{0, 1},\
    \ {0, -1}, {1, 0}, {-1, 0}};\n    std::priority_queue<std::pair<long, std::pair<int,\
    \ int>>, std::vector<std::pair<long, std::pair<int, int>>>, std::greater<std::pair<long,\
    \ std::pair<int, int>>>> pq;\n    pq.push({grid[0][0], {0, 0}});\n    dp[0][0]\
    \ = grid[0][0];\n    while(!pq.empty()) {\n        auto cur = pq.top();\n    \
    \    pq.pop();\n        int i = cur.second.first;\n        int j = cur.second.second;\n\
    \        if(dp[i][j] < cur.first) continue;\n        for(int k = 0; k < 4; k++)\
    \ {\n            int x = i + dir[k][0];\n            int y = j + dir[k][1];\n\
    \            if(x < 0 || x >= n || y < 0 || y >= m) continue;\n            if(dp[x][y]\
    \ > dp[i][j] + grid[x][y]) {\n                dp[x][y] = dp[i][j] + grid[x][y];\n\
    \                parent[x][y] = k;\n                pq.push({dp[x][y], {x, y}});\n\
    \            }\n        }\n    }\n    int i = n - 1;\n    int j = m - 1;\n   \
    \ while(k--) {\n        res.push_back(grid[i][j]);\n        int x = i - dir[parent[i][j]][0];\n\
    \        int y =", "    int n = grid.size();\n    assert(n >= 2);\n    assert(k\
    \ >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>()));\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j]\
    \ = 0;\n                path[i][j].push_back(grid[i][j]);\n            } else\
    \ {\n                if (i > 0) {\n                    if (dp[i - 1][j] + 1 <\
    \ dp[i][j]) {\n                        dp[i][j] = dp[i - 1][j] + 1;\n        \
    \                path[i][j] = path[i - 1][j];\n                        path[i][j].push_back(grid[i][j]);\n\
    \                    } else if (dp[i - 1][j] + 1 == dp[i][j]) {\n            \
    \            std::vector<long> tmp = path[i - 1][j];\n                       \
    \ tmp.push_back(grid[i][j]);\n                        if (tmp < path[i][j]) {\n\
    \                            path[i][j] = tmp;\n                        }\n  \
    \                  }\n                }\n                if (j > 0) {\n      \
    \              if (dp[i][j - 1] + 1 < dp[i][j]) {\n                        dp[i][j]\
    \ = dp[i][j - 1] + 1;\n                        path[i][j] = path[i][j - 1];\n\
    \                        path[i][j].push_back(grid[i][j]);\n                 \
    \   } else if (dp[i][j - 1] + 1 == dp[i][j]) {\n                        std::vector<long>\
    \ tmp = path[i][j - 1];\n                        tmp.push_back(grid[i][j]);\n",
  "    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k+1, 0)));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n         \
    \   dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int l = 2; l <= k; l++)\
    \ {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m;\
    \ j++) {\n                long min_val = INT_MAX;\n                if (i > 0)\
    \ {\n                    min_val = std::min(min_val, dp[i-1][j][l-1]);\n     \
    \           }\n                if (i < n-1) {\n                    min_val = std::min(min_val,\
    \ dp[i+1][j][l-1]);\n                }\n                if (j > 0) {\n       \
    \             min_val = std::min(min_val, dp[i][j-1][l-1]);\n                }\n\
    \                if (j < m-1) {\n                    min_val = std::min(min_val,\
    \ dp[i][j+1][l-1]);\n                }\n                dp[i][j][l] = min_val\
    \ + grid[i][j];\n            }\n        }\n    }\n    std::vector<long> res;\n\
    \    long min_val = INT_MAX;\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < m; j++) {\n            if (dp[i][j][k] < min_val) {\n           \
    \     min_val = dp[i][j][k];\n                res = {grid[i][j]};\n          \
    \  } else if (dp[i][j][k] == min_val) {\n                res.push_back(grid[i][j]);\n\
    \            }\n        }\n", "    int n = grid.size();\n    int m = grid[0].size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ parent(n, std::vector<std::vector<std::vector<long>>>(m, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(2, -1))));\n    for (int i = 0; i < n; i++) {\n     \
    \   for (int j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n   \
    \     }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <\
    \ m; j++) {\n            for (int l = 2; l <= k; l++) {\n                if (i\
    \ > 0) {\n                    if (dp[i - 1][j][l - 1] != -1) {\n             \
    \           if (dp[i][j][l] == -1 || dp[i - 1][j][l - 1] < dp[i][j][l]) {\n  \
    \                          dp[i][j][l] = dp[i - 1][j][l - 1];\n              \
    \              parent[i][j][l][0] = i - 1;\n                            parent[i][j][l][1]\
    \ = j;\n                        }\n                    }\n                }\n\
    \                if (i < n - 1) {\n                    if (dp[i + 1][j][l - 1]\
    \ != -1) {\n                        if (dp[i][j][l] == -1 || dp[i + 1][j][l -\
    \ 1] < dp[i][j][l]) {\n                            dp[i][j][l] = dp[i + 1][j][l\
    \ - 1];\n                            parent[i][j][l][0] = i + 1;\n           \
    \                 parent[i][j][l][1] = j;\n", "    int n = grid.size();\n    int\
    \ m = grid[0].size();\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ dp(n, std::vector<std::vector<std::vector<long>>>(m, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(2, 0))));\n    for (int i = 0; i < n; i++) {\n      \
    \  for (int j = 0; j < m; j++) {\n            for (int l = 0; l < k + 1; l++)\
    \ {\n                dp[i][j][l][0] = INT_MAX;\n                dp[i][j][l][1]\
    \ = INT_MAX;\n            }\n        }\n    }\n    for (int i = 0; i < n; i++)\
    \ {\n        for (int j = 0; j < m; j++) {\n            dp[i][j][0][0] = grid[i][j];\n\
    \            dp[i][j][0][1] = grid[i][j];\n        }\n    }\n    for (int l =\
    \ 1; l < k + 1; l++) {\n        for (int i = 0; i < n; i++) {\n            for\
    \ (int j = 0; j < m; j++) {\n                if (i > 0) {\n                  \
    \  if (dp[i - 1][j][l - 1][0] < dp[i][j][l][0]) {\n                        dp[i][j][l][0]\
    \ = dp[i - 1][j][l - 1][0];\n                        dp[i][j][l][1] = dp[i - 1][j][l\
    \ - 1][1];\n                    } else if (dp[i - 1][j][l - 1][0] == dp[i][j][l][0])\
    \ {\n                        dp[i][j][l][1] = std::min(dp[i - 1][j][l - 1][1],\
    \ dp[i][j][l][1]);\n                    }\n                }\n               \
    \ if (i < n - 1) {\n                    if (dp[i + 1][", "    int n = grid.size();\n\
    \    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<long>\
    \ ans;\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n\
    \    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(n * n + 1, -1)));\n    for (int i = 0; i < n; i++) {\n   \
    \     for (int j = 0; j < n; j++) {\n            dp[i][j] = grid[i][j];\n    \
    \        path[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    if (dp[i\
    \ - 1][j] < dp[i][j]) {\n                        dp[i][j] = dp[i - 1][j];\n  \
    \                      path[i][j][l] = path[i - 1][j][l - 1];\n              \
    \      }\n                }\n                if (i < n - 1) {\n              \
    \      if (dp[i + 1][j] < dp[i][j]) {\n                        dp[i][j] = dp[i\
    \ + 1][j];\n                        path[i][j][l] = path[i + 1][j][l - 1];\n \
    \                   }\n                }\n                if (j > 0) {\n     \
    \               if (dp[i][j - 1] < dp[i][j]) {\n                        dp[i][j]\
    \ = dp[i][j - 1];\n                        path[i][j][l] = path[i][j - 1][l -\
    \ 1];\n                    }\n                }\n                if (j < n - 1)\
    \ {\n                    if (dp[i][j + 1] < dp[i][j]) {\n                    \
    \   ", "    // Write your code here\n    int n = grid.size();\n    int m = grid[0].size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int l = 2; l <= k; l++) {\n        for (int i = 0;\
    \ i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if\
    \ (i > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i - 1][j][l\
    \ - 1]);\n                }\n                if (i < n - 1) {\n              \
    \      dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n           \
    \     }\n                if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (j < m - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n\
    \                }\n                dp[i][j][l] += grid[i][j];\n            }\n\
    \        }\n    }\n    std::vector<long> ans;\n    ans.push_back(grid[0][0]);\n\
    \    int i = 0, j = 0;\n    for (int l = 2; l <= k; l++) {\n        if (i > 0\
    \ && dp[i][j][l] == dp[i - 1][j][l - 1] + grid[i][j]) {\n            ans.push_back(grid[i\
    \ - 1][j", "    int n = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n\
    \    assert(k <= n * n);\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>()));\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            dp[i][j] = grid[i][j];\n            path[i][j].push_back(grid[i][j]);\n\
    \        }\n    }\n    for (int i = 1; i < k; i++) {\n        for (int j = 0;\
    \ j < n; j++) {\n            for (int l = 0; l < n; l++) {\n                if\
    \ (j > 0 && dp[j - 1][l] < dp[j][l]) {\n                    dp[j][l] = dp[j -\
    \ 1][l];\n                    path[j][l] = path[j - 1][l];\n                 \
    \   path[j][l].push_back(grid[j][l]);\n                }\n                if (j\
    \ < n - 1 && dp[j + 1][l] < dp[j][l]) {\n                    dp[j][l] = dp[j +\
    \ 1][l];\n                    path[j][l] = path[j + 1][l];\n                 \
    \   path[j][l].push_back(grid[j][l]);\n                }\n                if (l\
    \ > 0 && dp[j][l - 1] < dp[j][l]) {\n                    dp[j][l] = dp[j][l -\
    \ 1];\n                    path[j][l] = path[j][l - 1];\n                    path[j][l].push_back(grid[j][l]);\n\
    \                }\n                if (l < n - 1 && dp[j][l + 1] < dp[j][l])\
    \ {\n                    dp[j][l", "    int n = grid.size();\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ dp(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(n, 0))));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j][i][j] = grid[i][j];\n      \
    \  }\n    }\n    for (int len = 2; len <= k; len++) {\n        for (int i = 0;\
    \ i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                for\
    \ (int x = 0; x < n; x++) {\n                    for (int y = 0; y < n; y++) {\n\
    \                        if (i == x && j == y) {\n                           \
    \ continue;\n                        }\n                        if (i == x) {\n\
    \                            if (j < y) {\n                                dp[i][j][x][y]\
    \ = dp[i][j][x][y - 1];\n                            } else {\n              \
    \                  dp[i][j][x][y] = dp[i][j][x][y + 1];\n                    \
    \        }\n                        } else if (j == y) {\n                   \
    \         if (i < x) {\n                                dp[i][j][x][y] = dp[i][j][x\
    \ - 1][y];\n                            } else {\n                           \
    \     dp[i][j][x][y] = dp[i][j][x + 1][y];\n                            }\n  \
    \                      } else {\n                            if (i < x) {\n  \
    \                              if (j < y) {\n                                \
    \    dp[i][j][x][y] = std::min(dp[i][j][x - 1][y], dp[i][j][x][y - 1]);\n    \
    \                            } else {\n                                    dp[i][j][x][y]\
    \ = std::min(dp[i][j][x - 1][y],", "    // Your code here\n    int n = grid.size();\n\
    \    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, 0)));\n   \
    \ std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, 0)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n         \
    \   path[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n;\
    \ i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l = 2; l\
    \ <= k; l++) {\n                dp[i][j][l] = INT_MAX;\n                if (i\
    \ > 0) {\n                    if (dp[i][j][l] > dp[i - 1][j][l - 1]) {\n     \
    \                   dp[i][j][l] = dp[i - 1][j][l - 1];\n                     \
    \   path[i][j][l] = grid[i][j];\n                    }\n                }\n  \
    \              if (j > 0) {\n                    if (dp[i][j][l] > dp[i][j - 1][l\
    \ - 1]) {\n                        dp[i][j][l] = dp[i][j - 1][l - 1];\n      \
    \                  path[i][j][l] = grid[i][j];\n                    }\n      \
    \          }\n                if (i < n - 1) {\n                    if (dp[i][j][l]\
    \ > dp[i + 1][j][l - 1]) {\n                        dp[i][j][l] = dp[i + 1][j][l\
    \ - 1];\n                        path[i][j][l] = grid[i][j];\n               \
    \     }\n                }\n               ", "    // Implement your solution\
    \ here\n    return std::vector<long>();", "    int n = grid.size();\n    assert(n\
    \ >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> from(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>(2, -1))));\n    for\
    \ (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n         \
    \   dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int step = 2; step <=\
    \ k; ++step) {\n        for (int i = 0; i < n; ++i) {\n            for (int j\
    \ = 0; j < n; ++j) {\n                std::vector<long> cur(2, -1);\n        \
    \        if (i > 0) {\n                    if (dp[i - 1][j][step - 1] != -1) {\n\
    \                        cur = {dp[i - 1][j][step - 1], grid[i][j]};\n       \
    \             }\n                }\n                if (i < n - 1) {\n       \
    \             if (dp[i + 1][j][step - 1] != -1) {\n                        if\
    \ (cur[0] == -1 || cur[0] > dp[i + 1][j][step - 1]) {\n                      \
    \      cur = {dp[i + 1][j][step - 1], grid[i][j]};\n                        }\n\
    \                    }\n                }\n                if (j > 0) {\n    \
    \                if (dp[i][j - 1][step - 1] != -1) {\n                       \
    \ if (cur[0] == -1 || cur[0] > dp[i][j - 1][step - 1]) {\n                   \
    \         cur = {dp[i][j - 1][step - 1], grid", "    int n = grid.size();\n  \
    \  std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ path(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>())));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n         \
    \   path[i][j][1].push_back(grid[i][j]);\n        }\n    }\n    for (int i = 0;\
    \ i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l\
    \ = 2; l <= k; l++) {\n                for (int x = -1; x <= 1; x++) {\n     \
    \               for (int y = -1; y <= 1; y++) {\n                        if (x\
    \ == 0 && y == 0) {\n                            continue;\n                 \
    \       }\n                        int nx = i + x;\n                        int\
    \ ny = j + y;\n                        if (nx < 0 || nx >= n || ny < 0 || ny >=\
    \ n) {\n                            continue;\n                        }\n   \
    \                     if (dp[nx][ny][l - 1] == -1) {\n                       \
    \     continue;\n                        }\n                        if (dp[i][j][l]\
    \ == -1 || dp[nx][ny][l - 1] < dp[i][j][l]) {\n                            dp[i][j][l]\
    \ = dp[nx][ny][l - 1];\n                            path[i][j][l] = path[nx][ny][l\
    \ - 1];\n                            path[i][j][l].push_back(grid[i][j]);\n  \
    \                      }\n                    }\n                }\n         \
    \   }\n        }\n    }\n    long min", "    int n = grid.size();\n    assert(n\
    \ >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, 0)));\n   \
    \ std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, 0)));\n    for (int i = 0; i < n; ++i) {\n        for\
    \ (int j = 0; j < n; ++j) {\n            dp[i][j][1] = grid[i][j];\n         \
    \   path[i][j][1] = grid[i][j];\n        }\n    }\n    for (int l = 2; l <= k;\
    \ ++l) {\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j\
    \ < n; ++j) {\n                dp[i][j][l] = INT_MAX;\n                if (i >\
    \ 0 && dp[i - 1][j][l - 1] < dp[i][j][l]) {\n                    dp[i][j][l] =\
    \ dp[i - 1][j][l - 1];\n                    path[i][j][l] = grid[i][j];\n    \
    \            }\n                if (i < n - 1 && dp[i + 1][j][l - 1] < dp[i][j][l])\
    \ {\n                    dp[i][j][l] = dp[i + 1][j][l - 1];\n                \
    \    path[i][j][l] = grid[i][j];\n                }\n                if (j > 0\
    \ && dp[i][j - 1][l - 1] < dp[i][j][l]) {\n                    dp[i][j][l] = dp[i][j\
    \ - 1][l - 1];\n                    path[i][j][l] = grid[i][j];\n            \
    \    }\n                if (j < n - 1", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> parent(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>(2, -1))));\n    std::vector<std::vector<long>>\
    \ dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    std::function<long(int, int,\
    \ int)> dfs = [&](int x, int y, int step) {\n        if (step == 0) {\n      \
    \      return grid[x][y];\n        }\n        if (dp[x][y][step] != -1) {\n  \
    \          return dp[x][y][step];\n        }\n        long min_val = INT_MAX;\n\
    \        for (int i = 0; i < 4; ++i) {\n            int nx = x + dir[i][0];\n\
    \            int ny = y + dir[i][1];\n            if (nx >= 0 && nx < n && ny\
    \ >= 0 && ny < n) {\n                long val = dfs(nx, ny, step - 1);\n     \
    \           if (val < min_val) {\n                    min_val = val;\n       \
    \             parent[x][y][step][0] = nx;\n                    parent[x][y][step][1]\
    \ = ny;\n                }\n            }\n        }\n        dp[x][y][step] =\
    \ min_val;\n        return min_val;\n    };\n    long min_val = INT_MAX;\n   \
    \ std::vector<long> res;\n    for (int i = 0; i < n; ++i) {\n        for (int\
    \ j = 0; j < n; ++j) {\n            long val = dfs(i, j, k - 1);\n           \
    \ if (val < min_val) {", "    int n = grid.size();\n    assert(n >= 2);\n    assert(k\
    \ >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> par(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    std::vector<std::vector<long>>\
    \ dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    std::vector<long> ans;\n    for\
    \ (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n         \
    \   dp[i][j][1] = grid[i][j];\n            par[i][j][1] = {{i, j}};\n        }\n\
    \    }\n    for (int len = 2; len <= k; ++len) {\n        for (int i = 0; i <\
    \ n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                for (int\
    \ d = 0; d < 4; ++d) {\n                    int x = i + dir[d][0];\n         \
    \           int y = j + dir[d][1];\n                    if (x < 0 || x >= n ||\
    \ y < 0 || y >= n) continue;\n                    if (dp[x][y][len - 1] == -1)\
    \ continue;\n                    if (dp[i][j][len] == -1 || dp[x][y][len - 1]\
    \ < dp[i][j][len]) {\n                        dp[i][j][len] = dp[x][y][len - 1];\n\
    \                        par[i][j][len] = par[x][y][len - 1];\n              \
    \          par[i][j][len].push_back({i, j});\n                    }\n        \
    \        }", "    int n = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n\
    \    assert(k <= n * n);\n    std::vector<long> ans;\n    for (int i = 0; i <\
    \ n; i++) {\n        for (int j = 0; j < n; j++) {\n            assert(grid[i][j]\
    \ >= 1);\n            assert(grid[i][j] <= n * n);\n        }\n    }\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>()));\n    dp[0][0]\
    \ = grid[0][0];\n    path[0][0].push_back(grid[0][0]);\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (i - 1 >=\
    \ 0) {\n                if (dp[i - 1][j] + grid[i][j] < dp[i][j]) {\n        \
    \            dp[i][j] = dp[i - 1][j] + grid[i][j];\n                    path[i][j]\
    \ = path[i - 1][j];\n                    path[i][j].push_back(grid[i][j]);\n \
    \               } else if (dp[i - 1][j] + grid[i][j] == dp[i][j]) {\n        \
    \            std::vector<long> tmp = path[i - 1][j];\n                    tmp.push_back(grid[i][j]);\n\
    \                    if (tmp < path[i][j]) {\n                        path[i][j]\
    \ = tmp;\n                    }\n                }\n            }\n          \
    \  if (j - 1 >= 0) {\n                if (dp[i][j - 1] + grid[i][j] < dp[i][j])\
    \ {\n                    dp[i][j] = dp[i][j - 1] + grid[i][j];\n             \
    \       path[i", "    // Your code here\n    int n = grid.size();\n    int m =\
    \ grid[0].size();\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, 0)));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, 0)));\n \
    \   for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n   \
    \         dp[i][j][1] = grid[i][j];\n            path[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < m; j++) {\n            for (int l = 2; l <= k; l++) {\n                if\
    \ (i > 0) {\n                    if (dp[i - 1][j][l - 1] < dp[i][j][l]) {\n  \
    \                      dp[i][j][l] = dp[i - 1][j][l - 1];\n                  \
    \      path[i][j][l] = grid[i][j];\n                    }\n                }\n\
    \                if (i < n - 1) {\n                    if (dp[i + 1][j][l - 1]\
    \ < dp[i][j][l]) {\n                        dp[i][j][l] = dp[i + 1][j][l - 1];\n\
    \                        path[i][j][l] = grid[i][j];\n                    }\n\
    \                }\n                if (j > 0) {\n                    if (dp[i][j\
    \ - 1][l - 1] < dp[i][j][l]) {\n                        dp[i][j][l] = dp[i][j\
    \ - 1][l - 1];\n                        path[i][j][l] = grid[i][j];\n        \
    \            }\n                }\n                if (j < m - 1) {\n        \
    \            if (dp[i", "    int n = grid.size();\n    int m = grid[0].size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, 0)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n        }\n\
    \    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++)\
    \ {\n            for (int l = 2; l <= k; l++) {\n                long min = INT_MAX;\n\
    \                if (i > 0) {\n                    min = std::min(min, dp[i -\
    \ 1][j][l - 1]);\n                }\n                if (i < n - 1) {\n      \
    \              min = std::min(min, dp[i + 1][j][l - 1]);\n                }\n\
    \                if (j > 0) {\n                    min = std::min(min, dp[i][j\
    \ - 1][l - 1]);\n                }\n                if (j < m - 1) {\n       \
    \             min = std::min(min, dp[i][j + 1][l - 1]);\n                }\n \
    \               dp[i][j][l] = min + grid[i][j];\n            }\n        }\n  \
    \  }\n    long min = INT_MAX;\n    int x, y;\n    for (int i = 0; i < n; i++)\
    \ {\n        for (int j = 0; j < m; j++) {\n            if (dp[i][j][k] < min)\
    \ {\n                min = dp[i][j][k];\n                x = i;\n            \
    \    y = j;\n            }\n        }\n    }\n    std::vector<long> ans;\n   \
    \ ans.push_back(grid[x][y]);\n    for (int i = k - 1; i > 0; i--) {\n        if\
    \ (x > 0 && dp[x - 1][y][i", "    int n = grid.size();\n    assert(n >= 2);\n\
    \    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> parent(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>(2, -1))));\n    for\
    \ (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n         \
    \   dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int len = 2; len <=\
    \ k; ++len) {\n        for (int i = 0; i < n; ++i) {\n            for (int j =\
    \ 0; j < n; ++j) {\n                if (i > 0 && dp[i - 1][j][len - 1] != -1)\
    \ {\n                    if (dp[i][j][len] == -1 || dp[i - 1][j][len - 1] < dp[i][j][len])\
    \ {\n                        dp[i][j][len] = dp[i - 1][j][len - 1];\n        \
    \                parent[i][j][len][0] = i - 1;\n                        parent[i][j][len][1]\
    \ = j;\n                    }\n                }\n                if (i < n -\
    \ 1 && dp[i + 1][j][len - 1] != -1) {\n                    if (dp[i][j][len] ==\
    \ -1 || dp[i + 1][j][len - 1] < dp[i][j][len]) {\n                        dp[i][j][len]\
    \ = dp[i + 1][j][len - 1];\n                        parent[i][j][len][0] = i +\
    \ 1;\n                        parent[i][j][len][1] =", "    int n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ path(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>())));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n         \
    \   path[i][j][1] = {grid[i][j]};\n        }\n    }\n    for (int l = 2; l <=\
    \ k; l++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0;\
    \ j < n; j++) {\n                for (int x = -1; x <= 1; x++) {\n           \
    \         for (int y = -1; y <= 1; y++) {\n                        if (x == 0\
    \ && y == 0) continue;\n                        int nx = i + x;\n            \
    \            int ny = j + y;\n                        if (nx < 0 || nx >= n ||\
    \ ny < 0 || ny >= n) continue;\n                        if (dp[nx][ny][l - 1]\
    \ == INT_MAX) continue;\n                        if (dp[nx][ny][l - 1] + grid[i][j]\
    \ < dp[i][j][l]) {\n                            dp[i][j][l] = dp[nx][ny][l - 1]\
    \ + grid[i][j];\n                            path[i][j][l] = path[nx][ny][l -\
    \ 1];\n                            path[i][j][l].push_back(grid[i][j]);\n    \
    \                    } else if (dp[nx][ny][l - 1] + grid[i][j] == dp[i][j][l])\
    \ {\n                            std::vector", "    int n = grid.size();\n   \
    \ int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>> dp(n,\
    \ std::vector<std::vector<long>>(m, std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<int>>\
    \ dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    std::vector<long> ans;\n    std::function<long(int,\
    \ int, int)> dfs = [&](int x, int y, int cnt) {\n        if (cnt == k) {\n   \
    \         return grid[x][y];\n        }\n        if (dp[x][y][cnt] != -1) {\n\
    \            return dp[x][y][cnt];\n        }\n        long res = INT_MAX;\n \
    \       for (int i = 0; i < 4; i++) {\n            int nx = x + dir[i][0];\n \
    \           int ny = y + dir[i][1];\n            if (nx >= 0 && nx < n && ny >=\
    \ 0 && ny < m) {\n                res = std::min(res, dfs(nx, ny, cnt + 1));\n\
    \            }\n        }\n        dp[x][y][cnt] = res;\n        return res;\n\
    \    };\n    long min_val = INT_MAX;\n    for (int i = 0; i < n; i++) {\n    \
    \    for (int j = 0; j < m; j++) {\n            min_val = std::min(min_val, dfs(i,\
    \ j, 0));\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < m; j++) {\n            if (dp[i][j][0] == min_val) {\n          \
    \      ans.push_back(grid[i][j]);\n            }\n        }\n    }\n    return\
    \ ans;", "    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (i < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n\
    \                }\n                if (j < m - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    ans.push_back(grid[0][0]);\n    int i = 0, j = 0;\n    for (int l\
    \ = 2; l <= k; l++) {\n        if (i > 0 && dp[i][j][l] == dp[i - 1][j][l - 1]\
    \ + grid[i][j]) {\n            ans.push_back(grid[i - 1][j]);\n            i--;\n",
  "    int n = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n    assert(k\
    \ <= n * n);\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, -1)));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k, -1)));\n    std::vector<std::vector<long>>\
    \ dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    for (int i = 0; i < n; ++i) {\n\
    \        for (int j = 0; j < n; ++j) {\n            dp[i][j][0] = grid[i][j];\n\
    \        }\n    }\n    for (int l = 1; l < k; ++l) {\n        for (int i = 0;\
    \ i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                for\
    \ (int d = 0; d < 4; ++d) {\n                    int x = i + dir[d][0];\n    \
    \                int y = j + dir[d][1];\n                    if (x >= 0 && x <\
    \ n && y >= 0 && y < n && dp[x][y][l - 1] != -1) {\n                        if\
    \ (dp[i][j][l] == -1 || dp[i][j][l] > dp[x][y][l - 1] || (dp[i][j][l] == dp[x][y][l\
    \ - 1] && path[i][j][l] > path[x][y][l - 1])) {\n                            dp[i][j][l]\
    \ = dp[x][y][l - 1];\n                            path[i][j][l] = grid[i][j];\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n    }\n    std::vector<long> ans;\n    for (int i = 0; i",
  "    int n = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n    assert(k\
    \ <= n * n);\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ prev(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(2, -1))));\n    for (int i = 0; i < n; ++i) {\n     \
    \   for (int j = 0; j < n; ++j) {\n            dp[i][j][1] = grid[i][j];\n   \
    \     }\n    }\n    for (int l = 2; l <= k; ++l) {\n        for (int i = 0; i\
    \ < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                dp[i][j][l]\
    \ = -1;\n                if (i > 0 && dp[i - 1][j][l - 1] != -1) {\n         \
    \           if (dp[i][j][l] == -1 || dp[i - 1][j][l - 1] < dp[i][j][l]) {\n  \
    \                      dp[i][j][l] = dp[i - 1][j][l - 1];\n                  \
    \      prev[i][j][l][0] = i - 1;\n                        prev[i][j][l][1] = j;\n\
    \                    }\n                }\n                if (i < n - 1 && dp[i\
    \ + 1][j][l - 1] != -1) {\n                    if (dp[i][j][l] == -1 || dp[i +\
    \ 1][j][l - 1] < dp[i][j][l]) {\n                        dp[i][j][l] = dp[i +\
    \ 1][j][l - 1];\n                        prev[i][j][l][0] = i +", "    // Your\
    \ code here\n    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < m - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    long min_val = INT_MAX;\n    for (int i = 0; i < n; i++) {\n     \
    \   for (int j = 0; j < m; j++) {\n            if (dp[i][j][k] < min_val) {\n\
    \                min_val = dp[i][j][k];\n                ans.clear();\n      \
    \          ans.push_back(grid[i][j]);", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, 0)));\n   \
    \ std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, 0)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n         \
    \   path[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n;\
    \ i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l = 2; l\
    \ <= k; l++) {\n                std::vector<long> curr(3, 0);\n              \
    \  if (i > 0) {\n                    curr[0] = dp[i - 1][j][l - 1];\n        \
    \        }\n                if (j > 0) {\n                    curr[1] = dp[i][j\
    \ - 1][l - 1];\n                }\n                if (i < n - 1) {\n        \
    \            curr[2] = dp[i + 1][j][l - 1];\n                }\n             \
    \   std::sort(curr.begin(), curr.end());\n                dp[i][j][l] = curr[0]\
    \ + grid[i][j];\n                if (i > 0 && dp[i - 1][j][l - 1] == curr[0])\
    \ {\n                    path[i][j][l] = 1;\n                } else if (j > 0\
    \ && dp[i][j - 1][l - 1] == curr[0]) {\n                    path[i][j][l] = 2;\n\
    \                } else {\n                    path[i][j][l] = 3;\n          \
    \      }\n            }\n        }\n    }\n    std::vector<long> ans(k, 0);\n\
    \    int i =", "    int n = grid.size();\n    int m = grid[0].size();\n    int\
    \ sx = 0, sy = 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < m; j++) {\n            if (grid[i][j] == 1) {\n                sx = i;\n\
    \                sy = j;\n                break;\n            }\n        }\n \
    \   }\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ from(n, std::vector<std::vector<std::vector<long>>>(m, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(2, -1))));\n    std::vector<std::vector<long>> dir =\
    \ {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    std::queue<std::vector<long>> q;\n\
    \    q.push({sx, sy, 0});\n    dp[sx][sy][0] = grid[sx][sy];\n    while (!q.empty())\
    \ {\n        std::vector<long> cur = q.front();\n        q.pop();\n        for\
    \ (int i = 0; i < 4; i++) {\n            int nx = cur[0] + dir[i][0];\n      \
    \      int ny = cur[1] + dir[i][1];\n            if (nx < 0 || nx >= n || ny <\
    \ 0 || ny >= m) continue;\n            if (dp[nx][ny][cur[2] + 1] == -1) {\n \
    \               dp[nx][ny][cur[2] + 1] = dp[cur[0]][cur[1]][cur[2]] + grid[nx][ny];\n\
    \                from[nx][ny][cur[2] + 1] = {cur[0], cur[1]};\n              \
    \  q.push({nx, n", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    std::vector<long> ans;\n    ans.push_back(grid[0][0]);\n\
    \    int x = 0, y = 0;\n    for (int i = 2; i <= k; i++) {\n        if (x > 0\
    \ && dp[x][y][i] == dp[x - 1][y][i - 1]) {\n            ans.push_back(grid[x -\
    \ 1][y]);\n            x--;\n        } else if (x < n - 1 && dp[x][y][i] == dp[x\
    \ + 1][y][i - 1]) {\n", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<int>> pre(n,\
    \ std::vector<int>(n, -1));\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j]\
    \ = grid[i][j];\n            } else if (i == 0) {\n                dp[i][j] =\
    \ dp[i][j - 1] + grid[i][j];\n                pre[i][j] = 1;\n            } else\
    \ if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n     \
    \           pre[i][j] = 0;\n            } else {\n                if (dp[i - 1][j]\
    \ < dp[i][j - 1]) {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                    pre[i][j] = 0;\n                } else {\n              \
    \      dp[i][j] = dp[i][j - 1] + grid[i][j];\n                    pre[i][j] =\
    \ 1;\n                }\n            }\n        }\n    }\n    std::vector<long>\
    \ res;\n    int i = n - 1, j = n - 1;\n    while (k > 0) {\n        res.push_back(grid[i][j]);\n\
    \        if (pre[i][j] == 0) {\n            i--;\n        } else {\n         \
    \   j--;\n        }\n        k--;\n    }\n    return res;", "    int n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ parent(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(2, -1))));\n    for (int i = 0; i < n; i++) {\n     \
    \   for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n   \
    \     }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <\
    \ n; j++) {\n            for (int l = 2; l <= k; l++) {\n                if (i\
    \ > 0 && dp[i - 1][j][l - 1] != -1) {\n                    if (dp[i][j][l] ==\
    \ -1 || dp[i - 1][j][l - 1] < dp[i][j][l]) {\n                        dp[i][j][l]\
    \ = dp[i - 1][j][l - 1];\n                        parent[i][j][l][0] = i - 1;\n\
    \                        parent[i][j][l][1] = j;\n                    }\n    \
    \            }\n                if (i < n - 1 && dp[i + 1][j][l - 1] != -1) {\n\
    \                    if (dp[i][j][l] == -1 || dp[i + 1][j][l - 1] < dp[i][j][l])\
    \ {\n                        dp[i][j][l] = dp[i + 1][j][l - 1];\n            \
    \            parent[i][j][l][0] = i + 1;\n                        parent[i][j][l][1]\
    \ = j;\n                    }\n                }\n                if (j > 0 &&\
    \ dp[i][j - 1][l - 1] != -", "    // Implement your solution here\n    return\
    \ std::vector<long>();", "    std::vector<long> res;\n    int n = grid.size();\n\
    \    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, 0)));\n   \
    \ std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, 0)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n         \
    \   path[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n;\
    \ i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l = 2; l\
    \ <= k; l++) {\n                dp[i][j][l] = INT_MAX;\n                if (i\
    \ > 0) {\n                    if (dp[i - 1][j][l - 1] < dp[i][j][l]) {\n     \
    \                   dp[i][j][l] = dp[i - 1][j][l - 1];\n                     \
    \   path[i][j][l] = grid[i][j];\n                    }\n                }\n  \
    \              if (i < n - 1) {\n                    if (dp[i + 1][j][l - 1] <\
    \ dp[i][j][l]) {\n                        dp[i][j][l] = dp[i + 1][j][l - 1];\n\
    \                        path[i][j][l] = grid[i][j];\n                    }\n\
    \                }\n                if (j > 0) {\n                    if (dp[i][j\
    \ - 1][l - 1] < dp[i][j][l]) {\n                        dp[i][j][l] = dp[i][j\
    \ - 1][l - 1];\n                        path[i][", "    int n = grid.size();\n\
    \    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ prev(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>())));\n    for (int i = 0; i < n; ++i) {\n        for\
    \ (int j = 0; j < n; ++j) {\n            dp[i][j][1] = grid[i][j];\n         \
    \   path[i][j][1].push_back(grid[i][j]);\n        }\n    }\n    for (int len =\
    \ 2; len <= k; ++len) {\n        for (int i = 0; i < n; ++i) {\n            for\
    \ (int j = 0; j < n; ++j) {\n                for (int x = 0; x < n; ++x) {\n \
    \                   for (int y = 0; y < n; ++y) {\n                        if\
    \ (std::abs(x - i) + std::abs(y - j) == 1 && dp[x][y][len - 1] != -1) {\n    \
    \                        if (dp[i][j][len] == -1 || dp[i][j][len] > dp[x][y][len\
    \ - 1] * 10 + grid[i][j]) {\n                                dp[i][j][len] = dp[x][y][len\
    \ - 1] * 10 + grid[i][j];\n                                path[i][j][len] = path[x",
  "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>> dp(n,\
    \ std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ parent(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(2, -1))));\n    for (int i = 0; i < n; i++) {\n     \
    \   for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n   \
    \     }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <\
    \ n; j++) {\n            for (int l = 2; l <= k; l++) {\n                std::vector<long>\
    \ v;\n                if (i - 1 >= 0) {\n                    v.push_back(dp[i\
    \ - 1][j][l - 1]);\n                    parent[i][j][l][0] = i - 1;\n        \
    \            parent[i][j][l][1] = j;\n                }\n                if (i\
    \ + 1 < n) {\n                    v.push_back(dp[i + 1][j][l - 1]);\n        \
    \            parent[i][j][l][0] = i + 1;\n                    parent[i][j][l][1]\
    \ = j;\n                }\n                if (j - 1 >= 0) {\n               \
    \     v.push_back(dp[i][j - 1][l - 1]);\n                    parent[i][j][l][0]\
    \ = i;\n                    parent[i][j][l][1] = j - 1;\n                }\n \
    \               if (j + 1 < n) {\n                    v.push_back(dp[i][j + 1][l\
    \ - 1]);\n                    parent[i][j][l][0] = i;\n                    parent[i][j][l][1]\
    \ = j + 1;\n                }\n                if (v.size() >", "    std::vector<long>\
    \ result;\n    return result;", "    int n = grid.size();\n    assert(n >= 2);\n\
    \    assert(n == grid[0].size());\n    assert(k >= 1);\n    assert(k <= n * n);\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ prev(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(2, -1))));\n    for (int i = 0; i < n; ++i) {\n     \
    \   for (int j = 0; j < n; ++j) {\n            dp[i][j][1] = grid[i][j];\n   \
    \     }\n    }\n    for (int l = 2; l <= k; ++l) {\n        for (int i = 0; i\
    \ < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                std::vector<long>\
    \ cur = {grid[i][j], -1};\n                if (i > 0) {\n                    if\
    \ (dp[i - 1][j][l - 1] != -1) {\n                        if (cur[1] == -1 || dp[i\
    \ - 1][j][l - 1] < cur[1]) {\n                            cur[0] = dp[i - 1][j][l\
    \ - 1];\n                            cur[1] = dp[i - 1][j][l - 1];\n         \
    \                   prev[i][j][l][0] = i - 1;\n                            prev[i][j][l][1]\
    \ = j;\n                        }\n                    }\n                }\n\
    \                if (i < n - 1) {\n                    if (dp[i + 1][j][l - 1]\
    \ != -1) {\n                        if (cur[1] == -1 || dp[i + 1][j][l - 1] <\
    \ cur[1]) {\n                            cur[0] = dp[", "    int n = grid.size();\n\
    \    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, LONG_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>()));\n    for (int\
    \ i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if\
    \ (i == 0 && j == 0) {\n                dp[i][j] = 0;\n                path[i][j].push_back(grid[i][j]);\n\
    \            } else {\n                if (i > 0) {\n                    if (dp[i\
    \ - 1][j] < dp[i][j]) {\n                        dp[i][j] = dp[i - 1][j];\n  \
    \                      path[i][j] = path[i - 1][j];\n                    } else\
    \ if (dp[i - 1][j] == dp[i][j]) {\n                        if (path[i - 1][j]\
    \ < path[i][j]) {\n                            path[i][j] = path[i - 1][j];\n\
    \                        }\n                    }\n                }\n       \
    \         if (j > 0) {\n                    if (dp[i][j - 1] < dp[i][j]) {\n \
    \                       dp[i][j] = dp[i][j - 1];\n                        path[i][j]\
    \ = path[i][j - 1];\n                    } else if (dp[i][j - 1] == dp[i][j])\
    \ {\n                        if (path[i][j - 1] < path[i][j]) {\n            \
    \                path[i][j] = path[i][j - 1];\n                        }\n   \
    \                 }\n                }\n                dp[i][j] += grid[i][j];\n\
    \                path[i][j].push_back(grid[i][j]);\n            }\n        }\n\
    \    }\n    std::vector<long> ans =", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k, 0)));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   if (i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n        \
    \        path[i][j][0] = grid[i][j];\n            } else if (i == 0) {\n     \
    \           dp[i][j] = dp[i][j - 1] + grid[i][j];\n                path[i][j]\
    \ = path[i][j - 1];\n                path[i][j][0] = grid[i][j];\n           \
    \ } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                path[i][j] = path[i - 1][j];\n                path[i][j][0] =\
    \ grid[i][j];\n            } else {\n                dp[i][j] = std::min(dp[i\
    \ - 1][j], dp[i][j - 1]) + grid[i][j];\n                if (dp[i - 1][j] < dp[i][j\
    \ - 1]) {\n                    path[i][j] = path[i - 1][j];\n                }\
    \ else {\n                    path[i][j] = path[i][j - 1];\n                }\n\
    \                path[i][j][0] = grid[i][j];\n            }\n        }\n    }\n\
    \    std::vector<long> ans;\n    ans.push_back(grid[0][0]);\n    int i = 0, j\
    \ = 0;\n    for (int l = 1; l < k; l++) {\n        if (i == 0) {\n           \
    \ j++;\n        } else if (j == 0) {\n", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int l = 2; l\
    \ <= k; l++) {\n        for (int i = 0; i < n; i++) {\n            for (int j\
    \ = 0; j < n; j++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    std::vector<long>\
    \ ans(k);\n    ans[k - 1] = grid[0][0];\n    int i = 0, j = 0;\n    for (int l\
    \ = k - 1; l >= 1; l--) {\n        if (i > 0 && dp[i - 1][j][l] == dp[i][j][l\
    \ + 1] - grid[i][j]) {\n            ans[l - 1] = grid[i - 1][j];\n           \
    \ i--;\n        } else if", "    int n = grid.size();\n    assert(n >= 2);\n \
    \   assert(k >= 1);\n    assert(n * n >= k);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> prev(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    for (int\
    \ i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            dp[i][j][1]\
    \ = grid[i][j];\n            prev[i][j][1] = std::vector<long>({i, j});\n    \
    \    }\n    }\n    for (int l = 2; l <= k; ++l) {\n        for (int i = 0; i <\
    \ n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                for (int\
    \ di = -1; di <= 1; ++di) {\n                    for (int dj = -1; dj <= 1; ++dj)\
    \ {\n                        if (di * di + dj * dj == 1) {\n                 \
    \           int ni = i + di;\n                            int nj = j + dj;\n \
    \                           if (ni >= 0 && ni < n && nj >= 0 && nj < n) {\n  \
    \                              if (dp[ni][nj][l - 1] != -1) {\n              \
    \                      if (dp[i][j][l] == -1 || dp[i][j][l] > dp[ni][nj][l - 1])\
    \ {\n                                        dp[i][j][l] = dp[ni][nj][l - 1];\n\
    \                                        prev[i][j][l] = prev[ni][nj][l - 1];\n\
    \                                    }\n                                }\n  \
    \                          }\n                        }\n                    }\n\
    \                }\n                if (dp[i", "    int n = grid.size();\n   \
    \ assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int l = 2; l\
    \ <= k; ++l) {\n        for (int i = 0; i < n; ++i) {\n            for (int j\
    \ = 0; j < n; ++j) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    long\
    \ min_val = INT_MAX;\n    int min_i = -1, min_j = -1;\n    for (int i = 0; i <\
    \ n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            if (dp[i][j][k]\
    \ < min_val) {\n                min_val = dp[i][j", "    // Write your code here\n\
    \    int n = grid.size();\n    assert(n >= 2);\n    assert(n == grid[0].size());\n\
    \    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, -1));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>()));\n    std::vector<std::vector<std::vector<long>>>\
    \ path_val(n, std::vector<std::vector<long>>(n, std::vector<long>()));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   dp[i][j] = grid[i][j];\n            path[i][j].push_back(grid[i][j]);\n  \
    \          path_val[i][j].push_back(grid[i][j]);\n        }\n    }\n    for (int\
    \ i = 1; i < k; i++) {\n        for (int j = 0; j < n; j++) {\n            for\
    \ (int l = 0; l < n; l++) {\n                if (j > 0) {\n                  \
    \  if (dp[j][l] > dp[j - 1][l]) {\n                        dp[j][l] = dp[j - 1][l];\n\
    \                        path[j][l] = path[j - 1][l];\n                      \
    \  path_val[j][l] = path_val[j - 1][l];\n                    } else if (dp[j][l]\
    \ == dp[j - 1][l]) {\n                        if (path_val[j][l] > path_val[j\
    \ - 1][l]) {\n                            path[j][l] = path[j - 1][l];\n     \
    \                       path_val[j][l] = path_val[j - 1][l];\n               \
    \         }\n                    }\n                }\n                if (j <\
    \ n - 1) {\n                    if (dp[j][l] > d", "    int n = grid.size();\n\
    \    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, 0)));\n   \
    \ for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n     \
    \       dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n;\
    \ i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l = 2; l\
    \ <= k; l++) {\n                long min_val = INT_MAX;\n                if (i\
    \ > 0) {\n                    min_val = std::min(min_val, dp[i - 1][j][l - 1]);\n\
    \                }\n                if (i < n - 1) {\n                    min_val\
    \ = std::min(min_val, dp[i + 1][j][l - 1]);\n                }\n             \
    \   if (j > 0) {\n                    min_val = std::min(min_val, dp[i][j - 1][l\
    \ - 1]);\n                }\n                if (j < m - 1) {\n              \
    \      min_val = std::min(min_val, dp[i][j + 1][l - 1]);\n                }\n\
    \                dp[i][j][l] = min_val;\n            }\n        }\n    }\n   \
    \ std::vector<long> ans;\n    ans.push_back(dp[0][0][k]);\n    int i = 0, j =\
    \ 0;\n    for (int l = k - 1; l >= 1; l--) {\n        if (i > 0 && dp[i - 1][j][l]\
    \ == ans.back()) {\n            ans.push_back(dp[i - 1][j][l - 1]);\n        \
    \    i--;\n        } else if (i < n - 1 && dp[i + 1][j][l] == ans.back()) {\n\
    \            ans.push_back(dp[", "    // Write your code here\n    int n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int len = 2; len <= k; len++) {\n        for (int\
    \ i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n          \
    \      if (i > 0) {\n                    dp[i][j][len] = std::min(dp[i][j][len],\
    \ dp[i - 1][j][len - 1]);\n                }\n                if (i < n - 1) {\n\
    \                    dp[i][j][len] = std::min(dp[i][j][len], dp[i + 1][j][len\
    \ - 1]);\n                }\n                if (j > 0) {\n                  \
    \  dp[i][j][len] = std::min(dp[i][j][len], dp[i][j - 1][len - 1]);\n         \
    \       }\n                if (j < n - 1) {\n                    dp[i][j][len]\
    \ = std::min(dp[i][j][len], dp[i][j + 1][len - 1]);\n                }\n     \
    \           dp[i][j][len] += grid[i][j];\n            }\n        }\n    }\n  \
    \  std::vector<long> ans;\n    long min_val = INT_MAX;\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if (dp[i][j][k]\
    \ < min_val) {\n                min_val = dp[i][j][k];\n                ans.clear();\n\
    \                ans.push_back(grid[i][j]);\n            } else if (dp[i][", " \
    \   int n = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n    assert(k\
    \ <= n * n);\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ prev(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k,\
    \ std::vector<long>(2, -1))));\n    for (int i = 0; i < n; ++i) {\n        for\
    \ (int j = 0; j < n; ++j) {\n            dp[i][j][0] = grid[i][j];\n        }\n\
    \    }\n    for (int l = 1; l < k; ++l) {\n        for (int i = 0; i < n; ++i)\
    \ {\n            for (int j = 0; j < n; ++j) {\n                if (i > 0 && dp[i\
    \ - 1][j][l - 1] != -1) {\n                    if (dp[i][j][l] == -1 || dp[i -\
    \ 1][j][l - 1] < dp[i][j][l]) {\n                        dp[i][j][l] = dp[i -\
    \ 1][j][l - 1];\n                        prev[i][j][l][0] = i - 1;\n         \
    \               prev[i][j][l][1] = j;\n                    }\n               \
    \ }\n                if (i < n - 1 && dp[i + 1][j][l - 1] != -1) {\n         \
    \           if (dp[i][j][l] == -1 || dp[i + 1][j][l - 1] < dp[i][j][l]) {\n  \
    \                      dp[i][j][l] = dp[i + 1][j][l - 1];\n                  \
    \      prev[i][j][l][0] = i + 1;\n                        prev[i][j][l][1] = j;\n\
    \                   ", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k, 0)));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   if (i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n        \
    \        path[i][j][0] = grid[i][j];\n            } else if (i == 0) {\n     \
    \           dp[i][j] = dp[i][j - 1] + grid[i][j];\n                path[i][j]\
    \ = path[i][j - 1];\n                path[i][j][0] = grid[i][j];\n           \
    \ } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                path[i][j] = path[i - 1][j];\n                path[i][j][0] =\
    \ grid[i][j];\n            } else {\n                dp[i][j] = std::min(dp[i\
    \ - 1][j], dp[i][j - 1]) + grid[i][j];\n                if (dp[i - 1][j] < dp[i][j\
    \ - 1]) {\n                    path[i][j] = path[i - 1][j];\n                }\
    \ else {\n                    path[i][j] = path[i][j - 1];\n                }\n\
    \                path[i][j][0] = grid[i][j];\n            }\n        }\n    }\n\
    \    int x = n - 1, y = n - 1;\n    for (int i = 1; i < k; i++) {\n        if\
    \ (x == 0) {\n            path[x][y][i] = path[x][y - 1][i - 1];\n           \
    \ y--;\n        } else if (y ==", "    int n = grid.size();\n    assert(n >= 2);\n\
    \    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> prev(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>(2, -1))));\n    std::vector<std::vector<long>>\
    \ dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    for (int i = 0; i < n; ++i) {\n\
    \        for (int j = 0; j < n; ++j) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int len = 2; len <= k; ++len) {\n        for (int\
    \ i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n          \
    \      for (int d = 0; d < 4; ++d) {\n                    int x = i + dir[d][0];\n\
    \                    int y = j + dir[d][1];\n                    if (x >= 0 &&\
    \ x < n && y >= 0 && y < n && dp[x][y][len - 1] != -1) {\n                   \
    \     if (dp[i][j][len] == -1 || dp[i][j][len] > dp[x][y][len - 1] + grid[i][j])\
    \ {\n                            dp[i][j][len] = dp[x][y][len - 1] + grid[i][j];\n\
    \                            prev[i][j][len][0] = x;\n                       \
    \     prev[i][j][len][1] = y;\n                        }\n                   \
    \ }\n                }\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<long> ans;\n    std::vector<std::vector<int>>\
    \ dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    for (int i = 0; i < n; i++) {\n\
    \        for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < n; j++) {\n            for (int l = 2; l <= k; l++) {\n                for\
    \ (int d = 0; d < 4; d++) {\n                    int x = i + dir[d][0];\n    \
    \                int y = j + dir[d][1];\n                    if (x < 0 || x >=\
    \ n || y < 0 || y >= n) continue;\n                    if (dp[x][y][l - 1] ==\
    \ -1) continue;\n                    if (dp[i][j][l] == -1 || dp[i][j][l] > dp[x][y][l\
    \ - 1] * 10 + grid[i][j]) {\n                        dp[i][j][l] = dp[x][y][l\
    \ - 1] * 10 + grid[i][j];\n                        path[i][j][l] = d;\n      \
    \              }\n                }\n            }\n        }\n    }\n    long\
    \ min_val = -1;\n    int min_i = -1, min_j = -1;\n    for (int i = 0; i < n; i++)\
    \ {\n        for (int j = 0; j < n; j++) {\n            if (dp[i", "    int n\
    \ = grid.size();\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ dp(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(n, 0))));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j][i][j] = grid[i][j];\n      \
    \  }\n    }\n    for (int len = 2; len <= k; len++) {\n        for (int i = 0;\
    \ i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                for\
    \ (int x = 0; x < n; x++) {\n                    for (int y = 0; y < n; y++) {\n\
    \                        if (i == x && j == y) {\n                           \
    \ continue;\n                        }\n                        if (i == x &&\
    \ abs(j - y) == 1) {\n                            dp[i][j][x][y] = std::min(dp[i][j][x][y],\
    \ dp[i][j][i][y] + grid[x][y]);\n                        } else if (j == y &&\
    \ abs(i - x) == 1) {\n                            dp[i][j][x][y] = std::min(dp[i][j][x][y],\
    \ dp[i][j][x][j] + grid[x][y]);\n                        } else {\n          \
    \                  dp[i][j][x][y] = std::min(dp[i][j][x][y], dp[i][j][x][y]);\n\
    \                        }\n                    }\n                }\n       \
    \     }\n        }\n    }\n    std::vector<long> ans;\n    long min_val = INT_MAX;\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          if (dp[i][j][i][j] < min_val) {\n                min_val = dp[i", " \
    \   int n = grid.size();\n    std::vector<std::vector<std::vector<long>>> dp(n,\
    \ std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ prev(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(2, -1))));\n    for (int i = 0; i < n; i++) {\n     \
    \   for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n   \
    \     }\n    }\n    for (int l = 2; l <= k; l++) {\n        for (int i = 0; i\
    \ < n; i++) {\n            for (int j = 0; j < n; j++) {\n                for\
    \ (int di = -1; di <= 1; di++) {\n                    for (int dj = -1; dj <=\
    \ 1; dj++) {\n                        if (di == 0 && dj == 0) {\n            \
    \                continue;\n                        }\n                      \
    \  int ni = i + di;\n                        int nj = j + dj;\n              \
    \          if (ni < 0 || ni >= n || nj < 0 || nj >= n) {\n                   \
    \         continue;\n                        }\n                        if (dp[ni][nj][l\
    \ - 1] == -1) {\n                            continue;\n                     \
    \   }\n                        if (dp[i][j][l] == -1 || dp[i][j][l] > dp[ni][nj][l\
    \ - 1] || (dp[i][j][l] == dp[ni][nj][l - 1] && grid[i][j] < grid[prev[i][j][l][0]][prev[i][j][l][1]]))\
    \ {\n                            dp[i][j][l] = dp[ni][nj][l - 1];\n          \
    \                  prev[i][j][l][0] = ni;\n                            prev[i][j][l][1]\
    \ = n", "    // Write your code here\n    int n = grid.size();\n    assert(n >=\
    \ 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int len = 2;\
    \ len <= k; len++) {\n        for (int i = 0; i < n; i++) {\n            for (int\
    \ j = 0; j < n; j++) {\n                if (i - 1 >= 0) {\n                  \
    \  dp[i][j][len] = std::min(dp[i][j][len], dp[i - 1][j][len - 1]);\n         \
    \       }\n                if (i + 1 < n) {\n                    dp[i][j][len]\
    \ = std::min(dp[i][j][len], dp[i + 1][j][len - 1]);\n                }\n     \
    \           if (j - 1 >= 0) {\n                    dp[i][j][len] = std::min(dp[i][j][len],\
    \ dp[i][j - 1][len - 1]);\n                }\n                if (j + 1 < n) {\n\
    \                    dp[i][j][len] = std::min(dp[i][j][len], dp[i][j + 1][len\
    \ - 1]);\n                }\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    ans.push_back(grid[0][0]);\n    int i = 0, j = 0;\n    for (int len\
    \ = 2; len <= k; len++) {\n        if (i - 1 >= 0 && dp[i][j][len] == dp[i - 1][j][len\
    \ - 1]) {\n            ans.push_back(grid[i - 1][j]);\n            i", "    int\
    \ n = grid.size();\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ path(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>())));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n         \
    \   path[i][j][1].push_back(grid[i][j]);\n        }\n    }\n    for (int len =\
    \ 2; len <= k; len++) {\n        for (int i = 0; i < n; i++) {\n            for\
    \ (int j = 0; j < n; j++) {\n                for (int di = -1; di <= 1; di++)\
    \ {\n                    for (int dj = -1; dj <= 1; dj++) {\n                \
    \        if (di * di + dj * dj == 1) {\n                            int ni = i\
    \ + di;\n                            int nj = j + dj;\n                      \
    \      if (ni >= 0 && ni < n && nj >= 0 && nj < n && dp[ni][nj][len - 1] != -1)\
    \ {\n                                if (dp[i][j][len] == -1 || dp[i][j][len]\
    \ > dp[ni][nj][len - 1] * 10 + grid[i][j]) {\n                               \
    \     dp[i][j][len] = dp[ni][nj][len - 1] * 10 + grid[i][j];\n               \
    \                     path[i][j][len] = path[ni][nj][len - 1];\n             \
    \                       path[i][j][len].push_back(grid[i][j]);\n             \
    \                   }\n                            }\n                       \
    \ }\n                    }\n                }\n            }\n        }\n    }\n\
    \    std", "    // your code here\n    int n = grid.size();\n    int m = grid[0].size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < m; j++) {\n            for (int l = 2; l <= k; l++) {\n                if\
    \ (i - 1 >= 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i\
    \ - 1][j][l - 1]);\n                }\n                if (i + 1 < n) {\n    \
    \                dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n \
    \               }\n                if (j - 1 >= 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n                }\n         \
    \       if (j + 1 < m) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j + 1][l - 1]);\n                }\n                dp[i][j][l] += grid[i][j];\n\
    \            }\n        }\n    }\n    long min_val = INT_MAX;\n    int min_i =\
    \ -1;\n    int min_j = -1;\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < m; j++) {\n            if (dp[i][j][k] < min_val) {\n           \
    \     min_val = dp[i][j][k];\n                min_i =", "    int n = grid.size();\n\
    \    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, -1));\n    std::vector<std::vector<long>> prev(n,\
    \ std::vector<long>(n, -1));\n    std::vector<std::vector<std::vector<long>>>\
    \ dp_path(n, std::vector<std::vector<long>>(n, std::vector<long>()));\n    for\
    \ (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n         \
    \   if (i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n        \
    \        dp_path[i][j].push_back(grid[i][j]);\n            } else if (i == 0)\
    \ {\n                dp[i][j] = dp[i][j - 1] + grid[i][j];\n                dp_path[i][j]\
    \ = dp_path[i][j - 1];\n                dp_path[i][j].push_back(grid[i][j]);\n\
    \            } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                dp_path[i][j] = dp_path[i - 1][j];\n                dp_path[i][j].push_back(grid[i][j]);\n\
    \            } else {\n                if (dp[i - 1][j] < dp[i][j - 1]) {\n  \
    \                  dp[i][j] = dp[i - 1][j] + grid[i][j];\n                   \
    \ dp_path[i][j] = dp_path[i - 1][j];\n                    dp_path[i][j].push_back(grid[i][j]);\n\
    \                } else {\n                    dp[i][j] = dp[i][j - 1] + grid[i][j];\n\
    \                    d", "    int n = grid.size();\n    assert(n >= 2);\n    assert(k\
    \ >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, 0)));\n   \
    \ std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, 0)));\n    for (int i = 0; i < n; ++i) {\n        for\
    \ (int j = 0; j < n; ++j) {\n            dp[i][j][1] = grid[i][j];\n         \
    \   path[i][j][1] = grid[i][j];\n        }\n    }\n    for (int len = 2; len <=\
    \ k; ++len) {\n        for (int i = 0; i < n; ++i) {\n            for (int j =\
    \ 0; j < n; ++j) {\n                long min_val = 1e9;\n                std::vector<long>\
    \ min_path;\n                if (i > 0) {\n                    if (dp[i - 1][j][len\
    \ - 1] < min_val) {\n                        min_val = dp[i - 1][j][len - 1];\n\
    \                        min_path = path[i - 1][j][len - 1];\n               \
    \     }\n                }\n                if (i < n - 1) {\n               \
    \     if (dp[i + 1][j][len - 1] < min_val) {\n                        min_val\
    \ = dp[i + 1][j][len - 1];\n                        min_path = path[i + 1][j][len\
    \ - 1];\n                    }\n                }\n                if (j > 0)\
    \ {\n                    if (dp[i][j - 1][len - 1] < min_val) {\n            \
    \            min_val = dp[i][j - 1][len - 1];\n                        min_path\
    \ = path[i][j - 1][len - 1];\n                    }\n                }\n     \
    \           if (j < n - 1) {", "    // your code here\n    int n = grid.size();\n\
    \    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < m - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    long\
    \ min_val = INT_MAX;\n    int x = 0, y = 0;\n    for (int i = 0; i < n; i++) {\n\
    \        for (int j = 0; j < m; j++) {\n            if (dp[i][j][k] < min_val)\
    \ {\n                min_val = dp[i][j][k];\n                x = i;\n        \
    \        y = j;\n            }\n        }\n", "    int n = grid.size();\n    assert(n\
    \ >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> pre(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    for (int\
    \ i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            dp[i][j][1]\
    \ = grid[i][j];\n            pre[i][j][1] = std::vector<long>({grid[i][j]});\n\
    \        }\n    }\n    for (int l = 2; l <= k; ++l) {\n        for (int i = 0;\
    \ i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                std::vector<long>\
    \ cur = {grid[i][j]};\n                if (i > 0 && dp[i - 1][j][l - 1] != -1)\
    \ {\n                    if (dp[i][j][l] == -1 || dp[i - 1][j][l - 1] < dp[i][j][l])\
    \ {\n                        dp[i][j][l] = dp[i - 1][j][l - 1];\n            \
    \            pre[i][j][l] = pre[i - 1][j][l - 1];\n                        pre[i][j][l].push_back(grid[i][j]);\n\
    \                    }\n                }\n                if (i < n - 1 && dp[i\
    \ + 1][j][l - 1] != -1) {\n                    if (dp[i][j][l] == -1 || dp[i +\
    \ 1][j][l - 1] < dp[i][j][l]) {\n                        dp", "    int n = grid.size();\n\
    \    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<long>> dir = {{0,\
    \ 1}, {0, -1}, {1, 0}, {-1, 0}};\n    for (int i = 0; i < n; ++i) {\n        for\
    \ (int j = 0; j < n; ++j) {\n            dp[i][j][1] = grid[i][j];\n        }\n\
    \    }\n    for (int l = 2; l <= k; ++l) {\n        for (int i = 0; i < n; ++i)\
    \ {\n            for (int j = 0; j < n; ++j) {\n                for (int d = 0;\
    \ d < 4; ++d) {\n                    int x = i + dir[d][0];\n                \
    \    int y = j + dir[d][1];\n                    if (x >= 0 && x < n && y >= 0\
    \ && y < n && dp[x][y][l - 1] != -1) {\n                        if (dp[i][j][l]\
    \ == -1 || dp[i][j][l] > dp[x][y][l - 1] * 10 + grid[i][j]) {\n              \
    \              dp[i][j][l] = dp[x][y][l - 1] * 10 + grid[i][j];\n            \
    \                path[i][j][l] = d;\n                        }\n             \
    \       }\n                }\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    long min_val = -1;\n    int x, y;\n    for (int i = 0; i < n; ++i)\
    \ {\n", "    std::vector<long> res;\n    return res;", "    // Your code here\n\
    \    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k, INT_MAX)));\n \
    \   std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k, -1)));\n    for(int i = 0; i < n; i++) {\n        for(int\
    \ j = 0; j < m; j++) {\n            dp[i][j][0] = grid[i][j];\n        }\n   \
    \ }\n    for(int l = 1; l < k; l++) {\n        for(int i = 0; i < n; i++) {\n\
    \            for(int j = 0; j < m; j++) {\n                if(i > 0) {\n     \
    \               if(dp[i][j][l] > dp[i - 1][j][l - 1]) {\n                    \
    \    dp[i][j][l] = dp[i - 1][j][l - 1];\n                        path[i][j][l]\
    \ = 0;\n                    }\n                }\n                if(i < n - 1)\
    \ {\n                    if(dp[i][j][l] > dp[i + 1][j][l - 1]) {\n           \
    \             dp[i][j][l] = dp[i + 1][j][l - 1];\n                        path[i][j][l]\
    \ = 1;\n                    }\n                }\n                if(j > 0) {\n\
    \                    if(dp[i][j][l] > dp[i][j - 1][l - 1]) {\n               \
    \         dp[i][j][l] = dp[i][j - 1][l - 1];\n                        path[i][j][l]\
    \ = 2;\n                    }\n                }\n                if(j < m - 1)\
    \ {\n                    if(dp[i][j][l] > dp[i][j + 1][l - 1]) {\n           \
    \             dp[i][j][l", "    int n = grid.size();\n    int m = grid[0].size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, 0)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n        }\n\
    \    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++)\
    \ {\n            for (int l = 2; l <= k; l++) {\n                dp[i][j][l] =\
    \ INT_MAX;\n                if (i > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i - 1][j][l - 1]);\n                }\n                if (i < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n\
    \                }\n                if (j > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n                }\n         \
    \       if (j < m - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j + 1][l - 1]);\n                }\n                dp[i][j][l] += grid[i][j];\n\
    \            }\n        }\n    }\n    long min_val = INT_MAX;\n    int min_i =\
    \ -1;\n    int min_j = -1;\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < m; j++) {\n            if (dp[i][j][k] < min_val) {\n           \
    \     min_val = dp[i][j][k];\n               ", "    int n = grid.size();\n  \
    \  int m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k, 0)));\n    dp[0][0] = grid[0][0];\n    path[0][0][0] =\
    \ grid[0][0];\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j <\
    \ m; j++) {\n            if (i > 0) {\n                if (dp[i - 1][j] < dp[i][j])\
    \ {\n                    dp[i][j] = dp[i - 1][j];\n                    path[i][j]\
    \ = path[i - 1][j];\n                } else if (dp[i - 1][j] == dp[i][j]) {\n\
    \                    for (int l = 0; l < k; l++) {\n                        if\
    \ (path[i - 1][j][l] < path[i][j][l]) {\n                            path[i][j]\
    \ = path[i - 1][j];\n                            break;\n                    \
    \    } else if (path[i - 1][j][l] > path[i][j][l]) {\n                       \
    \     break;\n                        }\n                    }\n             \
    \   }\n            }\n            if (j > 0) {\n                if (dp[i][j -\
    \ 1] < dp[i][j]) {\n                    dp[i][j] = dp[i][j - 1];\n           \
    \         path[i][j] = path[i][j - 1];\n                } else if (dp[i][j - 1]\
    \ == dp[i][j]) {\n                    for (int l = 0; l < k; l++) {\n        \
    \                if (path[i][j - 1][l] < path[i][j][l]) {\n                  \
    \          path[i][j] = path[i][j - 1];\n                            break;\n\
    \                        } else if (path", "    int n = grid.size();\n    int\
    \ m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ path(n, std::vector<std::vector<std::vector<long>>>(m, std::vector<std::vector<long>>(k,\
    \ std::vector<long>())));\n    std::vector<std::vector<long>> dir = {{0, 1}, {0,\
    \ -1}, {1, 0}, {-1, 0}};\n    std::function<long(int, int, int)> dfs = [&](int\
    \ x, int y, int z) {\n        if (dp[x][y][z] != -1) return dp[x][y][z];\n   \
    \     if (z == 0) return dp[x][y][z] = grid[x][y];\n        long ans = INT_MAX;\n\
    \        for (int i = 0; i < 4; i++) {\n            int nx = x + dir[i][0];\n\
    \            int ny = y + dir[i][1];\n            if (nx < 0 || nx >= n || ny\
    \ < 0 || ny >= m) continue;\n            long tmp = dfs(nx, ny, z - 1);\n    \
    \        if (tmp < ans) {\n                ans = tmp;\n                path[x][y][z]\
    \ = path[nx][ny][z - 1];\n                path[x][y][z].push_back(grid[x][y]);\n\
    \            }\n        }\n        return dp[x][y][z] = ans;\n    };\n    long\
    \ ans = INT_MAX;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j\
    \ < m; j++) {\n            long tmp = dfs(i, j, k - 1);\n            if (tmp <\
    \ ans) {\n                ans = tmp;\n                path[i][j][k - 1].push_back",
  "    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int len = 2;\
    \ len <= k; len++) {\n        for (int i = 0; i < n; i++) {\n            for (int\
    \ j = 0; j < m; j++) {\n                if (i > 0) {\n                    dp[i][j][len]\
    \ = std::min(dp[i][j][len], dp[i - 1][j][len - 1]);\n                }\n     \
    \           if (i < n - 1) {\n                    dp[i][j][len] = std::min(dp[i][j][len],\
    \ dp[i + 1][j][len - 1]);\n                }\n                if (j > 0) {\n \
    \                   dp[i][j][len] = std::min(dp[i][j][len], dp[i][j - 1][len -\
    \ 1]);\n                }\n                if (j < m - 1) {\n                \
    \    dp[i][j][len] = std::min(dp[i][j][len], dp[i][j + 1][len - 1]);\n       \
    \         }\n                dp[i][j][len] += grid[i][j];\n            }\n   \
    \     }\n    }\n    std::vector<long> ans;\n    long min_val = INT_MAX;\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n         \
    \   if (dp[i][j][k] < min_val) {\n                min_val = dp[i][j][k];\n   \
    \             ans = std::vector<long>({grid[i][j]});\n            }\n        }\n\
    \   ", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> dp_path(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ dp_path_idx(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>())));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n         \
    \   dp_path[i][j][1].push_back(grid[i][j]);\n            dp_path_idx[i][j][1].push_back(i\
    \ * n + j);\n        }\n    }\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            for (int l = 2; l <= k; l++) {\n    \
    \            std::vector<long> cur_path;\n                std::vector<long> cur_path_idx;\n\
    \                if (i > 0) {\n                    if (dp[i - 1][j][l - 1] !=\
    \ -1) {\n                        if (cur_path.size() == 0 || dp[i - 1][j][l -\
    \ 1] < dp[cur_path_idx[0] / n][cur_path_idx[0] % n][l - 1]) {\n              \
    \              cur_path = dp_path[i - 1][j][l - 1];\n                        \
    \    cur_path_idx = dp_path_idx[i - 1][j][l", "    int n = grid.size();\n    int\
    \ m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, INT_MAX)));\n    for (int i = 0; i < n; i++) {\n  \
    \      for (int j = 0; j < m; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int len = 2; len <= k; len++) {\n        for (int\
    \ i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n          \
    \      if (i > 0) {\n                    dp[i][j][len] = std::min(dp[i][j][len],\
    \ dp[i - 1][j][len - 1]);\n                }\n                if (i < n - 1) {\n\
    \                    dp[i][j][len] = std::min(dp[i][j][len], dp[i + 1][j][len\
    \ - 1]);\n                }\n                if (j > 0) {\n                  \
    \  dp[i][j][len] = std::min(dp[i][j][len], dp[i][j - 1][len - 1]);\n         \
    \       }\n                if (j < m - 1) {\n                    dp[i][j][len]\
    \ = std::min(dp[i][j][len], dp[i][j + 1][len - 1]);\n                }\n     \
    \           dp[i][j][len] += grid[i][j];\n            }\n        }\n    }\n  \
    \  std::vector<long> ans;\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < m; j++) {\n            if (dp[i][j][k] < dp[ans[0]][ans[1]][k]) {\n\
    \                ans = {i, j};\n            }\n        }\n    }\n    std::vector<long>\
    \ path;\n    while (k > 0) {\n        path.", "    int n = grid.size();\n    int\
    \ m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < m; j++) {\n            if (i == 0 && j == 0) {\n           \
    \     dp[i][j] = grid[i][j];\n                path[i][j][1] = grid[i][j];\n  \
    \          } else {\n                if (i > 0) {\n                    if (dp[i\
    \ - 1][j] < dp[i][j]) {\n                        dp[i][j] = dp[i - 1][j];\n  \
    \                      path[i][j] = path[i - 1][j];\n                    } else\
    \ if (dp[i - 1][j] == dp[i][j]) {\n                        if (path[i - 1][j]\
    \ < path[i][j]) {\n                            path[i][j] = path[i - 1][j];\n\
    \                        }\n                    }\n                }\n       \
    \         if (j > 0) {\n                    if (dp[i][j - 1] < dp[i][j]) {\n \
    \                       dp[i][j] = dp[i][j - 1];\n                        path[i][j]\
    \ = path[i][j - 1];\n                    } else if (dp[i][j - 1] == dp[i][j])\
    \ {\n                        if (path[i][j - 1] < path[i][j]) {\n            \
    \                path[i][j] = path[i][j - 1];\n                        }\n   \
    \                 }\n                }\n                dp[i][j] += grid[i][j];\n\
    \                path[i][j][1] = grid[i][j];\n            }\n        }\n    }\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j", "    int n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ path(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>())));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n         \
    \   path[i][j][1].push_back(grid[i][j]);\n        }\n    }\n    for (int l = 2;\
    \ l <= k; l++) {\n        for (int i = 0; i < n; i++) {\n            for (int\
    \ j = 0; j < n; j++) {\n                for (int x = -1; x <= 1; x++) {\n    \
    \                for (int y = -1; y <= 1; y++) {\n                        if (x\
    \ == 0 && y == 0) {\n                            continue;\n                 \
    \       }\n                        int nx = i + x;\n                        int\
    \ ny = j + y;\n                        if (nx < 0 || nx >= n || ny < 0 || ny >=\
    \ n) {\n                            continue;\n                        }\n   \
    \                     if (dp[nx][ny][l - 1] == -1) {\n                       \
    \     continue;\n                        }\n                        if (dp[i][j][l]\
    \ == -1 || dp[nx][ny][l - 1] < dp[i][j][l]) {\n                            dp[i][j][l]\
    \ = dp[nx][ny][l - 1];\n                            path[i][j][l] = path[nx][ny][l\
    \ - 1];\n                            path[i][j][l].push_back(grid[i][j]);\n  \
    \                      }\n                    }\n                }\n         \
    \   }\n        }\n    }\n    std::", "    int n = grid.size();\n    assert(n >=\
    \ 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<int>> dir(n,\
    \ std::vector<int>(n, -1));\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j]\
    \ = grid[i][j];\n            } else if (i == 0) {\n                dp[i][j] =\
    \ dp[i][j - 1] + grid[i][j];\n                dir[i][j] = 0;\n            } else\
    \ if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n     \
    \           dir[i][j] = 1;\n            } else {\n                if (dp[i - 1][j]\
    \ < dp[i][j - 1]) {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                    dir[i][j] = 1;\n                } else {\n              \
    \      dp[i][j] = dp[i][j - 1] + grid[i][j];\n                    dir[i][j] =\
    \ 0;\n                }\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    int x = n - 1, y = n - 1;\n    for (int i = 0; i < k; i++) {\n   \
    \     ans.push_back(grid[x][y]);\n        if (dir[x][y] == 0) {\n            y--;\n\
    \        } else {\n            x--;\n        }\n    }\n    return ans;", "   \
    \ int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ dp(n, std::vector<std::vector<std::vector<long>>>(m, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(2, INT_MAX))));\n    for (int i = 0; i < n; i++) {\n\
    \        for (int j = 0; j < m; j++) {\n            dp[i][j][1][0] = grid[i][j];\n\
    \            dp[i][j][1][1] = grid[i][j];\n        }\n    }\n    for (int i =\
    \ 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int\
    \ l = 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l][0]\
    \ = std::min(dp[i][j][l][0], dp[i - 1][j][l - 1][0]);\n                    dp[i][j][l][1]\
    \ = std::min(dp[i][j][l][1], dp[i - 1][j][l - 1][1]);\n                }\n   \
    \             if (j > 0) {\n                    dp[i][j][l][0] = std::min(dp[i][j][l][0],\
    \ dp[i][j - 1][l - 1][0]);\n                    dp[i][j][l][1] = std::min(dp[i][j][l][1],\
    \ dp[i][j - 1][l - 1][1]);\n                }\n                if (i < n - 1)\
    \ {\n                    dp[i][j][l][0] = std::min(dp[i][j][l][0], dp[i + 1][j][l\
    \ - 1][0]);\n                    dp[i][j][l][1] = std::min(dp[i][j][l][1], dp[i\
    \ + 1][j][l - 1][1]);\n                }", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<int>> parent(n,\
    \ std::vector<int>(n, -1));\n    std::vector<std::vector<int>> dir = {{0, 1},\
    \ {0, -1}, {1, 0}, {-1, 0}};\n    std::vector<std::vector<int>> visited(n, std::vector<int>(n,\
    \ 0));\n    std::queue<std::pair<int, int>> q;\n    dp[0][0] = grid[0][0];\n \
    \   q.push({0, 0});\n    visited[0][0] = 1;\n    while (!q.empty()) {\n      \
    \  int x = q.front().first;\n        int y = q.front().second;\n        q.pop();\n\
    \        for (int i = 0; i < 4; i++) {\n            int nx = x + dir[i][0];\n\
    \            int ny = y + dir[i][1];\n            if (nx < 0 || nx >= n || ny\
    \ < 0 || ny >= n) {\n                continue;\n            }\n            if\
    \ (visited[nx][ny]) {\n                continue;\n            }\n            if\
    \ (dp[nx][ny] > dp[x][y] + grid[nx][ny]) {\n                dp[nx][ny] = dp[x][y]\
    \ + grid[nx][ny];\n                parent[nx][ny] = i;\n            }\n      \
    \      q.push({nx, ny});\n            visited[nx][ny] = 1;\n        }\n    }\n\
    \    int x = n - 1;\n    int y = n - 1;\n    std::vector<long> ans;\n    while\
    \ (k--) {\n        ans.push_back(grid[x][y]);\n        int p = parent[x][y];\n\
    \        x -= dir[p][0];\n        y -= dir[p][1];\n    }\n    std::reverse(ans.begin(),\
    \ ans.end());\n", "    int n = grid.size();\n    assert(n >= 2);\n    assert(n\
    \ == grid[0].size());\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<long>\
    \ ans;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++)\
    \ {\n            assert(1 <= grid[i][j] && grid[i][j] <= n * n);\n        }\n\
    \    }\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    for (int i = 0; i < n; i++) {\n       \
    \ for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n     \
    \   }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n;\
    \ j++) {\n            for (int l = 2; l <= k; l++) {\n                std::vector<long>\
    \ tmp;\n                if (i > 0) {\n                    tmp.push_back(dp[i -\
    \ 1][j][l - 1]);\n                }\n                if (i < n - 1) {\n      \
    \              tmp.push_back(dp[i + 1][j][l - 1]);\n                }\n      \
    \          if (j > 0) {\n                    tmp.push_back(dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    tmp.push_back(dp[i][j\
    \ + 1][l - 1]);\n                }\n                if (tmp.size() > 0) {\n  \
    \                  std::sort(tmp.begin(), tmp.end());\n                    dp[i][j][l]\
    \ = tmp[0];\n                }\n            }\n        }\n    }\n    std::vector<long>\
    \ tmp;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++)\
    \ {\n            tmp", "    int n = grid.size();\n    int m = grid[0].size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<int>> dir = {{1,\
    \ 0}, {-1, 0}, {0, 1}, {0, -1}};\n    std::function<long(int, int, int)> dfs =\
    \ [&](int x, int y, int step) {\n        if (step == 0) return 0;\n        if\
    \ (dp[x][y][step] != -1) return dp[x][y][step];\n        long ans = INT_MAX;\n\
    \        for (int i = 0; i < 4; i++) {\n            int nx = x + dir[i][0];\n\
    \            int ny = y + dir[i][1];\n            if (nx < 0 || nx >= n || ny\
    \ < 0 || ny >= m) continue;\n            ans = std::min(ans, dfs(nx, ny, step\
    \ - 1) + grid[x][y]);\n        }\n        return dp[x][y][step] = ans;\n    };\n\
    \    long min_val = INT_MAX;\n    std::vector<std::vector<int>> pos;\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n         \
    \   long val = dfs(i, j, k);\n            if (val < min_val) {\n             \
    \   min_val = val;\n                pos.clear();\n                pos.push_back({i,\
    \ j});\n            } else if (val == min_val) {\n                pos.push_back({i,\
    \ j});\n            }\n        }\n    }\n    std::vector<long> ans;\n    for (int\
    \ i = 0; i < pos.size(); i++) {\n        ans.push_back(grid[pos[i][0]][pos[i][1]]);\n\
    \    }\n    return ans;", "    int n = grid.size();\n    assert(n >= 2);\n   \
    \ assert(n == grid[0].size());\n    assert(k >= 1);\n    assert(k <= n * n);\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<long>> prev(n,\
    \ std::vector<long>(n, -1));\n    std::vector<std::vector<long>> prev_k(n, std::vector<long>(n,\
    \ -1));\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j)\
    \ {\n            dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i =\
    \ 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            for (int\
    \ l = 2; l <= k; ++l) {\n                if (i > 0 && dp[i - 1][j][l - 1] != -1)\
    \ {\n                    if (dp[i][j][l] == -1 || dp[i - 1][j][l - 1] < dp[i][j][l])\
    \ {\n                        dp[i][j][l] = dp[i - 1][j][l - 1];\n            \
    \            prev[i][j] = 0;\n                        prev_k[i][j] = l - 1;\n\
    \                    }\n                }\n                if (i < n - 1 && dp[i\
    \ + 1][j][l - 1] != -1) {\n                    if (dp[i][j][l] == -1 || dp[i +\
    \ 1][j][l - 1] < dp[i][j][l]) {\n                        dp[i][j][l] = dp[i +\
    \ 1][j][l - 1];\n                        prev[i][j] = 1;\n                   \
    \     prev_k[i][j] = l - 1;\n                    }\n                }\n      \
    \          if (", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, 0)));\n   \
    \ for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n     \
    \       dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n;\
    \ i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l = 2; l\
    \ <= k; l++) {\n                long min = LONG_MAX;\n                if (i >\
    \ 0) {\n                    min = std::min(min, dp[i - 1][j][l - 1]);\n      \
    \          }\n                if (i < n - 1) {\n                    min = std::min(min,\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 min = std::min(min, dp[i][j - 1][l - 1]);\n                }\n\
    \                if (j < n - 1) {\n                    min = std::min(min, dp[i][j\
    \ + 1][l - 1]);\n                }\n                dp[i][j][l] = min * 10 + grid[i][j];\n\
    \            }\n        }\n    }\n    long min = LONG_MAX;\n    int x = 0, y =\
    \ 0;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n\
    \            if (dp[i][j][k] < min) {\n                min = dp[i][j][k];\n  \
    \              x = i;\n                y = j;\n            }\n        }\n    }\n\
    \    std::vector<long> ans;\n    ans.push_back(grid[x][y]);\n    for (int i =\
    \ k - 1; i > 0; i--) {\n        long min = LONG_MAX;\n        int x1 = 0, y1 =\
    \ 0;\n", "    int n = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n\
    \    assert(k <= n * n);\n    std::vector<long> ans;\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k, 0)));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   if (i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n        \
    \        path[i][j][0] = grid[i][j];\n            } else if (i == 0) {\n     \
    \           dp[i][j] = dp[i][j - 1] + grid[i][j];\n                path[i][j]\
    \ = path[i][j - 1];\n                path[i][j][0] = grid[i][j];\n           \
    \ } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                path[i][j] = path[i - 1][j];\n                path[i][j][0] =\
    \ grid[i][j];\n            } else {\n                dp[i][j] = std::min(dp[i\
    \ - 1][j], dp[i][j - 1]) + grid[i][j];\n                if (dp[i - 1][j] < dp[i][j\
    \ - 1]) {\n                    path[i][j] = path[i - 1][j];\n                }\
    \ else if (dp[i - 1][j] > dp[i][j - 1]) {\n                    path[i][j] = path[i][j\
    \ - 1];\n                } else {\n                    path[i][j] = std::min(path[i\
    \ - 1][j], path[i][j - 1]);\n                }\n                path[i][j][0]\
    \ = grid", "    int n = grid.size();\n    assert(n >= 2);\n    assert(n == grid[0].size());\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ prev(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(2, -1))));\n    for (int i = 0; i < n; ++i) {\n     \
    \   for (int j = 0; j < n; ++j) {\n            dp[i][j][1] = grid[i][j];\n   \
    \     }\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j <\
    \ n; ++j) {\n            for (int l = 2; l <= k; ++l) {\n                if (i\
    \ > 0) {\n                    if (dp[i - 1][j][l - 1] != -1) {\n             \
    \           if (dp[i][j][l] == -1 || dp[i - 1][j][l - 1] < dp[i][j][l]) {\n  \
    \                          dp[i][j][l] = dp[i - 1][j][l - 1];\n              \
    \              prev[i][j][l][0] = i - 1;\n                            prev[i][j][l][1]\
    \ = j;\n                        }\n                    }\n                }\n\
    \                if (i < n - 1) {\n                    if (dp[i + 1][j][l - 1]\
    \ != -1) {\n                        if (dp[i][j][l] == -1 || dp[i + 1][j][l -\
    \ 1] < dp[i][j][l]) {\n                            dp[i][j][l] = dp[i + 1][j][l\
    \ - 1];\n                            prev[i][j][l][0] = i + 1;\n             \
    \              ", "    int n = grid.size();\n    assert(n >= 2);\n    assert(k\
    \ >= 1);\n    assert(k <= n * n);\n    std::vector<long> res;\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<int>> path(n,\
    \ std::vector<int>(n, 0));\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j]\
    \ = grid[i][j];\n                path[i][j] = 1;\n            } else if (i ==\
    \ 0) {\n                dp[i][j] = dp[i][j - 1] + grid[i][j];\n              \
    \  path[i][j] = path[i][j - 1];\n            } else if (j == 0) {\n          \
    \      dp[i][j] = dp[i - 1][j] + grid[i][j];\n                path[i][j] = path[i\
    \ - 1][j];\n            } else {\n                if (dp[i - 1][j] < dp[i][j -\
    \ 1]) {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n         \
    \           path[i][j] = path[i - 1][j];\n                } else if (dp[i - 1][j]\
    \ > dp[i][j - 1]) {\n                    dp[i][j] = dp[i][j - 1] + grid[i][j];\n\
    \                    path[i][j] = path[i][j - 1];\n                } else {\n\
    \                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n                 \
    \   path[i][j] = path[i - 1][j] + path[i][j - 1];\n                }\n       \
    \     }\n        }\n    }\n    int i = n - 1, j = n - 1;\n    while (k > 0) {",
  "    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, 0)));\n   \
    \ for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n     \
    \       dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n;\
    \ i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l = 2; l\
    \ <= k; l++) {\n                dp[i][j][l] = INT_MAX;\n                if (i\
    \ > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l], dp[i - 1][j][l\
    \ - 1]);\n                }\n                if (i < n - 1) {\n              \
    \      dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n           \
    \     }\n                if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (j < m - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n\
    \                }\n                dp[i][j][l] += grid[i][j];\n            }\n\
    \        }\n    }\n    long min_val = INT_MAX;\n    int min_i = -1;\n    int min_j\
    \ = -1;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++)\
    \ {\n            if (dp[i][j][k] < min_val) {\n                min_val = dp[i][j][k];\n\
    \               ", "    std::vector<long> res;\n    int n = grid.size();\n   \
    \ int m = grid[0].size();\n    int i = 0, j = 0;\n    while (k--) {\n        res.push_back(grid[i][j]);\n\
    \        if (i + 1 < n && grid[i + 1][j] < grid[i][j]) {\n            i++;\n \
    \       } else if (j + 1 < m && grid[i][j + 1] < grid[i][j]) {\n            j++;\n\
    \        } else if (i - 1 >= 0 && grid[i - 1][j] < grid[i][j]) {\n           \
    \ i--;\n        } else if (j - 1 >= 0 && grid[i][j - 1] < grid[i][j]) {\n    \
    \        j--;\n        }\n    }\n    return res;", "    int n = grid.size();\n\
    \    assert(n >= 2);\n    assert(n == grid[0].size());\n    assert(k >= 1);\n\
    \    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>> dp(n,\
    \ std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ prev(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(2, -1))));\n    for (int i = 0; i < n; ++i) {\n     \
    \   for (int j = 0; j < n; ++j) {\n            dp[i][j][1] = grid[i][j];\n   \
    \     }\n    }\n    for (int l = 2; l <= k; ++l) {\n        for (int i = 0; i\
    \ < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                for\
    \ (int di = -1; di <= 1; ++di) {\n                    for (int dj = -1; dj <=\
    \ 1; ++dj) {\n                        if (di == 0 && dj == 0) {\n            \
    \                continue;\n                        }\n                      \
    \  int ni = i + di;\n                        int nj = j + dj;\n              \
    \          if (ni < 0 || ni >= n || nj < 0 || nj >= n) {\n                   \
    \         continue;\n                        }\n                        if (dp[ni][nj][l\
    \ - 1] == -1) {\n                            continue;\n                     \
    \   }\n                        if (dp[i][j][l] == -1 || dp[ni][nj][l - 1] < dp[i][j][l])\
    \ {\n                            dp[i][j][l] = dp[ni][nj][l - 1];\n          \
    \                  prev[i][j][l][0] = ni;\n                            prev[i][j][l][1]\
    \ = nj;\n                        }\n                    }\n               ", " \
    \   // Write your code here\n    std::vector<long> result;\n    int n = grid.size();\n\
    \    int m = grid[0].size();\n    std::vector<std::vector<long>> dp(n, std::vector<long>(m,\
    \ INT_MAX));\n    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>()));\n    for(int i = 0; i < n; i++){\n        for(int j =\
    \ 0; j < m; j++){\n            if(i == 0 && j == 0){\n                dp[i][j]\
    \ = grid[i][j];\n                path[i][j].push_back(grid[i][j]);\n         \
    \   }\n            else if(i == 0){\n                dp[i][j] = dp[i][j-1] + grid[i][j];\n\
    \                path[i][j] = path[i][j-1];\n                path[i][j].push_back(grid[i][j]);\n\
    \            }\n            else if(j == 0){\n                dp[i][j] = dp[i-1][j]\
    \ + grid[i][j];\n                path[i][j] = path[i-1][j];\n                path[i][j].push_back(grid[i][j]);\n\
    \            }\n            else{\n                if(dp[i-1][j] < dp[i][j-1]){\n\
    \                    dp[i][j] = dp[i-1][j] + grid[i][j];\n                   \
    \ path[i][j] = path[i-1][j];\n                    path[i][j].push_back(grid[i][j]);\n\
    \                }\n                else if(dp[i-1][j] > dp[i][j-1]){\n      \
    \              dp[i][j] = dp[i][j-1] + grid[i][j];\n                    path[i][j]\
    \ = path[i][j-1];\n                    path[i][j].push_back(grid[i][j]);\n   \
    \            ", "    int n = grid.size();\n    assert(n >= 2);\n    assert(k >=\
    \ 1);\n    assert(k <= n * n);\n    std::vector<long> ans;\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, -1));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>()));\n    for (int\
    \ i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if\
    \ (i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n             \
    \   path[i][j].push_back(grid[i][j]);\n            } else if (i == 0) {\n    \
    \            dp[i][j] = dp[i][j - 1] + grid[i][j];\n                path[i][j]\
    \ = path[i][j - 1];\n                path[i][j].push_back(grid[i][j]);\n     \
    \       } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                path[i][j] = path[i - 1][j];\n                path[i][j].push_back(grid[i][j]);\n\
    \            } else {\n                if (dp[i - 1][j] < dp[i][j - 1]) {\n  \
    \                  dp[i][j] = dp[i - 1][j] + grid[i][j];\n                   \
    \ path[i][j] = path[i - 1][j];\n                    path[i][j].push_back(grid[i][j]);\n\
    \                } else {\n                    dp[i][j] = dp[i][j - 1] + grid[i][j];\n\
    \                    path[i][j] = path[i][j - 1];\n                    path[i][j].push_back(grid[i][j]);\n\
    \                }\n            }\n        }\n    }\n    int x = n - 1", "   \
    \ int n = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n    assert(k\
    \ <= n * n);\n    std::vector<long> ans;\n    std::vector<std::vector<int>> dp(n,\
    \ std::vector<int>(n, -1));\n    std::vector<std::vector<int>> pre(n, std::vector<int>(n,\
    \ -1));\n    std::vector<std::vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1,\
    \ 0}};\n    std::queue<std::pair<int, int>> q;\n    for (int i = 0; i < n; ++i)\
    \ {\n        for (int j = 0; j < n; ++j) {\n            if (grid[i][j] == 1) {\n\
    \                dp[i][j] = 0;\n                q.push({i, j});\n            }\n\
    \        }\n    }\n    while (!q.empty()) {\n        auto p = q.front();\n   \
    \     q.pop();\n        for (int i = 0; i < 4; ++i) {\n            int x = p.first\
    \ + dir[i][0];\n            int y = p.second + dir[i][1];\n            if (x >=\
    \ 0 && x < n && y >= 0 && y < n && dp[x][y] == -1) {\n                dp[x][y]\
    \ = dp[p.first][p.second] + 1;\n                pre[x][y] = i;\n             \
    \   q.push({x, y});\n            }\n        }\n    }\n    int x = 0, y = 0;\n\
    \    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n  \
    \          if (dp[i][j] == k - 1) {\n                x = i;\n                y\
    \ = j;\n            }\n        }\n    }\n    ans.push_back(grid[x][y]);\n    for\
    \ (int i = 0; i < k - 1; ++i) {\n        int d = pre[x", "    int n = grid.size();\n\
    \    int m = grid[0].size();\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ dp(n, std::vector<std::vector<std::vector<long>>>(m, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(m, INT_MAX))));\n    std::vector<std::vector<std::vector<std::vector<std::vector<long>>>>>\
    \ path(n, std::vector<std::vector<std::vector<std::vector<long>>>>(m, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(m, std::vector<long>()))));\n    for (int i =\
    \ 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            dp[i][j][i][j]\
    \ = grid[i][j];\n            path[i][j][i][j].push_back(grid[i][j]);\n       \
    \ }\n    }\n    for (int len = 2; len <= k; len++) {\n        for (int i = 0;\
    \ i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                for\
    \ (int x = 0; x < n; x++) {\n                    for (int y = 0; y < m; y++) {\n\
    \                        if (i == x && j == y) {\n                           \
    \ continue;\n                        }\n                        if (i - 1 >= 0\
    \ && dp[i - 1][j][x][y] != INT_MAX) {\n                            if (dp[i -\
    \ 1][j][x][y] < dp[i][j][x][y]) {\n                                dp[i][j][x][y]\
    \ = dp[i - 1][j][x][y];\n                                path[i][j][x][y] = path[i\
    \ - 1][j][x][y];\n                            } else if (dp[i - 1][j][x][y] ==\
    \ dp[i][j][x][y]) {\n                                if (path[i -", "    int n\
    \ = grid.size();\n    std::vector<std::vector<std::vector<std::vector<int>>>>\
    \ dp(n, std::vector<std::vector<std::vector<int>>>(n, std::vector<std::vector<int>>(k\
    \ + 1, std::vector<int>(n * n + 1, -1))));\n    std::vector<std::vector<int>>\
    \ path(n, std::vector<int>(n, -1));\n    std::vector<std::vector<int>> prev(n,\
    \ std::vector<int>(n, -1));\n    for (int i = 0; i < n; i++) {\n        for (int\
    \ j = 0; j < n; j++) {\n            dp[i][j][1][grid[i][j]] = 1;\n        }\n\
    \    }\n    for (int len = 2; len <= k; len++) {\n        for (int i = 0; i <\
    \ n; i++) {\n            for (int j = 0; j < n; j++) {\n                for (int\
    \ val = 1; val <= n * n; val++) {\n                    if (i > 0 && dp[i - 1][j][len\
    \ - 1][val] != -1) {\n                        dp[i][j][len][val] = 1;\n      \
    \                  prev[i][j] = 0;\n                    }\n                  \
    \  if (j > 0 && dp[i][j - 1][len - 1][val] != -1) {\n                        dp[i][j][len][val]\
    \ = 1;\n                        prev[i][j] = 1;\n                    }\n     \
    \               if (i < n - 1 && dp[i + 1][j][len - 1][val] != -1) {\n       \
    \                 dp[i][j][len][val] = 1;\n                        prev[i][j]\
    \ = 2;\n                    }\n                    if (j < n - 1 && dp[i][j +\
    \ 1][len - 1][val] != -1) {\n                        dp[i][j][len][val] = 1;\n\
    \                        prev[i][j] = 3;\n                    }\n            \
    \    }\n            }\n        }\n    }\n    std::", "    int n = grid.size();\n\
    \    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(m,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    std::vector<std::vector<long>>\
    \ directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    std::function<long(int,\
    \ int, int)> dfs = [&](int x, int y, int k) {\n        if (k == 0) return 0;\n\
    \        if (dp[x][y][k] != -1) return dp[x][y][k];\n        long ans = INT_MAX;\n\
    \        for (auto d : directions) {\n            int nx = x + d[0];\n       \
    \     int ny = y + d[1];\n            if (nx < 0 || nx >= n || ny < 0 || ny >=\
    \ m) continue;\n            long cur = dfs(nx, ny, k - 1);\n            if (cur\
    \ < ans) {\n                ans = cur;\n                path[x][y][k] = path[nx][ny][k\
    \ - 1];\n                path[x][y][k].push_back(grid[x][y]);\n            }\n\
    \        }\n        return dp[x][y][k] = ans + grid[x][y];\n    };\n    long ans\
    \ = INT_MAX;\n    std::vector<long> res;\n    for (int i = 0; i < n; ++i) {\n\
    \        for (int j = 0; j < m; ++j) {\n            long cur = dfs(i, j, k);\n\
    \            if (cur < ans) {\n                ans = cur;\n                res\
    \ = path[i][j][k];\n                res.push_back", "    int n = grid.size();\n\
    \    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (i < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n\
    \                }\n                if (j < m - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    std::vector<long>\
    \ ans(k);\n    ans[k - 1] = grid[0][0];\n    int i = 0, j = 0;\n    for (int l\
    \ = k - 1; l >= 1; l--) {\n        if (i > 0 && dp[i - 1][j][l] == dp[i][j][l\
    \ + 1] - grid[i][j]) {\n            ans[l - 1] = grid[i - 1][j", "    int n =\
    \ grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n *\
    \ n);\n    std::vector<long> ans;\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> dp_path(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    for (int\
    \ i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            dp[i][j][1]\
    \ = grid[i][j];\n            dp_path[i][j][1].push_back(grid[i][j]);\n       \
    \ }\n    }\n    for (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n;\
    \ ++j) {\n            for (int l = 2; l <= k; ++l) {\n                if (i -\
    \ 1 >= 0) {\n                    if (dp[i - 1][j][l - 1] != -1) {\n          \
    \              if (dp[i][j][l] == -1 || dp[i - 1][j][l - 1] < dp[i][j][l]) {\n\
    \                            dp[i][j][l] = dp[i - 1][j][l - 1];\n            \
    \                dp_path[i][j][l] = dp_path[i - 1][j][l - 1];\n              \
    \              dp_path[i][j][l].push_back(grid[i][j]);\n                     \
    \   }\n                    }\n                }\n                if (i + 1 < n)\
    \ {\n                    if (dp[i + 1][j][l - 1] != -1) {\n                  \
    \      if (dp[i][j][l] == -1 || dp[i + 1][j][l", "    int n = grid.size();\n \
    \   assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int l = 2; l\
    \ <= k; l++) {\n        for (int i = 0; i < n; i++) {\n            for (int j\
    \ = 0; j < n; j++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    std::vector<long> ans;\n    int i = 0, j = 0;\n \
    \   for (int l = 1; l <= k; l++) {\n        ans.push_back(grid[i][j]);\n     \
    \   if (i > 0 && dp[i][j][l] == dp[i - 1][j][l - 1]) {\n            i--;\n   \
    \     } else if (i < n - 1 && dp[i][j][l] == dp[i +", "    int n = grid.size();\n\
    \    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, -1));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>()));\n    std::vector<std::vector<std::vector<long>>>\
    \ path_val(n, std::vector<std::vector<long>>(n, std::vector<long>()));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   dp[i][j] = grid[i][j];\n            path[i][j].push_back(grid[i][j]);\n  \
    \          path_val[i][j].push_back(grid[i][j]);\n        }\n    }\n    for (int\
    \ i = 1; i < k; i++) {\n        for (int j = 0; j < n; j++) {\n            for\
    \ (int l = 0; l < n; l++) {\n                if (j > 0 && dp[j - 1][l] < dp[j][l])\
    \ {\n                    dp[j][l] = dp[j - 1][l];\n                    path[j][l]\
    \ = path[j - 1][l];\n                    path_val[j][l] = path_val[j - 1][l];\n\
    \                }\n                if (j < n - 1 && dp[j + 1][l] < dp[j][l])\
    \ {\n                    dp[j][l] = dp[j + 1][l];\n                    path[j][l]\
    \ = path[j + 1][l];\n                    path_val[j][l] = path_val[j + 1][l];\n\
    \                }\n                if (l > 0 && dp[j][l - 1] < dp[j][l]) {\n\
    \                    dp[j][l] = dp[j][l - 1];\n                    path[j][",
  "    int n = grid.size();\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ dp(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(2, -1))));\n    std::vector<std::vector<long>> path(n,\
    \ std::vector<long>(n, -1));\n    std::vector<std::vector<long>> dir = {{0, 1},\
    \ {0, -1}, {1, 0}, {-1, 0}};\n    std::vector<long> ans;\n    long min_val = INT_MAX;\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          if (dp[i][j][1][0] == -1) {\n                dp[i][j][1][0] = grid[i][j];\n\
    \                dp[i][j][1][1] = grid[i][j];\n                path[i][j] = grid[i][j];\n\
    \            }\n            for (int l = 2; l <= k; l++) {\n                for\
    \ (int m = 0; m < 4; m++) {\n                    int x = i + dir[m][0];\n    \
    \                int y = j + dir[m][1];\n                    if (x >= 0 && x <\
    \ n && y >= 0 && y < n) {\n                        if (dp[x][y][l - 1][0] != -1)\
    \ {\n                            if (dp[x][y][l - 1][0] < dp[i][j][l][0]) {\n\
    \                                dp[i][j][l][0] = dp[x][y][l - 1][0];\n      \
    \                          dp[i][j][l][1] = dp[x][y][l - 1][1];\n            \
    \                    path[i][j] = path[x][y];\n                            } else\
    \ if (dp[x][y][l - 1][0] == dp[i][j][l][0]) {\n                              \
    \  if (dp", "    int n = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n\
    \    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>> dp(n,\
    \ std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ parent(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(2, -1))));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n\
    \    std::vector<std::vector<std::vector<long>>> path_len(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    for (int i = 0; i < n; ++i) {\n       \
    \ for (int j = 0; j < n; ++j) {\n            dp[i][j][1] = grid[i][j];\n     \
    \       path[i][j][1] = grid[i][j];\n            path_len[i][j][1] = 1;\n    \
    \    }\n    }\n    for (int l = 2; l <= k; ++l) {\n        for (int i = 0; i <\
    \ n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (i\
    \ > 0) {\n                    if (dp[i - 1][j][l - 1] != -1) {\n             \
    \           if (dp[i][j][l] == -1 || dp[i - 1][j][l - 1] < dp[i][j][l]) {\n  \
    \                          dp[i][j][l] = dp[i - 1][j][l - 1];\n              \
    \              parent[i][j][l][0] = i - 1;\n                            parent[i][j][l",
  "    // Implement your solution here\n    return std::vector<long>();", "    int\
    \ n = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <=\
    \ n * n);\n    std::vector<long> ans;\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, 0)));\n   \
    \ std::vector<std::vector<std::vector<std::vector<long>>>> pre(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>(2, 0))));\n    for (int\
    \ i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n            dp[i][j][1]\
    \ = grid[i][j];\n            pre[i][j][1][0] = i;\n            pre[i][j][1][1]\
    \ = j;\n        }\n    }\n    for (int l = 2; l <= k; ++l) {\n        for (int\
    \ i = 0; i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n          \
    \      dp[i][j][l] = INT_MAX;\n                for (int x = 0; x < n; ++x) {\n\
    \                    for (int y = 0; y < n; ++y) {\n                        if\
    \ (x == i && y == j) continue;\n                        if (abs(x - i) + abs(y\
    \ - j) != 1) continue;\n                        if (dp[x][y][l - 1] < dp[i][j][l])\
    \ {\n                            dp[i][j][l] = dp[x][y][l - 1];\n            \
    \                pre[i][j][l][0] = x;\n                            pre[i][j][l][1]\
    \ = y;\n                        }\n                    }\n                }\n\
    \                dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n\
    \    int x = 0, y = 0;", "    int n = grid.size();\n    int m = grid[0].size();\n\
    \    std::vector<std::vector<std::vector<std::vector<long>>>> dp(n, std::vector<std::vector<std::vector<long>>>(m,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>(2, -1))));\n    std::vector<std::vector<long>>\
    \ path(n, std::vector<long>(m, -1));\n    std::vector<std::vector<long>> dir =\
    \ {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    std::vector<long> ans;\n    for (int\
    \ i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for\
    \ (int l = 0; l < k; l++) {\n                dp[i][j][l][0] = grid[i][j];\n  \
    \              dp[i][j][l][1] = grid[i][j];\n            }\n        }\n    }\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          for (int l = 1; l <= k; l++) {\n                for (int d = 0; d <\
    \ 4; d++) {\n                    int x = i + dir[d][0];\n                    int\
    \ y = j + dir[d][1];\n                    if (x >= 0 && x < n && y >= 0 && y <\
    \ m) {\n                        if (dp[x][y][l - 1][0] != -1) {\n            \
    \                if (dp[i][j][l][0] == -1 || dp[i][j][l][0] > dp[x][y][l - 1][0])\
    \ {\n                                dp[i][j][l][0] = dp[x][y][l - 1][0];\n  \
    \                              dp[i][j][l][1] = dp[x][y][l - 1][1];\n        \
    \                        path[i][j] = d;\n                            } else if\
    \ (", "    // Write your code here\n    int n = grid.size();\n    int m = grid[0].size();\n\
    \    long dp[n][m][k+1];\n    for(int i=0;i<n;i++){\n        for(int j=0;j<m;j++){\n\
    \            for(int l=0;l<=k;l++){\n                dp[i][j][l] = INT_MAX;\n\
    \            }\n        }\n    }\n    dp[0][0][0] = grid[0][0];\n    for(int i=0;i<n;i++){\n\
    \        for(int j=0;j<m;j++){\n            for(int l=0;l<k;l++){\n          \
    \      if(i>0){\n                    dp[i][j][l+1] = min(dp[i][j][l+1],dp[i-1][j][l]+grid[i][j]);\n\
    \                }\n                if(j>0){\n                    dp[i][j][l+1]\
    \ = min(dp[i][j][l+1],dp[i][j-1][l]+grid[i][j]);\n                }\n        \
    \        if(i<n-1){\n                    dp[i][j][l+1] = min(dp[i][j][l+1],dp[i+1][j][l]+grid[i][j]);\n\
    \                }\n                if(j<m-1){\n                    dp[i][j][l+1]\
    \ = min(dp[i][j][l+1],dp[i][j+1][l]+grid[i][j]);\n                }\n        \
    \    }\n        }\n    }\n    std::vector<long> ans;\n    ans.push_back(dp[n-1][m-1][k]);\n\
    \    return ans;", "    int n = grid.size();\n    int m = grid[0].size();\n  \
    \  std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, -1)));\n\
    \    std::vector<std::vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 2; i\
    \ <= k; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l\
    \ = 0; l < m; l++) {\n                for (int d = 0; d < 4; d++) {\n        \
    \            int x = j + dir[d][0];\n                    int y = l + dir[d][1];\n\
    \                    if (x >= 0 && x < n && y >= 0 && y < m && dp[x][y][i - 1]\
    \ != -1) {\n                        if (dp[j][l][i] == -1 || dp[j][l][i] > dp[x][y][i\
    \ - 1] + grid[j][l]) {\n                            dp[j][l][i] = dp[x][y][i -\
    \ 1] + grid[j][l];\n                            path[j][l][i] = d;\n         \
    \               }\n                    }\n                }\n            }\n \
    \       }\n    }\n    int x = 0, y = 0;\n    for (int i = 0; i < n; i++) {\n \
    \       for (int j = 0; j < m; j++) {\n            if (dp[x][y][k] == -1 || dp[x][y][k]\
    \ > d", "    int n = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n\
    \    assert(k <= n * n);\n    std::vector<long> ans;\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k, 0)));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n         \
    \   if (i == 0 && j == 0) {\n                dp[i][j] = 0;\n                path[i][j][0]\
    \ = grid[i][j];\n            } else if (i == 0) {\n                dp[i][j] =\
    \ dp[i][j - 1] + 1;\n                path[i][j] = path[i][j - 1];\n          \
    \      path[i][j][dp[i][j]] = grid[i][j];\n            } else if (j == 0) {\n\
    \                dp[i][j] = dp[i - 1][j] + 1;\n                path[i][j] = path[i\
    \ - 1][j];\n                path[i][j][dp[i][j]] = grid[i][j];\n            }\
    \ else {\n                if (dp[i - 1][j] < dp[i][j - 1]) {\n               \
    \     dp[i][j] = dp[i - 1][j] + 1;\n                    path[i][j] = path[i -\
    \ 1][j];\n                    path[i][j][dp[i][j]] = grid[i][j];\n           \
    \     } else if (dp[i - 1][j] > dp[i][j - 1]) {\n                    dp[i][j]\
    \ = dp[i][j - 1] + 1;\n                    path[i][j] = path[i][j - 1];\n    \
    \                path[i][j][dp[i][j]] = grid[i][j];\n                } else {",
  "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>> dp(n,\
    \ std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0 && dp[i - 1][j][l - 1] != -1) {\n\
    \                    if (dp[i][j][l] == -1 || dp[i - 1][j][l - 1] < dp[i][j][l])\
    \ {\n                        dp[i][j][l] = dp[i - 1][j][l - 1];\n            \
    \            path[i][j][l] = 0;\n                    }\n                }\n  \
    \              if (i < n - 1 && dp[i + 1][j][l - 1] != -1) {\n               \
    \     if (dp[i][j][l] == -1 || dp[i + 1][j][l - 1] < dp[i][j][l]) {\n        \
    \                dp[i][j][l] = dp[i + 1][j][l - 1];\n                        path[i][j][l]\
    \ = 1;\n                    }\n                }\n                if (j > 0 &&\
    \ dp[i][j - 1][l - 1] != -1) {\n                    if (dp[i][j][l] == -1 || dp[i][j\
    \ - 1][l - 1] < dp[i][j][l]) {\n                        dp[i][j][l] = dp[i", " \
    \   int n = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n    assert(k\
    \ <= n * n);\n    std::vector<long> ans;\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    int x = 0, y = 0;\n    for (int i = 0; i < n; i++)\
    \ {\n        for (int j = 0; j < n; j++) {\n            if (dp[i][j][k] < dp[x][y][k])\
    \ {\n                x = i;\n                y = j;\n            }\n        }\n\
    \    }\n    ans.push_back(grid[x][y]);\n    for (", "    int n = grid.size();\n\
    \    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<long>\
    \ ans;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++)\
    \ {\n            assert(grid[i][j] >= 1);\n            assert(grid[i][j] <= n\
    \ * n);\n        }\n    }\n    std::vector<std::vector<std::vector<long>>> dp(n,\
    \ std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ path(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>())));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n         \
    \   path[i][j][1].push_back(grid[i][j]);\n        }\n    }\n    for (int l = 2;\
    \ l <= k; l++) {\n        for (int i = 0; i < n; i++) {\n            for (int\
    \ j = 0; j < n; j++) {\n                for (int x = 0; x < n; x++) {\n      \
    \              for (int y = 0; y < n; y++) {\n                        if (x ==\
    \ i && y == j) {\n                            continue;\n                    \
    \    }\n                        if (abs(x - i) + abs(y - j) != 1) {\n        \
    \                    continue;\n                        }\n                  \
    \      if (dp[x][y][l - 1] == -1) {\n                            continue;\n \
    \                       }\n                        if (dp[i][j][l] == -1 || dp[i][j][l]\
    \ > dp[x][y][l - 1] + grid[i][j]) {\n                            dp[i][j][", " \
    \   int n = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n    assert(k\
    \ <= n * n);\n    std::vector<long> ans;\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    int x = 0, y = 0;\n    for (int i = 0; i < n; i++)\
    \ {\n        for (int j = 0; j < n; j++) {\n            if (dp[i][j][k] < dp[x][y][k])\
    \ {\n                x = i;\n                y = j;\n            }\n        }\n\
    \    }\n    ans.push_back(grid[x][y]);\n    for (", "    int n = grid.size();\n\
    \    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ prev(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(2, -1))));\n    for (int i = 0; i < n; i++) {\n     \
    \   for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n   \
    \     }\n    }\n    for (int l = 2; l <= k; l++) {\n        for (int i = 0; i\
    \ < n; i++) {\n            for (int j = 0; j < n; j++) {\n                for\
    \ (int di = -1; di <= 1; di++) {\n                    for (int dj = -1; dj <=\
    \ 1; dj++) {\n                        if (di == 0 && dj == 0) {\n            \
    \                continue;\n                        }\n                      \
    \  int ni = i + di;\n                        int nj = j + dj;\n              \
    \          if (ni < 0 || ni >= n || nj < 0 || nj >= n) {\n                   \
    \         continue;\n                        }\n                        if (dp[ni][nj][l\
    \ - 1] == -1) {\n                            continue;\n                     \
    \   }\n                        if (dp[i][j][l] == -1 || dp[i][j][l] > dp[ni][nj][l\
    \ - 1] || (dp[i][j][l] == dp[ni][nj][l - 1] && grid[i][j] < grid[prev[i][j][l][0]][prev[i][j][l][1]]))\
    \ {\n                            dp[i][j][l] = dp[ni][nj][l - 1];\n          \
    \                  prev[i][j][l][0] = ni;\n                            prev[i][j][l][1]\
    \ = n", "    // Your code here\n    // return (std::vector<long>({(long)0}));\n\
    \    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, 0)));\n   \
    \ for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n     \
    \       dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n;\
    \ i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l = 2; l\
    \ <= k; l++) {\n                if (i - 1 >= 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i + 1 < n) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j - 1 >= 0) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j + 1 < m) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    std::vector<long> ans;\n    for (int i = 0; i < n;\
    \ i++) {\n        for (int j = 0; j < m; j++) {\n            if (dp[i][j][k] ==\
    \ 0) {\n                ans = {grid[i][j]};\n                int x = i, y = j;\n\
    \                for (int l = k - 1; l >= 1; l--) {\n                    if (",
  "    int n = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n    assert(k\
    \ <= n * n);\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<long>> path(n,\
    \ std::vector<long>(n, -1));\n    std::vector<std::vector<long>> dir = {{0, 1},\
    \ {0, -1}, {1, 0}, {-1, 0}};\n    for (int i = 0; i < n; ++i) {\n        for (int\
    \ j = 0; j < n; ++j) {\n            dp[i][j][1] = grid[i][j];\n        }\n   \
    \ }\n    for (int l = 2; l <= k; ++l) {\n        for (int i = 0; i < n; ++i) {\n\
    \            for (int j = 0; j < n; ++j) {\n                for (int d = 0; d\
    \ < 4; ++d) {\n                    int x = i + dir[d][0];\n                  \
    \  int y = j + dir[d][1];\n                    if (x >= 0 && x < n && y >= 0 &&\
    \ y < n && dp[x][y][l - 1] != -1) {\n                        if (dp[i][j][l] ==\
    \ -1 || dp[i][j][l] > dp[x][y][l - 1] * 10 + grid[i][j]) {\n                 \
    \           dp[i][j][l] = dp[x][y][l - 1] * 10 + grid[i][j];\n               \
    \             path[i][j] = d;\n                        }\n                   \
    \ }\n                }\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    int x = 0, y = 0;\n    for (int i = 0; i < k; ++i) {\n        ans.push_back(grid[x][y]);\n\
    \        int d = path[x][y];\n        x +=", "    int n = grid.size();\n    assert(n\
    \ >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<long>\
    \ ans;\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, 0));\n \
    \   std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, 0)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j] = grid[i][j];\n            path[i][j][1]\
    \ = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n; i++) {\n       \
    \ for (int j = 0; j < n; j++) {\n            for (int l = 2; l <= k; l++) {\n\
    \                long min_val = INT_MAX;\n                if (i > 0) {\n     \
    \               if (dp[i - 1][j] < min_val) {\n                        min_val\
    \ = dp[i - 1][j];\n                        path[i][j][l] = path[i - 1][j][l -\
    \ 1];\n                    }\n                }\n                if (i < n - 1)\
    \ {\n                    if (dp[i + 1][j] < min_val) {\n                     \
    \   min_val = dp[i + 1][j];\n                        path[i][j][l] = path[i +\
    \ 1][j][l - 1];\n                    }\n                }\n                if\
    \ (j > 0) {\n                    if (dp[i][j - 1] < min_val) {\n             \
    \           min_val = dp[i][j - 1];\n                        path[i][j][l] = path[i][j\
    \ - 1][l - 1];\n                    }\n                }\n                if (j\
    \ < n - 1) {\n                    if (dp[i][j + 1] < min_val) {\n            \
    \            min_val = dp[i][j + 1];\n                        path[i", "    int\
    \ n = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <=\
    \ n * n);\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1, -1)));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ prev(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(2, -1))));\n    std::vector<std::vector<long>> dirs =\
    \ {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    for (int i = 0; i < n; ++i) {\n   \
    \     for (int j = 0; j < n; ++j) {\n            dp[i][j][1] = grid[i][j];\n \
    \       }\n    }\n    for (int l = 2; l <= k; ++l) {\n        for (int i = 0;\
    \ i < n; ++i) {\n            for (int j = 0; j < n; ++j) {\n                for\
    \ (int d = 0; d < 4; ++d) {\n                    int ni = i + dirs[d][0];\n  \
    \                  int nj = j + dirs[d][1];\n                    if (ni < 0 ||\
    \ ni >= n || nj < 0 || nj >= n) {\n                        continue;\n       \
    \             }\n                    if (dp[ni][nj][l - 1] == -1) {\n        \
    \                continue;\n                    }\n                    if (dp[i][j][l]\
    \ == -1 || dp[i][j][l] > dp[ni][nj][l - 1]) {\n                        dp[i][j][l]\
    \ = dp[ni][nj][l - 1];\n                        prev[i][j][l][0] = ni;\n     \
    \                   prev[i][j][l][1] = nj;\n                    }\n          \
    \      }\n            }\n        }\n    }\n   ", "    int n = grid.size();\n \
    \   int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>> dp(n,\
    \ std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n   \
    \ for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n     \
    \       dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n;\
    \ i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l = 2; l\
    \ <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < m - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    long\
    \ min_val = INT_MAX;\n    int min_i = -1;\n    int min_j = -1;\n    for (int i\
    \ = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (dp[i][j][k]\
    \ < min_val) {\n                min_val = dp[i][j][k];\n                min_i\
    \ = i;\n                min_j = j;", "    // Write your code here\n    std::vector<long>\
    \ result;\n    int n = grid.size();\n    int m = grid[0].size();\n    int visited[n][m];\n\
    \    int path[n][m];\n    for(int i = 0; i < n; i++){\n        for(int j = 0;\
    \ j < m; j++){\n            visited[i][j] = 0;\n            path[i][j] = 0;\n\
    \        }\n    }\n    int x = 0, y = 0;\n    for(int i = 0; i < n; i++){\n  \
    \      for(int j = 0; j < m; j++){\n            if(grid[i][j] == 1){\n       \
    \         x = i;\n                y = j;\n                break;\n           \
    \ }\n        }\n    }\n    std::queue<std::pair<int, int>> q;\n    q.push(std::make_pair(x,\
    \ y));\n    visited[x][y] = 1;\n    path[x][y] = 1;\n    while(!q.empty()){\n\
    \        std::pair<int, int> p = q.front();\n        q.pop();\n        int i =\
    \ p.first;\n        int j = p.second;\n        if(i > 0 && visited[i-1][j] ==\
    \ 0){\n            q.push(std::make_pair(i-1, j));\n            visited[i-1][j]\
    \ = 1;\n            path[i-1][j] = path[i][j] + 1;\n        }\n        if(i <\
    \ n-1 && visited[i+1][j] == 0){\n            q.push(std::make_pair(i+1, j));\n\
    \            visited[i+1][j] = 1;\n            path[i+1][j] = path[i][j] + 1;\n\
    \        }\n        if(j > 0 && visited[i][j-1] == 0){\n            q.push(std::make_pair(i,\
    \ j-1));\n            visited[i][j-1] = 1;\n            path[i][j-1] = path[i",
  "    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, 0)));\n   \
    \ std::vector<std::vector<std::vector<long>>> prev(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, 0)));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, 0)));\n \
    \   for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n   \
    \         dp[i][j][1] = grid[i][j];\n            path[i][j][1] = grid[i][j];\n\
    \        }\n    }\n    for (int l = 2; l <= k; l++) {\n        for (int i = 0;\
    \ i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                dp[i][j][l]\
    \ = INT_MAX;\n                for (int x = 0; x < n; x++) {\n                \
    \    for (int y = 0; y < m; y++) {\n                        if (dp[x][y][l - 1]\
    \ + grid[i][j] < dp[i][j][l]) {\n                            dp[i][j][l] = dp[x][y][l\
    \ - 1] + grid[i][j];\n                            prev[i][j][l] = x * m + y;\n\
    \                            path[i][j][l] = grid[i][j];\n                   \
    \     } else if (dp[x][y][l - 1] + grid[i][j] == dp[i][j][l]) {\n            \
    \                if (path[x][y][l - 1] < path[i][j][l]) {\n                  \
    \              prev[i][j][l] = x * m + y;\n                                path[i][j",
  "    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, 0)));\n   \
    \ for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n     \
    \       dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 1; i < k;\
    \ i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l = 0; l\
    \ < m; l++) {\n                long min = INT_MAX;\n                if (j - 1\
    \ >= 0) {\n                    min = std::min(min, dp[j - 1][l][i]);\n       \
    \         }\n                if (j + 1 < n) {\n                    min = std::min(min,\
    \ dp[j + 1][l][i]);\n                }\n                if (l - 1 >= 0) {\n  \
    \                  min = std::min(min, dp[j][l - 1][i]);\n                }\n\
    \                if (l + 1 < m) {\n                    min = std::min(min, dp[j][l\
    \ + 1][i]);\n                }\n                dp[j][l][i + 1] = min;\n     \
    \       }\n        }\n    }\n    std::vector<long> ans;\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (dp[i][j][k]\
    \ == INT_MAX) {\n                continue;\n            }\n            if (ans.size()\
    \ == 0) {\n                ans = dp[i][j];\n            } else {\n           \
    \     for (int l = 0; l < k; l++) {\n                    if (ans[l] < dp[i][j][l])\
    \ {\n                        break;\n                    }\n                 \
    \   if (ans[l] > dp[i][j][l]) {\n                        ans = dp[i][j];", " \
    \   int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(m, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(m, std::vector<long>(k, 0)));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n         \
    \   if (i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n        \
    \        path[i][j][0] = grid[i][j];\n            } else if (i == 0) {\n     \
    \           dp[i][j] = dp[i][j - 1] + grid[i][j];\n                path[i][j]\
    \ = path[i][j - 1];\n                path[i][j][0] = grid[i][j];\n           \
    \ } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                path[i][j] = path[i - 1][j];\n                path[i][j][0] =\
    \ grid[i][j];\n            } else {\n                if (dp[i - 1][j] < dp[i][j\
    \ - 1]) {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n       \
    \             path[i][j] = path[i - 1][j];\n                    path[i][j][0]\
    \ = grid[i][j];\n                } else if (dp[i - 1][j] > dp[i][j - 1]) {\n \
    \                   dp[i][j] = dp[i][j - 1] + grid[i][j];\n                  \
    \  path[i][j] = path[i][j - 1];\n                    path[i][j][0] = grid[i][j];\n\
    \                } else {\n                    dp[i][j] = dp[i - 1][j] + grid",
  "    std::vector<long> result;\n    return result;", "    int n = grid.size();\n\
    \    assert(n >= 2);\n    assert(k >= 1);\n    assert(n * n >= k);\n    std::vector<long>\
    \ ans;\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n\
    \    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k + 1)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            dp[i][j] = grid[i][j];\n            path[i][j][1]\
    \ = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n; i++) {\n       \
    \ for (int j = 0; j < n; j++) {\n            for (int l = 2; l <= k; l++) {\n\
    \                if (i > 0 && dp[i - 1][j] < dp[i][j]) {\n                   \
    \ dp[i][j] = dp[i - 1][j];\n                    path[i][j][l] = path[i - 1][j][l\
    \ - 1];\n                }\n                if (j > 0 && dp[i][j - 1] < dp[i][j])\
    \ {\n                    dp[i][j] = dp[i][j - 1];\n                    path[i][j][l]\
    \ = path[i][j - 1][l - 1];\n                }\n                if (i < n - 1 &&\
    \ dp[i + 1][j] < dp[i][j]) {\n                    dp[i][j] = dp[i + 1][j];\n \
    \                   path[i][j][l] = path[i + 1][j][l - 1];\n                }\n\
    \                if (j < n - 1 && dp[i][j + 1] < dp[i][j]) {\n               \
    \     dp[i][j] = dp[i][j + 1];\n                    path[i][j][l] = path["]
stop_tokens:
- "\n}"
