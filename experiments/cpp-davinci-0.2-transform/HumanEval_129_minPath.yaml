name: HumanEval_129_minPath
language: cpp
prompt: "#include<assert.h>\n#include<bits/stdc++.h>\n// Given a grid with N rows\
  \ and N columns (N >= 2) and a positive integer k, \n// each cell of the grid contains\
  \ a value. Every integer in the range [1, N * N]\n// inclusive appears exactly once\
  \ on the cells of the grid.\n// You have to find the minimum path of length k in\
  \ the grid. You can start\n// from any cell, and in each step you can move to any\
  \ of the neighbor cells,\n// in other words, you can go to cells which share an\
  \ edge with you current\n// cell.\n// Please note that a path of length k means\
  \ visiting exactly k cells (not\n// necessarily distinct).\n// You CANNOT go off\
  \ the grid.\n// A path A (of length k) is considered less than a path B (of length\
  \ k) if\n// after making the ordered lists of the values on the cells that A and\
  \ B go\n// through (let's call them lst_A and lst_B), lst_A is lexicographically\
  \ less\n// than lst_B, in other words, there exist an integer index i (1 <= i <=\
  \ k)\n// such that lst_A[i] < lst_B[i] and for any j (1 <= j < i) we have\n// lst_A[j]\
  \ = lst_B[j].\n// It is guaranteed that the answer is unique.\n// Return an ordered\
  \ list of the values on the cells that the minimum path go through.\n// Examples:\
  \    \n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}),\
  \ (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3))\n//\
  \ (std::vector<long>({(long)1, (long)2, (long)1}))\n// >>> minPath((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5,\
  \ (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}),\
  \ (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1))\n//\
  \ (std::vector<long>({(long)1}))\nstd::vector<long> minPath(std::vector<std::vector<long>>\
  \ grid, long k) {\n"
tests: "}\nint main() {\n    auto candidate = minPath;\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)5, (long)6}),\
  \ (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)9})})), (3)) ==\
  \ (std::vector<long>({(long)1, (long)2, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)5,\
  \ (long)9, (long)3}), (std::vector<long>)std::vector<long>({(long)4, (long)1, (long)6}),\
  \ (std::vector<long>)std::vector<long>({(long)7, (long)8, (long)2})})), (1)) ==\
  \ (std::vector<long>({(long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2, (long)3, (long)4}), (std::vector<long>)std::vector<long>({(long)5, (long)6,\
  \ (long)7, (long)8}), (std::vector<long>)std::vector<long>({(long)9, (long)10, (long)11,\
  \ (long)12}), (std::vector<long>)std::vector<long>({(long)13, (long)14, (long)15,\
  \ (long)16})})), (4)) == (std::vector<long>({(long)1, (long)2, (long)1, (long)2})));\n\
  \    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6,\
  \ (long)4, (long)13, (long)10}), (std::vector<long>)std::vector<long>({(long)5,\
  \ (long)7, (long)12, (long)1}), (std::vector<long>)std::vector<long>({(long)3, (long)16,\
  \ (long)11, (long)15}), (std::vector<long>)std::vector<long>({(long)8, (long)14,\
  \ (long)9, (long)2})})), (7)) == (std::vector<long>({(long)1, (long)10, (long)1,\
  \ (long)10, (long)1, (long)10, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)8,\
  \ (long)14, (long)9, (long)2}), (std::vector<long>)std::vector<long>({(long)6, (long)4,\
  \ (long)13, (long)15}), (std::vector<long>)std::vector<long>({(long)5, (long)7,\
  \ (long)1, (long)12}), (std::vector<long>)std::vector<long>({(long)3, (long)10,\
  \ (long)11, (long)16})})), (5)) == (std::vector<long>({(long)1, (long)7, (long)1,\
  \ (long)7, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)11,\
  \ (long)8, (long)7, (long)2}), (std::vector<long>)std::vector<long>({(long)5, (long)16,\
  \ (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)9, (long)3, (long)15,\
  \ (long)6}), (std::vector<long>)std::vector<long>({(long)12, (long)13, (long)10,\
  \ (long)1})})), (9)) == (std::vector<long>({(long)1, (long)6, (long)1, (long)6,\
  \ (long)1, (long)6, (long)1, (long)6, (long)1})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)12,\
  \ (long)13, (long)10, (long)1}), (std::vector<long>)std::vector<long>({(long)9,\
  \ (long)3, (long)15, (long)6}), (std::vector<long>)std::vector<long>({(long)5, (long)16,\
  \ (long)14, (long)4}), (std::vector<long>)std::vector<long>({(long)11, (long)8,\
  \ (long)7, (long)2})})), (12)) == (std::vector<long>({(long)1, (long)6, (long)1,\
  \ (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6, (long)1, (long)6})));\n\
  \    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)2,\
  \ (long)7, (long)4}), (std::vector<long>)std::vector<long>({(long)3, (long)1, (long)5}),\
  \ (std::vector<long>)std::vector<long>({(long)6, (long)8, (long)9})})), (8)) ==\
  \ (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1,\
  \ (long)3})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)6,\
  \ (long)1, (long)5}), (std::vector<long>)std::vector<long>({(long)3, (long)8, (long)9}),\
  \ (std::vector<long>)std::vector<long>({(long)2, (long)7, (long)4})})), (8)) ==\
  \ (std::vector<long>({(long)1, (long)5, (long)1, (long)5, (long)1, (long)5, (long)1,\
  \ (long)5})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
  \ (long)2}), (std::vector<long>)std::vector<long>({(long)3, (long)4})})), (10))\
  \ == (std::vector<long>({(long)1, (long)2, (long)1, (long)2, (long)1, (long)2, (long)1,\
  \ (long)2, (long)1, (long)2})));\n    assert(candidate((std::vector<std::vector<long>>({(std::vector<long>)std::vector<long>({(long)1,\
  \ (long)3}), (std::vector<long>)std::vector<long>({(long)3, (long)2})})), (10))\
  \ == (std::vector<long>({(long)1, (long)3, (long)1, (long)3, (long)1, (long)3, (long)1,\
  \ (long)3, (long)1, (long)3})));\n}\n"
completions: ["    // Write your code here\n    int n = grid.size();\n    int m =\
    \ grid[0].size();\n    std::vector<std::vector<std::vector<long>>> dp(n, std::vector<std::vector<long>>(m,\
    \ std::vector<long>(k + 1, 0)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < m; j++) {\n            for (int l = 0; l <= k; l++) {\n    \
    \            dp[i][j][l] = INT_MAX;\n            }\n        }\n    }\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n         \
    \   dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int l = 2; l <= k; l++)\
    \ {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m;\
    \ j++) {\n                if (i > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i - 1][j][l - 1]);\n                }\n                if (i < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n\
    \                }\n                if (j > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n                }\n         \
    \       if (j < m - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j + 1][l - 1]);\n                }\n                dp[i][j][l] += grid[i][j];\n\
    \            }\n        }\n    }\n    std::vector<long> ans;\n    long min_val\
    \ = INT_MAX;\n    for (int i = 0; i < n;", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    for (int\
    \ i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            dp[i][j][1]\
    \ = grid[i][j];\n            path[i][j][1].push_back(grid[i][j]);\n        }\n\
    \    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++)\
    \ {\n            for (int l = 2; l <= k; l++) {\n                for (int x =\
    \ 0; x < n; x++) {\n                    for (int y = 0; y < n; y++) {\n      \
    \                  if (dp[x][y][l - 1] != -1) {\n                            if\
    \ (i == x && j == y) {\n                                continue;\n          \
    \                  }\n                            if (std::abs(i - x) + std::abs(j\
    \ - y) != 1) {\n                                continue;\n                  \
    \          }\n                            if (dp[i][j][l] == -1 || dp[i][j][l]\
    \ > dp[x][y][l - 1] + grid[i][j]) {\n                                dp[i][j][l]\
    \ = dp[x][y][l - 1] + grid[i][j];\n                                path[i][j][l]\
    \ = path[x][y][l - 1];\n                                path[i][j][l].push_back(grid[i][j]);\n\
    \                            }\n                        }\n                  \
    \  }\n                }\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    for (int", "    int n = grid.size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>(k, 0)));\n    dp[0][0]\
    \ = grid[0][0];\n    path[0][0][0] = grid[0][0];\n    for (int i = 0; i < n; i++)\
    \ {\n        for (int j = 0; j < n; j++) {\n            if (i > 0) {\n       \
    \         if (dp[i][j] > dp[i - 1][j] + grid[i][j]) {\n                    dp[i][j]\
    \ = dp[i - 1][j] + grid[i][j];\n                    path[i][j] = path[i - 1][j];\n\
    \                    path[i][j][0] = grid[i][j];\n                } else if (dp[i][j]\
    \ == dp[i - 1][j] + grid[i][j]) {\n                    if (path[i][j] > path[i\
    \ - 1][j]) {\n                        path[i][j] = path[i - 1][j];\n         \
    \               path[i][j][0] = grid[i][j];\n                    }\n         \
    \       }\n            }\n            if (j > 0) {\n                if (dp[i][j]\
    \ > dp[i][j - 1] + grid[i][j]) {\n                    dp[i][j] = dp[i][j - 1]\
    \ + grid[i][j];\n                    path[i][j] = path[i][j - 1];\n          \
    \          path[i][j][0] = grid[i][j];\n                } else if (dp[i][j] ==\
    \ dp[i][j - 1] + grid[i][j]) {\n                    if (path[i][j] > path[i][j\
    \ - 1]) {\n                        path[i][j] = path[i][j - 1];\n            \
    \            path[i][j][0] =", "    int n = grid.size();\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ dp(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(k + 1, INT_MAX))));\n    for (int i = 0; i < n; i++)\
    \ {\n        for (int j = 0; j < n; j++) {\n            dp[i][j][1][grid[i][j]]\
    \ = grid[i][j];\n        }\n    }\n    for (int i = 0; i < n; i++) {\n       \
    \ for (int j = 0; j < n; j++) {\n            for (int l = 1; l <= k; l++) {\n\
    \                for (int m = 1; m <= k; m++) {\n                    if (i > 0)\
    \ {\n                        if (dp[i - 1][j][l][m] != INT_MAX) {\n          \
    \                  dp[i][j][l][m] = std::min(dp[i][j][l][m], dp[i - 1][j][l][m]);\n\
    \                        }\n                    }\n                    if (j >\
    \ 0) {\n                        if (dp[i][j - 1][l][m] != INT_MAX) {\n       \
    \                     dp[i][j][l][m] = std::min(dp[i][j][l][m], dp[i][j - 1][l][m]);\n\
    \                        }\n                    }\n                    if (i <\
    \ n - 1) {\n                        if (dp[i + 1][j][l][m] != INT_MAX) {\n   \
    \                         dp[i][j][l][m] = std::min(dp[i][j][l][m], dp[i + 1][j][l][m]);\n\
    \                        }\n                    }\n                    if (j <\
    \ n - 1) {\n                        if (dp[i][j + 1][l][m] != INT_MAX) {\n   \
    \                         dp[i][j][l][m] = std::min(dp[i][j][l][m], dp[i", " \
    \   int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(m,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    std::vector<std::vector<long>>\
    \ dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    std::function<long(int, int,\
    \ int)> dfs = [&](int x, int y, int k) {\n        if (k == 0) return 0;\n    \
    \    if (dp[x][y][k] != -1) return dp[x][y][k];\n        long ans = INT_MAX;\n\
    \        for (int i = 0; i < 4; i++) {\n            int nx = x + dir[i][0];\n\
    \            int ny = y + dir[i][1];\n            if (nx < 0 || nx >= n || ny\
    \ < 0 || ny >= m) continue;\n            long tmp = dfs(nx, ny, k - 1);\n    \
    \        if (tmp < ans) {\n                ans = tmp;\n                path[x][y][k]\
    \ = path[nx][ny][k - 1];\n                path[x][y][k].push_back(grid[x][y]);\n\
    \            }\n        }\n        dp[x][y][k] = ans + grid[x][y];\n        return\
    \ dp[x][y][k];\n    };\n    long ans = INT_MAX;\n    std::vector<long> res;\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          long tmp = dfs(i, j, k);\n            if (tmp < ans) {\n          \
    \      ans = tmp;", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<int>> dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n \
    \   std::vector<long> ans;\n    std::function<long(int, int, int)> dfs = [&](int\
    \ x, int y, int step) {\n        if (step == 0) return 0;\n        if (dp[x][y][step]\
    \ != -1) return dp[x][y][step];\n        long res = INT_MAX;\n        for (auto\
    \ d : dir) {\n            int nx = x + d[0], ny = y + d[1];\n            if (nx\
    \ < 0 || nx >= n || ny < 0 || ny >= n) continue;\n            res = std::min(res,\
    \ dfs(nx, ny, step - 1) + grid[nx][ny]);\n        }\n        return dp[x][y][step]\
    \ = res;\n    };\n    long min_val = INT_MAX;\n    for (int i = 0; i < n; ++i)\
    \ {\n        for (int j = 0; j < n; ++j) {\n            min_val = std::min(min_val,\
    \ dfs(i, j, k));\n        }\n    }\n    for (int i = 0; i < n; ++i) {\n      \
    \  for (int j = 0; j < n; ++j) {\n            if (dp[i][j][k] == min_val) {\n\
    \                ans.push_back(grid[i][j]);\n                k--;\n          \
    \      if (k == 0) return ans;\n                for (auto d : dir) {\n       \
    \             int nx = i + d[0], ny = j + d[1];\n                    if (nx <\
    \ 0 || nx >= n || ny < 0 || ny >= n) continue;\n                    if (dp[nx][ny",
  "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>> dp(n,\
    \ std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n   \
    \ for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n     \
    \       dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int l = 2; l <=\
    \ k; l++) {\n        for (int i = 0; i < n; i++) {\n            for (int j = 0;\
    \ j < n; j++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    std::vector<long>\
    \ res(k);\n    res[k - 1] = dp[0][0][k];\n    int i = 0, j = 0;\n    for (int\
    \ l = k - 1; l >= 1; l--) {\n        if (i > 0 && dp[i - 1][j][l] == res[l] -\
    \ grid[i][j]) {\n            res[l - 1] = dp[i - 1][j][l];\n            i--;\n\
    \        } else if (", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    std::vector<std::vector<long>>\
    \ dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    for (int i = 0; i < n; i++) {\n\
    \        for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n\
    \            path[i][j][1].push_back(grid[i][j]);\n        }\n    }\n    for (int\
    \ l = 2; l <= k; l++) {\n        for (int i = 0; i < n; i++) {\n            for\
    \ (int j = 0; j < n; j++) {\n                for (int d = 0; d < 4; d++) {\n \
    \                   int x = i + dir[d][0];\n                    int y = j + dir[d][1];\n\
    \                    if (x < 0 || x >= n || y < 0 || y >= n) continue;\n     \
    \               if (dp[x][y][l - 1] == -1) continue;\n                    if (dp[i][j][l]\
    \ == -1 || dp[x][y][l - 1] < dp[i][j][l]) {\n                        dp[i][j][l]\
    \ = dp[x][y][l - 1];\n                        path[i][j][l] = path[x][y][l - 1];\n\
    \                        path[i][j][l].push_back(grid[i][j]);\n              \
    \      }\n                }\n            }\n        }\n    }\n    std::vector<long>\
    \ ans;\n    for (int i = 0; i < n; i++) {\n       ", "    int n = grid.size();\n\
    \    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(n, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(n, std::vector<long>()));\n    for (int\
    \ i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            if\
    \ (i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n             \
    \   path[i][j].push_back(grid[i][j]);\n            } else if (i == 0) {\n    \
    \            dp[i][j] = dp[i][j - 1] + grid[i][j];\n                path[i][j]\
    \ = path[i][j - 1];\n                path[i][j].push_back(grid[i][j]);\n     \
    \       } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                path[i][j] = path[i - 1][j];\n                path[i][j].push_back(grid[i][j]);\n\
    \            } else {\n                if (dp[i - 1][j] < dp[i][j - 1]) {\n  \
    \                  dp[i][j] = dp[i - 1][j] + grid[i][j];\n                   \
    \ path[i][j] = path[i - 1][j];\n                    path[i][j].push_back(grid[i][j]);\n\
    \                } else if (dp[i - 1][j] > dp[i][j - 1]) {\n                 \
    \   dp[i][j] = dp[i][j - 1] + grid[i][j];\n                    path[i][j] = path[i][j\
    \ - 1];\n                    path[i][j].push_back(grid[i][j]);\n             \
    \   } else {\n                    dp", "    int n = grid.size();\n    assert(n\
    \ >= 2);\n    assert(n == grid[0].size());\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    std::vector<std::vector<long>>\
    \ dir = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n    for (int i = 0; i < n; ++i) {\n\
    \        for (int j = 0; j < n; ++j) {\n            dp[i][j][1] = grid[i][j];\n\
    \            path[i][j][1].push_back(grid[i][j]);\n        }\n    }\n    for (int\
    \ l = 2; l <= k; ++l) {\n        for (int i = 0; i < n; ++i) {\n            for\
    \ (int j = 0; j < n; ++j) {\n                for (int d = 0; d < 4; ++d) {\n \
    \                   int x = i + dir[d][0];\n                    int y = j + dir[d][1];\n\
    \                    if (x < 0 || x >= n || y < 0 || y >= n) continue;\n     \
    \               if (dp[x][y][l - 1] == -1) continue;\n                    if (dp[i][j][l]\
    \ == -1 || dp[x][y][l - 1] < dp[i][j][l]) {\n                        dp[i][j][l]\
    \ = dp[x][y][l - 1];\n                        path[i][j][l] = path[x][y][l - 1];\n\
    \                        path[i][j][l].push_back(grid[i][j]);\n              \
    \      }\n                }\n            }\n        }\n    }\n   ", "    int n\
    \ = grid.size();\n    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n\
    \ * n);\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, -1));\n\
    \    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>()));\n    std::vector<std::vector<std::vector<long>>> path_grid(n,\
    \ std::vector<std::vector<long>>(n, std::vector<long>()));\n    for (int i = 0;\
    \ i < n; i++) {\n        for (int j = 0; j < n; j++) {\n            path_grid[i][j].push_back(grid[i][j]);\n\
    \        }\n    }\n    for (int i = 0; i < n; i++) {\n        for (int j = 0;\
    \ j < n; j++) {\n            if (i == 0 && j == 0) {\n                dp[i][j]\
    \ = 0;\n                path[i][j] = path_grid[i][j];\n            } else if (i\
    \ == 0) {\n                dp[i][j] = dp[i][j - 1] + 1;\n                path[i][j]\
    \ = path[i][j - 1];\n                path[i][j].insert(path[i][j].end(), path_grid[i][j].begin(),\
    \ path_grid[i][j].end());\n            } else if (j == 0) {\n                dp[i][j]\
    \ = dp[i - 1][j] + 1;\n                path[i][j] = path[i - 1][j];\n        \
    \        path[i][j].insert(path[i][j].end(), path_grid[i][j].begin(), path_grid[i][j].end());\n\
    \            } else {\n                if (dp[i - 1][j] < dp[i][j - 1]) {\n  \
    \                  dp[i][j] = dp[i - 1][j] + 1;\n                    path[i][j",
  "    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<long>>\
    \ dp(n, std::vector<long>(m, INT_MAX));\n    std::vector<std::vector<std::vector<long>>>\
    \ path(n, std::vector<std::vector<long>>(m, std::vector<long>(k, 0)));\n    for\
    \ (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n         \
    \   if (i == 0 && j == 0) {\n                dp[i][j] = grid[i][j];\n        \
    \        path[i][j][0] = grid[i][j];\n            } else if (i == 0) {\n     \
    \           dp[i][j] = dp[i][j - 1] + grid[i][j];\n                path[i][j]\
    \ = path[i][j - 1];\n                path[i][j][0] = grid[i][j];\n           \
    \ } else if (j == 0) {\n                dp[i][j] = dp[i - 1][j] + grid[i][j];\n\
    \                path[i][j] = path[i - 1][j];\n                path[i][j][0] =\
    \ grid[i][j];\n            } else {\n                if (dp[i - 1][j] < dp[i][j\
    \ - 1]) {\n                    dp[i][j] = dp[i - 1][j] + grid[i][j];\n       \
    \             path[i][j] = path[i - 1][j];\n                    path[i][j][0]\
    \ = grid[i][j];\n                } else if (dp[i - 1][j] > dp[i][j - 1]) {\n \
    \                   dp[i][j] = dp[i][j - 1] + grid[i][j];\n                  \
    \  path[i][j] = path[i][j - 1];\n                    path[i][j][0] = grid[i][j];\n\
    \                } else {\n                    dp[i][j] = dp[i - 1][j] + grid",
  "    int n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(m, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (j > 0) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i][j - 1][l - 1]);\n                }\n                if (i < n - 1) {\n\
    \                    dp[i][j][l] = std::min(dp[i][j][l], dp[i + 1][j][l - 1]);\n\
    \                }\n                if (j < m - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \       dp[i][j][l] += grid[i][j];\n            }\n        }\n    }\n    long\
    \ min = INT_MAX;\n    int min_i = -1;\n    int min_j = -1;\n    for (int i = 0;\
    \ i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            if (dp[i][j][k]\
    \ < min) {\n                min = dp[i][j][k];\n                min_i = i;\n \
    \               min_j = j;\n            }\n        }", "    int n = grid.size();\n\
    \    assert(n >= 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<long>\
    \ ans;\n    std::vector<std::vector<long>> dp(n, std::vector<long>(n, INT_MAX));\n\
    \    std::vector<std::vector<std::vector<long>>> path(n, std::vector<std::vector<long>>(n,\
    \ std::vector<long>(k, -1)));\n    for (int i = 0; i < n; i++) {\n        for\
    \ (int j = 0; j < n; j++) {\n            if (i == 0 && j == 0) {\n           \
    \     dp[i][j] = 0;\n                path[i][j][0] = grid[i][j];\n           \
    \ } else if (i == 0) {\n                dp[i][j] = dp[i][j - 1] + 1;\n       \
    \         path[i][j] = path[i][j - 1];\n                path[i][j][dp[i][j]] =\
    \ grid[i][j];\n            } else if (j == 0) {\n                dp[i][j] = dp[i\
    \ - 1][j] + 1;\n                path[i][j] = path[i - 1][j];\n               \
    \ path[i][j][dp[i][j]] = grid[i][j];\n            } else {\n                if\
    \ (dp[i - 1][j] < dp[i][j - 1]) {\n                    dp[i][j] = dp[i - 1][j]\
    \ + 1;\n                    path[i][j] = path[i - 1][j];\n                   \
    \ path[i][j][dp[i][j]] = grid[i][j];\n                } else if (dp[i - 1][j]\
    \ > dp[i][j - 1]) {\n                    dp[i][j] = dp[i][j - 1] + 1;\n      \
    \              path[i][j] = path[i][j - 1];\n                    path[i][j][dp[i][j]]\
    \ = grid[i][j];\n                } else", "    // Write your code here\n    int\
    \ n = grid.size();\n    int m = grid[0].size();\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ dp(n, std::vector<std::vector<std::vector<long>>>(m, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(2, INT_MAX))));\n    for (int i = 0; i < n; i++) {\n\
    \        for (int j = 0; j < m; j++) {\n            dp[i][j][1][0] = grid[i][j];\n\
    \            dp[i][j][1][1] = grid[i][j];\n        }\n    }\n    for (int i =\
    \ 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            for (int\
    \ l = 2; l <= k; l++) {\n                if (i - 1 >= 0) {\n                 \
    \   if (dp[i - 1][j][l - 1][0] < dp[i][j][l][0]) {\n                        dp[i][j][l][0]\
    \ = dp[i - 1][j][l - 1][0];\n                    }\n                    if (dp[i\
    \ - 1][j][l - 1][1] > dp[i][j][l][1]) {\n                        dp[i][j][l][1]\
    \ = dp[i - 1][j][l - 1][1];\n                    }\n                }\n      \
    \          if (i + 1 < n) {\n                    if (dp[i + 1][j][l - 1][0] <\
    \ dp[i][j][l][0]) {\n                        dp[i][j][l][0] = dp[i + 1][j][l -\
    \ 1][0];\n                    }\n                    if (dp[i + 1][j][l - 1][1]\
    \ > dp[i][j][l][1]) {\n                        dp[i][j][l][1] = dp[i + 1][j][l\
    \ - 1][1];\n                    }\n                }\n                if (j -\
    \ 1 >= 0", "    int n = grid.size();\n    assert(n >= 2);\n    assert(n == grid[0].size());\n\
    \    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> parent(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>(2, -1))));\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ path(n, std::vector<std::vector<std::vector<long>>>(n, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(2, -1))));\n    for (int i = 0; i < n; i++) {\n     \
    \   for (int j = 0; j < n; j++) {\n            dp[i][j][1] = grid[i][j];\n   \
    \         parent[i][j][1][0] = i;\n            parent[i][j][1][1] = j;\n     \
    \   }\n    }\n    for (int l = 2; l <= k; l++) {\n        for (int i = 0; i <\
    \ n; i++) {\n            for (int j = 0; j < n; j++) {\n                for (int\
    \ x = 0; x < n; x++) {\n                    for (int y = 0; y < n; y++) {\n  \
    \                      if (dp[x][y][l - 1] != -1) {\n                        \
    \    if (x == i && y == j) {\n                                continue;\n    \
    \                        }\n                            if (x == i && abs(y -\
    \ j) == 1) {\n                                if (dp[i][j][l] == -1 || dp[x][y][l\
    \ - 1] < dp[i][j][l]) {\n                                    dp[i][j][l] = dp",
  "    int n = grid.size();\n    std::vector<long> ans;\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, INT_MAX)));\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < n; j++) {\n  \
    \          dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int i = 0; i\
    \ < n; i++) {\n        for (int j = 0; j < n; j++) {\n            for (int l =\
    \ 2; l <= k; l++) {\n                if (i > 0) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i - 1][j][l - 1]);\n                }\n         \
    \       if (i < n - 1) {\n                    dp[i][j][l] = std::min(dp[i][j][l],\
    \ dp[i + 1][j][l - 1]);\n                }\n                if (j > 0) {\n   \
    \                 dp[i][j][l] = std::min(dp[i][j][l], dp[i][j - 1][l - 1]);\n\
    \                }\n                if (j < n - 1) {\n                    dp[i][j][l]\
    \ = std::min(dp[i][j][l], dp[i][j + 1][l - 1]);\n                }\n         \
    \   }\n        }\n    }\n    long min_val = INT_MAX;\n    for (int i = 0; i <\
    \ n; i++) {\n        for (int j = 0; j < n; j++) {\n            min_val = std::min(min_val,\
    \ dp[i][j][k]);\n        }\n    }\n    for (int i = 0; i < n; i++) {\n       \
    \ for (int j = 0; j < n; j++) {\n            if (dp[i][j][k] == min_val) {\n \
    \               ans.push_back(grid", "    int n = grid.size();\n    assert(n >=\
    \ 2);\n    assert(k >= 1);\n    assert(k <= n * n);\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> prev(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>(2, -1))));\n    for\
    \ (int i = 0; i < n; ++i) {\n        for (int j = 0; j < n; ++j) {\n         \
    \   dp[i][j][1] = grid[i][j];\n        }\n    }\n    for (int len = 2; len <=\
    \ k; ++len) {\n        for (int i = 0; i < n; ++i) {\n            for (int j =\
    \ 0; j < n; ++j) {\n                for (int di = -1; di <= 1; ++di) {\n     \
    \               for (int dj = -1; dj <= 1; ++dj) {\n                        if\
    \ (di == 0 && dj == 0) {\n                            continue;\n            \
    \            }\n                        int ni = i + di;\n                   \
    \     int nj = j + dj;\n                        if (ni < 0 || ni >= n || nj <\
    \ 0 || nj >= n) {\n                            continue;\n                   \
    \     }\n                        if (dp[ni][nj][len - 1] == -1) {\n          \
    \                  continue;\n                        }\n                    \
    \    if (dp[i][j][len] == -1 || dp[ni][nj][len - 1] < dp[i][j][len]) {\n     \
    \                       dp[i][j][len] = dp[ni][nj][len - 1];\n               \
    \             prev[i][j][len][0] = ni;\n                            prev[i][j][len][1]\
    \ = nj;\n                        }\n                    }\n                }\n\
    \            }\n        }\n    }\n   ", "    int n = grid.size();\n    std::vector<std::vector<std::vector<long>>>\
    \ dp(n, std::vector<std::vector<long>>(n, std::vector<long>(k + 1, -1)));\n  \
    \  std::vector<std::vector<std::vector<std::vector<long>>>> path(n, std::vector<std::vector<std::vector<long>>>(n,\
    \ std::vector<std::vector<long>>(k + 1, std::vector<long>())));\n    std::vector<std::vector<long>>\
    \ dir = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\n    std::function<long(int, int,\
    \ int)> dfs = [&](int x, int y, int step) {\n        if (step == 0) return 0;\n\
    \        if (dp[x][y][step] != -1) return dp[x][y][step];\n        long res =\
    \ INT_MAX;\n        for (auto d : dir) {\n            int nx = x + d[0], ny =\
    \ y + d[1];\n            if (nx < 0 || nx >= n || ny < 0 || ny >= n) continue;\n\
    \            long tmp = dfs(nx, ny, step - 1) + grid[x][y];\n            if (tmp\
    \ < res) {\n                res = tmp;\n                path[x][y][step] = path[nx][ny][step\
    \ - 1];\n                path[x][y][step].push_back(grid[x][y]);\n           \
    \ }\n        }\n        return dp[x][y][step] = res;\n    };\n    long res = INT_MAX;\n\
    \    std::vector<long> ans;\n    for (int i = 0; i < n; ++i) {\n        for (int\
    \ j = 0; j < n; ++j) {\n            long tmp = dfs(i, j, k);\n            if (tmp\
    \ < res) {\n                res = tmp;\n                ans = path[i][j][k];\n\
    \            }\n        }\n    }\n    return ans;", "    int n = grid.size();\n\
    \    int m = grid[0].size();\n    std::vector<std::vector<std::vector<std::vector<long>>>>\
    \ dp(n, std::vector<std::vector<std::vector<long>>>(m, std::vector<std::vector<long>>(k\
    \ + 1, std::vector<long>(2, -1))));\n    std::vector<std::vector<long>> path(n,\
    \ std::vector<long>(m, -1));\n    std::vector<std::vector<long>> dir = {{0, 1},\
    \ {0, -1}, {1, 0}, {-1, 0}};\n    std::vector<long> res;\n    for (int i = 0;\
    \ i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            dp[i][j][1][0]\
    \ = grid[i][j];\n            dp[i][j][1][1] = grid[i][j];\n        }\n    }\n\
    \    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n  \
    \          for (int l = 2; l <= k; l++) {\n                for (int d = 0; d <\
    \ 4; d++) {\n                    int x = i + dir[d][0];\n                    int\
    \ y = j + dir[d][1];\n                    if (x >= 0 && x < n && y >= 0 && y <\
    \ m) {\n                        if (dp[x][y][l - 1][0] != -1) {\n            \
    \                if (dp[i][j][l][0] == -1 || dp[i][j][l][0] > dp[x][y][l - 1][0]\
    \ + grid[i][j]) {\n                                dp[i][j][l][0] = dp[x][y][l\
    \ - 1][0] + grid[i][j];\n                                dp[i][j][l][1] = dp[x][y][l\
    \ - 1][1] + grid[i][j];\n                                path[i][j] = d;\n   \
    \                         } else"]
stop_tokens:
- "\n}"
