language: cpp
name: HumanEval_1_separate_paren_groups
results:
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int open = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n    \
    \    if (paren_string[i] == '(') {\n            open++;\n            temp += paren_string[i];\n\
    \        } else if (paren_string[i] == ')') {\n            open--;\n         \
    \   temp += paren_string[i];\n        }\n        if (open == 0 && temp.size()\
    \ > 0) {\n            result.push_back(temp);\n            temp = \"\";\n    \
    \    }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwd2xvnk0.cpp: In function 'int main()':\n/tmp/tmpwd2xvnk0.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwd2xvnk0.cpp:2:\n/tmp/tmpwd2xvnk0.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpwd2xvnk0.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpwd2xvnk0.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpwd2xvnk0.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpwd2xvnk0.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpwd2xvnk0.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n  std::vector<std::string> result;\n  std::string temp;\n \
    \ int count = 0;\n  for (int i = 0; i < paren_string.size(); i++) {\n    if (paren_string[i]\
    \ == '(') {\n      count++;\n      temp.push_back(paren_string[i]);\n    } else\
    \ if (paren_string[i] == ')') {\n      count--;\n      temp.push_back(paren_string[i]);\n\
    \    }\n    if (count == 0 && temp.size() > 0) {\n      result.push_back(temp);\n\
    \      temp.clear();\n    }\n  }\n  return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp5d7jcots.cpp: In function 'int main()':\n/tmp/tmp5d7jcots.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp5d7jcots.cpp:2:\n/tmp/tmp5d7jcots.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmp5d7jcots.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmp5d7jcots.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmp5d7jcots.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp5d7jcots.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp5d7jcots.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    int open = 0;\n \
    \   int close = 0;\n    std::string temp;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            open++;\n       \
    \     temp += paren_string[i];\n        }\n        else if (paren_string[i] ==\
    \ ')') {\n            close++;\n            temp += paren_string[i];\n       \
    \ }\n        if (open == close) {\n            result.push_back(temp);\n     \
    \       temp = \"\";\n            open = 0;\n            close = 0;\n        }\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp1ep1ge3w.cpp: In function 'int main()':\n/tmp/tmp1ep1ge3w.cpp:33:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp1ep1ge3w.cpp:2:\n/tmp/tmp1ep1ge3w.cpp:34:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmp1ep1ge3w.cpp:34:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmp1ep1ge3w.cpp:34:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmp1ep1ge3w.cpp:34:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp1ep1ge3w.cpp:34:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp1ep1ge3w.cpp:34:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n\tstd::vector<std::string> result;\n\tstd::string temp;\n\t\
    int open = 0;\n\tfor (int i = 0; i < paren_string.length(); i++) {\n\t\tif (paren_string[i]\
    \ == '(') {\n\t\t\topen++;\n\t\t\ttemp += paren_string[i];\n\t\t}\n\t\telse if\
    \ (paren_string[i] == ')') {\n\t\t\topen--;\n\t\t\ttemp += paren_string[i];\n\t\
    \t}\n\t\tif (open == 0 && temp.length() > 0) {\n\t\t\tresult.push_back(temp);\n\
    \t\t\ttemp = \"\";\n\t\t}\n\t}\n\treturn result;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmphqipxei8.cpp: In function 'int main()':\n/tmp/tmphqipxei8.cpp:30:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmphqipxei8.cpp:2:\n/tmp/tmphqipxei8.cpp:31:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmphqipxei8.cpp:31:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmphqipxei8.cpp:31:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmphqipxei8.cpp:31:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmphqipxei8.cpp:31:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmphqipxei8.cpp:31:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp\
    \ = \"\";\n    int count = 0;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \      temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            count--;\n            temp += paren_string[i];\n        }\n     \
    \   if (count == 0 && temp != \"\") {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_8d600_7.cpp: In function 'int main()':\n/tmp/tmp_8d600_7.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_8d600_7.cpp:2:\n/tmp/tmp_8d600_7.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmp_8d600_7.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmp_8d600_7.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    int start = 0;\n\
    \    int end = 0;\n    int count = 0;\n    for (int i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \  } else if (paren_string[i] == ')') {\n            count--;\n        }\n   \
    \     if (count == 0) {\n            end = i;\n            result.push_back(paren_string.substr(start,\
    \ end - start + 1));\n            start = end + 1;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpamtsyyy4.cpp: In function 'int main()':\n/tmp/tmpamtsyyy4.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpamtsyyy4.cpp:2:\n/tmp/tmpamtsyyy4.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpamtsyyy4.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpamtsyyy4.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpamtsyyy4.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpamtsyyy4.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpamtsyyy4.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    int i = 0;\n    int\
    \ j = 0;\n    int count = 0;\n    while (i < paren_string.length()) {\n      \
    \  if (paren_string[i] == '(') {\n            count++;\n        } else if (paren_string[i]\
    \ == ')') {\n            count--;\n        }\n        if (count == 0) {\n    \
    \        result.push_back(paren_string.substr(j, i - j + 1));\n            j =\
    \ i + 1;\n        }\n        i++;\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpah7_klv6.cpp: In function 'int main()':\n/tmp/tmpah7_klv6.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpah7_klv6.cpp:2:\n/tmp/tmpah7_klv6.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpah7_klv6.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpah7_klv6.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpah7_klv6.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpah7_klv6.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpah7_klv6.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string current_string;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            current_string\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            current_string += paren_string[i];\n        }\n   \
    \     if (count == 0 && current_string.length() > 0) {\n            result.push_back(current_string);\n\
    \            current_string = \"\";\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpe7_x9l48.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp.push_back(paren_string[i]);\n\
    \        } else if (paren_string[i] == ')') {\n            count--;\n        \
    \    temp.push_back(paren_string[i]);\n        }\n        if (count == 0 && temp.length()\
    \ > 0) {\n            result.push_back(temp);\n            temp.clear();\n   \
    \     }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp37gvme54.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stk;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            stk.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            stk.pop();\n\
    \            temp += paren_string[i];\n        }\n        else {\n           \
    \ temp += paren_string[i];\n        }\n        if(stk.empty()) {\n           \
    \ result.push_back(temp);\n            temp = \"\";\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpauefivfz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp.push_back(paren_string[i]);\n\
    \        } else if (paren_string[i] == ')') {\n            count--;\n        \
    \    temp.push_back(paren_string[i]);\n        }\n        if (count == 0 && temp.length()\
    \ > 0) {\n            result.push_back(temp);\n            temp.clear();\n   \
    \     }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp37gvme54.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            st.push(paren_string[i]);\n  \
    \      }\n        else if(paren_string[i]==')'){\n            st.pop();\n    \
    \    }\n        if(st.empty()){\n            result.push_back(temp);\n       \
    \     temp.clear();\n        }\n        else{\n            temp+=paren_string[i];\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpc7663yqf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int open = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n  \
    \      if (paren_string[i] == '(') {\n            open++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ open--;\n            temp += paren_string[i];\n        }\n        if (open ==\
    \ 0 && temp.length() > 0) {\n            result.push_back(temp);\n           \
    \ temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpp_amdazj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp\
    \ = \"\";\n    int count = 0;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \      temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            count--;\n            temp += paren_string[i];\n        }\n     \
    \   if (count == 0 && temp != \"\") {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_8d600_7.cpp: In function 'int main()':\n/tmp/tmp_8d600_7.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_8d600_7.cpp:2:\n/tmp/tmp_8d600_7.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmp_8d600_7.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmp_8d600_7.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int open = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n  \
    \      if (paren_string[i] == '(') {\n            open++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ open--;\n            temp += paren_string[i];\n        }\n        if (open ==\
    \ 0 && temp.length() > 0) {\n            result.push_back(temp);\n           \
    \ temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpp_amdazj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int open = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n  \
    \      if (paren_string[i] == '(') {\n            open++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ open--;\n            temp += paren_string[i];\n        }\n        if (open ==\
    \ 0 && temp.length() > 0) {\n            result.push_back(temp);\n           \
    \ temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n    auto\
    \ candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) ()\
    \ ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpp_amdazj.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stk;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            stk.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            stk.pop();\n\
    \            temp += paren_string[i];\n        }\n        else {\n           \
    \ temp += paren_string[i];\n        }\n        if(stk.empty()) {\n           \
    \ result.push_back(temp);\n            temp = \"\";\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpauefivfz.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    int start = 0;\n\
    \    int end = 0;\n    int count = 0;\n    for (int i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \  } else if (paren_string[i] == ')') {\n            count--;\n        }\n   \
    \     if (count == 0) {\n            end = i;\n            result.push_back(paren_string.substr(start,\
    \ end - start + 1));\n            start = end + 1;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpamtsyyy4.cpp: In function 'int main()':\n/tmp/tmpamtsyyy4.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpamtsyyy4.cpp:2:\n/tmp/tmpamtsyyy4.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpamtsyyy4.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpamtsyyy4.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpamtsyyy4.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpamtsyyy4.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpamtsyyy4.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string current_group;\n\
    \    int open_paren_count = 0;\n    for (int i = 0; i < paren_string.size(); i++)\
    \ {\n        if (paren_string[i] == '(') {\n            open_paren_count++;\n\
    \            current_group += paren_string[i];\n        } else if (paren_string[i]\
    \ == ')') {\n            open_paren_count--;\n            current_group += paren_string[i];\n\
    \            if (open_paren_count == 0) {\n                result.push_back(current_group);\n\
    \                current_group = \"\";\n            }\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp319mu290.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int open = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n    \
    \    if (paren_string[i] == '(') {\n            open++;\n            temp += paren_string[i];\n\
    \        } else if (paren_string[i] == ')') {\n            open--;\n         \
    \   temp += paren_string[i];\n        }\n        if (open == 0 && temp.size()\
    \ > 0) {\n            result.push_back(temp);\n            temp = \"\";\n    \
    \    }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwd2xvnk0.cpp: In function 'int main()':\n/tmp/tmpwd2xvnk0.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwd2xvnk0.cpp:2:\n/tmp/tmpwd2xvnk0.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpwd2xvnk0.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpwd2xvnk0.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpwd2xvnk0.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpwd2xvnk0.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpwd2xvnk0.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> groups;\n    std::string group;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            group\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            group += paren_string[i];\n        }\n        if (count\
    \ == 0 && group.length() > 0) {\n            groups.push_back(group);\n      \
    \      group = \"\";\n        }\n    }\n    return groups;\n}\nint main() {\n\
    \    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmps2j1hh64.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            st.push(paren_string[i]);\n  \
    \      }\n        else if(paren_string[i]==')'){\n            st.pop();\n    \
    \    }\n        if(st.empty()){\n            result.push_back(temp);\n       \
    \     temp=\"\";\n        }\n        else{\n            temp+=paren_string[i];\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9w8xm2p5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> res;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            res.push_back(temp);\n            temp\
    \ = \"\";\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpehe5cjf5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp\
    \ = \"\";\n    int count = 0;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \      temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            count--;\n            temp += paren_string[i];\n        }\n     \
    \   if (count == 0 && temp != \"\") {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_8d600_7.cpp: In function 'int main()':\n/tmp/tmp_8d600_7.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_8d600_7.cpp:2:\n/tmp/tmp_8d600_7.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmp_8d600_7.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmp_8d600_7.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int open = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n    \
    \    if (paren_string[i] == '(') {\n            open++;\n            temp += paren_string[i];\n\
    \        } else if (paren_string[i] == ')') {\n            open--;\n         \
    \   temp += paren_string[i];\n        }\n        if (open == 0 && temp.size()\
    \ > 0) {\n            result.push_back(temp);\n            temp = \"\";\n    \
    \    }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwd2xvnk0.cpp: In function 'int main()':\n/tmp/tmpwd2xvnk0.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwd2xvnk0.cpp:2:\n/tmp/tmpwd2xvnk0.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpwd2xvnk0.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpwd2xvnk0.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpwd2xvnk0.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpwd2xvnk0.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpwd2xvnk0.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            st.push(paren_string[i]);\n  \
    \      }\n        else if(paren_string[i]==')'){\n            st.pop();\n    \
    \    }\n        if(st.empty()){\n            result.push_back(temp);\n       \
    \     temp=\"\";\n        }\n        else{\n            temp+=paren_string[i];\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp9w8xm2p5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string str;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n        }\n     \
    \   if (paren_string[i] == ')') {\n            count--;\n        }\n        if\
    \ (count == 0 && paren_string[i] == ')') {\n            result.push_back(str);\n\
    \            str = \"\";\n        }\n        if (paren_string[i] != ' ') {\n \
    \           str += paren_string[i];\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpz2r5fzrf.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp\
    \ = \"\";\n    int count = 0;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \      temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            count--;\n            temp += paren_string[i];\n        }\n     \
    \   if (count == 0 && temp != \"\") {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_8d600_7.cpp: In function 'int main()':\n/tmp/tmp_8d600_7.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_8d600_7.cpp:2:\n/tmp/tmp_8d600_7.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmp_8d600_7.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmp_8d600_7.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp\
    \ = \"\";\n    int count = 0;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \      temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            count--;\n            temp += paren_string[i];\n        }\n     \
    \   if (count == 0 && temp != \"\") {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_8d600_7.cpp: In function 'int main()':\n/tmp/tmp_8d600_7.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_8d600_7.cpp:2:\n/tmp/tmp_8d600_7.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmp_8d600_7.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmp_8d600_7.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp\
    \ = \"\";\n    int count = 0;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \      temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            count--;\n            temp += paren_string[i];\n        }\n     \
    \   if (count == 0 && temp != \"\") {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_8d600_7.cpp: In function 'int main()':\n/tmp/tmp_8d600_7.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_8d600_7.cpp:2:\n/tmp/tmp_8d600_7.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmp_8d600_7.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmp_8d600_7.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> paren_groups;\n    std::string\
    \ group;\n    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++)\
    \ {\n        if (paren_string[i] == '(') {\n            count++;\n           \
    \ group += paren_string[i];\n        } else if (paren_string[i] == ')') {\n  \
    \          count--;\n            group += paren_string[i];\n        }\n      \
    \  if (count == 0 && group.length() > 0) {\n            paren_groups.push_back(group);\n\
    \            group = \"\";\n        }\n    }\n    return paren_groups;\n}\nint\
    \ main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpdwsfowkm.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp\
    \ = \"\";\n    int count = 0;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \      temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            count--;\n            temp += paren_string[i];\n        }\n     \
    \   if (count == 0 && temp != \"\") {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_8d600_7.cpp: In function 'int main()':\n/tmp/tmp_8d600_7.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_8d600_7.cpp:2:\n/tmp/tmp_8d600_7.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmp_8d600_7.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmp_8d600_7.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int open = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n    \
    \    if (paren_string[i] == '(') {\n            open++;\n            temp.push_back(paren_string[i]);\n\
    \        } else if (paren_string[i] == ')') {\n            open--;\n         \
    \   temp.push_back(paren_string[i]);\n        }\n        if (open == 0 && temp.size()\
    \ > 0) {\n            result.push_back(temp);\n            temp.clear();\n   \
    \     }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpj4wdc7pn.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    int start = 0;\n\
    \    int end = 0;\n    int count = 0;\n    for (int i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            if (count == 0) {\n\
    \                start = i;\n            }\n            count++;\n        } else\
    \ if (paren_string[i] == ')') {\n            count--;\n            if (count ==\
    \ 0) {\n                end = i;\n                result.push_back(paren_string.substr(start,\
    \ end - start + 1));\n            }\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpystf0vlc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp\
    \ = \"\";\n    int count = 0;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \      temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            count--;\n            temp += paren_string[i];\n        }\n     \
    \   if (count == 0 && temp != \"\") {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_8d600_7.cpp: In function 'int main()':\n/tmp/tmp_8d600_7.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_8d600_7.cpp:2:\n/tmp/tmp_8d600_7.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmp_8d600_7.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmp_8d600_7.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            st.push(paren_string[i]);\n  \
    \      }\n        else if(paren_string[i]==')'){\n            st.pop();\n    \
    \    }\n        else{\n            continue;\n        }\n        if(st.empty()){\n\
    \            result.push_back(temp);\n            temp.clear();\n        }\n \
    \       else{\n            temp+=paren_string[i];\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0t7d6cjg.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    int open_count =\
    \ 0;\n    int close_count = 0;\n    std::string temp;\n    for (int i = 0; i <\
    \ paren_string.length(); i++) {\n        if (paren_string[i] == '(') {\n     \
    \       open_count++;\n            temp += paren_string[i];\n        } else if\
    \ (paren_string[i] == ')') {\n            close_count++;\n            temp +=\
    \ paren_string[i];\n        }\n        if (open_count == close_count) {\n    \
    \        result.push_back(temp);\n            temp = \"\";\n            open_count\
    \ = 0;\n            close_count = 0;\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpfxohwc_n.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp.push_back(paren_string[i]);\n\
    \        } else if (paren_string[i] == ')') {\n            count--;\n        \
    \    temp.push_back(paren_string[i]);\n        }\n        if (count == 0 && temp.length()\
    \ > 0) {\n            result.push_back(temp);\n            temp.clear();\n   \
    \     }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp37gvme54.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp\
    \ = \"\";\n    int count = 0;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \      temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            count--;\n            temp += paren_string[i];\n        }\n     \
    \   if (count == 0 && temp != \"\") {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_8d600_7.cpp: In function 'int main()':\n/tmp/tmp_8d600_7.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_8d600_7.cpp:2:\n/tmp/tmp_8d600_7.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmp_8d600_7.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmp_8d600_7.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n  std::vector<std::string> result;\n  std::stack<char> st;\n\
    \  std::string temp;\n  for(int i=0;i<paren_string.length();i++){\n    if(paren_string[i]=='('){\n\
    \      st.push(paren_string[i]);\n    }\n    else if(paren_string[i]==')'){\n\
    \      st.pop();\n      if(st.empty()){\n        result.push_back(temp);\n   \
    \     temp=\"\";\n      }\n    }\n    else if(paren_string[i]!=' '){\n      temp+=paren_string[i];\n\
    \    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpfr_op1o4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int open_count = 0;\n    for (int i = 0; i < paren_string.length(); i++)\
    \ {\n        if (paren_string[i] == '(') {\n            open_count++;\n      \
    \      temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            open_count--;\n            temp += paren_string[i];\n        }\n\
    \        if (open_count == 0 && temp.length() > 0) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmps55ecv83.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n  std::vector<std::string> result;\n  std::string temp;\n \
    \ int count = 0;\n  for (int i = 0; i < paren_string.size(); i++) {\n    if (paren_string[i]\
    \ == '(') {\n      count++;\n      temp += paren_string[i];\n    } else if (paren_string[i]\
    \ == ')') {\n      count--;\n      temp += paren_string[i];\n    }\n    if (count\
    \ == 0 && temp.size() > 0) {\n      result.push_back(temp);\n      temp = \"\"\
    ;\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpf6etx58w.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> res;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            count++;\n            temp +=\
    \ paren_string[i];\n        } else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.size() > 0) {\n            res.push_back(temp);\n            temp\
    \ = \"\";\n        }\n    }\n    return res;\n}\nint main() {\n    auto candidate\
    \ = separate_paren_groups;\n    assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpehe5cjf5.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ s;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n \
    \       if(paren_string[i]=='('){\n            s.push(paren_string[i]);\n    \
    \    }\n        else if(paren_string[i]==')'){\n            s.pop();\n       \
    \ }\n        else{\n            continue;\n        }\n        if(s.empty()){\n\
    \            result.push_back(temp);\n            temp=\"\";\n        }\n    \
    \    else{\n            temp+=paren_string[i];\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmppul59bew.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp\
    \ = \"\";\n    int count = 0;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \      temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            count--;\n            temp += paren_string[i];\n        }\n     \
    \   if (count == 0 && temp != \"\") {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_8d600_7.cpp: In function 'int main()':\n/tmp/tmp_8d600_7.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_8d600_7.cpp:2:\n/tmp/tmp_8d600_7.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmp_8d600_7.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmp_8d600_7.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp.push_back(paren_string[i]);\n\
    \        } else if (paren_string[i] == ')') {\n            count--;\n        \
    \    temp.push_back(paren_string[i]);\n        }\n        if (count == 0 && temp.length()\
    \ > 0) {\n            result.push_back(temp);\n            temp.clear();\n   \
    \     }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp37gvme54.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp.push_back(paren_string[i]);\n\
    \        } else if (paren_string[i] == ')') {\n            count--;\n        \
    \    temp.push_back(paren_string[i]);\n        }\n        if (count == 0 && temp.length()\
    \ > 0) {\n            result.push_back(temp);\n            temp.clear();\n   \
    \     }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp37gvme54.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += '(';\n        }\n        else if (paren_string[i] == ')') {\n           \
    \ count--;\n            temp += ')';\n        }\n        if (count == 0 && temp.length()\
    \ > 0) {\n            result.push_back(temp);\n            temp = \"\";\n    \
    \    }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp8yd0zd5h.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    int start = 0;\n\
    \    int end = 0;\n    int count = 0;\n    for (int i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \  } else if (paren_string[i] == ')') {\n            count--;\n        }\n   \
    \     if (count == 0) {\n            end = i;\n            result.push_back(paren_string.substr(start,\
    \ end - start + 1));\n            start = end + 1;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpamtsyyy4.cpp: In function 'int main()':\n/tmp/tmpamtsyyy4.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpamtsyyy4.cpp:2:\n/tmp/tmpamtsyyy4.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpamtsyyy4.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpamtsyyy4.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpamtsyyy4.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpamtsyyy4.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpamtsyyy4.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    int start = 0;\n\
    \    int end = 0;\n    int count = 0;\n    for (int i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            if (count == 0) {\n\
    \                start = i;\n            }\n            count++;\n        } else\
    \ if (paren_string[i] == ')') {\n            count--;\n            if (count ==\
    \ 0) {\n                end = i;\n                result.push_back(paren_string.substr(start,\
    \ end - start + 1));\n            }\n        }\n    }\n    return result;\n}\n\
    int main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpystf0vlc.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp\
    \ = \"\";\n    int count = 0;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \      temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            count--;\n            temp += paren_string[i];\n        }\n     \
    \   if (count == 0 && temp != \"\") {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_8d600_7.cpp: In function 'int main()':\n/tmp/tmp_8d600_7.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_8d600_7.cpp:2:\n/tmp/tmp_8d600_7.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmp_8d600_7.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmp_8d600_7.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stk;\n    int start = 0;\n    for (int i = 0; i < paren_string.size(); i++)\
    \ {\n        if (paren_string[i] == '(') {\n            stk.push(paren_string[i]);\n\
    \        } else if (paren_string[i] == ')') {\n            stk.pop();\n      \
    \  }\n        if (stk.empty()) {\n            result.push_back(paren_string.substr(start,\
    \ i - start + 1));\n            start = i + 1;\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpdxxc34i7.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n  std::vector<std::string> result;\n  std::string temp;\n \
    \ int count = 0;\n  for (int i = 0; i < paren_string.size(); i++) {\n    if (paren_string[i]\
    \ == '(') {\n      count++;\n      temp += paren_string[i];\n    } else if (paren_string[i]\
    \ == ')') {\n      count--;\n      temp += paren_string[i];\n    }\n    if (count\
    \ == 0 && temp.size() > 0) {\n      result.push_back(temp);\n      temp = \"\"\
    ;\n    }\n  }\n  return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpf6etx58w.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> res;\n    std::stack<char> st;\n\
    \    int start = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n   \
    \     if (paren_string[i] == '(') {\n            st.push(paren_string[i]);\n \
    \       } else if (paren_string[i] == ')') {\n            st.pop();\n        }\n\
    \        if (st.empty()) {\n            res.push_back(paren_string.substr(start,\
    \ i - start + 1));\n            start = i + 1;\n        }\n    }\n    return res;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpu0lkbnqd.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    // TODO: implement this function\n    std::vector<std::string>\
    \ result;\n    std::string temp;\n    int count = 0;\n    for (int i = 0; i <\
    \ paren_string.size(); i++) {\n        if (paren_string[i] == '(') {\n       \
    \     count++;\n            temp += paren_string[i];\n        }\n        else\
    \ if (paren_string[i] == ')') {\n            count--;\n            temp += paren_string[i];\n\
    \        }\n        if (count == 0 && temp.size() > 0) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpo1rkaimu.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            st.push(paren_string[i]);\n  \
    \      }\n        else if(paren_string[i]==')'){\n            if(st.top()=='('){\n\
    \                st.pop();\n                temp+=paren_string[i];\n         \
    \   }\n            else{\n                st.push(paren_string[i]);\n        \
    \    }\n        }\n        if(st.empty()){\n            result.push_back(temp);\n\
    \            temp=\"\";\n        }\n    }\n    return result;\n}\nint main() {\n\
    \    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpumn20kg6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n\
    \        if(paren_string[i]=='('){\n            st.push(paren_string[i]);\n  \
    \      }\n        else if(paren_string[i]==')'){\n            st.pop();\n    \
    \        if(st.empty()){\n                result.push_back(temp);\n          \
    \      temp.clear();\n            }\n        }\n        else if(paren_string[i]!='\
    \ '){\n            temp+=paren_string[i];\n        }\n    }\n    return result;\n\
    }\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp17j5di5_.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ s;\n    std::string temp = \"\";\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            s.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            s.pop();\n\
    \            temp += paren_string[i];\n        }\n        else if(paren_string[i]\
    \ == ' ') {\n            continue;\n        }\n        else {\n            temp\
    \ += paren_string[i];\n        }\n        if(s.empty()) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpcs8fs4hq.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stack;\n    std::string temp;\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            stack.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            stack.pop();\n\
    \        }\n        else {\n            continue;\n        }\n        temp +=\
    \ paren_string[i];\n        if(stack.empty()) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpkpbf2jch.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ st;\n    std::string temp = \"\";\n    for(int i = 0; i < paren_string.length();\
    \ i++) {\n        if(paren_string[i] == '(') {\n            st.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            if(st.empty())\
    \ {\n                continue;\n            }\n            else {\n          \
    \      st.pop();\n                temp += paren_string[i];\n            }\n  \
    \      }\n        else {\n            continue;\n        }\n        if(st.empty())\
    \ {\n            result.push_back(temp);\n            temp = \"\";\n        }\n\
    \    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpell_iupd.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ s;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n \
    \       if(paren_string[i]=='('){\n            s.push(paren_string[i]);\n    \
    \    }\n        else if(paren_string[i]==')'){\n            if(s.empty()){\n \
    \               return result;\n            }\n            else{\n           \
    \     s.pop();\n                temp+=paren_string[i];\n            }\n      \
    \  }\n        else{\n            continue;\n        }\n        if(s.empty()){\n\
    \            result.push_back(temp);\n            temp=\"\";\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpq7r9kvrv.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp\
    \ = \"\";\n    int count = 0;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \      temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            count--;\n            temp += paren_string[i];\n        }\n     \
    \   if (count == 0 && temp != \"\") {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_8d600_7.cpp: In function 'int main()':\n/tmp/tmp_8d600_7.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_8d600_7.cpp:2:\n/tmp/tmp_8d600_7.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmp_8d600_7.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmp_8d600_7.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string curr_string;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            curr_string\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            curr_string += paren_string[i];\n        }\n      \
    \  if (count == 0 && curr_string.length() > 0) {\n            result.push_back(curr_string);\n\
    \            curr_string = \"\";\n        }\n    }\n    return result;\n}\nint\
    \ main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmp0a46vss6.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ stk;\n    std::string temp;\n    for(int i = 0; i < paren_string.length(); i++)\
    \ {\n        if(paren_string[i] == '(') {\n            stk.push(paren_string[i]);\n\
    \        }\n        else if(paren_string[i] == ')') {\n            stk.pop();\n\
    \            temp += paren_string[i];\n        }\n        else if(paren_string[i]\
    \ == ' ') {\n            continue;\n        }\n        else {\n            temp\
    \ += paren_string[i];\n        }\n        if(stk.empty()) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpbleu8ob4.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp\
    \ = \"\";\n    int count = 0;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \      temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            count--;\n            temp += paren_string[i];\n        }\n     \
    \   if (count == 0 && temp != \"\") {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_8d600_7.cpp: In function 'int main()':\n/tmp/tmp_8d600_7.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_8d600_7.cpp:2:\n/tmp/tmp_8d600_7.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmp_8d600_7.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmp_8d600_7.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::stack<char>\
    \ s;\n    std::string temp;\n    for(int i=0;i<paren_string.length();i++){\n \
    \       if(paren_string[i]=='('){\n            s.push(paren_string[i]);\n    \
    \    }\n        else if(paren_string[i]==')'){\n            s.pop();\n       \
    \ }\n        if(s.empty()){\n            result.push_back(temp);\n           \
    \ temp.clear();\n        }\n        else{\n            temp+=paren_string[i];\n\
    \        }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpr0imsvyd.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp\
    \ = \"\";\n    int count = 0;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \      temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            count--;\n            temp += paren_string[i];\n        }\n     \
    \   if (count == 0 && temp != \"\") {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_8d600_7.cpp: In function 'int main()':\n/tmp/tmp_8d600_7.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_8d600_7.cpp:2:\n/tmp/tmp_8d600_7.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmp_8d600_7.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmp_8d600_7.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int open_count = 0;\n    for (int i = 0; i < paren_string.length(); i++)\
    \ {\n        if (paren_string[i] == '(') {\n            open_count++;\n      \
    \      temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            open_count--;\n            temp += paren_string[i];\n        }\n\
    \        if (open_count == 0 && temp.length() > 0) {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmps55ecv83.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    int start = 0;\n\
    \    int end = 0;\n    int count = 0;\n    for (int i = 0; i < paren_string.size();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \  } else if (paren_string[i] == ')') {\n            count--;\n        }\n   \
    \     if (count == 0) {\n            end = i;\n            result.push_back(paren_string.substr(start,\
    \ end - start + 1));\n            start = end + 1;\n        }\n    }\n    return\
    \ result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"\
    (()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpamtsyyy4.cpp: In function 'int main()':\n/tmp/tmpamtsyyy4.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpamtsyyy4.cpp:2:\n/tmp/tmpamtsyyy4.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpamtsyyy4.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpamtsyyy4.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpamtsyyy4.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpamtsyyy4.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpamtsyyy4.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp\
    \ = \"\";\n    int count = 0;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \      temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            count--;\n            temp += paren_string[i];\n        }\n     \
    \   if (count == 0 && temp != \"\") {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_8d600_7.cpp: In function 'int main()':\n/tmp/tmp_8d600_7.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_8d600_7.cpp:2:\n/tmp/tmp_8d600_7.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmp_8d600_7.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmp_8d600_7.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int open = 0;\n    for (int i = 0; i < paren_string.size(); i++) {\n    \
    \    if (paren_string[i] == '(') {\n            open++;\n            temp += paren_string[i];\n\
    \        } else if (paren_string[i] == ')') {\n            open--;\n         \
    \   temp += paren_string[i];\n        }\n        if (open == 0 && temp.size()\
    \ > 0) {\n            result.push_back(temp);\n            temp = \"\";\n    \
    \    }\n    }\n    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpwd2xvnk0.cpp: In function 'int main()':\n/tmp/tmpwd2xvnk0.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpwd2xvnk0.cpp:2:\n/tmp/tmpwd2xvnk0.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpwd2xvnk0.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpwd2xvnk0.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpwd2xvnk0.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpwd2xvnk0.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpwd2xvnk0.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp\
    \ = \"\";\n    int count = 0;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \      temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            count--;\n            temp += paren_string[i];\n        }\n     \
    \   if (count == 0 && temp != \"\") {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_8d600_7.cpp: In function 'int main()':\n/tmp/tmp_8d600_7.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_8d600_7.cpp:2:\n/tmp/tmp_8d600_7.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmp_8d600_7.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmp_8d600_7.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp\
    \ = \"\";\n    int count = 0;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \      temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            count--;\n            temp += paren_string[i];\n        }\n     \
    \   if (count == 0 && temp != \"\") {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_8d600_7.cpp: In function 'int main()':\n/tmp/tmp_8d600_7.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_8d600_7.cpp:2:\n/tmp/tmp_8d600_7.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmp_8d600_7.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmp_8d600_7.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    int count = 0;\n\
    \    std::string temp = \"\";\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \      temp += paren_string[i];\n        }\n        else if (paren_string[i] ==\
    \ ')') {\n            count--;\n            temp += paren_string[i];\n       \
    \ }\n        if (count == 0 && temp != \"\") {\n            result.push_back(temp);\n\
    \            temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpkxsmg_dt.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp\
    \ = \"\";\n    int count = 0;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \      temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            count--;\n            temp += paren_string[i];\n        }\n     \
    \   if (count == 0 && temp != \"\") {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_8d600_7.cpp: In function 'int main()':\n/tmp/tmp_8d600_7.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_8d600_7.cpp:2:\n/tmp/tmp_8d600_7.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmp_8d600_7.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmp_8d600_7.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        } else if (paren_string[i]\
    \ == ' ') {\n            continue;\n        }\n        if (count == 0) {\n   \
    \         result.push_back(temp);\n            temp = \"\";\n        }\n    }\n\
    \    return result;\n}\nint main() {\n    auto candidate = separate_paren_groups;\n\
    \    assert(candidate((\"(()()) ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"\
    (()())\", (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"\
    })));\n    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "In file included from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/algorithm:61:0,\n\
    \                 from /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/x86_64-pc-linux-gnu/bits/stdc++.h:65,\n\
    \                 from /tmp/tmpbf_bvz7n.cpp:2:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_OI std::__copy_move_a(_II, _II, _OI)\u2019:\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueTypeI)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ error: there are no arguments to \u2018__is_trivially_copyable\u2019 that depend\
    \ on a template parameter, so a declaration of \u2018__is_trivially_copyable\u2019\
    \ must be available [-fpermissive]\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:398:65:\
    \ note: (if you use \u2018-fpermissive\u2019, G++ will accept your code, but allowing\
    \ the use of an undeclared name is deprecated)\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:403:40:\
    \ error: \u2018__simple\u2019 cannot appear in a constant-expression\n       return\
    \ std::__copy_move<_IsMove, __simple,\n                                      \
    \  ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:404:19:\
    \ error: template argument 2 is invalid\n          _Category>::__copy_m(__first,\
    \ __last, __result);\n                   ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:\
    \ In function \u2018_BI2 std::__copy_move_backward_a(_BI1, _BI1, _BI2)\u2019:\n\
    /shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: expected primary-expression before \u2018)\u2019 token\n       const\
    \ bool __simple = (__is_trivially_copyable(_ValueType1)\n                    \
    \                                             ^\n/shared/centos7/gcc/9.2.0-skylake/include/c++/9.2.0/bits/stl_algobase.h:600:65:\
    \ error: there are no arguments to \u2018__is_tri"
  stdout: ''
  timestamp: 1659747986
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp\
    \ = \"\";\n    int count = 0;\n    for (int i = 0; i < paren_string.length();\
    \ i++) {\n        if (paren_string[i] == '(') {\n            count++;\n      \
    \      temp += paren_string[i];\n        } else if (paren_string[i] == ')') {\n\
    \            count--;\n            temp += paren_string[i];\n        }\n     \
    \   if (count == 0 && temp != \"\") {\n            result.push_back(temp);\n \
    \           temp = \"\";\n        }\n    }\n    return result;\n}\nint main()\
    \ {\n    auto candidate = separate_paren_groups;\n    assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \    assert(candidate((\"() (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"\
    })));\n    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp_8d600_7.cpp: In function 'int main()':\n/tmp/tmp_8d600_7.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmp_8d600_7.cpp:2:\n/tmp/tmp_8d600_7.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmp_8d600_7.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmp_8d600_7.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmp_8d600_7.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Input to this function\
    \ is a string containing multiple groups of nested parentheses. Your goal is to\n\
    // separate those group into separate strings and return the list of those.\n\
    // Separate groups are balanced (each open brace is properly closed) and not nested\
    \ within each other\n// Ignore any spaces in the input string.\n// >>> separate_paren_groups((\"\
    ( ) (( )) (( )( ))\"))\n// (std::vector<std::string>({(std::string)\"()\", (std::string)\"\
    (())\", (std::string)\"(()())\"}))\nstd::vector<std::string> separate_paren_groups(std::string\
    \ paren_string) {\n    std::vector<std::string> result;\n    std::string temp;\n\
    \    int count = 0;\n    for (int i = 0; i < paren_string.length(); i++) {\n \
    \       if (paren_string[i] == '(') {\n            count++;\n            temp\
    \ += paren_string[i];\n        } else if (paren_string[i] == ')') {\n        \
    \    count--;\n            temp += paren_string[i];\n        }\n        if (count\
    \ == 0 && temp.length() > 0) {\n            result.push_back(temp);\n        \
    \    temp = \"\";\n        }\n    }\n    return result;\n}\nint main() {\n   \
    \ auto candidate = separate_paren_groups;\n    assert(candidate((\"(()()) ((()))\
    \ () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"\
    ((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n    assert(candidate((\"\
    () (()) ((())) (((())))\")) == (std::vector<std::string>({(std::string)\"()\"\
    , (std::string)\"(())\", (std::string)\"((()))\", (std::string)\"(((())))\"})));\n\
    \    assert(candidate((\"(()(())((())))\")) == (std::vector<std::string>({(std::string)\"\
    (()(())((())))\"})));\n    assert(candidate((\"( ) (( )) (( )( ))\")) == (std::vector<std::string>({(std::string)\"\
    ()\", (std::string)\"(())\", (std::string)\"(()())\"})));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpxn37vg84.cpp: In function 'int main()':\n/tmp/tmpxn37vg84.cpp:29:10:\
    \ error: 'candidate' does not name a type\n     auto candidate = separate_paren_groups;\n\
    \          ^\nIn file included from /usr/include/c++/4.8.2/cassert:43:0,\n   \
    \              from /usr/include/c++/4.8.2/x86_64-redhat-linux/bits/stdc++.h:33,\n\
    \                 from /tmp/tmpxn37vg84.cpp:2:\n/tmp/tmpxn37vg84.cpp:30:53: error:\
    \ 'candidate' was not declared in this scope\n     assert(candidate((\"(()())\
    \ ((())) () ((())()())\")) == (std::vector<std::string>({(std::string)\"(()())\"\
    , (std::string)\"((()))\", (std::string)\"()\", (std::string)\"((())()())\"})));\n\
    \                                                     ^\n/tmp/tmpxn37vg84.cpp:30:83:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                               ^\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ warning: extended initializer lists only available with -std=c++11 or -std=gnu++11\
    \ [enabled by default]\n     assert(candidate((\"(()()) ((())) () ((())()())\"\
    )) == (std::vector<std::string>({(std::string)\"(()())\", (std::string)\"((()))\"\
    , (std::string)\"()\", (std::string)\"((())()())\"})));\n                    \
    \                                                                            \
    \                                                                            \
    \    ^\n/tmp/tmpxn37vg84.cpp:30:176: warning: extended initializer lists only\
    \ available with -std=c++11 or -std=gnu++11 [enabled by default]\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ error: no matching function for call to 'std::vector<std::basic_string<char>\
    \ >::vector(<brace-enclosed initializer list>)'\n/tmp/tmpxn37vg84.cpp:30:176:\
    \ note: candidates are:\nIn file included from /usr/include/c++/4.8.2/vector:64:0,\n\
    \                 from /usr/include/c++/4.8.2/queue:61,\n                 from\
    \ /usr/include"
  stdout: ''
