language: cpp
name: HumanEval_99_closest_integer
results:
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    double d = std::stod(value);\n   \
    \ return std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  return std::stol(value);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp75ewq7ws: /tmp/tmp75ewq7ws.cpp:23: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double num = std::stod(value);\n  if\
    \ (num >= 0) {\n    return std::ceil(num);\n  } else {\n    return std::floor(num);\n\
    \  }\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpq8654kbq: /tmp/tmpq8654kbq.cpp:29: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065000
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  std::stringstream ss(value);\n  double\
    \ d;\n  ss >> d;\n  return round(d);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // your code here\n    double val\
    \ = std::stod(value);\n    if(val > 0)\n        return std::ceil(val);\n    else\n\
    \        return std::floor(val);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpd2pzqyr_: /tmp/tmpd2pzqyr_.cpp:29: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  double d = std::stod(value);\n\
    \  return std::round(d);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065000
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double num = std::stod(value);\n  double\
    \ floor_num = std::floor(num);\n  double ceil_num = std::ceil(num);\n  if (num\
    \ - floor_num < ceil_num - num) {\n    return floor_num;\n  } else {\n    return\
    \ ceil_num;\n  }\n}\nint main() {\n    auto candidate = closest_integer;\n   \
    \ assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpcl5514g8: /tmp/tmpcl5514g8.cpp:30: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double num = std::stod(value);\n  return\
    \ std::lround(num);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065000
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  double d = std::stod(value);\n\
    \  if (d < 0) {\n    return std::ceil(d);\n  }\n  return std::floor(d);\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpyd2ydq6e: /tmp/tmpyd2ydq6e.cpp:27: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065000
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  double d = std::stod(value);\n\
    \  if (d > 0) {\n    return std::ceil(d);\n  } else {\n    return std::floor(d);\n\
    \  }\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp9d8j6y_2: /tmp/tmp9d8j6y_2.cpp:30: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::round(d);\n}\nint main() {\n    auto candidate = closest_integer;\n   \
    \ assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double val = std::stod(value);\n  if\
    \ (val > 0) {\n    return std::ceil(val);\n  } else {\n    return std::floor(val);\n\
    \  }\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpcv2_2i1_: /tmp/tmpcv2_2i1_.cpp:29: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  long num = std::stol(value);\n\
    \  if (num < 0) {\n    return num - 0.5;\n  }\n  return num + 0.5;\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp5s6c7ev7: /tmp/tmp5s6c7ev7.cpp:27: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  long number = std::stol(value);\n  long\
    \ decimal = number - (long)number;\n  if (decimal >= 0.5) {\n    return (long)number\
    \ + 1;\n  } else {\n    return (long)number;\n  }\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpqd1slr4z: /tmp/tmpqd1slr4z.cpp:28: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  return 0;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp4fmgf70z: /tmp/tmp4fmgf70z.cpp:22: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  return std::round(std::stod(value));\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065000
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    double d = std::stod(value);\n   \
    \ return std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double val = std::stod(value);\n  return\
    \ std::round(val);\n}\nint main() {\n    auto candidate = closest_integer;\n \
    \   assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065000
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double num = std::stod(value);\n  return\
    \ std::lround(num);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065000
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ (long) (d > 0 ? std::floor(d) : std::ceil(d));\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmprs4incfm: /tmp/tmprs4incfm.cpp:23: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // Your code here\n  double d = std::stod(value);\n\
    \  if (d < 0) {\n    return std::ceil(d);\n  }\n  return std::floor(d);\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpi75ggkp4: /tmp/tmpi75ggkp4.cpp:27: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065000
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  double val = std::stod(value);\n\
    \  return std::round(val);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ (long)std::round(d);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double val = std::stod(value);\n  if\
    \ (val < 0) {\n    return std::ceil(val);\n  }\n  return std::floor(val);\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp127ako_3: /tmp/tmp127ako_3.cpp:26: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  int i = 0;\n  int len = value.length();\n\
    \  int num = 0;\n  int sign = 1;\n  if (value[0] == '-') {\n    sign = -1;\n \
    \   i++;\n  }\n  while (i < len) {\n    if (value[i] == '.') {\n      break;\n\
    \    }\n    num = num * 10 + (value[i] - '0');\n    i++;\n  }\n  if (i == len)\
    \ {\n    return num * sign;\n  }\n  i++;\n  int decimal = 0;\n  int decimal_len\
    \ = len - i;\n  while (i < len) {\n    decimal = decimal * 10 + (value[i] - '0');\n\
    \    i++;\n  }\n  if (decimal_len == 1) {\n    if (decimal >= 5) {\n      return\
    \ (num + 1) * sign;\n    }\n    return num * sign;\n  }\n  if (decimal_len ==\
    \ 2) {\n    if (decimal >= 50) {\n      return (num + 1) * sign;\n    }\n    return\
    \ num * sign;\n  }\n  if (decimal_len == 3) {\n    if (decimal >= 500) {\n   \
    \   return (num + 1) * sign;\n    }\n    return num * sign;\n  }\n  return num\
    \ * sign;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065000
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  return std::round(std::stod(value));\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065000
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  double d=std::stod(value);\n\
    \  long l=std::lround(d);\n  return l;\n}\nint main() {\n    auto candidate =\
    \ closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065001
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  int i = 0;\n  int j = 0;\n  int k =\
    \ 0;\n  int l = 0;\n  int m = 0;\n  int n = 0;\n  int o = 0;\n  int p = 0;\n \
    \ int q = 0;\n  int r = 0;\n  int s = 0;\n  int t = 0;\n  int u = 0;\n  int v\
    \ = 0;\n  int w = 0;\n  int x = 0;\n  int y = 0;\n  int z = 0;\n  int aa = 0;\n\
    \  int ab = 0;\n  int ac = 0;\n  int ad = 0;\n  int ae = 0;\n  int af = 0;\n \
    \ int ag = 0;\n  int ah = 0;\n  int ai = 0;\n  int aj = 0;\n  int ak = 0;\n  int\
    \ al = 0;\n  int am = 0;\n  int an = 0;\n  int ao = 0;\n  int ap = 0;\n  int aq\
    \ = 0;\n  int ar = 0;\n  int as = 0;\n  int at = 0;\n  int au = 0;\n  int av =\
    \ 0;\n  int aw = 0;\n  int ax = 0;\n  int ay = 0;\n  int az = 0;\n  int ba = 0;\n\
    \  int bb = 0;\n  int bc = 0;\n  int bd = 0;\n  int be = 0;\n  int bf = 0;\n \
    \ int bg = 0;\n  int bh = 0;\n  int bi = 0;\n  int bj = 0;\n  int bk = 0;\n  int\
    \ bl = 0;\n  int bm = 0;\n  int bn = 0;\n  int bo = 0;\n  int bp = 0;\n  int bq\
    \ = 0;\n  int br = 0;\n  int bs = 0;\n  int bt = 0;\n  int bu = 0;\n  int bv =\
    \ 0;\n  int bw = 0;\n  int bx = 0;\n  int by = 0;\n  int bz = 0\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmpihdxpbxm.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmpihdxpbxm.cpp:87:1: error: expected \u2018,\u2019 or \u2018;\u2019 before\
    \ \u2018}\u2019 token\n   87 | }\n      | ^\n/tmp/tmpihdxpbxm.cpp:87:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660065000
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    double num = std::stod(value);\n \
    \   return std::lround(num);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065001
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  double val = std::stod(value);\n\
    \  if (val < 0) {\n    val -= 0.5;\n  } else {\n    val += 0.5;\n  }\n  return\
    \ (long)val;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065001
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double num = std::stod(value);\n  long\
    \ rounded = std::lround(num);\n  return rounded;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065001
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  double d = std::stod(value);\n\
    \  return std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  return 0;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp4fmgf70z: /tmp/tmp4fmgf70z.cpp:22: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double val = std::stod(value);\n  long\
    \ int_val = (long) val;\n  if (val - int_val >= 0.5) {\n    return int_val + 1;\n\
    \  } else {\n    return int_val;\n  }\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmph79xx53e: /tmp/tmph79xx53e.cpp:29: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660065001
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    double d = std::stod(value);\n   \
    \ return std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  double val = std::stod(value);\n\
    \  if (val < 0) {\n    return std::ceil(val);\n  }\n  return std::floor(val);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpfuu8t8va: /tmp/tmpfuu8t8va.cpp:27: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065001
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double val = std::stod(value);\n  return\
    \ std::round(val);\n}\nint main() {\n    auto candidate = closest_integer;\n \
    \   assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065000
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  double d = std::stod(value);\n\
    \  if(d>0) {\n    return std::ceil(d);\n  }\n  else {\n    return std::floor(d);\n\
    \  }\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmputqhktp2: /tmp/tmputqhktp2.cpp:31: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  long result = 0;\n  double d = std::stod(value);\n\
    \  if (d > 0) {\n    result = (long)d + 1;\n  } else {\n    result = (long)d -\
    \ 1;\n  }\n  return result;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpf5uxiwzn: /tmp/tmpf5uxiwzn.cpp:28: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660065001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  return 0;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp4fmgf70z: /tmp/tmp4fmgf70z.cpp:22: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    double x = std::stod(value);\n   \
    \ long y = std::lround(x);\n    return y;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065001
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  int i = 0;\n  int len = value.length();\n\
    \  int sign = 1;\n  if (value[0] == '-') {\n    sign = -1;\n    i++;\n  }\n  int\
    \ integer = 0;\n  while (i < len && value[i] != '.') {\n    integer = integer\
    \ * 10 + (value[i] - '0');\n    i++;\n  }\n  if (i == len) {\n    return integer\
    \ * sign;\n  }\n  int decimal = 0;\n  int j = 0;\n  i++;\n  while (i < len) {\n\
    \    decimal = decimal * 10 + (value[i] - '0');\n    i++;\n    j++;\n  }\n  int\
    \ decimal_point = 1;\n  while (j--) {\n    decimal_point *= 10;\n  }\n  if (decimal\
    \ * 2 >= decimal_point) {\n    integer++;\n  }\n  return integer * sign;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065000
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  float num = std::stof(value);\n  float\
    \ decimal = num - (int)num;\n  if (decimal < 0.5) {\n    return (int)num;\n  }\
    \ else {\n    return (int)num + 1;\n  }\n}\nint main() {\n    auto candidate =\
    \ closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpw8xx3p09: /tmp/tmpw8xx3p09.cpp:29: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660065001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  double num = std::stod(value);\n\
    \  if (num < 0) {\n    num = std::ceil(num);\n  } else {\n    num = std::floor(num);\n\
    \  }\n  return num;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp3xfqqsa1: /tmp/tmp3xfqqsa1.cpp:29: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065001
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  std::stringstream\
    \ ss(value);\n  double d;\n  ss >> d;\n  return (long)round(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  long num = std::stol(value);\n  long\
    \ num_int = (long)num;\n  long num_dec = num - num_int;\n  if (num_dec >= 0.5)\
    \ {\n    return num_int + 1;\n  } else {\n    return num_int;\n  }\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpwcefvi2c: /tmp/tmpwcefvi2c.cpp:29: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065001
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    double val = std::stod(value);\n \
    \   return std::lround(val);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  return 0;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp4fmgf70z: /tmp/tmp4fmgf70z.cpp:22: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  std::stringstream ss(value);\n  double\
    \ d;\n  ss >> d;\n  return std::lround(d);\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  //std::cout <<\
    \ value << std::endl;\n  std::stringstream ss(value);\n  double d;\n  ss >> d;\n\
    \  //std::cout << d << std::endl;\n  if(d >= 0){\n    return std::ceil(d);\n \
    \ }\n  else{\n    return std::floor(d);\n  }\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpy_uv98ec: /tmp/tmpy_uv98ec.cpp:35: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065001
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::round(d);\n}\nint main() {\n    auto candidate = closest_integer;\n   \
    \ assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  int num = std::stoi(value);\n  if(num\
    \ < 0) {\n    return num - 1;\n  }\n  return num + 1;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpnbj5hl1j: /tmp/tmpnbj5hl1j.cpp:25: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660065001
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double num = std::stod(value);\n  return\
    \ std::round(num);\n}\nint main() {\n    auto candidate = closest_integer;\n \
    \   assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  double num = std::stod(value);\n\
    \  if (num < 0) {\n    return std::ceil(num);\n  }\n  return std::floor(num);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpc10d0vgq: /tmp/tmpc10d0vgq.cpp:27: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    int i = 0;\n    while(value[i] !=\
    \ '.')\n        i++;\n    if(value[i+1] >= '5')\n        return std::stol(value.substr(0,\
    \ i)) + 1;\n    else\n        return std::stol(value.substr(0, i));\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpxc59k57n: /tmp/tmpxc59k57n.cpp:29: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660065002
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  double num = std::stod(value);\n\
    \  long int_num = std::lround(num);\n  return int_num;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065002
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    double d = std::stod(value);\n   \
    \ return std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  double val = std::stod(value);\n\
    \  if(val > 0){\n    return ceil(val);\n  }\n  else{\n    return floor(val);\n\
    \  }\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpgteg8thw: /tmp/tmpgteg8thw.cpp:31: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065002
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n\tdouble d = std::stod(value);\n\treturn\
    \ std::round(d);\n}\nint main() {\n    auto candidate = closest_integer;\n   \
    \ assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065002
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n\tdouble d = std::stod(value);\n\treturn\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065002
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  double num = std::stod(value);\n\
    \  if (num < 0) {\n    return std::ceil(num);\n  }\n  return std::floor(num);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpc10d0vgq: /tmp/tmpc10d0vgq.cpp:27: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065001
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  double val = std::stod(value);\n\
    \  return std::round(val);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double num = std::stod(value);\n  long\
    \ int_num = std::lround(num);\n  return int_num;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065002
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::round(d);\n}\nint main() {\n    auto candidate = closest_integer;\n   \
    \ assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double val = std::stod(value);\n  return\
    \ std::round(val);\n}\nint main() {\n    auto candidate = closest_integer;\n \
    \   assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065000
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  double d = std::stod(value);\n\
    \  return std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  return 0;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp4fmgf70z: /tmp/tmp4fmgf70z.cpp:22: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double val = std::stod(value);\n  if\
    \ (val - (int)val > 0.5) {\n    return (int)val + 1;\n  } else {\n    return (int)val;\n\
    \  }\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp0szqs3s5: /tmp/tmp0szqs3s5.cpp:27: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065002
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  return 0;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp4fmgf70z: /tmp/tmp4fmgf70z.cpp:22: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double val = std::stod(value);\n  return\
    \ (long)val;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpf_7kwps6: /tmp/tmpf_7kwps6.cpp:23: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065002
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    double d = std::stod(value);\n   \
    \ long l = std::lround(d);\n    return l;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065002
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  int len = value.length();\n\
    \  int i = 0;\n  int flag = 0;\n  int num = 0;\n  if(value[0] == '-')\n  {\n \
    \   flag = 1;\n    i++;\n  }\n  while(i < len)\n  {\n    if(value[i] == '.')\n\
    \    {\n      break;\n    }\n    num = num * 10 + (value[i] - '0');\n    i++;\n\
    \  }\n  if(value[i] == '.')\n  {\n    i++;\n    if(value[i] >= '5')\n    {\n \
    \     num++;\n    }\n  }\n  if(flag == 1)\n  {\n    num = -num;\n  }\n  return\
    \ num;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065002
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  std::stringstream ss(value);\n  double\
    \ d;\n  ss >> d;\n  return (long) (d >= 0 ? d + 0.5 : d - 0.5);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065002
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  long num = std::stol(value);\n\
    \  if (num >= 0) {\n    if (num - (long)num >= 0.5) {\n      return (long)num\
    \ + 1;\n    } else {\n      return (long)num;\n    }\n  } else {\n    if (num\
    \ - (long)num <= -0.5) {\n      return (long)num - 1;\n    } else {\n      return\
    \ (long)num;\n    }\n  }\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpusqc3c_u: /tmp/tmpusqc3c_u.cpp:36: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065002
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ (long) (d + 0.5);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpzgv_ndfu: /tmp/tmpzgv_ndfu.cpp:24: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660065002
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  long val = std::stol(value);\n\
    \  long val1 = std::stol(value);\n  long val2 = std::stol(value);\n  if(val <\
    \ 0){\n    val1 = val1 - 1;\n    val2 = val2 + 1;\n  }\n  else{\n    val1 = val1\
    \ + 1;\n    val2 = val2 - 1;\n  }\n  if(abs(val - val1) < abs(val - val2)){\n\
    \    return val1;\n  }\n  else{\n    return val2;\n  }\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmphbeyvm4j: /tmp/tmphbeyvm4j.cpp:38: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660065002
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::round(d);\n}\nint main() {\n    auto candidate = closest_integer;\n   \
    \ assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  return 0;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp4fmgf70z: /tmp/tmp4fmgf70z.cpp:22: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ (long)std::round(d);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  long result = 0;\n  double value_double\
    \ = std::stod(value);\n  if (value_double > 0) {\n    result = std::ceil(value_double);\n\
    \  } else {\n    result = std::floor(value_double);\n  }\n  return result;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmphye5y0bs: /tmp/tmphye5y0bs.cpp:31: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065002
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  return 0;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp4fmgf70z: /tmp/tmp4fmgf70z.cpp:22: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double val = std::stod(value);\n  return\
    \ std::lround(val);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065002
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // Your code here\n  double val = std::stod(value);\n\
    \  if(val > 0) {\n    return std::ceil(val);\n  }\n  else {\n    return std::floor(val);\n\
    \  }\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpji1jnf_o: /tmp/tmpji1jnf_o.cpp:31: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065002
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  double val = std::stod(value);\n\
    \  double intpart;\n  double fracpart = modf(val, &intpart);\n  if (fracpart >=\
    \ 0.5) {\n    return intpart + 1;\n  } else {\n    return intpart;\n  }\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpv3_1q_mx: /tmp/tmpv3_1q_mx.cpp:31: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660065002
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::round(d);\n}\nint main() {\n    auto candidate = closest_integer;\n   \
    \ assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  double d = std::stod(value);\n\
    \  return (long)std::round(d);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065002
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  return 0;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp4fmgf70z: /tmp/tmp4fmgf70z.cpp:22: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  double d = std::stod(value);\n\
    \  if (d < 0) {\n    return std::ceil(d);\n  }\n  return std::floor(d);\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpyd2ydq6e: /tmp/tmpyd2ydq6e.cpp:27: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065000
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::round(d);\n}\nint main() {\n    auto candidate = closest_integer;\n   \
    \ assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  long result = 0;\n  double val = std::stod(value);\n\
    \  if (val > 0) {\n    result = std::ceil(val);\n  } else {\n    result = std::floor(val);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpdbacf5m4: /tmp/tmpdbacf5m4.cpp:31: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065002
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    double d = std::stod(value);\n   \
    \ return std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  int num = std::stoi(value);\n\
    \  int num2 = num + 1;\n  int num3 = num - 1;\n  double num4 = std::stod(value);\n\
    \  if(num4 - num < 0.5){\n    return num;\n  }\n  else{\n    return num2;\n  }\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpt_tft5xd: /tmp/tmpt_tft5xd.cpp:33: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660065002
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  double d = std::stod(value);\n\
    \  return std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065001
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    double val = std::stod(value);\n \
    \   long int_val = std::lround(val);\n    return int_val;\n}\nint main() {\n \
    \   auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065002
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  return 0;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp4fmgf70z: /tmp/tmp4fmgf70z.cpp:22: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // your code here\n    double d =\
    \ std::stod(value);\n    return std::lround(d);\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065002
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  long result = 0;\n  double d = std::stod(value);\n\
    \  if (d >= 0) {\n    result = (long)std::ceil(d);\n  } else {\n    result = (long)std::floor(d);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp5fx3t5g1: /tmp/tmp5fx3t5g1.cpp:31: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065003
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 1
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  int i = 0;\n  int\
    \ j = 0;\n  int k = 0;\n  int l = 0;\n  int m = 0;\n  int n = 0;\n  int o = 0;\n\
    \  int p = 0;\n  int q = 0;\n  int r = 0;\n  int s = 0;\n  int t = 0;\n  int u\
    \ = 0;\n  int v = 0;\n  int w = 0;\n  int x = 0;\n  int y = 0;\n  int z = 0;\n\
    \  int aa = 0;\n  int bb = 0;\n  int cc = 0;\n  int dd = 0;\n  int ee = 0;\n \
    \ int ff = 0;\n  int gg = 0;\n  int hh = 0;\n  int ii = 0;\n  int jj = 0;\n  int\
    \ kk = 0;\n  int ll = 0;\n  int mm = 0;\n  int nn = 0;\n  int oo = 0;\n  int pp\
    \ = 0;\n  int qq = 0;\n  int rr = 0;\n  int ss = 0;\n  int tt = 0;\n  int uu =\
    \ 0;\n  int vv = 0;\n  int ww = 0;\n  int xx = 0;\n  int yy = 0;\n  int zz = 0;\n\
    \  int aaa = 0;\n  int bbb = 0;\n  int ccc = 0;\n  int ddd = 0;\n  int eee = 0;\n\
    \  int fff = 0;\n  int ggg = 0;\n  int hhh = 0;\n  int iii = 0;\n  int jjj = 0;\n\
    \  int kkk = 0;\n  int lll = 0;\n  int mmm = 0;\n  int nnn = 0;\n  int ooo = 0;\n\
    \  int ppp = 0;\n  int qqq = 0;\n  int rrr = 0;\n  int sss = 0;\n  int ttt = 0;\n\
    \  int uuu = 0;\n  int vvv = 0;\n  int www = 0\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: SyntaxError
  stderr: "/tmp/tmp2g9cz1l5.cpp: In function \u2018long int closest_integer(std::string)\u2019\
    :\n/tmp/tmp2g9cz1l5.cpp:85:1: error: expected \u2018,\u2019 or \u2018;\u2019 before\
    \ \u2018}\u2019 token\n   85 | }\n      | ^\n/tmp/tmp2g9cz1l5.cpp:85:1: warning:\
    \ no return statement in function returning non-void [-Wreturn-type]\n"
  stdout: ''
  timestamp: 1660065003
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    double d = std::stod(value);\n   \
    \ long l = std::lround(d);\n    return l;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065002
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    double d = std::stod(value);\n   \
    \ return std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  long result = 0;\n  double d = std::stod(value);\n\
    \  if (d < 0) {\n    result = std::ceil(d);\n  } else {\n    result = std::floor(d);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpnn7pb_bw: /tmp/tmpnn7pb_bw.cpp:29: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065003
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  long result;\n  std::stringstream ss(value);\n\
    \  ss >> result;\n  return result;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmptjyy9l8p: /tmp/tmptjyy9l8p.cpp:25: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065003
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    double d =\
    \ std::stod(value);\n    if (d < 0) {\n        return std::ceil(d);\n    }\n \
    \   return std::floor(d);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp8vuf1anv: /tmp/tmp8vuf1anv.cpp:27: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065003
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  return std::stol(value);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp75ewq7ws: /tmp/tmp75ewq7ws.cpp:23: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  std::stringstream ss(value);\n  double\
    \ d;\n  ss >> d;\n  return (long)d;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp1jjn1_as: /tmp/tmp1jjn1_as.cpp:25: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065003
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // Your code here\n    double val\
    \ = std::stod(value);\n    if (val > 0) {\n        return std::ceil(val);\n  \
    \  } else {\n        return std::floor(val);\n    }\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp4ubptqa6: /tmp/tmp4ubptqa6.cpp:30: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065003
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  double d = std::stod(value);\n\
    \  if (d < 0) {\n    return std::ceil(d);\n  }\n  return std::floor(d);\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpyd2ydq6e: /tmp/tmpyd2ydq6e.cpp:27: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065000
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  long num = std::stol(value);\n  long\
    \ decimal = std::stol(value.substr(value.find(\".\")));\n  if (decimal >= 5) {\n\
    \    return num + 1;\n  } else {\n    return num;\n  }\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: "terminate called after throwing an instance of 'std::out_of_range'\n  what():\
    \  basic_string::substr: __pos (which is 18446744073709551615) > this->size()\
    \ (which is 2)\n"
  stdout: ''
  timestamp: 1660065003
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  return 0;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp4fmgf70z: /tmp/tmp4fmgf70z.cpp:22: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  return std::round(std::stod(value));\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065000
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  long num = std::stol(value);\n\
    \  long num1 = num;\n  long num2 = num;\n  if (num < 0) {\n    num1++;\n    num2--;\n\
    \  } else {\n    num1--;\n    num2++;\n  }\n  if (std::abs(num - num1) < std::abs(num\
    \ - num2)) {\n    return num1;\n  } else {\n    return num2;\n  }\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpn_wpnr3u: /tmp/tmpn_wpnr3u.cpp:36: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660065003
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  return 0;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp4fmgf70z: /tmp/tmp4fmgf70z.cpp:22: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  float f = std::stof(value);\n\
    \  if (f >= 0) {\n    return std::ceil(f);\n  } else {\n    return std::floor(f);\n\
    \  }\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpzmkp17m1: /tmp/tmpzmkp17m1.cpp:30: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065003
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::round(d);\n}\nint main() {\n    auto candidate = closest_integer;\n   \
    \ assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    std::stringstream ss(value);\n   \
    \ double d;\n    ss >> d;\n    return (long) (d > 0 ? d + 0.5 : d - 0.5);\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065003
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  int n = value.size();\n  int i = 0;\n\
    \  int sign = 1;\n  if (value[0] == '-') {\n    sign = -1;\n    i++;\n  }\n  long\
    \ ans = 0;\n  while (i < n && value[i] != '.') {\n    ans = ans * 10 + (value[i]\
    \ - '0');\n    i++;\n  }\n  if (i == n) {\n    return ans * sign;\n  }\n  i++;\n\
    \  long decimal = 0;\n  long multiplier = 1;\n  while (i < n) {\n    decimal =\
    \ decimal * 10 + (value[i] - '0');\n    multiplier *= 10;\n    i++;\n  }\n  if\
    \ (decimal * 2 >= multiplier) {\n    ans++;\n  }\n  return ans * sign;\n}\nint\
    \ main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\"\
    )) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065003
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // Your code here\n  double num = std::stod(value);\n\
    \  if (num < 0) {\n    return std::ceil(num);\n  }\n  return std::floor(num);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpnrzk83nt: /tmp/tmpnrzk83nt.cpp:27: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065003
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  return 0;\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp4fmgf70z: /tmp/tmp4fmgf70z.cpp:22: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  double d = std::stod(value);\n\
    \  return std::round(d);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065000
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    std::stringstream ss(value);\n   \
    \ double d;\n    ss >> d;\n    return std::lround(d);\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065003
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  long\
    \ l = std::lround(d);\n  return l;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065003
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  double d = std::stod(value);\n\
    \  if (d >= 0) {\n    return std::ceil(d);\n  } else {\n    return std::floor(d);\n\
    \  }\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmprtxwpx6m: /tmp/tmprtxwpx6m.cpp:30: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065003
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::round(d);\n}\nint main() {\n    auto candidate = closest_integer;\n   \
    \ assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // Your code here\n  int i = 0;\n  int\
    \ j = 0;\n  int k = 0;\n  int l = 0;\n  int m = 0;\n  int n = 0;\n  int o = 0;\n\
    \  int p = 0;\n  int q = 0;\n  int r = 0;\n  int s = 0;\n  int t = 0;\n  int u\
    \ = 0;\n  int v = 0;\n  int w = 0;\n  int x = 0;\n  int y = 0;\n  int z = 0;\n\
    \  int aa = 0;\n  int ab = 0;\n  int ac = 0;\n  int ad = 0;\n  int ae = 0;\n \
    \ int af = 0;\n  int ag = 0;\n  int ah = 0;\n  int ai = 0;\n  int aj = 0;\n  int\
    \ ak = 0;\n  int al = 0;\n  int am = 0;\n  int an = 0;\n  int ao = 0;\n  int ap\
    \ = 0;\n  int aq = 0;\n  int ar = 0;\n  int as = 0;\n  int at = 0;\n  int au =\
    \ 0;\n  int av = 0;\n  int aw = 0;\n  int ax = 0;\n  int ay = 0;\n  int az = 0;\n\
    \  int ba = 0;\n  int bb = 0;\n  int bc = 0;\n  int bd = 0;\n  int be = 0;\n \
    \ int bf = 0;\n  int bg = 0;\n  int bh = 0;\n  int bi = 0;\n  int bj = 0;\n  int\
    \ bk = 0;\n  int bl = 0;\n  int bm = 0;\n  int bn = 0;\n  int bo = 0;\n  int bp\
    \ = 0;\n  int bq = 0;\n  int br = 0;\n  int bs = 0;\n  int bt = 0;\n  int bu =\
    \ 0;\n  int bv = 0;\n  int bw = 0;\n  int bx = 0;\n  int by = 0;\n\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmprvdcjjd7: /tmp/tmprvdcjjd7.cpp:91: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660065003
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    // your code here\n    double num=std::stod(value);\n\
    \    if(num>0)\n    {\n        if(num-floor(num)<0.5)\n            return floor(num);\n\
    \        else\n            return ceil(num);\n    }\n    else\n    {\n       \
    \ if(num-floor(num)<0.5)\n            return ceil(num);\n        else\n      \
    \      return floor(num);\n    }\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065003
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double num = std::stod(value);\n  return\
    \ std::round(num);\n}\nint main() {\n    auto candidate = closest_integer;\n \
    \   assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065001
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  std::stringstream\
    \ ss(value);\n  double d;\n  ss >> d;\n  return d > 0 ? std::ceil(d) : std::floor(d);\n\
    }\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmph94etjwo: /tmp/tmph94etjwo.cpp:28: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065003
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double val = std::stod(value);\n  if\
    \ (val >= 0) {\n    return (long)std::ceil(val);\n  } else {\n    return (long)std::floor(val);\n\
    \  }\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp0gxyfbe0: /tmp/tmp0gxyfbe0.cpp:29: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065003
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // Your code here\n  double d = std::stod(value);\n\
    \  return std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065003
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ (long)std::round(d);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n\tdouble val = std::stod(value);\n\treturn\
    \ std::lround(val);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065003
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ (d>0) ? std::ceil(d) : std::floor(d);\n}\nint main() {\n    auto candidate =\
    \ closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpikb5rl_e: /tmp/tmpikb5rl_e.cpp:25: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065003
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  if (d\
    \ < 0) {\n    return std::ceil(d);\n  }\n  return std::floor(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp27mprnyq: /tmp/tmp27mprnyq.cpp:26: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065004
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  long result = 0;\n  double d = std::stod(value);\n\
    \  if (d > 0) {\n    result = std::ceil(d);\n  } else {\n    result = std::floor(d);\n\
    \  }\n  return result;\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpeaf0iam5: /tmp/tmpeaf0iam5.cpp:31: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065004
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double val = stod(value);\n  if (val\
    \ >= 0) {\n    return ceil(val);\n  } else {\n    return floor(val);\n  }\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpudqd11l_: /tmp/tmpudqd11l_.cpp:29: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065004
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    double d = std::stod(value);\n   \
    \ return (long)std::round(d);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065004
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  double val = std::stod(value);\n\
    \  long int_val = std::lround(val);\n  return int_val;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065004
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  double val = std::stod(value);\n\
    \  long int_val = std::lround(val);\n  return int_val;\n}\nint main() {\n    auto\
    \ candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n   \
    \ assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\")) ==\
    \ (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065004
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n    double d = std::stod(value);\n   \
    \ return std::round(d);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065004
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ (d > 0) ? std::ceil(d) : std::floor(d);\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpmr69tt20: /tmp/tmpmr69tt20.cpp:25: int main(): Assertion `candidate(("15.3"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065004
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // your code here\n  double d = std::stod(value);\n\
    \  return std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n\
    \    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) ==\
    \ (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065001
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double num = std::stod(value);\n  if\
    \ (num < 0) {\n    return std::ceil(num);\n  }\n  return std::floor(num);\n}\n\
    int main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmph1wehieq: /tmp/tmph1wehieq.cpp:26: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065004
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double val = std::stod(value);\n  long\
    \ int_val = std::lround(val);\n  return int_val;\n}\nint main() {\n    auto candidate\
    \ = closest_integer;\n    assert(candidate((\"10\")) == (10));\n    assert(candidate((\"\
    14.5\")) == (15));\n    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"\
    15.3\")) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660065004
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  int i = 0;\n  int j = value.size() -\
    \ 1;\n  int k = 0;\n  int l = 0;\n  int m = 0;\n  int n = 0;\n  int o = 0;\n \
    \ int p = 0;\n  int q = 0;\n  int r = 0;\n  int s = 0;\n  int t = 0;\n  int u\
    \ = 0;\n  int v = 0;\n  int w = 0;\n  int x = 0;\n  int y = 0;\n  int z = 0;\n\
    \  int aa = 0;\n  int ab = 0;\n  int ac = 0;\n  int ad = 0;\n  int ae = 0;\n \
    \ int af = 0;\n  int ag = 0;\n  int ah = 0;\n  int ai = 0;\n  int aj = 0;\n  int\
    \ ak = 0;\n  int al = 0;\n  int am = 0;\n  int an = 0;\n  int ao = 0;\n  int ap\
    \ = 0;\n  int aq = 0;\n  int ar = 0;\n  int as = 0;\n  int at = 0;\n  int au =\
    \ 0;\n  int av = 0;\n  int aw = 0;\n  int ax = 0;\n  int ay = 0;\n  int az = 0;\n\
    \  int ba = 0;\n  int bb = 0;\n  int bc = 0;\n  int bd = 0;\n  int be = 0;\n \
    \ int bf = 0;\n  int bg = 0;\n  int bh = 0;\n  int bi = 0;\n  int bj = 0;\n  int\
    \ bk = 0;\n  int bl = 0;\n  int bm = 0;\n  int bn = 0;\n  int bo = 0;\n  int bp\
    \ = 0;\n  int bq = 0;\n  int br = 0;\n  int bs = 0;\n  int bt = 0;\n  int bu =\
    \ 0;\n  int bv = 0;\n  int bw = 0;\n  int bx = 0;\n  int by = 0;\n \n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpn2x43317: /tmp/tmpn2x43317.cpp:90: int main(): Assertion `candidate(("10"))
    == (10)'' failed.

    '
  stdout: ''
  timestamp: 1660065004
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  if (d\
    \ < 0) {\n    return std::ceil(d);\n  }\n  return std::floor(d);\n}\nint main()\
    \ {\n    auto candidate = closest_integer;\n    assert(candidate((\"10\")) ==\
    \ (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp27mprnyq: /tmp/tmp27mprnyq.cpp:26: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065004
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double val = std::stod(value);\n  double\
    \ floor_val = std::floor(val);\n  double ceil_val = std::ceil(val);\n  if (val\
    \ - floor_val < ceil_val - val) {\n    return floor_val;\n  } else {\n    return\
    \ ceil_val;\n  }\n}\nint main() {\n    auto candidate = closest_integer;\n   \
    \ assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpn7xq21qo: /tmp/tmpn7xq21qo.cpp:30: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660065004
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // Your code here\n  double d = std::stod(value);\n\
    \  double d1 = std::floor(d);\n  double d2 = std::ceil(d);\n  if (d - d1 < d2\
    \ - d) {\n    return d1;\n  } else {\n    return d2;\n  }\n}\nint main() {\n \
    \   auto candidate = closest_integer;\n    assert(candidate((\"10\")) == (10));\n\
    \    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"-15.5\"))\
    \ == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmpm4owe92e: /tmp/tmpm4owe92e.cpp:31: int main(): Assertion `candidate(("-15.5"))
    == (-16)'' failed.

    '
  stdout: ''
  timestamp: 1660065004
- exit_code: -6
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  // Your code here\n  long int n = std::stol(value);\n\
    \  if(n < 0)\n  {\n    n = n - 0.5;\n  }\n  else\n  {\n    n = n + 0.5;\n  }\n\
    \  return n;\n}\nint main() {\n    auto candidate = closest_integer;\n    assert(candidate((\"\
    10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n    assert(candidate((\"\
    -15.5\")) == (-16));\n    assert(candidate((\"15.3\")) == (15));\n    assert(candidate((\"\
    0\")) == (0));\n}\n"
  status: Exception
  stderr: 'tmp3sje9f56: /tmp/tmp3sje9f56.cpp:32: int main(): Assertion `candidate(("14.5"))
    == (15)'' failed.

    '
  stdout: ''
  timestamp: 1660065004
- exit_code: 0
  program: "#include<assert.h>\n#include<bits/stdc++.h>\n// Create a function that\
    \ takes a value (string) representing a number\n// and returns the closest integer\
    \ to it. If the number is equidistant\n// from two integers, round it away from\
    \ zero.\n// Examples\n// >>> closest_integer((\"10\"))\n// (10)\n// >>> closest_integer((\"\
    15.3\"))\n// (15)\n// Note:\n// Rounding away from zero means that if the given\
    \ number is equidistant\n// from two integers, the one you should return is the\
    \ one that is the\n// farthest from zero. For example closest_integer(\"14.5\"\
    ) should\n// return 15 and closest_integer(\"-14.5\") should return -15.\nlong\
    \ closest_integer(std::string value) {\n  double d = std::stod(value);\n  return\
    \ std::lround(d);\n}\nint main() {\n    auto candidate = closest_integer;\n  \
    \  assert(candidate((\"10\")) == (10));\n    assert(candidate((\"14.5\")) == (15));\n\
    \    assert(candidate((\"-15.5\")) == (-16));\n    assert(candidate((\"15.3\"\
    )) == (15));\n    assert(candidate((\"0\")) == (0));\n}\n"
  status: OK
  stderr: ''
  stdout: ''
  timestamp: 1660064999
